/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "E:\\xbcx-work\\xstarp\\xstarp\\dist";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/1/19.
	 * package all the components.
	 * @output prod entry.
	 */


	__webpack_require__(1);
	__webpack_require__(3);
	__webpack_require__(47);
	__webpack_require__(52);
	__webpack_require__(65);
	__webpack_require__(68);



/***/ },
/* 1 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 2 */,
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by jesse on 2017/2/23.
	 */

	__webpack_require__(4)


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(5);


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @Function
	 * @主要功能：
	 * @first  将SMap注册到页面中去
	 * @second 自动引入对应地图的API
	 * @third  自动引入对应地图的插件
	 */
	var _ = __webpack_require__(6);

	var util = __webpack_require__(8);
	var GMap = __webpack_require__(9);
	var DMap = __webpack_require__(28);
	var loader = __webpack_require__(46);
	var config = __webpack_require__(15);

	window.GMap = GMap;
	window.DMap = DMap;

	var SMap = {};

	window.mapCreate = mapCreate;

	/**
	 * 默认设置地图类型为高德地图
	 * */
	// if(typeof AMap === 'undefined') {
	//   SMap = mapCreate('g');
	// }
	// else {
	//   SMap = mapCreate('a');
	// }

	/**
	 * @function 返回一个地图顶级命名空间变量，适用于单页面多地图
	 * 在页面中声明类似SMap这个变量来接收一个顶级命名空间
	 * @param {String} type
	 * **地图类型**
	 * * 'a' 代表高德地图
	 * * 'g' 代表谷歌地图
	 * * 'b' 代表百度地图
	 * */
	function mapCreate(type) {
	  if (type == 'a') {
	    initMap('AMap', 'AMap');
	    return window.AMap;
	  } else if (type == 'g') {
	    initMap('GMap', 'GMap');
	    return window.GMap;
	  } else if (type == 'b') {
	    initMap('DMap', 'DMap');
	    return window.DMap;
	  }
	}

	/**
	 * @function 设置地图类型
	 * @param {String} type
	 * **地图类型**
	 * * 'a' 代表高德地图
	 * * 'g' 代表谷歌地图
	 * * 'b' 代表百度地图
	 * */
	mapCreate.setType = function(type) {
	  var mapType = '';
	  if( type == 'a' ) {
	    window.SMap = AMap;
	    mapType = 'AMap';
	  } else if ( type == 'g' ) {
	    window.SMap = window.GMap;
	    mapType = 'GMap';
	  } else if ( type == 'b') {
	    console.log(type);
	    window.SMap = window.DMap;
	    mapType = 'DMap';
	  }
	  initMap(mapType, 'SMap');
	};

	/**
	 * @function 初始化地图
	 * @param {String} mapType
	 *   ** 有三种取值：
	 *     ** 'AMap'
	 *     ** 'GMap'
	 *     ** 'DMap'
	 * @param {String} Map
	 * */
	function initMap(mapType, Map) {
		// 设置各地图的文件插件名字
		// 这里主要为了兼容AMap只能使用它自己内置的字符串。
		// 栗子：'AMap.MarkerClusterer',高德只认得AMap开头的。
	  window[Map].sPlugin = {
	    MouseTool: mapType + '.MouseTool',
	    CircleEditor: mapType + '.CircleEditor',
	    PolyEditor: mapType + '.PolyEditor',
	    Hotspot: mapType + '.Hotspot',
	    MarkerClusterer: mapType + '.MarkerClusterer',
	    RangingTool: mapType + '.RangingTool'
	  };
	}

	/**
	 * @entry 接收页面设置的地图属性
	 * */
	if(typeof window.SMapConfig !== 'undefined') {
	  installMap(window.SMapConfig);
	} else {
	  console.warn("[你收到一条来自SMap的警告]：请在使用地图之前声明 SMap_target_type 这个变量！");
	}

	function installMap(SMapConfig) {
	  var type, mapType, url, key;

	  // 未设置则此处自动设置为高德地图
	  if(!SMapConfig.SMap_target_type) {
	    SMapConfig.SMap_target_type = 'a';
	  }

	  type = SMapConfig.SMap_target_type;

	  if(type === 'a') {
	    mapType = 'AMap';
	  }
	  else if(type === 'g') {
	    mapType = 'GMap';
	  }
	  else if(type === 'b') {
	    mapType = 'DMap';
	  }

	  key = SMapConfig[ mapType +'_key'] || config[ mapType +'_key'];
	  url = SMapConfig[ mapType +'_url'] || config[ mapType +'_url'];

	  document.write('<script src="'+url+key+'"><\/script>');
	  window.SMap = window.mapCreate(type);
	  getPluginScript(type);
	}

	/**
	 * @function 加载百度地图和谷歌的插件
	 *
	 * @param {String} type
	 *   ** 取值： 'a', 'g', 'b'
	 *
	 * 因为高德地图是直接将地图插件和主API JS文件在一起的
	 * 因此百度地图和谷歌地图也需要用插件的话，需要加载它们
	 * 所以这个函数将引入我们config中的插件
	 * */
	function getPluginScript(type){
	  if(type === 'a') {}
	  else if (type === 'b') {
	    document.write('<script src="'+ config.DMap_MarkerClusterer +'"><\/script>');
	    document.write('<script src="'+ config.DMap_TextIconOverlay +'"><\/script>');
	    document.write('<script src="'+ config.DMap_AreaRestriction +'"><\/script>');
	  }
	  else if (type === 'g') {
	    document.write('<script src="'+ config.GMap_MarkerClusterer +'"><\/script>');
	  }
	}

	module.exports = window.SMap;


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, module) {/**
	 * @license
	 * Lodash <https://lodash.com/>
	 * Copyright JS Foundation and other contributors <https://js.foundation/>
	 * Released under MIT license <https://lodash.com/license>
	 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
	 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 */
	;(function() {

	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
	  var undefined;

	  /** Used as the semantic version number. */
	  var VERSION = '4.17.4';

	  /** Used as the size to enable large array optimizations. */
	  var LARGE_ARRAY_SIZE = 200;

	  /** Error message constants. */
	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
	      FUNC_ERROR_TEXT = 'Expected a function';

	  /** Used to stand-in for `undefined` hash values. */
	  var HASH_UNDEFINED = '__lodash_hash_undefined__';

	  /** Used as the maximum memoize cache size. */
	  var MAX_MEMOIZE_SIZE = 500;

	  /** Used as the internal argument placeholder. */
	  var PLACEHOLDER = '__lodash_placeholder__';

	  /** Used to compose bitmasks for cloning. */
	  var CLONE_DEEP_FLAG = 1,
	      CLONE_FLAT_FLAG = 2,
	      CLONE_SYMBOLS_FLAG = 4;

	  /** Used to compose bitmasks for value comparisons. */
	  var COMPARE_PARTIAL_FLAG = 1,
	      COMPARE_UNORDERED_FLAG = 2;

	  /** Used to compose bitmasks for function metadata. */
	  var WRAP_BIND_FLAG = 1,
	      WRAP_BIND_KEY_FLAG = 2,
	      WRAP_CURRY_BOUND_FLAG = 4,
	      WRAP_CURRY_FLAG = 8,
	      WRAP_CURRY_RIGHT_FLAG = 16,
	      WRAP_PARTIAL_FLAG = 32,
	      WRAP_PARTIAL_RIGHT_FLAG = 64,
	      WRAP_ARY_FLAG = 128,
	      WRAP_REARG_FLAG = 256,
	      WRAP_FLIP_FLAG = 512;

	  /** Used as default options for `_.truncate`. */
	  var DEFAULT_TRUNC_LENGTH = 30,
	      DEFAULT_TRUNC_OMISSION = '...';

	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
	  var HOT_COUNT = 800,
	      HOT_SPAN = 16;

	  /** Used to indicate the type of lazy iteratees. */
	  var LAZY_FILTER_FLAG = 1,
	      LAZY_MAP_FLAG = 2,
	      LAZY_WHILE_FLAG = 3;

	  /** Used as references for various `Number` constants. */
	  var INFINITY = 1 / 0,
	      MAX_SAFE_INTEGER = 9007199254740991,
	      MAX_INTEGER = 1.7976931348623157e+308,
	      NAN = 0 / 0;

	  /** Used as references for the maximum length and index of an array. */
	  var MAX_ARRAY_LENGTH = 4294967295,
	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

	  /** Used to associate wrap methods with their bit flags. */
	  var wrapFlags = [
	    ['ary', WRAP_ARY_FLAG],
	    ['bind', WRAP_BIND_FLAG],
	    ['bindKey', WRAP_BIND_KEY_FLAG],
	    ['curry', WRAP_CURRY_FLAG],
	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
	    ['flip', WRAP_FLIP_FLAG],
	    ['partial', WRAP_PARTIAL_FLAG],
	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
	    ['rearg', WRAP_REARG_FLAG]
	  ];

	  /** `Object#toString` result references. */
	  var argsTag = '[object Arguments]',
	      arrayTag = '[object Array]',
	      asyncTag = '[object AsyncFunction]',
	      boolTag = '[object Boolean]',
	      dateTag = '[object Date]',
	      domExcTag = '[object DOMException]',
	      errorTag = '[object Error]',
	      funcTag = '[object Function]',
	      genTag = '[object GeneratorFunction]',
	      mapTag = '[object Map]',
	      numberTag = '[object Number]',
	      nullTag = '[object Null]',
	      objectTag = '[object Object]',
	      promiseTag = '[object Promise]',
	      proxyTag = '[object Proxy]',
	      regexpTag = '[object RegExp]',
	      setTag = '[object Set]',
	      stringTag = '[object String]',
	      symbolTag = '[object Symbol]',
	      undefinedTag = '[object Undefined]',
	      weakMapTag = '[object WeakMap]',
	      weakSetTag = '[object WeakSet]';

	  var arrayBufferTag = '[object ArrayBuffer]',
	      dataViewTag = '[object DataView]',
	      float32Tag = '[object Float32Array]',
	      float64Tag = '[object Float64Array]',
	      int8Tag = '[object Int8Array]',
	      int16Tag = '[object Int16Array]',
	      int32Tag = '[object Int32Array]',
	      uint8Tag = '[object Uint8Array]',
	      uint8ClampedTag = '[object Uint8ClampedArray]',
	      uint16Tag = '[object Uint16Array]',
	      uint32Tag = '[object Uint32Array]';

	  /** Used to match empty string literals in compiled template source. */
	  var reEmptyStringLeading = /\b__p \+= '';/g,
	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

	  /** Used to match HTML entities and HTML characters. */
	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
	      reUnescapedHtml = /[&<>"']/g,
	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

	  /** Used to match template delimiters. */
	  var reEscape = /<%-([\s\S]+?)%>/g,
	      reEvaluate = /<%([\s\S]+?)%>/g,
	      reInterpolate = /<%=([\s\S]+?)%>/g;

	  /** Used to match property names within property paths. */
	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
	      reIsPlainProp = /^\w*$/,
	      reLeadingDot = /^\./,
	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

	  /**
	   * Used to match `RegExp`
	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	   */
	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
	      reHasRegExpChar = RegExp(reRegExpChar.source);

	  /** Used to match leading and trailing whitespace. */
	  var reTrim = /^\s+|\s+$/g,
	      reTrimStart = /^\s+/,
	      reTrimEnd = /\s+$/;

	  /** Used to match wrap detail comments. */
	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
	      reSplitDetails = /,? & /;

	  /** Used to match words composed of alphanumeric characters. */
	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

	  /** Used to match backslashes in property paths. */
	  var reEscapeChar = /\\(\\)?/g;

	  /**
	   * Used to match
	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
	   */
	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

	  /** Used to match `RegExp` flags from their coerced string values. */
	  var reFlags = /\w*$/;

	  /** Used to detect bad signed hexadecimal string values. */
	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

	  /** Used to detect binary string values. */
	  var reIsBinary = /^0b[01]+$/i;

	  /** Used to detect host constructors (Safari). */
	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

	  /** Used to detect octal string values. */
	  var reIsOctal = /^0o[0-7]+$/i;

	  /** Used to detect unsigned integer values. */
	  var reIsUint = /^(?:0|[1-9]\d*)$/;

	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

	  /** Used to ensure capturing order of template delimiters. */
	  var reNoMatch = /($^)/;

	  /** Used to match unescaped characters in compiled string literals. */
	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

	  /** Used to compose unicode character classes. */
	  var rsAstralRange = '\\ud800-\\udfff',
	      rsComboMarksRange = '\\u0300-\\u036f',
	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
	      rsDingbatRange = '\\u2700-\\u27bf',
	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
	      rsPunctuationRange = '\\u2000-\\u206f',
	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
	      rsVarRange = '\\ufe0e\\ufe0f',
	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

	  /** Used to compose unicode capture groups. */
	  var rsApos = "['\u2019]",
	      rsAstral = '[' + rsAstralRange + ']',
	      rsBreak = '[' + rsBreakRange + ']',
	      rsCombo = '[' + rsComboRange + ']',
	      rsDigits = '\\d+',
	      rsDingbat = '[' + rsDingbatRange + ']',
	      rsLower = '[' + rsLowerRange + ']',
	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
	      rsNonAstral = '[^' + rsAstralRange + ']',
	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
	      rsUpper = '[' + rsUpperRange + ']',
	      rsZWJ = '\\u200d';

	  /** Used to compose unicode regexes. */
	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
	      reOptMod = rsModifier + '?',
	      rsOptVar = '[' + rsVarRange + ']?',
	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
	      rsOrdLower = '\\d*(?:(?:1st|2nd|3rd|(?![123])\\dth)\\b)',
	      rsOrdUpper = '\\d*(?:(?:1ST|2ND|3RD|(?![123])\\dTH)\\b)',
	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

	  /** Used to match apostrophes. */
	  var reApos = RegExp(rsApos, 'g');

	  /**
	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
	   */
	  var reComboMark = RegExp(rsCombo, 'g');

	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

	  /** Used to match complex or compound words. */
	  var reUnicodeWord = RegExp([
	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
	    rsUpper + '+' + rsOptContrUpper,
	    rsOrdUpper,
	    rsOrdLower,
	    rsDigits,
	    rsEmoji
	  ].join('|'), 'g');

	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

	  /** Used to detect strings that need a more robust regexp to match words. */
	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

	  /** Used to assign default `context` object properties. */
	  var contextProps = [
	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
	  ];

	  /** Used to make template sourceURLs easier to identify. */
	  var templateCounter = -1;

	  /** Used to identify `toStringTag` values of typed arrays. */
	  var typedArrayTags = {};
	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
	  typedArrayTags[uint32Tag] = true;
	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
	  typedArrayTags[weakMapTag] = false;

	  /** Used to identify `toStringTag` values supported by `_.clone`. */
	  var cloneableTags = {};
	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
	  cloneableTags[boolTag] = cloneableTags[dateTag] =
	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
	  cloneableTags[numberTag] = cloneableTags[objectTag] =
	  cloneableTags[regexpTag] = cloneableTags[setTag] =
	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
	  cloneableTags[errorTag] = cloneableTags[funcTag] =
	  cloneableTags[weakMapTag] = false;

	  /** Used to map Latin Unicode letters to basic Latin letters. */
	  var deburredLetters = {
	    // Latin-1 Supplement block.
	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
	    '\xc7': 'C',  '\xe7': 'c',
	    '\xd0': 'D',  '\xf0': 'd',
	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
	    '\xd1': 'N',  '\xf1': 'n',
	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
	    '\xc6': 'Ae', '\xe6': 'ae',
	    '\xde': 'Th', '\xfe': 'th',
	    '\xdf': 'ss',
	    // Latin Extended-A block.
	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
	    '\u0134': 'J',  '\u0135': 'j',
	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
	    '\u0174': 'W',  '\u0175': 'w',
	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
	    '\u0132': 'IJ', '\u0133': 'ij',
	    '\u0152': 'Oe', '\u0153': 'oe',
	    '\u0149': "'n", '\u017f': 's'
	  };

	  /** Used to map characters to HTML entities. */
	  var htmlEscapes = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#39;'
	  };

	  /** Used to map HTML entities to characters. */
	  var htmlUnescapes = {
	    '&amp;': '&',
	    '&lt;': '<',
	    '&gt;': '>',
	    '&quot;': '"',
	    '&#39;': "'"
	  };

	  /** Used to escape characters for inclusion in compiled string literals. */
	  var stringEscapes = {
	    '\\': '\\',
	    "'": "'",
	    '\n': 'n',
	    '\r': 'r',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  /** Built-in method references without a dependency on `root`. */
	  var freeParseFloat = parseFloat,
	      freeParseInt = parseInt;

	  /** Detect free variable `global` from Node.js. */
	  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	  /** Detect free variable `self`. */
	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	  /** Used as a reference to the global object. */
	  var root = freeGlobal || freeSelf || Function('return this')();

	  /** Detect free variable `exports`. */
	  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

	  /** Detect free variable `module`. */
	  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

	  /** Detect the popular CommonJS extension `module.exports`. */
	  var moduleExports = freeModule && freeModule.exports === freeExports;

	  /** Detect free variable `process` from Node.js. */
	  var freeProcess = moduleExports && freeGlobal.process;

	  /** Used to access faster Node.js helpers. */
	  var nodeUtil = (function() {
	    try {
	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
	    } catch (e) {}
	  }());

	  /* Node.js helper references. */
	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
	      nodeIsDate = nodeUtil && nodeUtil.isDate,
	      nodeIsMap = nodeUtil && nodeUtil.isMap,
	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
	      nodeIsSet = nodeUtil && nodeUtil.isSet,
	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Adds the key-value `pair` to `map`.
	   *
	   * @private
	   * @param {Object} map The map to modify.
	   * @param {Array} pair The key-value pair to add.
	   * @returns {Object} Returns `map`.
	   */
	  function addMapEntry(map, pair) {
	    // Don't return `map.set` because it's not chainable in IE 11.
	    map.set(pair[0], pair[1]);
	    return map;
	  }

	  /**
	   * Adds `value` to `set`.
	   *
	   * @private
	   * @param {Object} set The set to modify.
	   * @param {*} value The value to add.
	   * @returns {Object} Returns `set`.
	   */
	  function addSetEntry(set, value) {
	    // Don't return `set.add` because it's not chainable in IE 11.
	    set.add(value);
	    return set;
	  }

	  /**
	   * A faster alternative to `Function#apply`, this function invokes `func`
	   * with the `this` binding of `thisArg` and the arguments of `args`.
	   *
	   * @private
	   * @param {Function} func The function to invoke.
	   * @param {*} thisArg The `this` binding of `func`.
	   * @param {Array} args The arguments to invoke `func` with.
	   * @returns {*} Returns the result of `func`.
	   */
	  function apply(func, thisArg, args) {
	    switch (args.length) {
	      case 0: return func.call(thisArg);
	      case 1: return func.call(thisArg, args[0]);
	      case 2: return func.call(thisArg, args[0], args[1]);
	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
	    }
	    return func.apply(thisArg, args);
	  }

	  /**
	   * A specialized version of `baseAggregator` for arrays.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} setter The function to set `accumulator` values.
	   * @param {Function} iteratee The iteratee to transform keys.
	   * @param {Object} accumulator The initial aggregated object.
	   * @returns {Function} Returns `accumulator`.
	   */
	  function arrayAggregator(array, setter, iteratee, accumulator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      var value = array[index];
	      setter(accumulator, value, iteratee(value), array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.forEach` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEach(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (iteratee(array[index], index, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.forEachRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayEachRight(array, iteratee) {
	    var length = array == null ? 0 : array.length;

	    while (length--) {
	      if (iteratee(array[length], length, array) === false) {
	        break;
	      }
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.every` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
	   *  else `false`.
	   */
	  function arrayEvery(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (!predicate(array[index], index, array)) {
	        return false;
	      }
	    }
	    return true;
	  }

	  /**
	   * A specialized version of `_.filter` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {Array} Returns the new filtered array.
	   */
	  function arrayFilter(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (predicate(value, index, array)) {
	        result[resIndex++] = value;
	      }
	    }
	    return result;
	  }

	  /**
	   * A specialized version of `_.includes` for arrays without support for
	   * specifying an index to search from.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludes(array, value) {
	    var length = array == null ? 0 : array.length;
	    return !!length && baseIndexOf(array, value, 0) > -1;
	  }

	  /**
	   * This function is like `arrayIncludes` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} [array] The array to inspect.
	   * @param {*} target The value to search for.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
	   */
	  function arrayIncludesWith(array, value, comparator) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (comparator(value, array[index])) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * A specialized version of `_.map` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the new mapped array.
	   */
	  function arrayMap(array, iteratee) {
	    var index = -1,
	        length = array == null ? 0 : array.length,
	        result = Array(length);

	    while (++index < length) {
	      result[index] = iteratee(array[index], index, array);
	    }
	    return result;
	  }

	  /**
	   * Appends the elements of `values` to `array`.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {Array} values The values to append.
	   * @returns {Array} Returns `array`.
	   */
	  function arrayPush(array, values) {
	    var index = -1,
	        length = values.length,
	        offset = array.length;

	    while (++index < length) {
	      array[offset + index] = values[index];
	    }
	    return array;
	  }

	  /**
	   * A specialized version of `_.reduce` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the first element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduce(array, iteratee, accumulator, initAccum) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    if (initAccum && length) {
	      accumulator = array[++index];
	    }
	    while (++index < length) {
	      accumulator = iteratee(accumulator, array[index], index, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.reduceRight` for arrays without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} [accumulator] The initial value.
	   * @param {boolean} [initAccum] Specify using the last element of `array` as
	   *  the initial value.
	   * @returns {*} Returns the accumulated value.
	   */
	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
	    var length = array == null ? 0 : array.length;
	    if (initAccum && length) {
	      accumulator = array[--length];
	    }
	    while (length--) {
	      accumulator = iteratee(accumulator, array[length], length, array);
	    }
	    return accumulator;
	  }

	  /**
	   * A specialized version of `_.some` for arrays without support for iteratee
	   * shorthands.
	   *
	   * @private
	   * @param {Array} [array] The array to iterate over.
	   * @param {Function} predicate The function invoked per iteration.
	   * @returns {boolean} Returns `true` if any element passes the predicate check,
	   *  else `false`.
	   */
	  function arraySome(array, predicate) {
	    var index = -1,
	        length = array == null ? 0 : array.length;

	    while (++index < length) {
	      if (predicate(array[index], index, array)) {
	        return true;
	      }
	    }
	    return false;
	  }

	  /**
	   * Gets the size of an ASCII `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  var asciiSize = baseProperty('length');

	  /**
	   * Converts an ASCII `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function asciiToArray(string) {
	    return string.split('');
	  }

	  /**
	   * Splits an ASCII `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function asciiWords(string) {
	    return string.match(reAsciiWord) || [];
	  }

	  /**
	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
	   * without support for iteratee shorthands, which iterates over `collection`
	   * using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the found element or its key, else `undefined`.
	   */
	  function baseFindKey(collection, predicate, eachFunc) {
	    var result;
	    eachFunc(collection, function(value, key, collection) {
	      if (predicate(value, key, collection)) {
	        result = key;
	        return false;
	      }
	    });
	    return result;
	  }

	  /**
	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
	   * support for iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {Function} predicate The function invoked per iteration.
	   * @param {number} fromIndex The index to search from.
	   * @param {boolean} [fromRight] Specify iterating from right to left.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
	    var length = array.length,
	        index = fromIndex + (fromRight ? 1 : -1);

	    while ((fromRight ? index-- : ++index < length)) {
	      if (predicate(array[index], index, array)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOf(array, value, fromIndex) {
	    return value === value
	      ? strictIndexOf(array, value, fromIndex)
	      : baseFindIndex(array, baseIsNaN, fromIndex);
	  }

	  /**
	   * This function is like `baseIndexOf` except that it accepts a comparator.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @param {Function} comparator The comparator invoked per element.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function baseIndexOfWith(array, value, fromIndex, comparator) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (comparator(array[index], value)) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * The base implementation of `_.isNaN` without support for number objects.
	   *
	   * @private
	   * @param {*} value The value to check.
	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	   */
	  function baseIsNaN(value) {
	    return value !== value;
	  }

	  /**
	   * The base implementation of `_.mean` and `_.meanBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the mean.
	   */
	  function baseMean(array, iteratee) {
	    var length = array == null ? 0 : array.length;
	    return length ? (baseSum(array, iteratee) / length) : NAN;
	  }

	  /**
	   * The base implementation of `_.property` without support for deep paths.
	   *
	   * @private
	   * @param {string} key The key of the property to get.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function baseProperty(key) {
	    return function(object) {
	      return object == null ? undefined : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.propertyOf` without support for deep paths.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @returns {Function} Returns the new accessor function.
	   */
	  function basePropertyOf(object) {
	    return function(key) {
	      return object == null ? undefined : object[key];
	    };
	  }

	  /**
	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
	   *
	   * @private
	   * @param {Array|Object} collection The collection to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @param {*} accumulator The initial value.
	   * @param {boolean} initAccum Specify using the first or last element of
	   *  `collection` as the initial value.
	   * @param {Function} eachFunc The function to iterate over `collection`.
	   * @returns {*} Returns the accumulated value.
	   */
	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
	    eachFunc(collection, function(value, index, collection) {
	      accumulator = initAccum
	        ? (initAccum = false, value)
	        : iteratee(accumulator, value, index, collection);
	    });
	    return accumulator;
	  }

	  /**
	   * The base implementation of `_.sortBy` which uses `comparer` to define the
	   * sort order of `array` and replaces criteria objects with their corresponding
	   * values.
	   *
	   * @private
	   * @param {Array} array The array to sort.
	   * @param {Function} comparer The function to define sort order.
	   * @returns {Array} Returns `array`.
	   */
	  function baseSortBy(array, comparer) {
	    var length = array.length;

	    array.sort(comparer);
	    while (length--) {
	      array[length] = array[length].value;
	    }
	    return array;
	  }

	  /**
	   * The base implementation of `_.sum` and `_.sumBy` without support for
	   * iteratee shorthands.
	   *
	   * @private
	   * @param {Array} array The array to iterate over.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {number} Returns the sum.
	   */
	  function baseSum(array, iteratee) {
	    var result,
	        index = -1,
	        length = array.length;

	    while (++index < length) {
	      var current = iteratee(array[index]);
	      if (current !== undefined) {
	        result = result === undefined ? current : (result + current);
	      }
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.times` without support for iteratee shorthands
	   * or max array length checks.
	   *
	   * @private
	   * @param {number} n The number of times to invoke `iteratee`.
	   * @param {Function} iteratee The function invoked per iteration.
	   * @returns {Array} Returns the array of results.
	   */
	  function baseTimes(n, iteratee) {
	    var index = -1,
	        result = Array(n);

	    while (++index < n) {
	      result[index] = iteratee(index);
	    }
	    return result;
	  }

	  /**
	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
	   * of key-value pairs for `object` corresponding to the property names of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the key-value pairs.
	   */
	  function baseToPairs(object, props) {
	    return arrayMap(props, function(key) {
	      return [key, object[key]];
	    });
	  }

	  /**
	   * The base implementation of `_.unary` without support for storing metadata.
	   *
	   * @private
	   * @param {Function} func The function to cap arguments for.
	   * @returns {Function} Returns the new capped function.
	   */
	  function baseUnary(func) {
	    return function(value) {
	      return func(value);
	    };
	  }

	  /**
	   * The base implementation of `_.values` and `_.valuesIn` which creates an
	   * array of `object` property values corresponding to the property names
	   * of `props`.
	   *
	   * @private
	   * @param {Object} object The object to query.
	   * @param {Array} props The property names to get values for.
	   * @returns {Object} Returns the array of property values.
	   */
	  function baseValues(object, props) {
	    return arrayMap(props, function(key) {
	      return object[key];
	    });
	  }

	  /**
	   * Checks if a `cache` value for `key` exists.
	   *
	   * @private
	   * @param {Object} cache The cache to query.
	   * @param {string} key The key of the entry to check.
	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	   */
	  function cacheHas(cache, key) {
	    return cache.has(key);
	  }

	  /**
	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the first unmatched string symbol.
	   */
	  function charsStartIndex(strSymbols, chrSymbols) {
	    var index = -1,
	        length = strSymbols.length;

	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
	   * that is not found in the character symbols.
	   *
	   * @private
	   * @param {Array} strSymbols The string symbols to inspect.
	   * @param {Array} chrSymbols The character symbols to find.
	   * @returns {number} Returns the index of the last unmatched string symbol.
	   */
	  function charsEndIndex(strSymbols, chrSymbols) {
	    var index = strSymbols.length;

	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
	    return index;
	  }

	  /**
	   * Gets the number of `placeholder` occurrences in `array`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} placeholder The placeholder to search for.
	   * @returns {number} Returns the placeholder count.
	   */
	  function countHolders(array, placeholder) {
	    var length = array.length,
	        result = 0;

	    while (length--) {
	      if (array[length] === placeholder) {
	        ++result;
	      }
	    }
	    return result;
	  }

	  /**
	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
	   * letters to basic Latin letters.
	   *
	   * @private
	   * @param {string} letter The matched letter to deburr.
	   * @returns {string} Returns the deburred letter.
	   */
	  var deburrLetter = basePropertyOf(deburredLetters);

	  /**
	   * Used by `_.escape` to convert characters to HTML entities.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  var escapeHtmlChar = basePropertyOf(htmlEscapes);

	  /**
	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
	   *
	   * @private
	   * @param {string} chr The matched character to escape.
	   * @returns {string} Returns the escaped character.
	   */
	  function escapeStringChar(chr) {
	    return '\\' + stringEscapes[chr];
	  }

	  /**
	   * Gets the value at `key` of `object`.
	   *
	   * @private
	   * @param {Object} [object] The object to query.
	   * @param {string} key The key of the property to get.
	   * @returns {*} Returns the property value.
	   */
	  function getValue(object, key) {
	    return object == null ? undefined : object[key];
	  }

	  /**
	   * Checks if `string` contains Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
	   */
	  function hasUnicode(string) {
	    return reHasUnicode.test(string);
	  }

	  /**
	   * Checks if `string` contains a word composed of Unicode symbols.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {boolean} Returns `true` if a word is found, else `false`.
	   */
	  function hasUnicodeWord(string) {
	    return reHasUnicodeWord.test(string);
	  }

	  /**
	   * Converts `iterator` to an array.
	   *
	   * @private
	   * @param {Object} iterator The iterator to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function iteratorToArray(iterator) {
	    var data,
	        result = [];

	    while (!(data = iterator.next()).done) {
	      result.push(data.value);
	    }
	    return result;
	  }

	  /**
	   * Converts `map` to its key-value pairs.
	   *
	   * @private
	   * @param {Object} map The map to convert.
	   * @returns {Array} Returns the key-value pairs.
	   */
	  function mapToArray(map) {
	    var index = -1,
	        result = Array(map.size);

	    map.forEach(function(value, key) {
	      result[++index] = [key, value];
	    });
	    return result;
	  }

	  /**
	   * Creates a unary function that invokes `func` with its argument transformed.
	   *
	   * @private
	   * @param {Function} func The function to wrap.
	   * @param {Function} transform The argument transform.
	   * @returns {Function} Returns the new function.
	   */
	  function overArg(func, transform) {
	    return function(arg) {
	      return func(transform(arg));
	    };
	  }

	  /**
	   * Replaces all `placeholder` elements in `array` with an internal placeholder
	   * and returns an array of their indexes.
	   *
	   * @private
	   * @param {Array} array The array to modify.
	   * @param {*} placeholder The placeholder to replace.
	   * @returns {Array} Returns the new array of placeholder indexes.
	   */
	  function replaceHolders(array, placeholder) {
	    var index = -1,
	        length = array.length,
	        resIndex = 0,
	        result = [];

	    while (++index < length) {
	      var value = array[index];
	      if (value === placeholder || value === PLACEHOLDER) {
	        array[index] = PLACEHOLDER;
	        result[resIndex++] = index;
	      }
	    }
	    return result;
	  }

	  /**
	   * Converts `set` to an array of its values.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the values.
	   */
	  function setToArray(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = value;
	    });
	    return result;
	  }

	  /**
	   * Converts `set` to its value-value pairs.
	   *
	   * @private
	   * @param {Object} set The set to convert.
	   * @returns {Array} Returns the value-value pairs.
	   */
	  function setToPairs(set) {
	    var index = -1,
	        result = Array(set.size);

	    set.forEach(function(value) {
	      result[++index] = [value, value];
	    });
	    return result;
	  }

	  /**
	   * A specialized version of `_.indexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictIndexOf(array, value, fromIndex) {
	    var index = fromIndex - 1,
	        length = array.length;

	    while (++index < length) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return -1;
	  }

	  /**
	   * A specialized version of `_.lastIndexOf` which performs strict equality
	   * comparisons of values, i.e. `===`.
	   *
	   * @private
	   * @param {Array} array The array to inspect.
	   * @param {*} value The value to search for.
	   * @param {number} fromIndex The index to search from.
	   * @returns {number} Returns the index of the matched value, else `-1`.
	   */
	  function strictLastIndexOf(array, value, fromIndex) {
	    var index = fromIndex + 1;
	    while (index--) {
	      if (array[index] === value) {
	        return index;
	      }
	    }
	    return index;
	  }

	  /**
	   * Gets the number of symbols in `string`.
	   *
	   * @private
	   * @param {string} string The string to inspect.
	   * @returns {number} Returns the string size.
	   */
	  function stringSize(string) {
	    return hasUnicode(string)
	      ? unicodeSize(string)
	      : asciiSize(string);
	  }

	  /**
	   * Converts `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function stringToArray(string) {
	    return hasUnicode(string)
	      ? unicodeToArray(string)
	      : asciiToArray(string);
	  }

	  /**
	   * Used by `_.unescape` to convert HTML entities to characters.
	   *
	   * @private
	   * @param {string} chr The matched character to unescape.
	   * @returns {string} Returns the unescaped character.
	   */
	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

	  /**
	   * Gets the size of a Unicode `string`.
	   *
	   * @private
	   * @param {string} string The string inspect.
	   * @returns {number} Returns the string size.
	   */
	  function unicodeSize(string) {
	    var result = reUnicode.lastIndex = 0;
	    while (reUnicode.test(string)) {
	      ++result;
	    }
	    return result;
	  }

	  /**
	   * Converts a Unicode `string` to an array.
	   *
	   * @private
	   * @param {string} string The string to convert.
	   * @returns {Array} Returns the converted array.
	   */
	  function unicodeToArray(string) {
	    return string.match(reUnicode) || [];
	  }

	  /**
	   * Splits a Unicode `string` into an array of its words.
	   *
	   * @private
	   * @param {string} The string to inspect.
	   * @returns {Array} Returns the words of `string`.
	   */
	  function unicodeWords(string) {
	    return string.match(reUnicodeWord) || [];
	  }

	  /*--------------------------------------------------------------------------*/

	  /**
	   * Create a new pristine `lodash` function using the `context` object.
	   *
	   * @static
	   * @memberOf _
	   * @since 1.1.0
	   * @category Util
	   * @param {Object} [context=root] The context object.
	   * @returns {Function} Returns a new `lodash` function.
	   * @example
	   *
	   * _.mixin({ 'foo': _.constant('foo') });
	   *
	   * var lodash = _.runInContext();
	   * lodash.mixin({ 'bar': lodash.constant('bar') });
	   *
	   * _.isFunction(_.foo);
	   * // => true
	   * _.isFunction(_.bar);
	   * // => false
	   *
	   * lodash.isFunction(lodash.foo);
	   * // => false
	   * lodash.isFunction(lodash.bar);
	   * // => true
	   *
	   * // Create a suped-up `defer` in Node.js.
	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
	   */
	  var runInContext = (function runInContext(context) {
	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

	    /** Built-in constructor references. */
	    var Array = context.Array,
	        Date = context.Date,
	        Error = context.Error,
	        Function = context.Function,
	        Math = context.Math,
	        Object = context.Object,
	        RegExp = context.RegExp,
	        String = context.String,
	        TypeError = context.TypeError;

	    /** Used for built-in method references. */
	    var arrayProto = Array.prototype,
	        funcProto = Function.prototype,
	        objectProto = Object.prototype;

	    /** Used to detect overreaching core-js shims. */
	    var coreJsData = context['__core-js_shared__'];

	    /** Used to resolve the decompiled source of functions. */
	    var funcToString = funcProto.toString;

	    /** Used to check objects for own properties. */
	    var hasOwnProperty = objectProto.hasOwnProperty;

	    /** Used to generate unique IDs. */
	    var idCounter = 0;

	    /** Used to detect methods masquerading as native. */
	    var maskSrcKey = (function() {
	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	      return uid ? ('Symbol(src)_1.' + uid) : '';
	    }());

	    /**
	     * Used to resolve the
	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	     * of values.
	     */
	    var nativeObjectToString = objectProto.toString;

	    /** Used to infer the `Object` constructor. */
	    var objectCtorString = funcToString.call(Object);

	    /** Used to restore the original `_` reference in `_.noConflict`. */
	    var oldDash = root._;

	    /** Used to detect if a method is native. */
	    var reIsNative = RegExp('^' +
	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	    );

	    /** Built-in value references. */
	    var Buffer = moduleExports ? context.Buffer : undefined,
	        Symbol = context.Symbol,
	        Uint8Array = context.Uint8Array,
	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
	        getPrototype = overArg(Object.getPrototypeOf, Object),
	        objectCreate = Object.create,
	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
	        splice = arrayProto.splice,
	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
	        symIterator = Symbol ? Symbol.iterator : undefined,
	        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	    var defineProperty = (function() {
	      try {
	        var func = getNative(Object, 'defineProperty');
	        func({}, '', {});
	        return func;
	      } catch (e) {}
	    }());

	    /** Mocked built-ins. */
	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

	    /* Built-in method references for those with the same name as other `lodash` methods. */
	    var nativeCeil = Math.ceil,
	        nativeFloor = Math.floor,
	        nativeGetSymbols = Object.getOwnPropertySymbols,
	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	        nativeIsFinite = context.isFinite,
	        nativeJoin = arrayProto.join,
	        nativeKeys = overArg(Object.keys, Object),
	        nativeMax = Math.max,
	        nativeMin = Math.min,
	        nativeNow = Date.now,
	        nativeParseInt = context.parseInt,
	        nativeRandom = Math.random,
	        nativeReverse = arrayProto.reverse;

	    /* Built-in method references that are verified to be native. */
	    var DataView = getNative(context, 'DataView'),
	        Map = getNative(context, 'Map'),
	        Promise = getNative(context, 'Promise'),
	        Set = getNative(context, 'Set'),
	        WeakMap = getNative(context, 'WeakMap'),
	        nativeCreate = getNative(Object, 'create');

	    /** Used to store function metadata. */
	    var metaMap = WeakMap && new WeakMap;

	    /** Used to lookup unminified function names. */
	    var realNames = {};

	    /** Used to detect maps, sets, and weakmaps. */
	    var dataViewCtorString = toSource(DataView),
	        mapCtorString = toSource(Map),
	        promiseCtorString = toSource(Promise),
	        setCtorString = toSource(Set),
	        weakMapCtorString = toSource(WeakMap);

	    /** Used to convert symbols to primitives and strings. */
	    var symbolProto = Symbol ? Symbol.prototype : undefined,
	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
	        symbolToString = symbolProto ? symbolProto.toString : undefined;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` object which wraps `value` to enable implicit method
	     * chain sequences. Methods that operate on and return arrays, collections,
	     * and functions can be chained together. Methods that retrieve a single value
	     * or may return a primitive value will automatically end the chain sequence
	     * and return the unwrapped value. Otherwise, the value must be unwrapped
	     * with `_#value`.
	     *
	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
	     * enabled using `_.chain`.
	     *
	     * The execution of chained methods is lazy, that is, it's deferred until
	     * `_#value` is implicitly or explicitly called.
	     *
	     * Lazy evaluation allows several methods to support shortcut fusion.
	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
	     * the creation of intermediate arrays and can greatly reduce the number of
	     * iteratee executions. Sections of a chain sequence qualify for shortcut
	     * fusion if the section is applied to an array and iteratees accept only
	     * one argument. The heuristic for whether a section qualifies for shortcut
	     * fusion is subject to change.
	     *
	     * Chaining is supported in custom builds as long as the `_#value` method is
	     * directly or indirectly included in the build.
	     *
	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
	     *
	     * The wrapper `Array` methods are:
	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
	     *
	     * The wrapper `String` methods are:
	     * `replace` and `split`
	     *
	     * The wrapper methods that support shortcut fusion are:
	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
	     *
	     * The chainable wrapper methods are:
	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
	     * `zipObject`, `zipObjectDeep`, and `zipWith`
	     *
	     * The wrapper methods that are **not** chainable by default are:
	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
	     * `upperFirst`, `value`, and `words`
	     *
	     * @name _
	     * @constructor
	     * @category Seq
	     * @param {*} value The value to wrap in a `lodash` instance.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2, 3]);
	     *
	     * // Returns an unwrapped value.
	     * wrapped.reduce(_.add);
	     * // => 6
	     *
	     * // Returns a wrapped value.
	     * var squares = wrapped.map(square);
	     *
	     * _.isArray(squares);
	     * // => false
	     *
	     * _.isArray(squares.value());
	     * // => true
	     */
	    function lodash(value) {
	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
	        if (value instanceof LodashWrapper) {
	          return value;
	        }
	        if (hasOwnProperty.call(value, '__wrapped__')) {
	          return wrapperClone(value);
	        }
	      }
	      return new LodashWrapper(value);
	    }

	    /**
	     * The base implementation of `_.create` without support for assigning
	     * properties to the created object.
	     *
	     * @private
	     * @param {Object} proto The object to inherit from.
	     * @returns {Object} Returns the new object.
	     */
	    var baseCreate = (function() {
	      function object() {}
	      return function(proto) {
	        if (!isObject(proto)) {
	          return {};
	        }
	        if (objectCreate) {
	          return objectCreate(proto);
	        }
	        object.prototype = proto;
	        var result = new object;
	        object.prototype = undefined;
	        return result;
	      };
	    }());

	    /**
	     * The function whose prototype chain sequence wrappers inherit from.
	     *
	     * @private
	     */
	    function baseLodash() {
	      // No operation performed.
	    }

	    /**
	     * The base constructor for creating `lodash` wrapper objects.
	     *
	     * @private
	     * @param {*} value The value to wrap.
	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
	     */
	    function LodashWrapper(value, chainAll) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__chain__ = !!chainAll;
	      this.__index__ = 0;
	      this.__values__ = undefined;
	    }

	    /**
	     * By default, the template delimiters used by lodash are like those in
	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
	     * following template settings to use alternative delimiters.
	     *
	     * @static
	     * @memberOf _
	     * @type {Object}
	     */
	    lodash.templateSettings = {

	      /**
	       * Used to detect `data` property values to be HTML-escaped.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'escape': reEscape,

	      /**
	       * Used to detect code to be evaluated.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'evaluate': reEvaluate,

	      /**
	       * Used to detect `data` property values to inject.
	       *
	       * @memberOf _.templateSettings
	       * @type {RegExp}
	       */
	      'interpolate': reInterpolate,

	      /**
	       * Used to reference the data object in the template text.
	       *
	       * @memberOf _.templateSettings
	       * @type {string}
	       */
	      'variable': '',

	      /**
	       * Used to import variables into the compiled template.
	       *
	       * @memberOf _.templateSettings
	       * @type {Object}
	       */
	      'imports': {

	        /**
	         * A reference to the `lodash` function.
	         *
	         * @memberOf _.templateSettings.imports
	         * @type {Function}
	         */
	        '_': lodash
	      }
	    };

	    // Ensure wrappers are instances of `baseLodash`.
	    lodash.prototype = baseLodash.prototype;
	    lodash.prototype.constructor = lodash;

	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
	    LodashWrapper.prototype.constructor = LodashWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
	     *
	     * @private
	     * @constructor
	     * @param {*} value The value to wrap.
	     */
	    function LazyWrapper(value) {
	      this.__wrapped__ = value;
	      this.__actions__ = [];
	      this.__dir__ = 1;
	      this.__filtered__ = false;
	      this.__iteratees__ = [];
	      this.__takeCount__ = MAX_ARRAY_LENGTH;
	      this.__views__ = [];
	    }

	    /**
	     * Creates a clone of the lazy wrapper object.
	     *
	     * @private
	     * @name clone
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the cloned `LazyWrapper` object.
	     */
	    function lazyClone() {
	      var result = new LazyWrapper(this.__wrapped__);
	      result.__actions__ = copyArray(this.__actions__);
	      result.__dir__ = this.__dir__;
	      result.__filtered__ = this.__filtered__;
	      result.__iteratees__ = copyArray(this.__iteratees__);
	      result.__takeCount__ = this.__takeCount__;
	      result.__views__ = copyArray(this.__views__);
	      return result;
	    }

	    /**
	     * Reverses the direction of lazy iteration.
	     *
	     * @private
	     * @name reverse
	     * @memberOf LazyWrapper
	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
	     */
	    function lazyReverse() {
	      if (this.__filtered__) {
	        var result = new LazyWrapper(this);
	        result.__dir__ = -1;
	        result.__filtered__ = true;
	      } else {
	        result = this.clone();
	        result.__dir__ *= -1;
	      }
	      return result;
	    }

	    /**
	     * Extracts the unwrapped value from its lazy wrapper.
	     *
	     * @private
	     * @name value
	     * @memberOf LazyWrapper
	     * @returns {*} Returns the unwrapped value.
	     */
	    function lazyValue() {
	      var array = this.__wrapped__.value(),
	          dir = this.__dir__,
	          isArr = isArray(array),
	          isRight = dir < 0,
	          arrLength = isArr ? array.length : 0,
	          view = getView(0, arrLength, this.__views__),
	          start = view.start,
	          end = view.end,
	          length = end - start,
	          index = isRight ? end : (start - 1),
	          iteratees = this.__iteratees__,
	          iterLength = iteratees.length,
	          resIndex = 0,
	          takeCount = nativeMin(length, this.__takeCount__);

	      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
	        return baseWrapperValue(array, this.__actions__);
	      }
	      var result = [];

	      outer:
	      while (length-- && resIndex < takeCount) {
	        index += dir;

	        var iterIndex = -1,
	            value = array[index];

	        while (++iterIndex < iterLength) {
	          var data = iteratees[iterIndex],
	              iteratee = data.iteratee,
	              type = data.type,
	              computed = iteratee(value);

	          if (type == LAZY_MAP_FLAG) {
	            value = computed;
	          } else if (!computed) {
	            if (type == LAZY_FILTER_FLAG) {
	              continue outer;
	            } else {
	              break outer;
	            }
	          }
	        }
	        result[resIndex++] = value;
	      }
	      return result;
	    }

	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
	    LazyWrapper.prototype.constructor = LazyWrapper;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a hash object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Hash(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the hash.
	     *
	     * @private
	     * @name clear
	     * @memberOf Hash
	     */
	    function hashClear() {
	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the hash.
	     *
	     * @private
	     * @name delete
	     * @memberOf Hash
	     * @param {Object} hash The hash to modify.
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function hashDelete(key) {
	      var result = this.has(key) && delete this.__data__[key];
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the hash value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Hash
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function hashGet(key) {
	      var data = this.__data__;
	      if (nativeCreate) {
	        var result = data[key];
	        return result === HASH_UNDEFINED ? undefined : result;
	      }
	      return hasOwnProperty.call(data, key) ? data[key] : undefined;
	    }

	    /**
	     * Checks if a hash value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Hash
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function hashHas(key) {
	      var data = this.__data__;
	      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
	    }

	    /**
	     * Sets the hash `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Hash
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the hash instance.
	     */
	    function hashSet(key, value) {
	      var data = this.__data__;
	      this.size += this.has(key) ? 0 : 1;
	      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
	      return this;
	    }

	    // Add methods to `Hash`.
	    Hash.prototype.clear = hashClear;
	    Hash.prototype['delete'] = hashDelete;
	    Hash.prototype.get = hashGet;
	    Hash.prototype.has = hashHas;
	    Hash.prototype.set = hashSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an list cache object.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function ListCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the list cache.
	     *
	     * @private
	     * @name clear
	     * @memberOf ListCache
	     */
	    function listCacheClear() {
	      this.__data__ = [];
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the list cache.
	     *
	     * @private
	     * @name delete
	     * @memberOf ListCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function listCacheDelete(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        return false;
	      }
	      var lastIndex = data.length - 1;
	      if (index == lastIndex) {
	        data.pop();
	      } else {
	        splice.call(data, index, 1);
	      }
	      --this.size;
	      return true;
	    }

	    /**
	     * Gets the list cache value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf ListCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function listCacheGet(key) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      return index < 0 ? undefined : data[index][1];
	    }

	    /**
	     * Checks if a list cache value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf ListCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function listCacheHas(key) {
	      return assocIndexOf(this.__data__, key) > -1;
	    }

	    /**
	     * Sets the list cache `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf ListCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the list cache instance.
	     */
	    function listCacheSet(key, value) {
	      var data = this.__data__,
	          index = assocIndexOf(data, key);

	      if (index < 0) {
	        ++this.size;
	        data.push([key, value]);
	      } else {
	        data[index][1] = value;
	      }
	      return this;
	    }

	    // Add methods to `ListCache`.
	    ListCache.prototype.clear = listCacheClear;
	    ListCache.prototype['delete'] = listCacheDelete;
	    ListCache.prototype.get = listCacheGet;
	    ListCache.prototype.has = listCacheHas;
	    ListCache.prototype.set = listCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a map cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function MapCache(entries) {
	      var index = -1,
	          length = entries == null ? 0 : entries.length;

	      this.clear();
	      while (++index < length) {
	        var entry = entries[index];
	        this.set(entry[0], entry[1]);
	      }
	    }

	    /**
	     * Removes all key-value entries from the map.
	     *
	     * @private
	     * @name clear
	     * @memberOf MapCache
	     */
	    function mapCacheClear() {
	      this.size = 0;
	      this.__data__ = {
	        'hash': new Hash,
	        'map': new (Map || ListCache),
	        'string': new Hash
	      };
	    }

	    /**
	     * Removes `key` and its value from the map.
	     *
	     * @private
	     * @name delete
	     * @memberOf MapCache
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function mapCacheDelete(key) {
	      var result = getMapData(this, key)['delete'](key);
	      this.size -= result ? 1 : 0;
	      return result;
	    }

	    /**
	     * Gets the map value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf MapCache
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function mapCacheGet(key) {
	      return getMapData(this, key).get(key);
	    }

	    /**
	     * Checks if a map value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf MapCache
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function mapCacheHas(key) {
	      return getMapData(this, key).has(key);
	    }

	    /**
	     * Sets the map `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf MapCache
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the map cache instance.
	     */
	    function mapCacheSet(key, value) {
	      var data = getMapData(this, key),
	          size = data.size;

	      data.set(key, value);
	      this.size += data.size == size ? 0 : 1;
	      return this;
	    }

	    // Add methods to `MapCache`.
	    MapCache.prototype.clear = mapCacheClear;
	    MapCache.prototype['delete'] = mapCacheDelete;
	    MapCache.prototype.get = mapCacheGet;
	    MapCache.prototype.has = mapCacheHas;
	    MapCache.prototype.set = mapCacheSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     *
	     * Creates an array cache object to store unique values.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [values] The values to cache.
	     */
	    function SetCache(values) {
	      var index = -1,
	          length = values == null ? 0 : values.length;

	      this.__data__ = new MapCache;
	      while (++index < length) {
	        this.add(values[index]);
	      }
	    }

	    /**
	     * Adds `value` to the array cache.
	     *
	     * @private
	     * @name add
	     * @memberOf SetCache
	     * @alias push
	     * @param {*} value The value to cache.
	     * @returns {Object} Returns the cache instance.
	     */
	    function setCacheAdd(value) {
	      this.__data__.set(value, HASH_UNDEFINED);
	      return this;
	    }

	    /**
	     * Checks if `value` is in the array cache.
	     *
	     * @private
	     * @name has
	     * @memberOf SetCache
	     * @param {*} value The value to search for.
	     * @returns {number} Returns `true` if `value` is found, else `false`.
	     */
	    function setCacheHas(value) {
	      return this.__data__.has(value);
	    }

	    // Add methods to `SetCache`.
	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
	    SetCache.prototype.has = setCacheHas;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a stack cache object to store key-value pairs.
	     *
	     * @private
	     * @constructor
	     * @param {Array} [entries] The key-value pairs to cache.
	     */
	    function Stack(entries) {
	      var data = this.__data__ = new ListCache(entries);
	      this.size = data.size;
	    }

	    /**
	     * Removes all key-value entries from the stack.
	     *
	     * @private
	     * @name clear
	     * @memberOf Stack
	     */
	    function stackClear() {
	      this.__data__ = new ListCache;
	      this.size = 0;
	    }

	    /**
	     * Removes `key` and its value from the stack.
	     *
	     * @private
	     * @name delete
	     * @memberOf Stack
	     * @param {string} key The key of the value to remove.
	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
	     */
	    function stackDelete(key) {
	      var data = this.__data__,
	          result = data['delete'](key);

	      this.size = data.size;
	      return result;
	    }

	    /**
	     * Gets the stack value for `key`.
	     *
	     * @private
	     * @name get
	     * @memberOf Stack
	     * @param {string} key The key of the value to get.
	     * @returns {*} Returns the entry value.
	     */
	    function stackGet(key) {
	      return this.__data__.get(key);
	    }

	    /**
	     * Checks if a stack value for `key` exists.
	     *
	     * @private
	     * @name has
	     * @memberOf Stack
	     * @param {string} key The key of the entry to check.
	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
	     */
	    function stackHas(key) {
	      return this.__data__.has(key);
	    }

	    /**
	     * Sets the stack `key` to `value`.
	     *
	     * @private
	     * @name set
	     * @memberOf Stack
	     * @param {string} key The key of the value to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns the stack cache instance.
	     */
	    function stackSet(key, value) {
	      var data = this.__data__;
	      if (data instanceof ListCache) {
	        var pairs = data.__data__;
	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
	          pairs.push([key, value]);
	          this.size = ++data.size;
	          return this;
	        }
	        data = this.__data__ = new MapCache(pairs);
	      }
	      data.set(key, value);
	      this.size = data.size;
	      return this;
	    }

	    // Add methods to `Stack`.
	    Stack.prototype.clear = stackClear;
	    Stack.prototype['delete'] = stackDelete;
	    Stack.prototype.get = stackGet;
	    Stack.prototype.has = stackHas;
	    Stack.prototype.set = stackSet;

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of the enumerable property names of the array-like `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @param {boolean} inherited Specify returning inherited property names.
	     * @returns {Array} Returns the array of property names.
	     */
	    function arrayLikeKeys(value, inherited) {
	      var isArr = isArray(value),
	          isArg = !isArr && isArguments(value),
	          isBuff = !isArr && !isArg && isBuffer(value),
	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
	          skipIndexes = isArr || isArg || isBuff || isType,
	          result = skipIndexes ? baseTimes(value.length, String) : [],
	          length = result.length;

	      for (var key in value) {
	        if ((inherited || hasOwnProperty.call(value, key)) &&
	            !(skipIndexes && (
	               // Safari 9 has enumerable `arguments.length` in strict mode.
	               key == 'length' ||
	               // Node.js 0.10 has enumerable non-index properties on buffers.
	               (isBuff && (key == 'offset' || key == 'parent')) ||
	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
	               // Skip index properties.
	               isIndex(key, length)
	            ))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `_.sample` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @returns {*} Returns the random element.
	     */
	    function arraySample(array) {
	      var length = array.length;
	      return length ? array[baseRandom(0, length - 1)] : undefined;
	    }

	    /**
	     * A specialized version of `_.sampleSize` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function arraySampleSize(array, n) {
	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
	    }

	    /**
	     * A specialized version of `_.shuffle` for arrays.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function arrayShuffle(array) {
	      return shuffleSelf(copyArray(array));
	    }

	    /**
	     * This function is like `assignValue` except that it doesn't assign
	     * `undefined` values.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignMergeValue(object, key, value) {
	      if ((value !== undefined && !eq(object[key], value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function assignValue(object, key, value) {
	      var objValue = object[key];
	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
	          (value === undefined && !(key in object))) {
	        baseAssignValue(object, key, value);
	      }
	    }

	    /**
	     * Gets the index at which the `key` is found in `array` of key-value pairs.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {*} key The key to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     */
	    function assocIndexOf(array, key) {
	      var length = array.length;
	      while (length--) {
	        if (eq(array[length][0], key)) {
	          return length;
	        }
	      }
	      return -1;
	    }

	    /**
	     * Aggregates elements of `collection` on `accumulator` with keys transformed
	     * by `iteratee` and values set by `setter`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform keys.
	     * @param {Object} accumulator The initial aggregated object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseAggregator(collection, setter, iteratee, accumulator) {
	      baseEach(collection, function(value, key, collection) {
	        setter(accumulator, value, iteratee(value), collection);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.assign` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssign(object, source) {
	      return object && copyObject(source, keys(source), object);
	    }

	    /**
	     * The base implementation of `_.assignIn` without support for multiple sources
	     * or `customizer` functions.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @returns {Object} Returns `object`.
	     */
	    function baseAssignIn(object, source) {
	      return object && copyObject(source, keysIn(source), object);
	    }

	    /**
	     * The base implementation of `assignValue` and `assignMergeValue` without
	     * value checks.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {string} key The key of the property to assign.
	     * @param {*} value The value to assign.
	     */
	    function baseAssignValue(object, key, value) {
	      if (key == '__proto__' && defineProperty) {
	        defineProperty(object, key, {
	          'configurable': true,
	          'enumerable': true,
	          'value': value,
	          'writable': true
	        });
	      } else {
	        object[key] = value;
	      }
	    }

	    /**
	     * The base implementation of `_.at` without support for individual paths.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Array} Returns the picked elements.
	     */
	    function baseAt(object, paths) {
	      var index = -1,
	          length = paths.length,
	          result = Array(length),
	          skip = object == null;

	      while (++index < length) {
	        result[index] = skip ? undefined : get(object, paths[index]);
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.clamp` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     */
	    function baseClamp(number, lower, upper) {
	      if (number === number) {
	        if (upper !== undefined) {
	          number = number <= upper ? number : upper;
	        }
	        if (lower !== undefined) {
	          number = number >= lower ? number : lower;
	        }
	      }
	      return number;
	    }

	    /**
	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
	     * traversed objects.
	     *
	     * @private
	     * @param {*} value The value to clone.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Deep clone
	     *  2 - Flatten inherited properties
	     *  4 - Clone symbols
	     * @param {Function} [customizer] The function to customize cloning.
	     * @param {string} [key] The key of `value`.
	     * @param {Object} [object] The parent object of `value`.
	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
	     * @returns {*} Returns the cloned value.
	     */
	    function baseClone(value, bitmask, customizer, key, object, stack) {
	      var result,
	          isDeep = bitmask & CLONE_DEEP_FLAG,
	          isFlat = bitmask & CLONE_FLAT_FLAG,
	          isFull = bitmask & CLONE_SYMBOLS_FLAG;

	      if (customizer) {
	        result = object ? customizer(value, key, object, stack) : customizer(value);
	      }
	      if (result !== undefined) {
	        return result;
	      }
	      if (!isObject(value)) {
	        return value;
	      }
	      var isArr = isArray(value);
	      if (isArr) {
	        result = initCloneArray(value);
	        if (!isDeep) {
	          return copyArray(value, result);
	        }
	      } else {
	        var tag = getTag(value),
	            isFunc = tag == funcTag || tag == genTag;

	        if (isBuffer(value)) {
	          return cloneBuffer(value, isDeep);
	        }
	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
	          if (!isDeep) {
	            return isFlat
	              ? copySymbolsIn(value, baseAssignIn(result, value))
	              : copySymbols(value, baseAssign(result, value));
	          }
	        } else {
	          if (!cloneableTags[tag]) {
	            return object ? value : {};
	          }
	          result = initCloneByTag(value, tag, baseClone, isDeep);
	        }
	      }
	      // Check for circular references and return its corresponding clone.
	      stack || (stack = new Stack);
	      var stacked = stack.get(value);
	      if (stacked) {
	        return stacked;
	      }
	      stack.set(value, result);

	      var keysFunc = isFull
	        ? (isFlat ? getAllKeysIn : getAllKeys)
	        : (isFlat ? keysIn : keys);

	      var props = isArr ? undefined : keysFunc(value);
	      arrayEach(props || value, function(subValue, key) {
	        if (props) {
	          key = subValue;
	          subValue = value[key];
	        }
	        // Recursively populate clone (susceptible to call stack limits).
	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.conforms` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseConforms(source) {
	      var props = keys(source);
	      return function(object) {
	        return baseConformsTo(object, source, props);
	      };
	    }

	    /**
	     * The base implementation of `_.conformsTo` which accepts `props` to check.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     */
	    function baseConformsTo(object, source, props) {
	      var length = props.length;
	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (length--) {
	        var key = props[length],
	            predicate = source[key],
	            value = object[key];

	        if ((value === undefined && !(key in object)) || !predicate(value)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
	     * to provide to `func`.
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {Array} args The arguments to provide to `func`.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    function baseDelay(func, wait, args) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return setTimeout(function() { func.apply(undefined, args); }, wait);
	    }

	    /**
	     * The base implementation of methods like `_.difference` without support
	     * for excluding multiple arrays or iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Array} values The values to exclude.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     */
	    function baseDifference(array, values, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          isCommon = true,
	          length = array.length,
	          result = [],
	          valuesLength = values.length;

	      if (!length) {
	        return result;
	      }
	      if (iteratee) {
	        values = arrayMap(values, baseUnary(iteratee));
	      }
	      if (comparator) {
	        includes = arrayIncludesWith;
	        isCommon = false;
	      }
	      else if (values.length >= LARGE_ARRAY_SIZE) {
	        includes = cacheHas;
	        isCommon = false;
	        values = new SetCache(values);
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee == null ? value : iteratee(value);

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var valuesIndex = valuesLength;
	          while (valuesIndex--) {
	            if (values[valuesIndex] === computed) {
	              continue outer;
	            }
	          }
	          result.push(value);
	        }
	        else if (!includes(values, computed, comparator)) {
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.forEach` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEach = createBaseEach(baseForOwn);

	    /**
	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     */
	    var baseEachRight = createBaseEach(baseForOwnRight, true);

	    /**
	     * The base implementation of `_.every` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`
	     */
	    function baseEvery(collection, predicate) {
	      var result = true;
	      baseEach(collection, function(value, index, collection) {
	        result = !!predicate(value, index, collection);
	        return result;
	      });
	      return result;
	    }

	    /**
	     * The base implementation of methods like `_.max` and `_.min` which accepts a
	     * `comparator` to determine the extremum value.
	     *
	     * @private
	     * @param {Array} array The array to iterate over.
	     * @param {Function} iteratee The iteratee invoked per iteration.
	     * @param {Function} comparator The comparator used to compare values.
	     * @returns {*} Returns the extremum value.
	     */
	    function baseExtremum(array, iteratee, comparator) {
	      var index = -1,
	          length = array.length;

	      while (++index < length) {
	        var value = array[index],
	            current = iteratee(value);

	        if (current != null && (computed === undefined
	              ? (current === current && !isSymbol(current))
	              : comparator(current, computed)
	            )) {
	          var computed = current,
	              result = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.fill` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     */
	    function baseFill(array, value, start, end) {
	      var length = array.length;

	      start = toInteger(start);
	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = (end === undefined || end > length) ? length : toInteger(end);
	      if (end < 0) {
	        end += length;
	      }
	      end = start > end ? 0 : toLength(end);
	      while (start < end) {
	        array[start++] = value;
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.filter` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     */
	    function baseFilter(collection, predicate) {
	      var result = [];
	      baseEach(collection, function(value, index, collection) {
	        if (predicate(value, index, collection)) {
	          result.push(value);
	        }
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.flatten` with support for restricting flattening.
	     *
	     * @private
	     * @param {Array} array The array to flatten.
	     * @param {number} depth The maximum recursion depth.
	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	     * @param {Array} [result=[]] The initial result value.
	     * @returns {Array} Returns the new flattened array.
	     */
	    function baseFlatten(array, depth, predicate, isStrict, result) {
	      var index = -1,
	          length = array.length;

	      predicate || (predicate = isFlattenable);
	      result || (result = []);

	      while (++index < length) {
	        var value = array[index];
	        if (depth > 0 && predicate(value)) {
	          if (depth > 1) {
	            // Recursively flatten arrays (susceptible to call stack limits).
	            baseFlatten(value, depth - 1, predicate, isStrict, result);
	          } else {
	            arrayPush(result, value);
	          }
	        } else if (!isStrict) {
	          result[result.length] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `baseForOwn` which iterates over `object`
	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseFor = createBaseFor();

	    /**
	     * This function is like `baseFor` except that it iterates over properties
	     * in the opposite order.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @returns {Object} Returns `object`.
	     */
	    var baseForRight = createBaseFor(true);

	    /**
	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwn(object, iteratee) {
	      return object && baseFor(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     */
	    function baseForOwnRight(object, iteratee) {
	      return object && baseForRight(object, iteratee, keys);
	    }

	    /**
	     * The base implementation of `_.functions` which creates an array of
	     * `object` function property names filtered from `props`.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Array} props The property names to filter.
	     * @returns {Array} Returns the function names.
	     */
	    function baseFunctions(object, props) {
	      return arrayFilter(props, function(key) {
	        return isFunction(object[key]);
	      });
	    }

	    /**
	     * The base implementation of `_.get` without support for default values.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseGet(object, path) {
	      path = castPath(path, object);

	      var index = 0,
	          length = path.length;

	      while (object != null && index < length) {
	        object = object[toKey(path[index++])];
	      }
	      return (index && index == length) ? object : undefined;
	    }

	    /**
	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Function} keysFunc The function to get the keys of `object`.
	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
	      var result = keysFunc(object);
	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
	    }

	    /**
	     * The base implementation of `getTag` without fallbacks for buggy environments.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    function baseGetTag(value) {
	      if (value == null) {
	        return value === undefined ? undefinedTag : nullTag;
	      }
	      return (symToStringTag && symToStringTag in Object(value))
	        ? getRawTag(value)
	        : objectToString(value);
	    }

	    /**
	     * The base implementation of `_.gt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     */
	    function baseGt(value, other) {
	      return value > other;
	    }

	    /**
	     * The base implementation of `_.has` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHas(object, key) {
	      return object != null && hasOwnProperty.call(object, key);
	    }

	    /**
	     * The base implementation of `_.hasIn` without support for deep paths.
	     *
	     * @private
	     * @param {Object} [object] The object to query.
	     * @param {Array|string} key The key to check.
	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
	     */
	    function baseHasIn(object, key) {
	      return object != null && key in Object(object);
	    }

	    /**
	     * The base implementation of `_.inRange` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {number} number The number to check.
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     */
	    function baseInRange(number, start, end) {
	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
	    }

	    /**
	     * The base implementation of methods like `_.intersection`, without support
	     * for iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of shared values.
	     */
	    function baseIntersection(arrays, iteratee, comparator) {
	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
	          length = arrays[0].length,
	          othLength = arrays.length,
	          othIndex = othLength,
	          caches = Array(othLength),
	          maxLength = Infinity,
	          result = [];

	      while (othIndex--) {
	        var array = arrays[othIndex];
	        if (othIndex && iteratee) {
	          array = arrayMap(array, baseUnary(iteratee));
	        }
	        maxLength = nativeMin(array.length, maxLength);
	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
	          ? new SetCache(othIndex && array)
	          : undefined;
	      }
	      array = arrays[0];

	      var index = -1,
	          seen = caches[0];

	      outer:
	      while (++index < length && result.length < maxLength) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (!(seen
	              ? cacheHas(seen, computed)
	              : includes(result, computed, comparator)
	            )) {
	          othIndex = othLength;
	          while (--othIndex) {
	            var cache = caches[othIndex];
	            if (!(cache
	                  ? cacheHas(cache, computed)
	                  : includes(arrays[othIndex], computed, comparator))
	                ) {
	              continue outer;
	            }
	          }
	          if (seen) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.invert` and `_.invertBy` which inverts
	     * `object` with values transformed by `iteratee` and set by `setter`.
	     *
	     * @private
	     * @param {Object} object The object to iterate over.
	     * @param {Function} setter The function to set `accumulator` values.
	     * @param {Function} iteratee The iteratee to transform values.
	     * @param {Object} accumulator The initial inverted object.
	     * @returns {Function} Returns `accumulator`.
	     */
	    function baseInverter(object, setter, iteratee, accumulator) {
	      baseForOwn(object, function(value, key, object) {
	        setter(accumulator, iteratee(value), key, object);
	      });
	      return accumulator;
	    }

	    /**
	     * The base implementation of `_.invoke` without support for individual
	     * method arguments.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {Array} args The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     */
	    function baseInvoke(object, path, args) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      var func = object == null ? object : object[toKey(last(path))];
	      return func == null ? undefined : apply(func, object, args);
	    }

	    /**
	     * The base implementation of `_.isArguments`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     */
	    function baseIsArguments(value) {
	      return isObjectLike(value) && baseGetTag(value) == argsTag;
	    }

	    /**
	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     */
	    function baseIsArrayBuffer(value) {
	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
	    }

	    /**
	     * The base implementation of `_.isDate` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     */
	    function baseIsDate(value) {
	      return isObjectLike(value) && baseGetTag(value) == dateTag;
	    }

	    /**
	     * The base implementation of `_.isEqual` which supports partial comparisons
	     * and tracks traversed objects.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {boolean} bitmask The bitmask flags.
	     *  1 - Unordered comparison
	     *  2 - Partial comparison
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     */
	    function baseIsEqual(value, other, bitmask, customizer, stack) {
	      if (value === other) {
	        return true;
	      }
	      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
	        return value !== value && other !== other;
	      }
	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
	    }

	    /**
	     * A specialized version of `baseIsEqual` for arrays and objects which performs
	     * deep comparisons and tracks traversed objects enabling objects with circular
	     * references to be compared.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
	      var objIsArr = isArray(object),
	          othIsArr = isArray(other),
	          objTag = objIsArr ? arrayTag : getTag(object),
	          othTag = othIsArr ? arrayTag : getTag(other);

	      objTag = objTag == argsTag ? objectTag : objTag;
	      othTag = othTag == argsTag ? objectTag : othTag;

	      var objIsObj = objTag == objectTag,
	          othIsObj = othTag == objectTag,
	          isSameTag = objTag == othTag;

	      if (isSameTag && isBuffer(object)) {
	        if (!isBuffer(other)) {
	          return false;
	        }
	        objIsArr = true;
	        objIsObj = false;
	      }
	      if (isSameTag && !objIsObj) {
	        stack || (stack = new Stack);
	        return (objIsArr || isTypedArray(object))
	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
	      }
	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

	        if (objIsWrapped || othIsWrapped) {
	          var objUnwrapped = objIsWrapped ? object.value() : object,
	              othUnwrapped = othIsWrapped ? other.value() : other;

	          stack || (stack = new Stack);
	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
	        }
	      }
	      if (!isSameTag) {
	        return false;
	      }
	      stack || (stack = new Stack);
	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
	    }

	    /**
	     * The base implementation of `_.isMap` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     */
	    function baseIsMap(value) {
	      return isObjectLike(value) && getTag(value) == mapTag;
	    }

	    /**
	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Array} matchData The property names, values, and compare flags to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     */
	    function baseIsMatch(object, source, matchData, customizer) {
	      var index = matchData.length,
	          length = index,
	          noCustomizer = !customizer;

	      if (object == null) {
	        return !length;
	      }
	      object = Object(object);
	      while (index--) {
	        var data = matchData[index];
	        if ((noCustomizer && data[2])
	              ? data[1] !== object[data[0]]
	              : !(data[0] in object)
	            ) {
	          return false;
	        }
	      }
	      while (++index < length) {
	        data = matchData[index];
	        var key = data[0],
	            objValue = object[key],
	            srcValue = data[1];

	        if (noCustomizer && data[2]) {
	          if (objValue === undefined && !(key in object)) {
	            return false;
	          }
	        } else {
	          var stack = new Stack;
	          if (customizer) {
	            var result = customizer(objValue, srcValue, key, object, source, stack);
	          }
	          if (!(result === undefined
	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
	                : result
	              )) {
	            return false;
	          }
	        }
	      }
	      return true;
	    }

	    /**
	     * The base implementation of `_.isNative` without bad shim checks.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     */
	    function baseIsNative(value) {
	      if (!isObject(value) || isMasked(value)) {
	        return false;
	      }
	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
	      return pattern.test(toSource(value));
	    }

	    /**
	     * The base implementation of `_.isRegExp` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     */
	    function baseIsRegExp(value) {
	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
	    }

	    /**
	     * The base implementation of `_.isSet` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     */
	    function baseIsSet(value) {
	      return isObjectLike(value) && getTag(value) == setTag;
	    }

	    /**
	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     */
	    function baseIsTypedArray(value) {
	      return isObjectLike(value) &&
	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
	    }

	    /**
	     * The base implementation of `_.iteratee`.
	     *
	     * @private
	     * @param {*} [value=_.identity] The value to convert to an iteratee.
	     * @returns {Function} Returns the iteratee.
	     */
	    function baseIteratee(value) {
	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
	      if (typeof value == 'function') {
	        return value;
	      }
	      if (value == null) {
	        return identity;
	      }
	      if (typeof value == 'object') {
	        return isArray(value)
	          ? baseMatchesProperty(value[0], value[1])
	          : baseMatches(value);
	      }
	      return property(value);
	    }

	    /**
	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeys(object) {
	      if (!isPrototype(object)) {
	        return nativeKeys(object);
	      }
	      var result = [];
	      for (var key in Object(object)) {
	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function baseKeysIn(object) {
	      if (!isObject(object)) {
	        return nativeKeysIn(object);
	      }
	      var isProto = isPrototype(object),
	          result = [];

	      for (var key in object) {
	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.lt` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     */
	    function baseLt(value, other) {
	      return value < other;
	    }

	    /**
	     * The base implementation of `_.map` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} iteratee The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     */
	    function baseMap(collection, iteratee) {
	      var index = -1,
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value, key, collection) {
	        result[++index] = iteratee(value, key, collection);
	      });
	      return result;
	    }

	    /**
	     * The base implementation of `_.matches` which doesn't clone `source`.
	     *
	     * @private
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatches(source) {
	      var matchData = getMatchData(source);
	      if (matchData.length == 1 && matchData[0][2]) {
	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
	      }
	      return function(object) {
	        return object === source || baseIsMatch(object, source, matchData);
	      };
	    }

	    /**
	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
	     *
	     * @private
	     * @param {string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function baseMatchesProperty(path, srcValue) {
	      if (isKey(path) && isStrictComparable(srcValue)) {
	        return matchesStrictComparable(toKey(path), srcValue);
	      }
	      return function(object) {
	        var objValue = get(object, path);
	        return (objValue === undefined && objValue === srcValue)
	          ? hasIn(object, path)
	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
	      };
	    }

	    /**
	     * The base implementation of `_.merge` without support for multiple sources.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} [customizer] The function to customize merged values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMerge(object, source, srcIndex, customizer, stack) {
	      if (object === source) {
	        return;
	      }
	      baseFor(source, function(srcValue, key) {
	        if (isObject(srcValue)) {
	          stack || (stack = new Stack);
	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
	        }
	        else {
	          var newValue = customizer
	            ? customizer(object[key], srcValue, (key + ''), object, source, stack)
	            : undefined;

	          if (newValue === undefined) {
	            newValue = srcValue;
	          }
	          assignMergeValue(object, key, newValue);
	        }
	      }, keysIn);
	    }

	    /**
	     * A specialized version of `baseMerge` for arrays and objects which performs
	     * deep merges and tracks traversed objects enabling objects with circular
	     * references to be merged.
	     *
	     * @private
	     * @param {Object} object The destination object.
	     * @param {Object} source The source object.
	     * @param {string} key The key of the value to merge.
	     * @param {number} srcIndex The index of `source`.
	     * @param {Function} mergeFunc The function to merge values.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     */
	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
	      var objValue = object[key],
	          srcValue = source[key],
	          stacked = stack.get(srcValue);

	      if (stacked) {
	        assignMergeValue(object, key, stacked);
	        return;
	      }
	      var newValue = customizer
	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
	        : undefined;

	      var isCommon = newValue === undefined;

	      if (isCommon) {
	        var isArr = isArray(srcValue),
	            isBuff = !isArr && isBuffer(srcValue),
	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

	        newValue = srcValue;
	        if (isArr || isBuff || isTyped) {
	          if (isArray(objValue)) {
	            newValue = objValue;
	          }
	          else if (isArrayLikeObject(objValue)) {
	            newValue = copyArray(objValue);
	          }
	          else if (isBuff) {
	            isCommon = false;
	            newValue = cloneBuffer(srcValue, true);
	          }
	          else if (isTyped) {
	            isCommon = false;
	            newValue = cloneTypedArray(srcValue, true);
	          }
	          else {
	            newValue = [];
	          }
	        }
	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
	          newValue = objValue;
	          if (isArguments(objValue)) {
	            newValue = toPlainObject(objValue);
	          }
	          else if (!isObject(objValue) || (srcIndex && isFunction(objValue))) {
	            newValue = initCloneObject(srcValue);
	          }
	        }
	        else {
	          isCommon = false;
	        }
	      }
	      if (isCommon) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, newValue);
	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
	        stack['delete'](srcValue);
	      }
	      assignMergeValue(object, key, newValue);
	    }

	    /**
	     * The base implementation of `_.nth` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {number} n The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     */
	    function baseNth(array, n) {
	      var length = array.length;
	      if (!length) {
	        return;
	      }
	      n += n < 0 ? length : 0;
	      return isIndex(n, length) ? array[n] : undefined;
	    }

	    /**
	     * The base implementation of `_.orderBy` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
	     * @param {string[]} orders The sort orders of `iteratees`.
	     * @returns {Array} Returns the new sorted array.
	     */
	    function baseOrderBy(collection, iteratees, orders) {
	      var index = -1;
	      iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));

	      var result = baseMap(collection, function(value, key, collection) {
	        var criteria = arrayMap(iteratees, function(iteratee) {
	          return iteratee(value);
	        });
	        return { 'criteria': criteria, 'index': ++index, 'value': value };
	      });

	      return baseSortBy(result, function(object, other) {
	        return compareMultiple(object, other, orders);
	      });
	    }

	    /**
	     * The base implementation of `_.pick` without support for individual
	     * property identifiers.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @returns {Object} Returns the new object.
	     */
	    function basePick(object, paths) {
	      return basePickBy(object, paths, function(value, path) {
	        return hasIn(object, path);
	      });
	    }

	    /**
	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Object} object The source object.
	     * @param {string[]} paths The property paths to pick.
	     * @param {Function} predicate The function invoked per property.
	     * @returns {Object} Returns the new object.
	     */
	    function basePickBy(object, paths, predicate) {
	      var index = -1,
	          length = paths.length,
	          result = {};

	      while (++index < length) {
	        var path = paths[index],
	            value = baseGet(object, path);

	        if (predicate(value, path)) {
	          baseSet(result, castPath(path, object), value);
	        }
	      }
	      return result;
	    }

	    /**
	     * A specialized version of `baseProperty` which supports deep paths.
	     *
	     * @private
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     */
	    function basePropertyDeep(path) {
	      return function(object) {
	        return baseGet(object, path);
	      };
	    }

	    /**
	     * The base implementation of `_.pullAllBy` without support for iteratee
	     * shorthands.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAll(array, values, iteratee, comparator) {
	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
	          index = -1,
	          length = values.length,
	          seen = array;

	      if (array === values) {
	        values = copyArray(values);
	      }
	      if (iteratee) {
	        seen = arrayMap(array, baseUnary(iteratee));
	      }
	      while (++index < length) {
	        var fromIndex = 0,
	            value = values[index],
	            computed = iteratee ? iteratee(value) : value;

	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
	          if (seen !== array) {
	            splice.call(seen, fromIndex, 1);
	          }
	          splice.call(array, fromIndex, 1);
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.pullAt` without support for individual
	     * indexes or capturing the removed elements.
	     *
	     * @private
	     * @param {Array} array The array to modify.
	     * @param {number[]} indexes The indexes of elements to remove.
	     * @returns {Array} Returns `array`.
	     */
	    function basePullAt(array, indexes) {
	      var length = array ? indexes.length : 0,
	          lastIndex = length - 1;

	      while (length--) {
	        var index = indexes[length];
	        if (length == lastIndex || index !== previous) {
	          var previous = index;
	          if (isIndex(index)) {
	            splice.call(array, index, 1);
	          } else {
	            baseUnset(array, index);
	          }
	        }
	      }
	      return array;
	    }

	    /**
	     * The base implementation of `_.random` without support for returning
	     * floating-point numbers.
	     *
	     * @private
	     * @param {number} lower The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the random number.
	     */
	    function baseRandom(lower, upper) {
	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
	    }

	    /**
	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
	     * coerce arguments.
	     *
	     * @private
	     * @param {number} start The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} step The value to increment or decrement by.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the range of numbers.
	     */
	    function baseRange(start, end, step, fromRight) {
	      var index = -1,
	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
	          result = Array(length);

	      while (length--) {
	        result[fromRight ? length : ++index] = start;
	        start += step;
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.repeat` which doesn't coerce arguments.
	     *
	     * @private
	     * @param {string} string The string to repeat.
	     * @param {number} n The number of times to repeat the string.
	     * @returns {string} Returns the repeated string.
	     */
	    function baseRepeat(string, n) {
	      var result = '';
	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
	        return result;
	      }
	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
	      do {
	        if (n % 2) {
	          result += string;
	        }
	        n = nativeFloor(n / 2);
	        if (n) {
	          string += string;
	        }
	      } while (n);

	      return result;
	    }

	    /**
	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     */
	    function baseRest(func, start) {
	      return setToString(overRest(func, start, identity), func + '');
	    }

	    /**
	     * The base implementation of `_.sample`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     */
	    function baseSample(collection) {
	      return arraySample(values(collection));
	    }

	    /**
	     * The base implementation of `_.sampleSize` without param guards.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} n The number of elements to sample.
	     * @returns {Array} Returns the random elements.
	     */
	    function baseSampleSize(collection, n) {
	      var array = values(collection);
	      return shuffleSelf(array, baseClamp(n, 0, array.length));
	    }

	    /**
	     * The base implementation of `_.set`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseSet(object, path, value, customizer) {
	      if (!isObject(object)) {
	        return object;
	      }
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          lastIndex = length - 1,
	          nested = object;

	      while (nested != null && ++index < length) {
	        var key = toKey(path[index]),
	            newValue = value;

	        if (index != lastIndex) {
	          var objValue = nested[key];
	          newValue = customizer ? customizer(objValue, key, nested) : undefined;
	          if (newValue === undefined) {
	            newValue = isObject(objValue)
	              ? objValue
	              : (isIndex(path[index + 1]) ? [] : {});
	          }
	        }
	        assignValue(nested, key, newValue);
	        nested = nested[key];
	      }
	      return object;
	    }

	    /**
	     * The base implementation of `setData` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetData = !metaMap ? identity : function(func, data) {
	      metaMap.set(func, data);
	      return func;
	    };

	    /**
	     * The base implementation of `setToString` without support for hot loop shorting.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var baseSetToString = !defineProperty ? identity : function(func, string) {
	      return defineProperty(func, 'toString', {
	        'configurable': true,
	        'enumerable': false,
	        'value': constant(string),
	        'writable': true
	      });
	    };

	    /**
	     * The base implementation of `_.shuffle`.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     */
	    function baseShuffle(collection) {
	      return shuffleSelf(values(collection));
	    }

	    /**
	     * The base implementation of `_.slice` without an iteratee call guard.
	     *
	     * @private
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseSlice(array, start, end) {
	      var index = -1,
	          length = array.length;

	      if (start < 0) {
	        start = -start > length ? 0 : (length + start);
	      }
	      end = end > length ? length : end;
	      if (end < 0) {
	        end += length;
	      }
	      length = start > end ? 0 : ((end - start) >>> 0);
	      start >>>= 0;

	      var result = Array(length);
	      while (++index < length) {
	        result[index] = array[index + start];
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.some` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} predicate The function invoked per iteration.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     */
	    function baseSome(collection, predicate) {
	      var result;

	      baseEach(collection, function(value, index, collection) {
	        result = predicate(value, index, collection);
	        return !result;
	      });
	      return !!result;
	    }

	    /**
	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
	     * performs a binary search of `array` to determine the index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndex(array, value, retHighest) {
	      var low = 0,
	          high = array == null ? low : array.length;

	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
	        while (low < high) {
	          var mid = (low + high) >>> 1,
	              computed = array[mid];

	          if (computed !== null && !isSymbol(computed) &&
	              (retHighest ? (computed <= value) : (computed < value))) {
	            low = mid + 1;
	          } else {
	            high = mid;
	          }
	        }
	        return high;
	      }
	      return baseSortedIndexBy(array, value, identity, retHighest);
	    }

	    /**
	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
	     * which invokes `iteratee` for `value` and each element of `array` to compute
	     * their sort ranking. The iteratee is invoked with one argument; (value).
	     *
	     * @private
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} iteratee The iteratee invoked per element.
	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     */
	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
	      value = iteratee(value);

	      var low = 0,
	          high = array == null ? 0 : array.length,
	          valIsNaN = value !== value,
	          valIsNull = value === null,
	          valIsSymbol = isSymbol(value),
	          valIsUndefined = value === undefined;

	      while (low < high) {
	        var mid = nativeFloor((low + high) / 2),
	            computed = iteratee(array[mid]),
	            othIsDefined = computed !== undefined,
	            othIsNull = computed === null,
	            othIsReflexive = computed === computed,
	            othIsSymbol = isSymbol(computed);

	        if (valIsNaN) {
	          var setLow = retHighest || othIsReflexive;
	        } else if (valIsUndefined) {
	          setLow = othIsReflexive && (retHighest || othIsDefined);
	        } else if (valIsNull) {
	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
	        } else if (valIsSymbol) {
	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
	        } else if (othIsNull || othIsSymbol) {
	          setLow = false;
	        } else {
	          setLow = retHighest ? (computed <= value) : (computed < value);
	        }
	        if (setLow) {
	          low = mid + 1;
	        } else {
	          high = mid;
	        }
	      }
	      return nativeMin(high, MAX_ARRAY_INDEX);
	    }

	    /**
	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
	     * support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseSortedUniq(array, iteratee) {
	      var index = -1,
	          length = array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        if (!index || !eq(computed, seen)) {
	          var seen = computed;
	          result[resIndex++] = value === 0 ? 0 : value;
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.toNumber` which doesn't ensure correct
	     * conversions of binary, hexadecimal, or octal string values.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     */
	    function baseToNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      return +value;
	    }

	    /**
	     * The base implementation of `_.toString` which doesn't convert nullish
	     * values to empty strings.
	     *
	     * @private
	     * @param {*} value The value to process.
	     * @returns {string} Returns the string.
	     */
	    function baseToString(value) {
	      // Exit early for strings to avoid a performance hit in some environments.
	      if (typeof value == 'string') {
	        return value;
	      }
	      if (isArray(value)) {
	        // Recursively convert values (susceptible to call stack limits).
	        return arrayMap(value, baseToString) + '';
	      }
	      if (isSymbol(value)) {
	        return symbolToString ? symbolToString.call(value) : '';
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     */
	    function baseUniq(array, iteratee, comparator) {
	      var index = -1,
	          includes = arrayIncludes,
	          length = array.length,
	          isCommon = true,
	          result = [],
	          seen = result;

	      if (comparator) {
	        isCommon = false;
	        includes = arrayIncludesWith;
	      }
	      else if (length >= LARGE_ARRAY_SIZE) {
	        var set = iteratee ? null : createSet(array);
	        if (set) {
	          return setToArray(set);
	        }
	        isCommon = false;
	        includes = cacheHas;
	        seen = new SetCache;
	      }
	      else {
	        seen = iteratee ? [] : result;
	      }
	      outer:
	      while (++index < length) {
	        var value = array[index],
	            computed = iteratee ? iteratee(value) : value;

	        value = (comparator || value !== 0) ? value : 0;
	        if (isCommon && computed === computed) {
	          var seenIndex = seen.length;
	          while (seenIndex--) {
	            if (seen[seenIndex] === computed) {
	              continue outer;
	            }
	          }
	          if (iteratee) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	        else if (!includes(seen, computed, comparator)) {
	          if (seen !== result) {
	            seen.push(computed);
	          }
	          result.push(value);
	        }
	      }
	      return result;
	    }

	    /**
	     * The base implementation of `_.unset`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The property path to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     */
	    function baseUnset(object, path) {
	      path = castPath(path, object);
	      object = parent(object, path);
	      return object == null || delete object[toKey(last(path))];
	    }

	    /**
	     * The base implementation of `_.update`.
	     *
	     * @private
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to update.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize path creation.
	     * @returns {Object} Returns `object`.
	     */
	    function baseUpdate(object, path, updater, customizer) {
	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
	    }

	    /**
	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
	     * without support for iteratee shorthands.
	     *
	     * @private
	     * @param {Array} array The array to query.
	     * @param {Function} predicate The function invoked per iteration.
	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function baseWhile(array, predicate, isDrop, fromRight) {
	      var length = array.length,
	          index = fromRight ? length : -1;

	      while ((fromRight ? index-- : ++index < length) &&
	        predicate(array[index], index, array)) {}

	      return isDrop
	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
	    }

	    /**
	     * The base implementation of `wrapperValue` which returns the result of
	     * performing a sequence of actions on the unwrapped `value`, where each
	     * successive action is supplied the return value of the previous.
	     *
	     * @private
	     * @param {*} value The unwrapped value.
	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
	     * @returns {*} Returns the resolved value.
	     */
	    function baseWrapperValue(value, actions) {
	      var result = value;
	      if (result instanceof LazyWrapper) {
	        result = result.value();
	      }
	      return arrayReduce(actions, function(result, action) {
	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
	      }, result);
	    }

	    /**
	     * The base implementation of methods like `_.xor`, without support for
	     * iteratee shorthands, that accepts an array of arrays to inspect.
	     *
	     * @private
	     * @param {Array} arrays The arrays to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of values.
	     */
	    function baseXor(arrays, iteratee, comparator) {
	      var length = arrays.length;
	      if (length < 2) {
	        return length ? baseUniq(arrays[0]) : [];
	      }
	      var index = -1,
	          result = Array(length);

	      while (++index < length) {
	        var array = arrays[index],
	            othIndex = -1;

	        while (++othIndex < length) {
	          if (othIndex != index) {
	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
	          }
	        }
	      }
	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
	    }

	    /**
	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
	     *
	     * @private
	     * @param {Array} props The property identifiers.
	     * @param {Array} values The property values.
	     * @param {Function} assignFunc The function to assign values.
	     * @returns {Object} Returns the new object.
	     */
	    function baseZipObject(props, values, assignFunc) {
	      var index = -1,
	          length = props.length,
	          valsLength = values.length,
	          result = {};

	      while (++index < length) {
	        var value = index < valsLength ? values[index] : undefined;
	        assignFunc(result, props[index], value);
	      }
	      return result;
	    }

	    /**
	     * Casts `value` to an empty array if it's not an array like object.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Array|Object} Returns the cast array-like object.
	     */
	    function castArrayLikeObject(value) {
	      return isArrayLikeObject(value) ? value : [];
	    }

	    /**
	     * Casts `value` to `identity` if it's not a function.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {Function} Returns cast function.
	     */
	    function castFunction(value) {
	      return typeof value == 'function' ? value : identity;
	    }

	    /**
	     * Casts `value` to a path array if it's not one.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {Array} Returns the cast property path array.
	     */
	    function castPath(value, object) {
	      if (isArray(value)) {
	        return value;
	      }
	      return isKey(value, object) ? [value] : stringToPath(toString(value));
	    }

	    /**
	     * A `baseRest` alias which can be replaced with `identity` by module
	     * replacement plugins.
	     *
	     * @private
	     * @type {Function}
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    var castRest = baseRest;

	    /**
	     * Casts `array` to a slice if it's needed.
	     *
	     * @private
	     * @param {Array} array The array to inspect.
	     * @param {number} start The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the cast slice.
	     */
	    function castSlice(array, start, end) {
	      var length = array.length;
	      end = end === undefined ? length : end;
	      return (!start && end >= length) ? array : baseSlice(array, start, end);
	    }

	    /**
	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
	     *
	     * @private
	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
	     */
	    var clearTimeout = ctxClearTimeout || function(id) {
	      return root.clearTimeout(id);
	    };

	    /**
	     * Creates a clone of  `buffer`.
	     *
	     * @private
	     * @param {Buffer} buffer The buffer to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Buffer} Returns the cloned buffer.
	     */
	    function cloneBuffer(buffer, isDeep) {
	      if (isDeep) {
	        return buffer.slice();
	      }
	      var length = buffer.length,
	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

	      buffer.copy(result);
	      return result;
	    }

	    /**
	     * Creates a clone of `arrayBuffer`.
	     *
	     * @private
	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
	     * @returns {ArrayBuffer} Returns the cloned array buffer.
	     */
	    function cloneArrayBuffer(arrayBuffer) {
	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
	      return result;
	    }

	    /**
	     * Creates a clone of `dataView`.
	     *
	     * @private
	     * @param {Object} dataView The data view to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned data view.
	     */
	    function cloneDataView(dataView, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
	    }

	    /**
	     * Creates a clone of `map`.
	     *
	     * @private
	     * @param {Object} map The map to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned map.
	     */
	    function cloneMap(map, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(mapToArray(map), CLONE_DEEP_FLAG) : mapToArray(map);
	      return arrayReduce(array, addMapEntry, new map.constructor);
	    }

	    /**
	     * Creates a clone of `regexp`.
	     *
	     * @private
	     * @param {Object} regexp The regexp to clone.
	     * @returns {Object} Returns the cloned regexp.
	     */
	    function cloneRegExp(regexp) {
	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
	      result.lastIndex = regexp.lastIndex;
	      return result;
	    }

	    /**
	     * Creates a clone of `set`.
	     *
	     * @private
	     * @param {Object} set The set to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned set.
	     */
	    function cloneSet(set, isDeep, cloneFunc) {
	      var array = isDeep ? cloneFunc(setToArray(set), CLONE_DEEP_FLAG) : setToArray(set);
	      return arrayReduce(array, addSetEntry, new set.constructor);
	    }

	    /**
	     * Creates a clone of the `symbol` object.
	     *
	     * @private
	     * @param {Object} symbol The symbol object to clone.
	     * @returns {Object} Returns the cloned symbol object.
	     */
	    function cloneSymbol(symbol) {
	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
	    }

	    /**
	     * Creates a clone of `typedArray`.
	     *
	     * @private
	     * @param {Object} typedArray The typed array to clone.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the cloned typed array.
	     */
	    function cloneTypedArray(typedArray, isDeep) {
	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
	    }

	    /**
	     * Compares values to sort them in ascending order.
	     *
	     * @private
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {number} Returns the sort order indicator for `value`.
	     */
	    function compareAscending(value, other) {
	      if (value !== other) {
	        var valIsDefined = value !== undefined,
	            valIsNull = value === null,
	            valIsReflexive = value === value,
	            valIsSymbol = isSymbol(value);

	        var othIsDefined = other !== undefined,
	            othIsNull = other === null,
	            othIsReflexive = other === other,
	            othIsSymbol = isSymbol(other);

	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
	            (valIsNull && othIsDefined && othIsReflexive) ||
	            (!valIsDefined && othIsReflexive) ||
	            !valIsReflexive) {
	          return 1;
	        }
	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
	            (othIsNull && valIsDefined && valIsReflexive) ||
	            (!othIsDefined && valIsReflexive) ||
	            !othIsReflexive) {
	          return -1;
	        }
	      }
	      return 0;
	    }

	    /**
	     * Used by `_.orderBy` to compare multiple properties of a value to another
	     * and stable sort them.
	     *
	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
	     * specify an order of "desc" for descending or "asc" for ascending sort order
	     * of corresponding values.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {boolean[]|string[]} orders The order to sort by for each property.
	     * @returns {number} Returns the sort order indicator for `object`.
	     */
	    function compareMultiple(object, other, orders) {
	      var index = -1,
	          objCriteria = object.criteria,
	          othCriteria = other.criteria,
	          length = objCriteria.length,
	          ordersLength = orders.length;

	      while (++index < length) {
	        var result = compareAscending(objCriteria[index], othCriteria[index]);
	        if (result) {
	          if (index >= ordersLength) {
	            return result;
	          }
	          var order = orders[index];
	          return result * (order == 'desc' ? -1 : 1);
	        }
	      }
	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
	      // that causes it, under certain circumstances, to provide the same value for
	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
	      // for more details.
	      //
	      // This also ensures a stable sort in V8 and other engines.
	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
	      return object.index - other.index;
	    }

	    /**
	     * Creates an array that is the composition of partially applied arguments,
	     * placeholders, and provided arguments into a single array of arguments.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to prepend to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgs(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersLength = holders.length,
	          leftIndex = -1,
	          leftLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(leftLength + rangeLength),
	          isUncurried = !isCurried;

	      while (++leftIndex < leftLength) {
	        result[leftIndex] = partials[leftIndex];
	      }
	      while (++argsIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[holders[argsIndex]] = args[argsIndex];
	        }
	      }
	      while (rangeLength--) {
	        result[leftIndex++] = args[argsIndex++];
	      }
	      return result;
	    }

	    /**
	     * This function is like `composeArgs` except that the arguments composition
	     * is tailored for `_.partialRight`.
	     *
	     * @private
	     * @param {Array} args The provided arguments.
	     * @param {Array} partials The arguments to append to those provided.
	     * @param {Array} holders The `partials` placeholder indexes.
	     * @params {boolean} [isCurried] Specify composing for a curried function.
	     * @returns {Array} Returns the new array of composed arguments.
	     */
	    function composeArgsRight(args, partials, holders, isCurried) {
	      var argsIndex = -1,
	          argsLength = args.length,
	          holdersIndex = -1,
	          holdersLength = holders.length,
	          rightIndex = -1,
	          rightLength = partials.length,
	          rangeLength = nativeMax(argsLength - holdersLength, 0),
	          result = Array(rangeLength + rightLength),
	          isUncurried = !isCurried;

	      while (++argsIndex < rangeLength) {
	        result[argsIndex] = args[argsIndex];
	      }
	      var offset = argsIndex;
	      while (++rightIndex < rightLength) {
	        result[offset + rightIndex] = partials[rightIndex];
	      }
	      while (++holdersIndex < holdersLength) {
	        if (isUncurried || argsIndex < argsLength) {
	          result[offset + holders[holdersIndex]] = args[argsIndex++];
	        }
	      }
	      return result;
	    }

	    /**
	     * Copies the values of `source` to `array`.
	     *
	     * @private
	     * @param {Array} source The array to copy values from.
	     * @param {Array} [array=[]] The array to copy values to.
	     * @returns {Array} Returns `array`.
	     */
	    function copyArray(source, array) {
	      var index = -1,
	          length = source.length;

	      array || (array = Array(length));
	      while (++index < length) {
	        array[index] = source[index];
	      }
	      return array;
	    }

	    /**
	     * Copies properties of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy properties from.
	     * @param {Array} props The property identifiers to copy.
	     * @param {Object} [object={}] The object to copy properties to.
	     * @param {Function} [customizer] The function to customize copied values.
	     * @returns {Object} Returns `object`.
	     */
	    function copyObject(source, props, object, customizer) {
	      var isNew = !object;
	      object || (object = {});

	      var index = -1,
	          length = props.length;

	      while (++index < length) {
	        var key = props[index];

	        var newValue = customizer
	          ? customizer(object[key], source[key], key, object, source)
	          : undefined;

	        if (newValue === undefined) {
	          newValue = source[key];
	        }
	        if (isNew) {
	          baseAssignValue(object, key, newValue);
	        } else {
	          assignValue(object, key, newValue);
	        }
	      }
	      return object;
	    }

	    /**
	     * Copies own symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbols(source, object) {
	      return copyObject(source, getSymbols(source), object);
	    }

	    /**
	     * Copies own and inherited symbols of `source` to `object`.
	     *
	     * @private
	     * @param {Object} source The object to copy symbols from.
	     * @param {Object} [object={}] The object to copy symbols to.
	     * @returns {Object} Returns `object`.
	     */
	    function copySymbolsIn(source, object) {
	      return copyObject(source, getSymbolsIn(source), object);
	    }

	    /**
	     * Creates a function like `_.groupBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} [initializer] The accumulator object initializer.
	     * @returns {Function} Returns the new aggregator function.
	     */
	    function createAggregator(setter, initializer) {
	      return function(collection, iteratee) {
	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
	            accumulator = initializer ? initializer() : {};

	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
	      };
	    }

	    /**
	     * Creates a function like `_.assign`.
	     *
	     * @private
	     * @param {Function} assigner The function to assign values.
	     * @returns {Function} Returns the new assigner function.
	     */
	    function createAssigner(assigner) {
	      return baseRest(function(object, sources) {
	        var index = -1,
	            length = sources.length,
	            customizer = length > 1 ? sources[length - 1] : undefined,
	            guard = length > 2 ? sources[2] : undefined;

	        customizer = (assigner.length > 3 && typeof customizer == 'function')
	          ? (length--, customizer)
	          : undefined;

	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
	          customizer = length < 3 ? undefined : customizer;
	          length = 1;
	        }
	        object = Object(object);
	        while (++index < length) {
	          var source = sources[index];
	          if (source) {
	            assigner(object, source, index, customizer);
	          }
	        }
	        return object;
	      });
	    }

	    /**
	     * Creates a `baseEach` or `baseEachRight` function.
	     *
	     * @private
	     * @param {Function} eachFunc The function to iterate over a collection.
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseEach(eachFunc, fromRight) {
	      return function(collection, iteratee) {
	        if (collection == null) {
	          return collection;
	        }
	        if (!isArrayLike(collection)) {
	          return eachFunc(collection, iteratee);
	        }
	        var length = collection.length,
	            index = fromRight ? length : -1,
	            iterable = Object(collection);

	        while ((fromRight ? index-- : ++index < length)) {
	          if (iteratee(iterable[index], index, iterable) === false) {
	            break;
	          }
	        }
	        return collection;
	      };
	    }

	    /**
	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new base function.
	     */
	    function createBaseFor(fromRight) {
	      return function(object, iteratee, keysFunc) {
	        var index = -1,
	            iterable = Object(object),
	            props = keysFunc(object),
	            length = props.length;

	        while (length--) {
	          var key = props[fromRight ? length : ++index];
	          if (iteratee(iterable[key], key, iterable) === false) {
	            break;
	          }
	        }
	        return object;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the optional `this`
	     * binding of `thisArg`.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createBind(func, bitmask, thisArg) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return fn.apply(isBind ? thisArg : this, arguments);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.lowerFirst`.
	     *
	     * @private
	     * @param {string} methodName The name of the `String` case method to use.
	     * @returns {Function} Returns the new case function.
	     */
	    function createCaseFirst(methodName) {
	      return function(string) {
	        string = toString(string);

	        var strSymbols = hasUnicode(string)
	          ? stringToArray(string)
	          : undefined;

	        var chr = strSymbols
	          ? strSymbols[0]
	          : string.charAt(0);

	        var trailing = strSymbols
	          ? castSlice(strSymbols, 1).join('')
	          : string.slice(1);

	        return chr[methodName]() + trailing;
	      };
	    }

	    /**
	     * Creates a function like `_.camelCase`.
	     *
	     * @private
	     * @param {Function} callback The function to combine each word.
	     * @returns {Function} Returns the new compounder function.
	     */
	    function createCompounder(callback) {
	      return function(string) {
	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
	      };
	    }

	    /**
	     * Creates a function that produces an instance of `Ctor` regardless of
	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
	     *
	     * @private
	     * @param {Function} Ctor The constructor to wrap.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCtor(Ctor) {
	      return function() {
	        // Use a `switch` statement to work with class constructors. See
	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
	        // for more details.
	        var args = arguments;
	        switch (args.length) {
	          case 0: return new Ctor;
	          case 1: return new Ctor(args[0]);
	          case 2: return new Ctor(args[0], args[1]);
	          case 3: return new Ctor(args[0], args[1], args[2]);
	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
	        }
	        var thisBinding = baseCreate(Ctor.prototype),
	            result = Ctor.apply(thisBinding, args);

	        // Mimic the constructor's `return` behavior.
	        // See https://es5.github.io/#x13.2.2 for more details.
	        return isObject(result) ? result : thisBinding;
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to enable currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {number} arity The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createCurry(func, bitmask, arity) {
	      var Ctor = createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length,
	            placeholder = getHolder(wrapper);

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
	          ? []
	          : replaceHolders(args, placeholder);

	        length -= holders.length;
	        if (length < arity) {
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, undefined,
	            args, holders, undefined, undefined, arity - length);
	        }
	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
	        return apply(fn, this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.find` or `_.findLast` function.
	     *
	     * @private
	     * @param {Function} findIndexFunc The function to find the collection index.
	     * @returns {Function} Returns the new find function.
	     */
	    function createFind(findIndexFunc) {
	      return function(collection, predicate, fromIndex) {
	        var iterable = Object(collection);
	        if (!isArrayLike(collection)) {
	          var iteratee = getIteratee(predicate, 3);
	          collection = keys(collection);
	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
	        }
	        var index = findIndexFunc(collection, predicate, fromIndex);
	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
	      };
	    }

	    /**
	     * Creates a `_.flow` or `_.flowRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new flow function.
	     */
	    function createFlow(fromRight) {
	      return flatRest(function(funcs) {
	        var length = funcs.length,
	            index = length,
	            prereq = LodashWrapper.prototype.thru;

	        if (fromRight) {
	          funcs.reverse();
	        }
	        while (index--) {
	          var func = funcs[index];
	          if (typeof func != 'function') {
	            throw new TypeError(FUNC_ERROR_TEXT);
	          }
	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
	            var wrapper = new LodashWrapper([], true);
	          }
	        }
	        index = wrapper ? index : length;
	        while (++index < length) {
	          func = funcs[index];

	          var funcName = getFuncName(func),
	              data = funcName == 'wrapper' ? getData(func) : undefined;

	          if (data && isLaziable(data[0]) &&
	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
	                !data[4].length && data[9] == 1
	              ) {
	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
	          } else {
	            wrapper = (func.length == 1 && isLaziable(func))
	              ? wrapper[funcName]()
	              : wrapper.thru(func);
	          }
	        }
	        return function() {
	          var args = arguments,
	              value = args[0];

	          if (wrapper && args.length == 1 && isArray(value)) {
	            return wrapper.plant(value).value();
	          }
	          var index = 0,
	              result = length ? funcs[index].apply(this, args) : value;

	          while (++index < length) {
	            result = funcs[index].call(this, result);
	          }
	          return result;
	        };
	      });
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with optional `this`
	     * binding of `thisArg`, partial application, and currying.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [partialsRight] The arguments to append to those provided
	     *  to the new function.
	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
	      var isAry = bitmask & WRAP_ARY_FLAG,
	          isBind = bitmask & WRAP_BIND_FLAG,
	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
	          isFlip = bitmask & WRAP_FLIP_FLAG,
	          Ctor = isBindKey ? undefined : createCtor(func);

	      function wrapper() {
	        var length = arguments.length,
	            args = Array(length),
	            index = length;

	        while (index--) {
	          args[index] = arguments[index];
	        }
	        if (isCurried) {
	          var placeholder = getHolder(wrapper),
	              holdersCount = countHolders(args, placeholder);
	        }
	        if (partials) {
	          args = composeArgs(args, partials, holders, isCurried);
	        }
	        if (partialsRight) {
	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
	        }
	        length -= holdersCount;
	        if (isCurried && length < arity) {
	          var newHolders = replaceHolders(args, placeholder);
	          return createRecurry(
	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
	            args, newHolders, argPos, ary, arity - length
	          );
	        }
	        var thisBinding = isBind ? thisArg : this,
	            fn = isBindKey ? thisBinding[func] : func;

	        length = args.length;
	        if (argPos) {
	          args = reorder(args, argPos);
	        } else if (isFlip && length > 1) {
	          args.reverse();
	        }
	        if (isAry && ary < length) {
	          args.length = ary;
	        }
	        if (this && this !== root && this instanceof wrapper) {
	          fn = Ctor || createCtor(fn);
	        }
	        return fn.apply(thisBinding, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a function like `_.invertBy`.
	     *
	     * @private
	     * @param {Function} setter The function to set accumulator values.
	     * @param {Function} toIteratee The function to resolve iteratees.
	     * @returns {Function} Returns the new inverter function.
	     */
	    function createInverter(setter, toIteratee) {
	      return function(object, iteratee) {
	        return baseInverter(object, setter, toIteratee(iteratee), {});
	      };
	    }

	    /**
	     * Creates a function that performs a mathematical operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @param {number} [defaultValue] The value used for `undefined` arguments.
	     * @returns {Function} Returns the new mathematical operation function.
	     */
	    function createMathOperation(operator, defaultValue) {
	      return function(value, other) {
	        var result;
	        if (value === undefined && other === undefined) {
	          return defaultValue;
	        }
	        if (value !== undefined) {
	          result = value;
	        }
	        if (other !== undefined) {
	          if (result === undefined) {
	            return other;
	          }
	          if (typeof value == 'string' || typeof other == 'string') {
	            value = baseToString(value);
	            other = baseToString(other);
	          } else {
	            value = baseToNumber(value);
	            other = baseToNumber(other);
	          }
	          result = operator(value, other);
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function like `_.over`.
	     *
	     * @private
	     * @param {Function} arrayFunc The function to iterate over iteratees.
	     * @returns {Function} Returns the new over function.
	     */
	    function createOver(arrayFunc) {
	      return flatRest(function(iteratees) {
	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
	        return baseRest(function(args) {
	          var thisArg = this;
	          return arrayFunc(iteratees, function(iteratee) {
	            return apply(iteratee, thisArg, args);
	          });
	        });
	      });
	    }

	    /**
	     * Creates the padding for `string` based on `length`. The `chars` string
	     * is truncated if the number of characters exceeds `length`.
	     *
	     * @private
	     * @param {number} length The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padding for `string`.
	     */
	    function createPadding(length, chars) {
	      chars = chars === undefined ? ' ' : baseToString(chars);

	      var charsLength = chars.length;
	      if (charsLength < 2) {
	        return charsLength ? baseRepeat(chars, length) : chars;
	      }
	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
	      return hasUnicode(chars)
	        ? castSlice(stringToArray(result), 0, length).join('')
	        : result.slice(0, length);
	    }

	    /**
	     * Creates a function that wraps `func` to invoke it with the `this` binding
	     * of `thisArg` and `partials` prepended to the arguments it receives.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {Array} partials The arguments to prepend to those provided to
	     *  the new function.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createPartial(func, bitmask, thisArg, partials) {
	      var isBind = bitmask & WRAP_BIND_FLAG,
	          Ctor = createCtor(func);

	      function wrapper() {
	        var argsIndex = -1,
	            argsLength = arguments.length,
	            leftIndex = -1,
	            leftLength = partials.length,
	            args = Array(leftLength + argsLength),
	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

	        while (++leftIndex < leftLength) {
	          args[leftIndex] = partials[leftIndex];
	        }
	        while (argsLength--) {
	          args[leftIndex++] = arguments[++argsIndex];
	        }
	        return apply(fn, isBind ? thisArg : this, args);
	      }
	      return wrapper;
	    }

	    /**
	     * Creates a `_.range` or `_.rangeRight` function.
	     *
	     * @private
	     * @param {boolean} [fromRight] Specify iterating from right to left.
	     * @returns {Function} Returns the new range function.
	     */
	    function createRange(fromRight) {
	      return function(start, end, step) {
	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
	          end = step = undefined;
	        }
	        // Ensure the sign of `-0` is preserved.
	        start = toFinite(start);
	        if (end === undefined) {
	          end = start;
	          start = 0;
	        } else {
	          end = toFinite(end);
	        }
	        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
	        return baseRange(start, end, step, fromRight);
	      };
	    }

	    /**
	     * Creates a function that performs a relational operation on two values.
	     *
	     * @private
	     * @param {Function} operator The function to perform the operation.
	     * @returns {Function} Returns the new relational operation function.
	     */
	    function createRelationalOperation(operator) {
	      return function(value, other) {
	        if (!(typeof value == 'string' && typeof other == 'string')) {
	          value = toNumber(value);
	          other = toNumber(other);
	        }
	        return operator(value, other);
	      };
	    }

	    /**
	     * Creates a function that wraps `func` to continue currying.
	     *
	     * @private
	     * @param {Function} func The function to wrap.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @param {Function} wrapFunc The function to create the `func` wrapper.
	     * @param {*} placeholder The placeholder value.
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to prepend to those provided to
	     *  the new function.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
	      var isCurry = bitmask & WRAP_CURRY_FLAG,
	          newHolders = isCurry ? holders : undefined,
	          newHoldersRight = isCurry ? undefined : holders,
	          newPartials = isCurry ? partials : undefined,
	          newPartialsRight = isCurry ? undefined : partials;

	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
	      }
	      var newData = [
	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
	        newHoldersRight, argPos, ary, arity
	      ];

	      var result = wrapFunc.apply(undefined, newData);
	      if (isLaziable(func)) {
	        setData(result, newData);
	      }
	      result.placeholder = placeholder;
	      return setWrapToString(result, func, bitmask);
	    }

	    /**
	     * Creates a function like `_.round`.
	     *
	     * @private
	     * @param {string} methodName The name of the `Math` method to use when rounding.
	     * @returns {Function} Returns the new round function.
	     */
	    function createRound(methodName) {
	      var func = Math[methodName];
	      return function(number, precision) {
	        number = toNumber(number);
	        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
	        if (precision) {
	          // Shift with exponential notation to avoid floating-point issues.
	          // See [MDN](https://mdn.io/round#Examples) for more details.
	          var pair = (toString(number) + 'e').split('e'),
	              value = func(pair[0] + 'e' + (+pair[1] + precision));

	          pair = (toString(value) + 'e').split('e');
	          return +(pair[0] + 'e' + (+pair[1] - precision));
	        }
	        return func(number);
	      };
	    }

	    /**
	     * Creates a set object of `values`.
	     *
	     * @private
	     * @param {Array} values The values to add to the set.
	     * @returns {Object} Returns the new set.
	     */
	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
	      return new Set(values);
	    };

	    /**
	     * Creates a `_.toPairs` or `_.toPairsIn` function.
	     *
	     * @private
	     * @param {Function} keysFunc The function to get the keys of a given object.
	     * @returns {Function} Returns the new pairs function.
	     */
	    function createToPairs(keysFunc) {
	      return function(object) {
	        var tag = getTag(object);
	        if (tag == mapTag) {
	          return mapToArray(object);
	        }
	        if (tag == setTag) {
	          return setToPairs(object);
	        }
	        return baseToPairs(object, keysFunc(object));
	      };
	    }

	    /**
	     * Creates a function that either curries or invokes `func` with optional
	     * `this` binding and partially applied arguments.
	     *
	     * @private
	     * @param {Function|string} func The function or method name to wrap.
	     * @param {number} bitmask The bitmask flags.
	     *    1 - `_.bind`
	     *    2 - `_.bindKey`
	     *    4 - `_.curry` or `_.curryRight` of a bound function
	     *    8 - `_.curry`
	     *   16 - `_.curryRight`
	     *   32 - `_.partial`
	     *   64 - `_.partialRight`
	     *  128 - `_.rearg`
	     *  256 - `_.ary`
	     *  512 - `_.flip`
	     * @param {*} [thisArg] The `this` binding of `func`.
	     * @param {Array} [partials] The arguments to be partially applied.
	     * @param {Array} [holders] The `partials` placeholder indexes.
	     * @param {Array} [argPos] The argument positions of the new function.
	     * @param {number} [ary] The arity cap of `func`.
	     * @param {number} [arity] The arity of `func`.
	     * @returns {Function} Returns the new wrapped function.
	     */
	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
	      if (!isBindKey && typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var length = partials ? partials.length : 0;
	      if (!length) {
	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
	        partials = holders = undefined;
	      }
	      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
	      arity = arity === undefined ? arity : toInteger(arity);
	      length -= holders ? holders.length : 0;

	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
	        var partialsRight = partials,
	            holdersRight = holders;

	        partials = holders = undefined;
	      }
	      var data = isBindKey ? undefined : getData(func);

	      var newData = [
	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
	        argPos, ary, arity
	      ];

	      if (data) {
	        mergeData(newData, data);
	      }
	      func = newData[0];
	      bitmask = newData[1];
	      thisArg = newData[2];
	      partials = newData[3];
	      holders = newData[4];
	      arity = newData[9] = newData[9] === undefined
	        ? (isBindKey ? 0 : func.length)
	        : nativeMax(newData[9] - length, 0);

	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
	      }
	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
	        var result = createBind(func, bitmask, thisArg);
	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
	        result = createCurry(func, bitmask, arity);
	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
	        result = createPartial(func, bitmask, thisArg, partials);
	      } else {
	        result = createHybrid.apply(undefined, newData);
	      }
	      var setter = data ? baseSetData : setData;
	      return setWrapToString(setter(result, newData), func, bitmask);
	    }

	    /**
	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
	     * of source objects to the destination object for all destination properties
	     * that resolve to `undefined`.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to assign.
	     * @param {Object} object The parent object of `objValue`.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsAssignIn(objValue, srcValue, key, object) {
	      if (objValue === undefined ||
	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
	        return srcValue;
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
	     * objects into destination objects that are passed thru.
	     *
	     * @private
	     * @param {*} objValue The destination value.
	     * @param {*} srcValue The source value.
	     * @param {string} key The key of the property to merge.
	     * @param {Object} object The parent object of `objValue`.
	     * @param {Object} source The parent object of `srcValue`.
	     * @param {Object} [stack] Tracks traversed source values and their merged
	     *  counterparts.
	     * @returns {*} Returns the value to assign.
	     */
	    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
	      if (isObject(objValue) && isObject(srcValue)) {
	        // Recursively merge objects and arrays (susceptible to call stack limits).
	        stack.set(srcValue, objValue);
	        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
	        stack['delete'](srcValue);
	      }
	      return objValue;
	    }

	    /**
	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
	     * objects.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @param {string} key The key of the property to inspect.
	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
	     */
	    function customOmitClone(value) {
	      return isPlainObject(value) ? undefined : value;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for arrays with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Array} array The array to compare.
	     * @param {Array} other The other array to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `array` and `other` objects.
	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
	     */
	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          arrLength = array.length,
	          othLength = other.length;

	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
	        return false;
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(array);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var index = -1,
	          result = true,
	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

	      stack.set(array, other);
	      stack.set(other, array);

	      // Ignore non-index properties.
	      while (++index < arrLength) {
	        var arrValue = array[index],
	            othValue = other[index];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, arrValue, index, other, array, stack)
	            : customizer(arrValue, othValue, index, array, other, stack);
	        }
	        if (compared !== undefined) {
	          if (compared) {
	            continue;
	          }
	          result = false;
	          break;
	        }
	        // Recursively compare arrays (susceptible to call stack limits).
	        if (seen) {
	          if (!arraySome(other, function(othValue, othIndex) {
	                if (!cacheHas(seen, othIndex) &&
	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
	                  return seen.push(othIndex);
	                }
	              })) {
	            result = false;
	            break;
	          }
	        } else if (!(
	              arrValue === othValue ||
	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
	            )) {
	          result = false;
	          break;
	        }
	      }
	      stack['delete'](array);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for comparing objects of
	     * the same `toStringTag`.
	     *
	     * **Note:** This function only supports comparing values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {string} tag The `toStringTag` of the objects to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
	      switch (tag) {
	        case dataViewTag:
	          if ((object.byteLength != other.byteLength) ||
	              (object.byteOffset != other.byteOffset)) {
	            return false;
	          }
	          object = object.buffer;
	          other = other.buffer;

	        case arrayBufferTag:
	          if ((object.byteLength != other.byteLength) ||
	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
	            return false;
	          }
	          return true;

	        case boolTag:
	        case dateTag:
	        case numberTag:
	          // Coerce booleans to `1` or `0` and dates to milliseconds.
	          // Invalid dates are coerced to `NaN`.
	          return eq(+object, +other);

	        case errorTag:
	          return object.name == other.name && object.message == other.message;

	        case regexpTag:
	        case stringTag:
	          // Coerce regexes to strings and treat strings, primitives and objects,
	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
	          // for more details.
	          return object == (other + '');

	        case mapTag:
	          var convert = mapToArray;

	        case setTag:
	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
	          convert || (convert = setToArray);

	          if (object.size != other.size && !isPartial) {
	            return false;
	          }
	          // Assume cyclic values are equal.
	          var stacked = stack.get(object);
	          if (stacked) {
	            return stacked == other;
	          }
	          bitmask |= COMPARE_UNORDERED_FLAG;

	          // Recursively compare objects (susceptible to call stack limits).
	          stack.set(object, other);
	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
	          stack['delete'](object);
	          return result;

	        case symbolTag:
	          if (symbolValueOf) {
	            return symbolValueOf.call(object) == symbolValueOf.call(other);
	          }
	      }
	      return false;
	    }

	    /**
	     * A specialized version of `baseIsEqualDeep` for objects with support for
	     * partial deep comparisons.
	     *
	     * @private
	     * @param {Object} object The object to compare.
	     * @param {Object} other The other object to compare.
	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
	     * @param {Function} customizer The function to customize comparisons.
	     * @param {Function} equalFunc The function to determine equivalents of values.
	     * @param {Object} stack Tracks traversed `object` and `other` objects.
	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
	     */
	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
	          objProps = getAllKeys(object),
	          objLength = objProps.length,
	          othProps = getAllKeys(other),
	          othLength = othProps.length;

	      if (objLength != othLength && !isPartial) {
	        return false;
	      }
	      var index = objLength;
	      while (index--) {
	        var key = objProps[index];
	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
	          return false;
	        }
	      }
	      // Assume cyclic values are equal.
	      var stacked = stack.get(object);
	      if (stacked && stack.get(other)) {
	        return stacked == other;
	      }
	      var result = true;
	      stack.set(object, other);
	      stack.set(other, object);

	      var skipCtor = isPartial;
	      while (++index < objLength) {
	        key = objProps[index];
	        var objValue = object[key],
	            othValue = other[key];

	        if (customizer) {
	          var compared = isPartial
	            ? customizer(othValue, objValue, key, other, object, stack)
	            : customizer(objValue, othValue, key, object, other, stack);
	        }
	        // Recursively compare objects (susceptible to call stack limits).
	        if (!(compared === undefined
	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
	              : compared
	            )) {
	          result = false;
	          break;
	        }
	        skipCtor || (skipCtor = key == 'constructor');
	      }
	      if (result && !skipCtor) {
	        var objCtor = object.constructor,
	            othCtor = other.constructor;

	        // Non `Object` object instances with different constructors are not equal.
	        if (objCtor != othCtor &&
	            ('constructor' in object && 'constructor' in other) &&
	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
	          result = false;
	        }
	      }
	      stack['delete'](object);
	      stack['delete'](other);
	      return result;
	    }

	    /**
	     * A specialized version of `baseRest` which flattens the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @returns {Function} Returns the new function.
	     */
	    function flatRest(func) {
	      return setToString(overRest(func, undefined, flatten), func + '');
	    }

	    /**
	     * Creates an array of own enumerable property names and symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeys(object) {
	      return baseGetAllKeys(object, keys, getSymbols);
	    }

	    /**
	     * Creates an array of own and inherited enumerable property names and
	     * symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names and symbols.
	     */
	    function getAllKeysIn(object) {
	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
	    }

	    /**
	     * Gets metadata for `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {*} Returns the metadata for `func`.
	     */
	    var getData = !metaMap ? noop : function(func) {
	      return metaMap.get(func);
	    };

	    /**
	     * Gets the name of `func`.
	     *
	     * @private
	     * @param {Function} func The function to query.
	     * @returns {string} Returns the function name.
	     */
	    function getFuncName(func) {
	      var result = (func.name + ''),
	          array = realNames[result],
	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

	      while (length--) {
	        var data = array[length],
	            otherFunc = data.func;
	        if (otherFunc == null || otherFunc == func) {
	          return data.name;
	        }
	      }
	      return result;
	    }

	    /**
	     * Gets the argument placeholder value for `func`.
	     *
	     * @private
	     * @param {Function} func The function to inspect.
	     * @returns {*} Returns the placeholder value.
	     */
	    function getHolder(func) {
	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
	      return object.placeholder;
	    }

	    /**
	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
	     * this function returns the custom method, otherwise it returns `baseIteratee`.
	     * If arguments are provided, the chosen function is invoked with them and
	     * its result is returned.
	     *
	     * @private
	     * @param {*} [value] The value to convert to an iteratee.
	     * @param {number} [arity] The arity of the created iteratee.
	     * @returns {Function} Returns the chosen function or its result.
	     */
	    function getIteratee() {
	      var result = lodash.iteratee || iteratee;
	      result = result === iteratee ? baseIteratee : result;
	      return arguments.length ? result(arguments[0], arguments[1]) : result;
	    }

	    /**
	     * Gets the data for `map`.
	     *
	     * @private
	     * @param {Object} map The map to query.
	     * @param {string} key The reference key.
	     * @returns {*} Returns the map data.
	     */
	    function getMapData(map, key) {
	      var data = map.__data__;
	      return isKeyable(key)
	        ? data[typeof key == 'string' ? 'string' : 'hash']
	        : data.map;
	    }

	    /**
	     * Gets the property names, values, and compare flags of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the match data of `object`.
	     */
	    function getMatchData(object) {
	      var result = keys(object),
	          length = result.length;

	      while (length--) {
	        var key = result[length],
	            value = object[key];

	        result[length] = [key, value, isStrictComparable(value)];
	      }
	      return result;
	    }

	    /**
	     * Gets the native function at `key` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {string} key The key of the method to get.
	     * @returns {*} Returns the function if it's native, else `undefined`.
	     */
	    function getNative(object, key) {
	      var value = getValue(object, key);
	      return baseIsNative(value) ? value : undefined;
	    }

	    /**
	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the raw `toStringTag`.
	     */
	    function getRawTag(value) {
	      var isOwn = hasOwnProperty.call(value, symToStringTag),
	          tag = value[symToStringTag];

	      try {
	        value[symToStringTag] = undefined;
	        var unmasked = true;
	      } catch (e) {}

	      var result = nativeObjectToString.call(value);
	      if (unmasked) {
	        if (isOwn) {
	          value[symToStringTag] = tag;
	        } else {
	          delete value[symToStringTag];
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates an array of the own enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
	      if (object == null) {
	        return [];
	      }
	      object = Object(object);
	      return arrayFilter(nativeGetSymbols(object), function(symbol) {
	        return propertyIsEnumerable.call(object, symbol);
	      });
	    };

	    /**
	     * Creates an array of the own and inherited enumerable symbols of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of symbols.
	     */
	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
	      var result = [];
	      while (object) {
	        arrayPush(result, getSymbols(object));
	        object = getPrototype(object);
	      }
	      return result;
	    };

	    /**
	     * Gets the `toStringTag` of `value`.
	     *
	     * @private
	     * @param {*} value The value to query.
	     * @returns {string} Returns the `toStringTag`.
	     */
	    var getTag = baseGetTag;

	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	        (Map && getTag(new Map) != mapTag) ||
	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
	        (Set && getTag(new Set) != setTag) ||
	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	      getTag = function(value) {
	        var result = baseGetTag(value),
	            Ctor = result == objectTag ? value.constructor : undefined,
	            ctorString = Ctor ? toSource(Ctor) : '';

	        if (ctorString) {
	          switch (ctorString) {
	            case dataViewCtorString: return dataViewTag;
	            case mapCtorString: return mapTag;
	            case promiseCtorString: return promiseTag;
	            case setCtorString: return setTag;
	            case weakMapCtorString: return weakMapTag;
	          }
	        }
	        return result;
	      };
	    }

	    /**
	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
	     *
	     * @private
	     * @param {number} start The start of the view.
	     * @param {number} end The end of the view.
	     * @param {Array} transforms The transformations to apply to the view.
	     * @returns {Object} Returns an object containing the `start` and `end`
	     *  positions of the view.
	     */
	    function getView(start, end, transforms) {
	      var index = -1,
	          length = transforms.length;

	      while (++index < length) {
	        var data = transforms[index],
	            size = data.size;

	        switch (data.type) {
	          case 'drop':      start += size; break;
	          case 'dropRight': end -= size; break;
	          case 'take':      end = nativeMin(end, start + size); break;
	          case 'takeRight': start = nativeMax(start, end - size); break;
	        }
	      }
	      return { 'start': start, 'end': end };
	    }

	    /**
	     * Extracts wrapper details from the `source` body comment.
	     *
	     * @private
	     * @param {string} source The source to inspect.
	     * @returns {Array} Returns the wrapper details.
	     */
	    function getWrapDetails(source) {
	      var match = source.match(reWrapDetails);
	      return match ? match[1].split(reSplitDetails) : [];
	    }

	    /**
	     * Checks if `path` exists on `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @param {Function} hasFunc The function to check properties.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     */
	    function hasPath(object, path, hasFunc) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length,
	          result = false;

	      while (++index < length) {
	        var key = toKey(path[index]);
	        if (!(result = object != null && hasFunc(object, key))) {
	          break;
	        }
	        object = object[key];
	      }
	      if (result || ++index != length) {
	        return result;
	      }
	      length = object == null ? 0 : object.length;
	      return !!length && isLength(length) && isIndex(key, length) &&
	        (isArray(object) || isArguments(object));
	    }

	    /**
	     * Initializes an array clone.
	     *
	     * @private
	     * @param {Array} array The array to clone.
	     * @returns {Array} Returns the initialized clone.
	     */
	    function initCloneArray(array) {
	      var length = array.length,
	          result = array.constructor(length);

	      // Add properties assigned by `RegExp#exec`.
	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
	        result.index = array.index;
	        result.input = array.input;
	      }
	      return result;
	    }

	    /**
	     * Initializes an object clone.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneObject(object) {
	      return (typeof object.constructor == 'function' && !isPrototype(object))
	        ? baseCreate(getPrototype(object))
	        : {};
	    }

	    /**
	     * Initializes an object clone based on its `toStringTag`.
	     *
	     * **Note:** This function only supports cloning values with tags of
	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
	     *
	     * @private
	     * @param {Object} object The object to clone.
	     * @param {string} tag The `toStringTag` of the object to clone.
	     * @param {Function} cloneFunc The function to clone values.
	     * @param {boolean} [isDeep] Specify a deep clone.
	     * @returns {Object} Returns the initialized clone.
	     */
	    function initCloneByTag(object, tag, cloneFunc, isDeep) {
	      var Ctor = object.constructor;
	      switch (tag) {
	        case arrayBufferTag:
	          return cloneArrayBuffer(object);

	        case boolTag:
	        case dateTag:
	          return new Ctor(+object);

	        case dataViewTag:
	          return cloneDataView(object, isDeep);

	        case float32Tag: case float64Tag:
	        case int8Tag: case int16Tag: case int32Tag:
	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
	          return cloneTypedArray(object, isDeep);

	        case mapTag:
	          return cloneMap(object, isDeep, cloneFunc);

	        case numberTag:
	        case stringTag:
	          return new Ctor(object);

	        case regexpTag:
	          return cloneRegExp(object);

	        case setTag:
	          return cloneSet(object, isDeep, cloneFunc);

	        case symbolTag:
	          return cloneSymbol(object);
	      }
	    }

	    /**
	     * Inserts wrapper `details` in a comment at the top of the `source` body.
	     *
	     * @private
	     * @param {string} source The source to modify.
	     * @returns {Array} details The details to insert.
	     * @returns {string} Returns the modified source.
	     */
	    function insertWrapDetails(source, details) {
	      var length = details.length;
	      if (!length) {
	        return source;
	      }
	      var lastIndex = length - 1;
	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
	      details = details.join(length > 2 ? ', ' : ' ');
	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
	    }

	    /**
	     * Checks if `value` is a flattenable `arguments` object or array.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	     */
	    function isFlattenable(value) {
	      return isArray(value) || isArguments(value) ||
	        !!(spreadableSymbol && value && value[spreadableSymbol]);
	    }

	    /**
	     * Checks if `value` is a valid array-like index.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
	     */
	    function isIndex(value, length) {
	      length = length == null ? MAX_SAFE_INTEGER : length;
	      return !!length &&
	        (typeof value == 'number' || reIsUint.test(value)) &&
	        (value > -1 && value % 1 == 0 && value < length);
	    }

	    /**
	     * Checks if the given arguments are from an iteratee call.
	     *
	     * @private
	     * @param {*} value The potential iteratee value argument.
	     * @param {*} index The potential iteratee index or key argument.
	     * @param {*} object The potential iteratee object argument.
	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
	     *  else `false`.
	     */
	    function isIterateeCall(value, index, object) {
	      if (!isObject(object)) {
	        return false;
	      }
	      var type = typeof index;
	      if (type == 'number'
	            ? (isArrayLike(object) && isIndex(index, object.length))
	            : (type == 'string' && index in object)
	          ) {
	        return eq(object[index], value);
	      }
	      return false;
	    }

	    /**
	     * Checks if `value` is a property name and not a property path.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @param {Object} [object] The object to query keys on.
	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
	     */
	    function isKey(value, object) {
	      if (isArray(value)) {
	        return false;
	      }
	      var type = typeof value;
	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
	          value == null || isSymbol(value)) {
	        return true;
	      }
	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
	        (object != null && value in Object(object));
	    }

	    /**
	     * Checks if `value` is suitable for use as unique object key.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
	     */
	    function isKeyable(value) {
	      var type = typeof value;
	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
	        ? (value !== '__proto__')
	        : (value === null);
	    }

	    /**
	     * Checks if `func` has a lazy counterpart.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
	     *  else `false`.
	     */
	    function isLaziable(func) {
	      var funcName = getFuncName(func),
	          other = lodash[funcName];

	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
	        return false;
	      }
	      if (func === other) {
	        return true;
	      }
	      var data = getData(other);
	      return !!data && func === data[0];
	    }

	    /**
	     * Checks if `func` has its source masked.
	     *
	     * @private
	     * @param {Function} func The function to check.
	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	     */
	    function isMasked(func) {
	      return !!maskSrcKey && (maskSrcKey in func);
	    }

	    /**
	     * Checks if `func` is capable of being masked.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
	     */
	    var isMaskable = coreJsData ? isFunction : stubFalse;

	    /**
	     * Checks if `value` is likely a prototype object.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	     */
	    function isPrototype(value) {
	      var Ctor = value && value.constructor,
	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	      return value === proto;
	    }

	    /**
	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` if suitable for strict
	     *  equality comparisons, else `false`.
	     */
	    function isStrictComparable(value) {
	      return value === value && !isObject(value);
	    }

	    /**
	     * A specialized version of `matchesProperty` for source values suitable
	     * for strict equality comparisons, i.e. `===`.
	     *
	     * @private
	     * @param {string} key The key of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     */
	    function matchesStrictComparable(key, srcValue) {
	      return function(object) {
	        if (object == null) {
	          return false;
	        }
	        return object[key] === srcValue &&
	          (srcValue !== undefined || (key in Object(object)));
	      };
	    }

	    /**
	     * A specialized version of `_.memoize` which clears the memoized function's
	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
	     *
	     * @private
	     * @param {Function} func The function to have its output memoized.
	     * @returns {Function} Returns the new memoized function.
	     */
	    function memoizeCapped(func) {
	      var result = memoize(func, function(key) {
	        if (cache.size === MAX_MEMOIZE_SIZE) {
	          cache.clear();
	        }
	        return key;
	      });

	      var cache = result.cache;
	      return result;
	    }

	    /**
	     * Merges the function metadata of `source` into `data`.
	     *
	     * Merging metadata reduces the number of wrappers used to invoke a function.
	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
	     * may be applied regardless of execution order. Methods like `_.ary` and
	     * `_.rearg` modify function arguments, making the order in which they are
	     * executed important, preventing the merging of metadata. However, we make
	     * an exception for a safe combined case where curried functions have `_.ary`
	     * and or `_.rearg` applied.
	     *
	     * @private
	     * @param {Array} data The destination metadata.
	     * @param {Array} source The source metadata.
	     * @returns {Array} Returns `data`.
	     */
	    function mergeData(data, source) {
	      var bitmask = data[1],
	          srcBitmask = source[1],
	          newBitmask = bitmask | srcBitmask,
	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

	      var isCombo =
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

	      // Exit early if metadata can't be merged.
	      if (!(isCommon || isCombo)) {
	        return data;
	      }
	      // Use source `thisArg` if available.
	      if (srcBitmask & WRAP_BIND_FLAG) {
	        data[2] = source[2];
	        // Set when currying a bound function.
	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
	      }
	      // Compose partial arguments.
	      var value = source[3];
	      if (value) {
	        var partials = data[3];
	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
	      }
	      // Compose partial right arguments.
	      value = source[5];
	      if (value) {
	        partials = data[5];
	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
	      }
	      // Use source `argPos` if available.
	      value = source[7];
	      if (value) {
	        data[7] = value;
	      }
	      // Use source `ary` if it's smaller.
	      if (srcBitmask & WRAP_ARY_FLAG) {
	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
	      }
	      // Use source `arity` if one is not provided.
	      if (data[9] == null) {
	        data[9] = source[9];
	      }
	      // Use source `func` and merge bitmasks.
	      data[0] = source[0];
	      data[1] = newBitmask;

	      return data;
	    }

	    /**
	     * This function is like
	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * except that it includes inherited enumerable properties.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     */
	    function nativeKeysIn(object) {
	      var result = [];
	      if (object != null) {
	        for (var key in Object(object)) {
	          result.push(key);
	        }
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a string using `Object.prototype.toString`.
	     *
	     * @private
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     */
	    function objectToString(value) {
	      return nativeObjectToString.call(value);
	    }

	    /**
	     * A specialized version of `baseRest` which transforms the rest array.
	     *
	     * @private
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @param {Function} transform The rest array transform.
	     * @returns {Function} Returns the new function.
	     */
	    function overRest(func, start, transform) {
	      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
	      return function() {
	        var args = arguments,
	            index = -1,
	            length = nativeMax(args.length - start, 0),
	            array = Array(length);

	        while (++index < length) {
	          array[index] = args[start + index];
	        }
	        index = -1;
	        var otherArgs = Array(start + 1);
	        while (++index < start) {
	          otherArgs[index] = args[index];
	        }
	        otherArgs[start] = transform(array);
	        return apply(func, this, otherArgs);
	      };
	    }

	    /**
	     * Gets the parent value at `path` of `object`.
	     *
	     * @private
	     * @param {Object} object The object to query.
	     * @param {Array} path The path to get the parent value of.
	     * @returns {*} Returns the parent value.
	     */
	    function parent(object, path) {
	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
	    }

	    /**
	     * Reorder `array` according to the specified indexes where the element at
	     * the first index is assigned as the first element, the element at
	     * the second index is assigned as the second element, and so on.
	     *
	     * @private
	     * @param {Array} array The array to reorder.
	     * @param {Array} indexes The arranged array indexes.
	     * @returns {Array} Returns `array`.
	     */
	    function reorder(array, indexes) {
	      var arrLength = array.length,
	          length = nativeMin(indexes.length, arrLength),
	          oldArray = copyArray(array);

	      while (length--) {
	        var index = indexes[length];
	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
	      }
	      return array;
	    }

	    /**
	     * Sets metadata for `func`.
	     *
	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
	     * period of time, it will trip its breaker and transition to an identity
	     * function to avoid garbage collection pauses in V8. See
	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
	     * for more details.
	     *
	     * @private
	     * @param {Function} func The function to associate metadata with.
	     * @param {*} data The metadata.
	     * @returns {Function} Returns `func`.
	     */
	    var setData = shortOut(baseSetData);

	    /**
	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
	     *
	     * @private
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @returns {number|Object} Returns the timer id or timeout object.
	     */
	    var setTimeout = ctxSetTimeout || function(func, wait) {
	      return root.setTimeout(func, wait);
	    };

	    /**
	     * Sets the `toString` method of `func` to return `string`.
	     *
	     * @private
	     * @param {Function} func The function to modify.
	     * @param {Function} string The `toString` result.
	     * @returns {Function} Returns `func`.
	     */
	    var setToString = shortOut(baseSetToString);

	    /**
	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
	     * with wrapper details in a comment at the top of the source body.
	     *
	     * @private
	     * @param {Function} wrapper The function to modify.
	     * @param {Function} reference The reference function.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Function} Returns `wrapper`.
	     */
	    function setWrapToString(wrapper, reference, bitmask) {
	      var source = (reference + '');
	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
	    }

	    /**
	     * Creates a function that'll short out and invoke `identity` instead
	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
	     * milliseconds.
	     *
	     * @private
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new shortable function.
	     */
	    function shortOut(func) {
	      var count = 0,
	          lastCalled = 0;

	      return function() {
	        var stamp = nativeNow(),
	            remaining = HOT_SPAN - (stamp - lastCalled);

	        lastCalled = stamp;
	        if (remaining > 0) {
	          if (++count >= HOT_COUNT) {
	            return arguments[0];
	          }
	        } else {
	          count = 0;
	        }
	        return func.apply(undefined, arguments);
	      };
	    }

	    /**
	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
	     *
	     * @private
	     * @param {Array} array The array to shuffle.
	     * @param {number} [size=array.length] The size of `array`.
	     * @returns {Array} Returns `array`.
	     */
	    function shuffleSelf(array, size) {
	      var index = -1,
	          length = array.length,
	          lastIndex = length - 1;

	      size = size === undefined ? length : size;
	      while (++index < size) {
	        var rand = baseRandom(index, lastIndex),
	            value = array[rand];

	        array[rand] = array[index];
	        array[index] = value;
	      }
	      array.length = size;
	      return array;
	    }

	    /**
	     * Converts `string` to a property path array.
	     *
	     * @private
	     * @param {string} string The string to convert.
	     * @returns {Array} Returns the property path array.
	     */
	    var stringToPath = memoizeCapped(function(string) {
	      var result = [];
	      if (reLeadingDot.test(string)) {
	        result.push('');
	      }
	      string.replace(rePropName, function(match, number, quote, string) {
	        result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
	      });
	      return result;
	    });

	    /**
	     * Converts `value` to a string key if it's not a string or symbol.
	     *
	     * @private
	     * @param {*} value The value to inspect.
	     * @returns {string|symbol} Returns the key.
	     */
	    function toKey(value) {
	      if (typeof value == 'string' || isSymbol(value)) {
	        return value;
	      }
	      var result = (value + '');
	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
	    }

	    /**
	     * Converts `func` to its source code.
	     *
	     * @private
	     * @param {Function} func The function to convert.
	     * @returns {string} Returns the source code.
	     */
	    function toSource(func) {
	      if (func != null) {
	        try {
	          return funcToString.call(func);
	        } catch (e) {}
	        try {
	          return (func + '');
	        } catch (e) {}
	      }
	      return '';
	    }

	    /**
	     * Updates wrapper `details` based on `bitmask` flags.
	     *
	     * @private
	     * @returns {Array} details The details to modify.
	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
	     * @returns {Array} Returns `details`.
	     */
	    function updateWrapDetails(details, bitmask) {
	      arrayEach(wrapFlags, function(pair) {
	        var value = '_.' + pair[0];
	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
	          details.push(value);
	        }
	      });
	      return details.sort();
	    }

	    /**
	     * Creates a clone of `wrapper`.
	     *
	     * @private
	     * @param {Object} wrapper The wrapper to clone.
	     * @returns {Object} Returns the cloned wrapper.
	     */
	    function wrapperClone(wrapper) {
	      if (wrapper instanceof LazyWrapper) {
	        return wrapper.clone();
	      }
	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
	      result.__actions__ = copyArray(wrapper.__actions__);
	      result.__index__  = wrapper.__index__;
	      result.__values__ = wrapper.__values__;
	      return result;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an array of elements split into groups the length of `size`.
	     * If `array` can't be split evenly, the final chunk will be the remaining
	     * elements.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to process.
	     * @param {number} [size=1] The length of each chunk
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the new array of chunks.
	     * @example
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 2);
	     * // => [['a', 'b'], ['c', 'd']]
	     *
	     * _.chunk(['a', 'b', 'c', 'd'], 3);
	     * // => [['a', 'b', 'c'], ['d']]
	     */
	    function chunk(array, size, guard) {
	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
	        size = 1;
	      } else {
	        size = nativeMax(toInteger(size), 0);
	      }
	      var length = array == null ? 0 : array.length;
	      if (!length || size < 1) {
	        return [];
	      }
	      var index = 0,
	          resIndex = 0,
	          result = Array(nativeCeil(length / size));

	      while (index < length) {
	        result[resIndex++] = baseSlice(array, index, (index += size));
	      }
	      return result;
	    }

	    /**
	     * Creates an array with all falsey values removed. The values `false`, `null`,
	     * `0`, `""`, `undefined`, and `NaN` are falsey.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to compact.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.compact([0, 1, false, 2, '', 3]);
	     * // => [1, 2, 3]
	     */
	    function compact(array) {
	      var index = -1,
	          length = array == null ? 0 : array.length,
	          resIndex = 0,
	          result = [];

	      while (++index < length) {
	        var value = array[index];
	        if (value) {
	          result[resIndex++] = value;
	        }
	      }
	      return result;
	    }

	    /**
	     * Creates a new array concatenating `array` with any additional arrays
	     * and/or values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to concatenate.
	     * @param {...*} [values] The values to concatenate.
	     * @returns {Array} Returns the new concatenated array.
	     * @example
	     *
	     * var array = [1];
	     * var other = _.concat(array, 2, [3], [[4]]);
	     *
	     * console.log(other);
	     * // => [1, 2, 3, [4]]
	     *
	     * console.log(array);
	     * // => [1]
	     */
	    function concat() {
	      var length = arguments.length;
	      if (!length) {
	        return [];
	      }
	      var args = Array(length - 1),
	          array = arguments[0],
	          index = length;

	      while (index--) {
	        args[index - 1] = arguments[index];
	      }
	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
	    }

	    /**
	     * Creates an array of `array` values not included in the other given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.without, _.xor
	     * @example
	     *
	     * _.difference([2, 1], [2, 3]);
	     * // => [1]
	     */
	    var difference = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `iteratee` which
	     * is invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var differenceBy = baseRest(function(array, values) {
	      var iteratee = last(values);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.difference` except that it accepts `comparator`
	     * which is invoked to compare elements of `array` to `values`. The order and
	     * references of result values are determined by the first array. The comparator
	     * is invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...Array} [values] The values to exclude.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     *
	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }]
	     */
	    var differenceWith = baseRest(function(array, values) {
	      var comparator = last(values);
	      if (isArrayLikeObject(comparator)) {
	        comparator = undefined;
	      }
	      return isArrayLikeObject(array)
	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
	        : [];
	    });

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.drop([1, 2, 3]);
	     * // => [2, 3]
	     *
	     * _.drop([1, 2, 3], 2);
	     * // => [3]
	     *
	     * _.drop([1, 2, 3], 5);
	     * // => []
	     *
	     * _.drop([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function drop(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements dropped from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to drop.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.dropRight([1, 2, 3]);
	     * // => [1, 2]
	     *
	     * _.dropRight([1, 2, 3], 2);
	     * // => [1]
	     *
	     * _.dropRight([1, 2, 3], 5);
	     * // => []
	     *
	     * _.dropRight([1, 2, 3], 0);
	     * // => [1, 2, 3]
	     */
	    function dropRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the end.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.dropRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropRightWhile(users, ['active', false]);
	     * // => objects for ['barney']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropRightWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` excluding elements dropped from the beginning.
	     * Elements are dropped until `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.dropWhile(users, function(o) { return !o.active; });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.dropWhile(users, ['active', false]);
	     * // => objects for ['pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.dropWhile(users, 'active');
	     * // => objects for ['barney', 'fred', 'pebbles']
	     */
	    function dropWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), true)
	        : [];
	    }

	    /**
	     * Fills elements of `array` with `value` from `start` up to, but not
	     * including, `end`.
	     *
	     * **Note:** This method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Array
	     * @param {Array} array The array to fill.
	     * @param {*} value The value to fill `array` with.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.fill(array, 'a');
	     * console.log(array);
	     * // => ['a', 'a', 'a']
	     *
	     * _.fill(Array(3), 2);
	     * // => [2, 2, 2]
	     *
	     * _.fill([4, 6, 8, 10], '*', 1, 3);
	     * // => [4, '*', '*', 10]
	     */
	    function fill(array, value, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
	        start = 0;
	        end = length;
	      }
	      return baseFill(array, value, start, end);
	    }

	    /**
	     * This method is like `_.find` except that it returns the index of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
	     * // => 0
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findIndex(users, { 'user': 'fred', 'active': false });
	     * // => 1
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findIndex(users, ['active', false]);
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findIndex(users, 'active');
	     * // => 2
	     */
	    function findIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index);
	    }

	    /**
	     * This method is like `_.findIndex` except that it iterates over elements
	     * of `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the found element, else `-1`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
	     * // => 2
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
	     * // => 0
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastIndex(users, ['active', false]);
	     * // => 2
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastIndex(users, 'active');
	     * // => 0
	     */
	    function findLastIndex(array, predicate, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length - 1;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = fromIndex < 0
	          ? nativeMax(length + index, 0)
	          : nativeMin(index, length - 1);
	      }
	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
	    }

	    /**
	     * Flattens `array` a single level deep.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flatten([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, [3, [4]], 5]
	     */
	    function flatten(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, 1) : [];
	    }

	    /**
	     * Recursively flattens `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
	     * // => [1, 2, 3, 4, 5]
	     */
	    function flattenDeep(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseFlatten(array, INFINITY) : [];
	    }

	    /**
	     * Recursively flatten `array` up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Array
	     * @param {Array} array The array to flatten.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * var array = [1, [2, [3, [4]], 5]];
	     *
	     * _.flattenDepth(array, 1);
	     * // => [1, 2, [3, [4]], 5]
	     *
	     * _.flattenDepth(array, 2);
	     * // => [1, 2, 3, [4], 5]
	     */
	    function flattenDepth(array, depth) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(array, depth);
	    }

	    /**
	     * The inverse of `_.toPairs`; this method returns an object composed
	     * from key-value `pairs`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} pairs The key-value pairs.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.fromPairs([['a', 1], ['b', 2]]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function fromPairs(pairs) {
	      var index = -1,
	          length = pairs == null ? 0 : pairs.length,
	          result = {};

	      while (++index < length) {
	        var pair = pairs[index];
	        result[pair[0]] = pair[1];
	      }
	      return result;
	    }

	    /**
	     * Gets the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias first
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the first element of `array`.
	     * @example
	     *
	     * _.head([1, 2, 3]);
	     * // => 1
	     *
	     * _.head([]);
	     * // => undefined
	     */
	    function head(array) {
	      return (array && array.length) ? array[0] : undefined;
	    }

	    /**
	     * Gets the index at which the first occurrence of `value` is found in `array`
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. If `fromIndex` is negative, it's used as the
	     * offset from the end of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.indexOf([1, 2, 1, 2], 2);
	     * // => 1
	     *
	     * // Search from the `fromIndex`.
	     * _.indexOf([1, 2, 1, 2], 2, 2);
	     * // => 3
	     */
	    function indexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
	      if (index < 0) {
	        index = nativeMax(length + index, 0);
	      }
	      return baseIndexOf(array, value, index);
	    }

	    /**
	     * Gets all but the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.initial([1, 2, 3]);
	     * // => [1, 2]
	     */
	    function initial(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 0, -1) : [];
	    }

	    /**
	     * Creates an array of unique values that are included in all given arrays
	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons. The order and references of result values are
	     * determined by the first array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersection([2, 1], [2, 3]);
	     * // => [2]
	     */
	    var intersection = baseRest(function(arrays) {
	      var mapped = arrayMap(arrays, castArrayLikeObject);
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped)
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `iteratee`
	     * which is invoked for each element of each `arrays` to generate the criterion
	     * by which they're compared. The order and references of result values are
	     * determined by the first array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [2.1]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }]
	     */
	    var intersectionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      if (iteratee === last(mapped)) {
	        iteratee = undefined;
	      } else {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
	        : [];
	    });

	    /**
	     * This method is like `_.intersection` except that it accepts `comparator`
	     * which is invoked to compare elements of `arrays`. The order and references
	     * of result values are determined by the first array. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of intersecting values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.intersectionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }]
	     */
	    var intersectionWith = baseRest(function(arrays) {
	      var comparator = last(arrays),
	          mapped = arrayMap(arrays, castArrayLikeObject);

	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      if (comparator) {
	        mapped.pop();
	      }
	      return (mapped.length && mapped[0] === arrays[0])
	        ? baseIntersection(mapped, undefined, comparator)
	        : [];
	    });

	    /**
	     * Converts all elements in `array` into a string separated by `separator`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to convert.
	     * @param {string} [separator=','] The element separator.
	     * @returns {string} Returns the joined string.
	     * @example
	     *
	     * _.join(['a', 'b', 'c'], '~');
	     * // => 'a~b~c'
	     */
	    function join(array, separator) {
	      return array == null ? '' : nativeJoin.call(array, separator);
	    }

	    /**
	     * Gets the last element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {*} Returns the last element of `array`.
	     * @example
	     *
	     * _.last([1, 2, 3]);
	     * // => 3
	     */
	    function last(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? array[length - 1] : undefined;
	    }

	    /**
	     * This method is like `_.indexOf` except that it iterates over elements of
	     * `array` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=array.length-1] The index to search from.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.lastIndexOf([1, 2, 1, 2], 2);
	     * // => 3
	     *
	     * // Search from the `fromIndex`.
	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
	     * // => 1
	     */
	    function lastIndexOf(array, value, fromIndex) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return -1;
	      }
	      var index = length;
	      if (fromIndex !== undefined) {
	        index = toInteger(fromIndex);
	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
	      }
	      return value === value
	        ? strictLastIndexOf(array, value, index)
	        : baseFindIndex(array, baseIsNaN, index, true);
	    }

	    /**
	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
	     * element from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.11.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=0] The index of the element to return.
	     * @returns {*} Returns the nth element of `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     *
	     * _.nth(array, 1);
	     * // => 'b'
	     *
	     * _.nth(array, -2);
	     * // => 'c';
	     */
	    function nth(array, n) {
	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
	    }

	    /**
	     * Removes all given values from `array` using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
	     * to remove elements from an array by predicate.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...*} [values] The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pull(array, 'a', 'c');
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    var pull = baseRest(pullAll);

	    /**
	     * This method is like `_.pull` except that it accepts an array of values to remove.
	     *
	     * **Note:** Unlike `_.difference`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
	     *
	     * _.pullAll(array, ['a', 'c']);
	     * console.log(array);
	     * // => ['b', 'b']
	     */
	    function pullAll(array, values) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values)
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
	     * invoked for each element of `array` and `values` to generate the criterion
	     * by which they're compared. The iteratee is invoked with one argument: (value).
	     *
	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
	     *
	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
	     * console.log(array);
	     * // => [{ 'x': 2 }]
	     */
	    function pullAllBy(array, values, iteratee) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, getIteratee(iteratee, 2))
	        : array;
	    }

	    /**
	     * This method is like `_.pullAll` except that it accepts `comparator` which
	     * is invoked to compare elements of `array` to `values`. The comparator is
	     * invoked with two arguments: (arrVal, othVal).
	     *
	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Array} values The values to remove.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
	     *
	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
	     * console.log(array);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
	     */
	    function pullAllWith(array, values, comparator) {
	      return (array && array.length && values && values.length)
	        ? basePullAll(array, values, undefined, comparator)
	        : array;
	    }

	    /**
	     * Removes elements from `array` corresponding to `indexes` and returns an
	     * array of removed elements.
	     *
	     * **Note:** Unlike `_.at`, this method mutates `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = ['a', 'b', 'c', 'd'];
	     * var pulled = _.pullAt(array, [1, 3]);
	     *
	     * console.log(array);
	     * // => ['a', 'c']
	     *
	     * console.log(pulled);
	     * // => ['b', 'd']
	     */
	    var pullAt = flatRest(function(array, indexes) {
	      var length = array == null ? 0 : array.length,
	          result = baseAt(array, indexes);

	      basePullAt(array, arrayMap(indexes, function(index) {
	        return isIndex(index, length) ? +index : index;
	      }).sort(compareAscending));

	      return result;
	    });

	    /**
	     * Removes all elements from `array` that `predicate` returns truthy for
	     * and returns an array of the removed elements. The predicate is invoked
	     * with three arguments: (value, index, array).
	     *
	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
	     * to pull elements from an array by value.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new array of removed elements.
	     * @example
	     *
	     * var array = [1, 2, 3, 4];
	     * var evens = _.remove(array, function(n) {
	     *   return n % 2 == 0;
	     * });
	     *
	     * console.log(array);
	     * // => [1, 3]
	     *
	     * console.log(evens);
	     * // => [2, 4]
	     */
	    function remove(array, predicate) {
	      var result = [];
	      if (!(array && array.length)) {
	        return result;
	      }
	      var index = -1,
	          indexes = [],
	          length = array.length;

	      predicate = getIteratee(predicate, 3);
	      while (++index < length) {
	        var value = array[index];
	        if (predicate(value, index, array)) {
	          result.push(value);
	          indexes.push(index);
	        }
	      }
	      basePullAt(array, indexes);
	      return result;
	    }

	    /**
	     * Reverses `array` so that the first element becomes the last, the second
	     * element becomes the second to last, and so on.
	     *
	     * **Note:** This method mutates `array` and is based on
	     * [`Array#reverse`](https://mdn.io/Array/reverse).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to modify.
	     * @returns {Array} Returns `array`.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _.reverse(array);
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function reverse(array) {
	      return array == null ? array : nativeReverse.call(array);
	    }

	    /**
	     * Creates a slice of `array` from `start` up to, but not including, `end`.
	     *
	     * **Note:** This method is used instead of
	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
	     * returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to slice.
	     * @param {number} [start=0] The start position.
	     * @param {number} [end=array.length] The end position.
	     * @returns {Array} Returns the slice of `array`.
	     */
	    function slice(array, start, end) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
	        start = 0;
	        end = length;
	      }
	      else {
	        start = start == null ? 0 : toInteger(start);
	        end = end === undefined ? length : toInteger(end);
	      }
	      return baseSlice(array, start, end);
	    }

	    /**
	     * Uses a binary search to determine the lowest index at which `value`
	     * should be inserted into `array` in order to maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedIndex([30, 50], 40);
	     * // => 1
	     */
	    function sortedIndex(array, value) {
	      return baseSortedIndex(array, value);
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 0
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 0
	     */
	    function sortedIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
	    }

	    /**
	     * This method is like `_.indexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 1
	     */
	    function sortedIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value);
	        if (index < length && eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.sortedIndex` except that it returns the highest
	     * index at which `value` should be inserted into `array` in order to
	     * maintain its sort order.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
	     * // => 4
	     */
	    function sortedLastIndex(array, value) {
	      return baseSortedIndex(array, value, true);
	    }

	    /**
	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
	     * which is invoked for `value` and each element of `array` to compute their
	     * sort ranking. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The sorted array to inspect.
	     * @param {*} value The value to evaluate.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the index at which `value` should be inserted
	     *  into `array`.
	     * @example
	     *
	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
	     *
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
	     * // => 1
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
	     * // => 1
	     */
	    function sortedLastIndexBy(array, value, iteratee) {
	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
	    }

	    /**
	     * This method is like `_.lastIndexOf` except that it performs a binary
	     * search on a sorted `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {*} value The value to search for.
	     * @returns {number} Returns the index of the matched value, else `-1`.
	     * @example
	     *
	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
	     * // => 3
	     */
	    function sortedLastIndexOf(array, value) {
	      var length = array == null ? 0 : array.length;
	      if (length) {
	        var index = baseSortedIndex(array, value, true) - 1;
	        if (eq(array[index], value)) {
	          return index;
	        }
	      }
	      return -1;
	    }

	    /**
	     * This method is like `_.uniq` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniq([1, 1, 2]);
	     * // => [1, 2]
	     */
	    function sortedUniq(array) {
	      return (array && array.length)
	        ? baseSortedUniq(array)
	        : [];
	    }

	    /**
	     * This method is like `_.uniqBy` except that it's designed and optimized
	     * for sorted arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
	     * // => [1.1, 2.3]
	     */
	    function sortedUniqBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
	        : [];
	    }

	    /**
	     * Gets all but the first element of `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.tail([1, 2, 3]);
	     * // => [2, 3]
	     */
	    function tail(array) {
	      var length = array == null ? 0 : array.length;
	      return length ? baseSlice(array, 1, length) : [];
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the beginning.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.take([1, 2, 3]);
	     * // => [1]
	     *
	     * _.take([1, 2, 3], 2);
	     * // => [1, 2]
	     *
	     * _.take([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.take([1, 2, 3], 0);
	     * // => []
	     */
	    function take(array, n, guard) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      return baseSlice(array, 0, n < 0 ? 0 : n);
	    }

	    /**
	     * Creates a slice of `array` with `n` elements taken from the end.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {number} [n=1] The number of elements to take.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * _.takeRight([1, 2, 3]);
	     * // => [3]
	     *
	     * _.takeRight([1, 2, 3], 2);
	     * // => [2, 3]
	     *
	     * _.takeRight([1, 2, 3], 5);
	     * // => [1, 2, 3]
	     *
	     * _.takeRight([1, 2, 3], 0);
	     * // => []
	     */
	    function takeRight(array, n, guard) {
	      var length = array == null ? 0 : array.length;
	      if (!length) {
	        return [];
	      }
	      n = (guard || n === undefined) ? 1 : toInteger(n);
	      n = length - n;
	      return baseSlice(array, n < 0 ? 0 : n, length);
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the end. Elements are
	     * taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': true },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': false }
	     * ];
	     *
	     * _.takeRightWhile(users, function(o) { return !o.active; });
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
	     * // => objects for ['pebbles']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeRightWhile(users, ['active', false]);
	     * // => objects for ['fred', 'pebbles']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeRightWhile(users, 'active');
	     * // => []
	     */
	    function takeRightWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
	        : [];
	    }

	    /**
	     * Creates a slice of `array` with elements taken from the beginning. Elements
	     * are taken until `predicate` returns falsey. The predicate is invoked with
	     * three arguments: (value, index, array).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Array
	     * @param {Array} array The array to query.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the slice of `array`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'active': false },
	     *   { 'user': 'fred',    'active': false },
	     *   { 'user': 'pebbles', 'active': true }
	     * ];
	     *
	     * _.takeWhile(users, function(o) { return !o.active; });
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.takeWhile(users, ['active', false]);
	     * // => objects for ['barney', 'fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.takeWhile(users, 'active');
	     * // => []
	     */
	    function takeWhile(array, predicate) {
	      return (array && array.length)
	        ? baseWhile(array, getIteratee(predicate, 3))
	        : [];
	    }

	    /**
	     * Creates an array of unique values, in order, from all given arrays using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.union([2], [1, 2]);
	     * // => [2, 1]
	     */
	    var union = baseRest(function(arrays) {
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which uniqueness is computed. Result values are chosen from the first
	     * array in which the value occurs. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    var unionBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.union` except that it accepts `comparator` which
	     * is invoked to compare elements of `arrays`. Result values are chosen from
	     * the first array in which the value occurs. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of combined values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.unionWith(objects, others, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var unionWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
	    });

	    /**
	     * Creates a duplicate-free version of an array, using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons, in which only the first occurrence of each element
	     * is kept. The order of result values is determined by the order they occur
	     * in the array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniq([2, 1, 2]);
	     * // => [2, 1]
	     */
	    function uniq(array) {
	      return (array && array.length) ? baseUniq(array) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * uniqueness is computed. The order of result values is determined by the
	     * order they occur in the array. The iteratee is invoked with one argument:
	     * (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
	     * // => [2.1, 1.2]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 1 }, { 'x': 2 }]
	     */
	    function uniqBy(array, iteratee) {
	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
	    }

	    /**
	     * This method is like `_.uniq` except that it accepts `comparator` which
	     * is invoked to compare elements of `array`. The order of result values is
	     * determined by the order they occur in the array.The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new duplicate free array.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.uniqWith(objects, _.isEqual);
	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
	     */
	    function uniqWith(array, comparator) {
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
	    }

	    /**
	     * This method is like `_.zip` except that it accepts an array of grouped
	     * elements and creates an array regrouping the elements to their pre-zip
	     * configuration.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.2.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     *
	     * _.unzip(zipped);
	     * // => [['a', 'b'], [1, 2], [true, false]]
	     */
	    function unzip(array) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var length = 0;
	      array = arrayFilter(array, function(group) {
	        if (isArrayLikeObject(group)) {
	          length = nativeMax(group.length, length);
	          return true;
	        }
	      });
	      return baseTimes(length, function(index) {
	        return arrayMap(array, baseProperty(index));
	      });
	    }

	    /**
	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
	     * how regrouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {Array} array The array of grouped elements to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  regrouped values.
	     * @returns {Array} Returns the new array of regrouped elements.
	     * @example
	     *
	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
	     * // => [[1, 10, 100], [2, 20, 200]]
	     *
	     * _.unzipWith(zipped, _.add);
	     * // => [3, 30, 300]
	     */
	    function unzipWith(array, iteratee) {
	      if (!(array && array.length)) {
	        return [];
	      }
	      var result = unzip(array);
	      if (iteratee == null) {
	        return result;
	      }
	      return arrayMap(result, function(group) {
	        return apply(iteratee, undefined, group);
	      });
	    }

	    /**
	     * Creates an array excluding all given values using
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * for equality comparisons.
	     *
	     * **Note:** Unlike `_.pull`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {Array} array The array to inspect.
	     * @param {...*} [values] The values to exclude.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.xor
	     * @example
	     *
	     * _.without([2, 1, 2, 3], 1, 2);
	     * // => [3]
	     */
	    var without = baseRest(function(array, values) {
	      return isArrayLikeObject(array)
	        ? baseDifference(array, values)
	        : [];
	    });

	    /**
	     * Creates an array of unique values that is the
	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
	     * of the given arrays. The order of result values is determined by the order
	     * they occur in the arrays.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @returns {Array} Returns the new array of filtered values.
	     * @see _.difference, _.without
	     * @example
	     *
	     * _.xor([2, 1], [2, 3]);
	     * // => [1, 3]
	     */
	    var xor = baseRest(function(arrays) {
	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `iteratee` which is
	     * invoked for each element of each `arrays` to generate the criterion by
	     * which by which they're compared. The order of result values is determined
	     * by the order they occur in the arrays. The iteratee is invoked with one
	     * argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
	     * // => [1.2, 3.4]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
	     * // => [{ 'x': 2 }]
	     */
	    var xorBy = baseRest(function(arrays) {
	      var iteratee = last(arrays);
	      if (isArrayLikeObject(iteratee)) {
	        iteratee = undefined;
	      }
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
	    });

	    /**
	     * This method is like `_.xor` except that it accepts `comparator` which is
	     * invoked to compare elements of `arrays`. The order of result values is
	     * determined by the order they occur in the arrays. The comparator is invoked
	     * with two arguments: (arrVal, othVal).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to inspect.
	     * @param {Function} [comparator] The comparator invoked per element.
	     * @returns {Array} Returns the new array of filtered values.
	     * @example
	     *
	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
	     *
	     * _.xorWith(objects, others, _.isEqual);
	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
	     */
	    var xorWith = baseRest(function(arrays) {
	      var comparator = last(arrays);
	      comparator = typeof comparator == 'function' ? comparator : undefined;
	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
	    });

	    /**
	     * Creates an array of grouped elements, the first of which contains the
	     * first elements of the given arrays, the second of which contains the
	     * second elements of the given arrays, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zip(['a', 'b'], [1, 2], [true, false]);
	     * // => [['a', 1, true], ['b', 2, false]]
	     */
	    var zip = baseRest(unzip);

	    /**
	     * This method is like `_.fromPairs` except that it accepts two arrays,
	     * one of property identifiers and one of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.4.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObject(['a', 'b'], [1, 2]);
	     * // => { 'a': 1, 'b': 2 }
	     */
	    function zipObject(props, values) {
	      return baseZipObject(props || [], values || [], assignValue);
	    }

	    /**
	     * This method is like `_.zipObject` except that it supports property paths.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Array
	     * @param {Array} [props=[]] The property identifiers.
	     * @param {Array} [values=[]] The property values.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
	     */
	    function zipObjectDeep(props, values) {
	      return baseZipObject(props || [], values || [], baseSet);
	    }

	    /**
	     * This method is like `_.zip` except that it accepts `iteratee` to specify
	     * how grouped values should be combined. The iteratee is invoked with the
	     * elements of each group: (...group).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Array
	     * @param {...Array} [arrays] The arrays to process.
	     * @param {Function} [iteratee=_.identity] The function to combine
	     *  grouped values.
	     * @returns {Array} Returns the new array of grouped elements.
	     * @example
	     *
	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
	     *   return a + b + c;
	     * });
	     * // => [111, 222]
	     */
	    var zipWith = baseRest(function(arrays) {
	      var length = arrays.length,
	          iteratee = length > 1 ? arrays[length - 1] : undefined;

	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
	      return unzipWith(arrays, iteratee);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
	     * chain sequences enabled. The result of such sequences must be unwrapped
	     * with `_#value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Seq
	     * @param {*} value The value to wrap.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36 },
	     *   { 'user': 'fred',    'age': 40 },
	     *   { 'user': 'pebbles', 'age': 1 }
	     * ];
	     *
	     * var youngest = _
	     *   .chain(users)
	     *   .sortBy('age')
	     *   .map(function(o) {
	     *     return o.user + ' is ' + o.age;
	     *   })
	     *   .head()
	     *   .value();
	     * // => 'pebbles is 1'
	     */
	    function chain(value) {
	      var result = lodash(value);
	      result.__chain__ = true;
	      return result;
	    }

	    /**
	     * This method invokes `interceptor` and returns `value`. The interceptor
	     * is invoked with one argument; (value). The purpose of this method is to
	     * "tap into" a method chain sequence in order to modify intermediate results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * _([1, 2, 3])
	     *  .tap(function(array) {
	     *    // Mutate input array.
	     *    array.pop();
	     *  })
	     *  .reverse()
	     *  .value();
	     * // => [2, 1]
	     */
	    function tap(value, interceptor) {
	      interceptor(value);
	      return value;
	    }

	    /**
	     * This method is like `_.tap` except that it returns the result of `interceptor`.
	     * The purpose of this method is to "pass thru" values replacing intermediate
	     * results in a method chain sequence.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Seq
	     * @param {*} value The value to provide to `interceptor`.
	     * @param {Function} interceptor The function to invoke.
	     * @returns {*} Returns the result of `interceptor`.
	     * @example
	     *
	     * _('  abc  ')
	     *  .chain()
	     *  .trim()
	     *  .thru(function(value) {
	     *    return [value];
	     *  })
	     *  .value();
	     * // => ['abc']
	     */
	    function thru(value, interceptor) {
	      return interceptor(value);
	    }

	    /**
	     * This method is the wrapper version of `_.at`.
	     *
	     * @name at
	     * @memberOf _
	     * @since 1.0.0
	     * @category Seq
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _(object).at(['a[0].b.c', 'a[1]']).value();
	     * // => [3, 4]
	     */
	    var wrapperAt = flatRest(function(paths) {
	      var length = paths.length,
	          start = length ? paths[0] : 0,
	          value = this.__wrapped__,
	          interceptor = function(object) { return baseAt(object, paths); };

	      if (length > 1 || this.__actions__.length ||
	          !(value instanceof LazyWrapper) || !isIndex(start)) {
	        return this.thru(interceptor);
	      }
	      value = value.slice(start, +start + (length ? 1 : 0));
	      value.__actions__.push({
	        'func': thru,
	        'args': [interceptor],
	        'thisArg': undefined
	      });
	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
	        if (length && !array.length) {
	          array.push(undefined);
	        }
	        return array;
	      });
	    });

	    /**
	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
	     *
	     * @name chain
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 }
	     * ];
	     *
	     * // A sequence without explicit chaining.
	     * _(users).head();
	     * // => { 'user': 'barney', 'age': 36 }
	     *
	     * // A sequence with explicit chaining.
	     * _(users)
	     *   .chain()
	     *   .head()
	     *   .pick('user')
	     *   .value();
	     * // => { 'user': 'barney' }
	     */
	    function wrapperChain() {
	      return chain(this);
	    }

	    /**
	     * Executes the chain sequence and returns the wrapped result.
	     *
	     * @name commit
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2];
	     * var wrapped = _(array).push(3);
	     *
	     * console.log(array);
	     * // => [1, 2]
	     *
	     * wrapped = wrapped.commit();
	     * console.log(array);
	     * // => [1, 2, 3]
	     *
	     * wrapped.last();
	     * // => 3
	     *
	     * console.log(array);
	     * // => [1, 2, 3]
	     */
	    function wrapperCommit() {
	      return new LodashWrapper(this.value(), this.__chain__);
	    }

	    /**
	     * Gets the next value on a wrapped object following the
	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
	     *
	     * @name next
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the next iterator value.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 1 }
	     *
	     * wrapped.next();
	     * // => { 'done': false, 'value': 2 }
	     *
	     * wrapped.next();
	     * // => { 'done': true, 'value': undefined }
	     */
	    function wrapperNext() {
	      if (this.__values__ === undefined) {
	        this.__values__ = toArray(this.value());
	      }
	      var done = this.__index__ >= this.__values__.length,
	          value = done ? undefined : this.__values__[this.__index__++];

	      return { 'done': done, 'value': value };
	    }

	    /**
	     * Enables the wrapper to be iterable.
	     *
	     * @name Symbol.iterator
	     * @memberOf _
	     * @since 4.0.0
	     * @category Seq
	     * @returns {Object} Returns the wrapper object.
	     * @example
	     *
	     * var wrapped = _([1, 2]);
	     *
	     * wrapped[Symbol.iterator]() === wrapped;
	     * // => true
	     *
	     * Array.from(wrapped);
	     * // => [1, 2]
	     */
	    function wrapperToIterator() {
	      return this;
	    }

	    /**
	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
	     *
	     * @name plant
	     * @memberOf _
	     * @since 3.2.0
	     * @category Seq
	     * @param {*} value The value to plant.
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var wrapped = _([1, 2]).map(square);
	     * var other = wrapped.plant([3, 4]);
	     *
	     * other.value();
	     * // => [9, 16]
	     *
	     * wrapped.value();
	     * // => [1, 4]
	     */
	    function wrapperPlant(value) {
	      var result,
	          parent = this;

	      while (parent instanceof baseLodash) {
	        var clone = wrapperClone(parent);
	        clone.__index__ = 0;
	        clone.__values__ = undefined;
	        if (result) {
	          previous.__wrapped__ = clone;
	        } else {
	          result = clone;
	        }
	        var previous = clone;
	        parent = parent.__wrapped__;
	      }
	      previous.__wrapped__ = value;
	      return result;
	    }

	    /**
	     * This method is the wrapper version of `_.reverse`.
	     *
	     * **Note:** This method mutates the wrapped array.
	     *
	     * @name reverse
	     * @memberOf _
	     * @since 0.1.0
	     * @category Seq
	     * @returns {Object} Returns the new `lodash` wrapper instance.
	     * @example
	     *
	     * var array = [1, 2, 3];
	     *
	     * _(array).reverse().value()
	     * // => [3, 2, 1]
	     *
	     * console.log(array);
	     * // => [3, 2, 1]
	     */
	    function wrapperReverse() {
	      var value = this.__wrapped__;
	      if (value instanceof LazyWrapper) {
	        var wrapped = value;
	        if (this.__actions__.length) {
	          wrapped = new LazyWrapper(this);
	        }
	        wrapped = wrapped.reverse();
	        wrapped.__actions__.push({
	          'func': thru,
	          'args': [reverse],
	          'thisArg': undefined
	        });
	        return new LodashWrapper(wrapped, this.__chain__);
	      }
	      return this.thru(reverse);
	    }

	    /**
	     * Executes the chain sequence to resolve the unwrapped value.
	     *
	     * @name value
	     * @memberOf _
	     * @since 0.1.0
	     * @alias toJSON, valueOf
	     * @category Seq
	     * @returns {*} Returns the resolved unwrapped value.
	     * @example
	     *
	     * _([1, 2, 3]).value();
	     * // => [1, 2, 3]
	     */
	    function wrapperValue() {
	      return baseWrapperValue(this.__wrapped__, this.__actions__);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the number of times the key was returned by `iteratee`. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': 1, '6': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.countBy(['one', 'two', 'three'], 'length');
	     * // => { '3': 2, '5': 1 }
	     */
	    var countBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        ++result[key];
	      } else {
	        baseAssignValue(result, key, 1);
	      }
	    });

	    /**
	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
	     * Iteration is stopped once `predicate` returns falsey. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * **Note:** This method returns `true` for
	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
	     * elements of empty collections.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.every([true, 1, null, 'yes'], Boolean);
	     * // => false
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.every(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.every(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.every(users, 'active');
	     * // => false
	     */
	    function every(collection, predicate, guard) {
	      var func = isArray(collection) ? arrayEvery : baseEvery;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning an array of all elements
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * **Note:** Unlike `_.remove`, this method returns a new array.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.reject
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * _.filter(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, { 'age': 36, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.filter(users, 'active');
	     * // => objects for ['barney']
	     */
	    function filter(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Iterates over elements of `collection`, returning the first element
	     * `predicate` returns truthy for. The predicate is invoked with three
	     * arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': true },
	     *   { 'user': 'fred',    'age': 40, 'active': false },
	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
	     * ];
	     *
	     * _.find(users, function(o) { return o.age < 40; });
	     * // => object for 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.find(users, { 'age': 1, 'active': true });
	     * // => object for 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.find(users, ['active', false]);
	     * // => object for 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.find(users, 'active');
	     * // => object for 'barney'
	     */
	    var find = createFind(findIndex);

	    /**
	     * This method is like `_.find` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param {number} [fromIndex=collection.length-1] The index to search from.
	     * @returns {*} Returns the matched element, else `undefined`.
	     * @example
	     *
	     * _.findLast([1, 2, 3, 4], function(n) {
	     *   return n % 2 == 1;
	     * });
	     * // => 3
	     */
	    var findLast = createFind(findLastIndex);

	    /**
	     * Creates a flattened array of values by running each element in `collection`
	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
	     * with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [n, n];
	     * }
	     *
	     * _.flatMap([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMap(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), 1);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDeep([1, 2], duplicate);
	     * // => [1, 1, 2, 2]
	     */
	    function flatMapDeep(collection, iteratee) {
	      return baseFlatten(map(collection, iteratee), INFINITY);
	    }

	    /**
	     * This method is like `_.flatMap` except that it recursively flattens the
	     * mapped results up to `depth` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {number} [depth=1] The maximum recursion depth.
	     * @returns {Array} Returns the new flattened array.
	     * @example
	     *
	     * function duplicate(n) {
	     *   return [[[n, n]]];
	     * }
	     *
	     * _.flatMapDepth([1, 2], duplicate, 2);
	     * // => [[1, 1], [2, 2]]
	     */
	    function flatMapDepth(collection, iteratee, depth) {
	      depth = depth === undefined ? 1 : toInteger(depth);
	      return baseFlatten(map(collection, iteratee), depth);
	    }

	    /**
	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
	     * The iteratee is invoked with three arguments: (value, index|key, collection).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * **Note:** As with other "Collections" methods, objects with a "length"
	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
	     * or `_.forOwn` for object iteration.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @alias each
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEachRight
	     * @example
	     *
	     * _.forEach([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `1` then `2`.
	     *
	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forEach(collection, iteratee) {
	      var func = isArray(collection) ? arrayEach : baseEach;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forEach` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @alias eachRight
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array|Object} Returns `collection`.
	     * @see _.forEach
	     * @example
	     *
	     * _.forEachRight([1, 2], function(value) {
	     *   console.log(value);
	     * });
	     * // => Logs `2` then `1`.
	     */
	    function forEachRight(collection, iteratee) {
	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The order of grouped values
	     * is determined by the order they occur in `collection`. The corresponding
	     * value of each key is an array of elements responsible for generating the
	     * key. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
	     * // => { '4': [4.2], '6': [6.1, 6.3] }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.groupBy(['one', 'two', 'three'], 'length');
	     * // => { '3': ['one', 'two'], '5': ['three'] }
	     */
	    var groupBy = createAggregator(function(result, value, key) {
	      if (hasOwnProperty.call(result, key)) {
	        result[key].push(value);
	      } else {
	        baseAssignValue(result, key, [value]);
	      }
	    });

	    /**
	     * Checks if `value` is in `collection`. If `collection` is a string, it's
	     * checked for a substring of `value`, otherwise
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
	     * the offset from the end of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @param {*} value The value to search for.
	     * @param {number} [fromIndex=0] The index to search from.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
	     * @example
	     *
	     * _.includes([1, 2, 3], 1);
	     * // => true
	     *
	     * _.includes([1, 2, 3], 1, 2);
	     * // => false
	     *
	     * _.includes({ 'a': 1, 'b': 2 }, 1);
	     * // => true
	     *
	     * _.includes('abcd', 'bc');
	     * // => true
	     */
	    function includes(collection, value, fromIndex, guard) {
	      collection = isArrayLike(collection) ? collection : values(collection);
	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

	      var length = collection.length;
	      if (fromIndex < 0) {
	        fromIndex = nativeMax(length + fromIndex, 0);
	      }
	      return isString(collection)
	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
	    }

	    /**
	     * Invokes the method at `path` of each element in `collection`, returning
	     * an array of the results of each invoked method. Any additional arguments
	     * are provided to each invoked method. If `path` is a function, it's invoked
	     * for, and `this` bound to, each element in `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array|Function|string} path The path of the method to invoke or
	     *  the function invoked per iteration.
	     * @param {...*} [args] The arguments to invoke each method with.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
	     * // => [[1, 5, 7], [1, 2, 3]]
	     *
	     * _.invokeMap([123, 456], String.prototype.split, '');
	     * // => [['1', '2', '3'], ['4', '5', '6']]
	     */
	    var invokeMap = baseRest(function(collection, path, args) {
	      var index = -1,
	          isFunc = typeof path == 'function',
	          result = isArrayLike(collection) ? Array(collection.length) : [];

	      baseEach(collection, function(value) {
	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
	      });
	      return result;
	    });

	    /**
	     * Creates an object composed of keys generated from the results of running
	     * each element of `collection` thru `iteratee`. The corresponding value of
	     * each key is the last element responsible for generating the key. The
	     * iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
	     * @returns {Object} Returns the composed aggregate object.
	     * @example
	     *
	     * var array = [
	     *   { 'dir': 'left', 'code': 97 },
	     *   { 'dir': 'right', 'code': 100 }
	     * ];
	     *
	     * _.keyBy(array, function(o) {
	     *   return String.fromCharCode(o.code);
	     * });
	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
	     *
	     * _.keyBy(array, 'dir');
	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
	     */
	    var keyBy = createAggregator(function(result, value, key) {
	      baseAssignValue(result, key, value);
	    });

	    /**
	     * Creates an array of values by running each element in `collection` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
	     *
	     * The guarded methods are:
	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new mapped array.
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * _.map([4, 8], square);
	     * // => [16, 64]
	     *
	     * _.map({ 'a': 4, 'b': 8 }, square);
	     * // => [16, 64] (iteration order is not guaranteed)
	     *
	     * var users = [
	     *   { 'user': 'barney' },
	     *   { 'user': 'fred' }
	     * ];
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, 'user');
	     * // => ['barney', 'fred']
	     */
	    function map(collection, iteratee) {
	      var func = isArray(collection) ? arrayMap : baseMap;
	      return func(collection, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.sortBy` except that it allows specifying the sort
	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
	     * descending or "asc" for ascending sort order of corresponding values.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @param {string[]} [orders] The sort orders of `iteratees`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 34 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 36 }
	     * ];
	     *
	     * // Sort by `user` in ascending order and by `age` in descending order.
	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     */
	    function orderBy(collection, iteratees, orders, guard) {
	      if (collection == null) {
	        return [];
	      }
	      if (!isArray(iteratees)) {
	        iteratees = iteratees == null ? [] : [iteratees];
	      }
	      orders = guard ? undefined : orders;
	      if (!isArray(orders)) {
	        orders = orders == null ? [] : [orders];
	      }
	      return baseOrderBy(collection, iteratees, orders);
	    }

	    /**
	     * Creates an array of elements split into two groups, the first of which
	     * contains elements `predicate` returns truthy for, the second of which
	     * contains elements `predicate` returns falsey for. The predicate is
	     * invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of grouped elements.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney',  'age': 36, 'active': false },
	     *   { 'user': 'fred',    'age': 40, 'active': true },
	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
	     * ];
	     *
	     * _.partition(users, function(o) { return o.active; });
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.partition(users, { 'age': 1, 'active': false });
	     * // => objects for [['pebbles'], ['barney', 'fred']]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.partition(users, ['active', false]);
	     * // => objects for [['barney', 'pebbles'], ['fred']]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.partition(users, 'active');
	     * // => objects for [['fred'], ['barney', 'pebbles']]
	     */
	    var partition = createAggregator(function(result, value, key) {
	      result[key ? 0 : 1].push(value);
	    }, function() { return [[], []]; });

	    /**
	     * Reduces `collection` to a value which is the accumulated result of running
	     * each element in `collection` thru `iteratee`, where each successive
	     * invocation is supplied the return value of the previous. If `accumulator`
	     * is not given, the first element of `collection` is used as the initial
	     * value. The iteratee is invoked with four arguments:
	     * (accumulator, value, index|key, collection).
	     *
	     * Many lodash methods are guarded to work as iteratees for methods like
	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
	     *
	     * The guarded methods are:
	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
	     * and `sortBy`
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduceRight
	     * @example
	     *
	     * _.reduce([1, 2], function(sum, n) {
	     *   return sum + n;
	     * }, 0);
	     * // => 3
	     *
	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     *   return result;
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
	     */
	    function reduce(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduce : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
	    }

	    /**
	     * This method is like `_.reduce` except that it iterates over elements of
	     * `collection` from right to left.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The initial value.
	     * @returns {*} Returns the accumulated value.
	     * @see _.reduce
	     * @example
	     *
	     * var array = [[0, 1], [2, 3], [4, 5]];
	     *
	     * _.reduceRight(array, function(flattened, other) {
	     *   return flattened.concat(other);
	     * }, []);
	     * // => [4, 5, 2, 3, 0, 1]
	     */
	    function reduceRight(collection, iteratee, accumulator) {
	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
	          initAccum = arguments.length < 3;

	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
	    }

	    /**
	     * The opposite of `_.filter`; this method returns the elements of `collection`
	     * that `predicate` does **not** return truthy for.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the new filtered array.
	     * @see _.filter
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': false },
	     *   { 'user': 'fred',   'age': 40, 'active': true }
	     * ];
	     *
	     * _.reject(users, function(o) { return !o.active; });
	     * // => objects for ['fred']
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.reject(users, { 'age': 40, 'active': true });
	     * // => objects for ['barney']
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.reject(users, ['active', false]);
	     * // => objects for ['fred']
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.reject(users, 'active');
	     * // => objects for ['barney']
	     */
	    function reject(collection, predicate) {
	      var func = isArray(collection) ? arrayFilter : baseFilter;
	      return func(collection, negate(getIteratee(predicate, 3)));
	    }

	    /**
	     * Gets a random element from `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @returns {*} Returns the random element.
	     * @example
	     *
	     * _.sample([1, 2, 3, 4]);
	     * // => 2
	     */
	    function sample(collection) {
	      var func = isArray(collection) ? arraySample : baseSample;
	      return func(collection);
	    }

	    /**
	     * Gets `n` random elements at unique keys from `collection` up to the
	     * size of `collection`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to sample.
	     * @param {number} [n=1] The number of elements to sample.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the random elements.
	     * @example
	     *
	     * _.sampleSize([1, 2, 3], 2);
	     * // => [3, 1]
	     *
	     * _.sampleSize([1, 2, 3], 4);
	     * // => [2, 3, 1]
	     */
	    function sampleSize(collection, n, guard) {
	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
	      return func(collection, n);
	    }

	    /**
	     * Creates an array of shuffled values, using a version of the
	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to shuffle.
	     * @returns {Array} Returns the new shuffled array.
	     * @example
	     *
	     * _.shuffle([1, 2, 3, 4]);
	     * // => [4, 1, 3, 2]
	     */
	    function shuffle(collection) {
	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
	      return func(collection);
	    }

	    /**
	     * Gets the size of `collection` by returning its length for array-like
	     * values or the number of own enumerable string keyed properties for objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object|string} collection The collection to inspect.
	     * @returns {number} Returns the collection size.
	     * @example
	     *
	     * _.size([1, 2, 3]);
	     * // => 3
	     *
	     * _.size({ 'a': 1, 'b': 2 });
	     * // => 2
	     *
	     * _.size('pebbles');
	     * // => 7
	     */
	    function size(collection) {
	      if (collection == null) {
	        return 0;
	      }
	      if (isArrayLike(collection)) {
	        return isString(collection) ? stringSize(collection) : collection.length;
	      }
	      var tag = getTag(collection);
	      if (tag == mapTag || tag == setTag) {
	        return collection.size;
	      }
	      return baseKeys(collection).length;
	    }

	    /**
	     * Checks if `predicate` returns truthy for **any** element of `collection`.
	     * Iteration is stopped once `predicate` returns truthy. The predicate is
	     * invoked with three arguments: (value, index|key, collection).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {boolean} Returns `true` if any element passes the predicate check,
	     *  else `false`.
	     * @example
	     *
	     * _.some([null, 0, 'yes', false], Boolean);
	     * // => true
	     *
	     * var users = [
	     *   { 'user': 'barney', 'active': true },
	     *   { 'user': 'fred',   'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.some(users, { 'user': 'barney', 'active': false });
	     * // => false
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.some(users, ['active', false]);
	     * // => true
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.some(users, 'active');
	     * // => true
	     */
	    function some(collection, predicate, guard) {
	      var func = isArray(collection) ? arraySome : baseSome;
	      if (guard && isIterateeCall(collection, predicate, guard)) {
	        predicate = undefined;
	      }
	      return func(collection, getIteratee(predicate, 3));
	    }

	    /**
	     * Creates an array of elements, sorted in ascending order by the results of
	     * running each element in a collection thru each iteratee. This method
	     * performs a stable sort, that is, it preserves the original sort order of
	     * equal elements. The iteratees are invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Collection
	     * @param {Array|Object} collection The collection to iterate over.
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to sort by.
	     * @returns {Array} Returns the new sorted array.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'fred',   'age': 48 },
	     *   { 'user': 'barney', 'age': 36 },
	     *   { 'user': 'fred',   'age': 40 },
	     *   { 'user': 'barney', 'age': 34 }
	     * ];
	     *
	     * _.sortBy(users, [function(o) { return o.user; }]);
	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
	     *
	     * _.sortBy(users, ['user', 'age']);
	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 40], ['fred', 48]]
	     */
	    var sortBy = baseRest(function(collection, iteratees) {
	      if (collection == null) {
	        return [];
	      }
	      var length = iteratees.length;
	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
	        iteratees = [];
	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
	        iteratees = [iteratees[0]];
	      }
	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
	    });

	    /*------------------------------------------------------------------------*/

	    /**
	     * Gets the timestamp of the number of milliseconds that have elapsed since
	     * the Unix epoch (1 January 1970 00:00:00 UTC).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Date
	     * @returns {number} Returns the timestamp.
	     * @example
	     *
	     * _.defer(function(stamp) {
	     *   console.log(_.now() - stamp);
	     * }, _.now());
	     * // => Logs the number of milliseconds it took for the deferred invocation.
	     */
	    var now = ctxNow || function() {
	      return root.Date.now();
	    };

	    /*------------------------------------------------------------------------*/

	    /**
	     * The opposite of `_.before`; this method creates a function that invokes
	     * `func` once it's called `n` or more times.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {number} n The number of calls before `func` is invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var saves = ['profile', 'settings'];
	     *
	     * var done = _.after(saves.length, function() {
	     *   console.log('done saving!');
	     * });
	     *
	     * _.forEach(saves, function(type) {
	     *   asyncSave({ 'type': type, 'complete': done });
	     * });
	     * // => Logs 'done saving!' after the two async saves have completed.
	     */
	    function after(n, func) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n < 1) {
	          return func.apply(this, arguments);
	        }
	      };
	    }

	    /**
	     * Creates a function that invokes `func`, with up to `n` arguments,
	     * ignoring any additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @param {number} [n=func.length] The arity cap.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
	     * // => [6, 8, 10]
	     */
	    function ary(func, n, guard) {
	      n = guard ? undefined : n;
	      n = (func && n == null) ? func.length : n;
	      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
	    }

	    /**
	     * Creates a function that invokes `func`, with the `this` binding and arguments
	     * of the created function, while it's called less than `n` times. Subsequent
	     * calls to the created function return the result of the last `func` invocation.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {number} n The number of calls at which `func` is no longer invoked.
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * jQuery(element).on('click', _.before(5, addContactToList));
	     * // => Allows adding up to 4 contacts to the list.
	     */
	    function before(n, func) {
	      var result;
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      n = toInteger(n);
	      return function() {
	        if (--n > 0) {
	          result = func.apply(this, arguments);
	        }
	        if (n <= 1) {
	          func = undefined;
	        }
	        return result;
	      };
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
	     * and `partials` prepended to the arguments it receives.
	     *
	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
	     * property of bound functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to bind.
	     * @param {*} thisArg The `this` binding of `func`.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * function greet(greeting, punctuation) {
	     *   return greeting + ' ' + this.user + punctuation;
	     * }
	     *
	     * var object = { 'user': 'fred' };
	     *
	     * var bound = _.bind(greet, object, 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bind(greet, object, _, '!');
	     * bound('hi');
	     * // => 'hi fred!'
	     */
	    var bind = baseRest(function(func, thisArg, partials) {
	      var bitmask = WRAP_BIND_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bind));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(func, bitmask, thisArg, partials, holders);
	    });

	    /**
	     * Creates a function that invokes the method at `object[key]` with `partials`
	     * prepended to the arguments it receives.
	     *
	     * This method differs from `_.bind` by allowing bound functions to reference
	     * methods that may be redefined or don't yet exist. See
	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
	     * for more details.
	     *
	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Function
	     * @param {Object} object The object to invoke the method on.
	     * @param {string} key The key of the method.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new bound function.
	     * @example
	     *
	     * var object = {
	     *   'user': 'fred',
	     *   'greet': function(greeting, punctuation) {
	     *     return greeting + ' ' + this.user + punctuation;
	     *   }
	     * };
	     *
	     * var bound = _.bindKey(object, 'greet', 'hi');
	     * bound('!');
	     * // => 'hi fred!'
	     *
	     * object.greet = function(greeting, punctuation) {
	     *   return greeting + 'ya ' + this.user + punctuation;
	     * };
	     *
	     * bound('!');
	     * // => 'hiya fred!'
	     *
	     * // Bound with placeholders.
	     * var bound = _.bindKey(object, 'greet', _, '!');
	     * bound('hi');
	     * // => 'hiya fred!'
	     */
	    var bindKey = baseRest(function(object, key, partials) {
	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
	      if (partials.length) {
	        var holders = replaceHolders(partials, getHolder(bindKey));
	        bitmask |= WRAP_PARTIAL_FLAG;
	      }
	      return createWrap(key, bitmask, object, partials, holders);
	    });

	    /**
	     * Creates a function that accepts arguments of `func` and either invokes
	     * `func` returning its result, if at least `arity` number of arguments have
	     * been provided, or returns a function that accepts the remaining `func`
	     * arguments, and so on. The arity of `func` may be specified if `func.length`
	     * is not sufficient.
	     *
	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
	     * may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curry(abc);
	     *
	     * curried(1)(2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2)(3);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(1)(_, 3)(2);
	     * // => [1, 2, 3]
	     */
	    function curry(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curry.placeholder;
	      return result;
	    }

	    /**
	     * This method is like `_.curry` except that arguments are applied to `func`
	     * in the manner of `_.partialRight` instead of `_.partial`.
	     *
	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for provided arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of curried functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to curry.
	     * @param {number} [arity=func.length] The arity of `func`.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the new curried function.
	     * @example
	     *
	     * var abc = function(a, b, c) {
	     *   return [a, b, c];
	     * };
	     *
	     * var curried = _.curryRight(abc);
	     *
	     * curried(3)(2)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(2, 3)(1);
	     * // => [1, 2, 3]
	     *
	     * curried(1, 2, 3);
	     * // => [1, 2, 3]
	     *
	     * // Curried with placeholders.
	     * curried(3)(1, _)(2);
	     * // => [1, 2, 3]
	     */
	    function curryRight(func, arity, guard) {
	      arity = guard ? undefined : arity;
	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
	      result.placeholder = curryRight.placeholder;
	      return result;
	    }

	    /**
	     * Creates a debounced function that delays invoking `func` until after `wait`
	     * milliseconds have elapsed since the last time the debounced function was
	     * invoked. The debounced function comes with a `cancel` method to cancel
	     * delayed `func` invocations and a `flush` method to immediately invoke them.
	     * Provide `options` to indicate whether `func` should be invoked on the
	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
	     * with the last arguments provided to the debounced function. Subsequent
	     * calls to the debounced function return the result of the last `func`
	     * invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the debounced function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.debounce` and `_.throttle`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to debounce.
	     * @param {number} [wait=0] The number of milliseconds to delay.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=false]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {number} [options.maxWait]
	     *  The maximum time `func` is allowed to be delayed before it's invoked.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new debounced function.
	     * @example
	     *
	     * // Avoid costly calculations while the window size is in flux.
	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
	     *
	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
	     *   'leading': true,
	     *   'trailing': false
	     * }));
	     *
	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
	     * var source = new EventSource('/stream');
	     * jQuery(source).on('message', debounced);
	     *
	     * // Cancel the trailing debounced invocation.
	     * jQuery(window).on('popstate', debounced.cancel);
	     */
	    function debounce(func, wait, options) {
	      var lastArgs,
	          lastThis,
	          maxWait,
	          result,
	          timerId,
	          lastCallTime,
	          lastInvokeTime = 0,
	          leading = false,
	          maxing = false,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      wait = toNumber(wait) || 0;
	      if (isObject(options)) {
	        leading = !!options.leading;
	        maxing = 'maxWait' in options;
	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }

	      function invokeFunc(time) {
	        var args = lastArgs,
	            thisArg = lastThis;

	        lastArgs = lastThis = undefined;
	        lastInvokeTime = time;
	        result = func.apply(thisArg, args);
	        return result;
	      }

	      function leadingEdge(time) {
	        // Reset any `maxWait` timer.
	        lastInvokeTime = time;
	        // Start the timer for the trailing edge.
	        timerId = setTimeout(timerExpired, wait);
	        // Invoke the leading edge.
	        return leading ? invokeFunc(time) : result;
	      }

	      function remainingWait(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime,
	            result = wait - timeSinceLastCall;

	        return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
	      }

	      function shouldInvoke(time) {
	        var timeSinceLastCall = time - lastCallTime,
	            timeSinceLastInvoke = time - lastInvokeTime;

	        // Either this is the first call, activity has stopped and we're at the
	        // trailing edge, the system time has gone backwards and we're treating
	        // it as the trailing edge, or we've hit the `maxWait` limit.
	        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
	      }

	      function timerExpired() {
	        var time = now();
	        if (shouldInvoke(time)) {
	          return trailingEdge(time);
	        }
	        // Restart the timer.
	        timerId = setTimeout(timerExpired, remainingWait(time));
	      }

	      function trailingEdge(time) {
	        timerId = undefined;

	        // Only invoke if we have `lastArgs` which means `func` has been
	        // debounced at least once.
	        if (trailing && lastArgs) {
	          return invokeFunc(time);
	        }
	        lastArgs = lastThis = undefined;
	        return result;
	      }

	      function cancel() {
	        if (timerId !== undefined) {
	          clearTimeout(timerId);
	        }
	        lastInvokeTime = 0;
	        lastArgs = lastCallTime = lastThis = timerId = undefined;
	      }

	      function flush() {
	        return timerId === undefined ? result : trailingEdge(now());
	      }

	      function debounced() {
	        var time = now(),
	            isInvoking = shouldInvoke(time);

	        lastArgs = arguments;
	        lastThis = this;
	        lastCallTime = time;

	        if (isInvoking) {
	          if (timerId === undefined) {
	            return leadingEdge(lastCallTime);
	          }
	          if (maxing) {
	            // Handle invocations in a tight loop.
	            timerId = setTimeout(timerExpired, wait);
	            return invokeFunc(lastCallTime);
	          }
	        }
	        if (timerId === undefined) {
	          timerId = setTimeout(timerExpired, wait);
	        }
	        return result;
	      }
	      debounced.cancel = cancel;
	      debounced.flush = flush;
	      return debounced;
	    }

	    /**
	     * Defers invoking the `func` until the current call stack has cleared. Any
	     * additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to defer.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.defer(function(text) {
	     *   console.log(text);
	     * }, 'deferred');
	     * // => Logs 'deferred' after one millisecond.
	     */
	    var defer = baseRest(function(func, args) {
	      return baseDelay(func, 1, args);
	    });

	    /**
	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
	     * provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to delay.
	     * @param {number} wait The number of milliseconds to delay invocation.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {number} Returns the timer id.
	     * @example
	     *
	     * _.delay(function(text) {
	     *   console.log(text);
	     * }, 1000, 'later');
	     * // => Logs 'later' after one second.
	     */
	    var delay = baseRest(function(func, wait, args) {
	      return baseDelay(func, toNumber(wait) || 0, args);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments reversed.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to flip arguments for.
	     * @returns {Function} Returns the new flipped function.
	     * @example
	     *
	     * var flipped = _.flip(function() {
	     *   return _.toArray(arguments);
	     * });
	     *
	     * flipped('a', 'b', 'c', 'd');
	     * // => ['d', 'c', 'b', 'a']
	     */
	    function flip(func) {
	      return createWrap(func, WRAP_FLIP_FLAG);
	    }

	    /**
	     * Creates a function that memoizes the result of `func`. If `resolver` is
	     * provided, it determines the cache key for storing the result based on the
	     * arguments provided to the memoized function. By default, the first argument
	     * provided to the memoized function is used as the map cache key. The `func`
	     * is invoked with the `this` binding of the memoized function.
	     *
	     * **Note:** The cache is exposed as the `cache` property on the memoized
	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
	     * constructor with one whose instances implement the
	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to have its output memoized.
	     * @param {Function} [resolver] The function to resolve the cache key.
	     * @returns {Function} Returns the new memoized function.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     * var other = { 'c': 3, 'd': 4 };
	     *
	     * var values = _.memoize(_.values);
	     * values(object);
	     * // => [1, 2]
	     *
	     * values(other);
	     * // => [3, 4]
	     *
	     * object.a = 2;
	     * values(object);
	     * // => [1, 2]
	     *
	     * // Modify the result cache.
	     * values.cache.set(object, ['a', 'b']);
	     * values(object);
	     * // => ['a', 'b']
	     *
	     * // Replace `_.memoize.Cache`.
	     * _.memoize.Cache = WeakMap;
	     */
	    function memoize(func, resolver) {
	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      var memoized = function() {
	        var args = arguments,
	            key = resolver ? resolver.apply(this, args) : args[0],
	            cache = memoized.cache;

	        if (cache.has(key)) {
	          return cache.get(key);
	        }
	        var result = func.apply(this, args);
	        memoized.cache = cache.set(key, result) || cache;
	        return result;
	      };
	      memoized.cache = new (memoize.Cache || MapCache);
	      return memoized;
	    }

	    // Expose `MapCache`.
	    memoize.Cache = MapCache;

	    /**
	     * Creates a function that negates the result of the predicate `func`. The
	     * `func` predicate is invoked with the `this` binding and arguments of the
	     * created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} predicate The predicate to negate.
	     * @returns {Function} Returns the new negated function.
	     * @example
	     *
	     * function isEven(n) {
	     *   return n % 2 == 0;
	     * }
	     *
	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
	     * // => [1, 3, 5]
	     */
	    function negate(predicate) {
	      if (typeof predicate != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      return function() {
	        var args = arguments;
	        switch (args.length) {
	          case 0: return !predicate.call(this);
	          case 1: return !predicate.call(this, args[0]);
	          case 2: return !predicate.call(this, args[0], args[1]);
	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
	        }
	        return !predicate.apply(this, args);
	      };
	    }

	    /**
	     * Creates a function that is restricted to invoking `func` once. Repeat calls
	     * to the function return the value of the first invocation. The `func` is
	     * invoked with the `this` binding and arguments of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to restrict.
	     * @returns {Function} Returns the new restricted function.
	     * @example
	     *
	     * var initialize = _.once(createApplication);
	     * initialize();
	     * initialize();
	     * // => `createApplication` is invoked once
	     */
	    function once(func) {
	      return before(2, func);
	    }

	    /**
	     * Creates a function that invokes `func` with its arguments transformed.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Function
	     * @param {Function} func The function to wrap.
	     * @param {...(Function|Function[])} [transforms=[_.identity]]
	     *  The argument transforms.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * function doubled(n) {
	     *   return n * 2;
	     * }
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var func = _.overArgs(function(x, y) {
	     *   return [x, y];
	     * }, [square, doubled]);
	     *
	     * func(9, 3);
	     * // => [81, 6]
	     *
	     * func(10, 5);
	     * // => [100, 10]
	     */
	    var overArgs = castRest(function(func, transforms) {
	      transforms = (transforms.length == 1 && isArray(transforms[0]))
	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

	      var funcsLength = transforms.length;
	      return baseRest(function(args) {
	        var index = -1,
	            length = nativeMin(args.length, funcsLength);

	        while (++index < length) {
	          args[index] = transforms[index].call(this, args[index]);
	        }
	        return apply(func, this, args);
	      });
	    });

	    /**
	     * Creates a function that invokes `func` with `partials` prepended to the
	     * arguments it receives. This method is like `_.bind` except it does **not**
	     * alter the `this` binding.
	     *
	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.2.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var sayHelloTo = _.partial(greet, 'hello');
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     *
	     * // Partially applied with placeholders.
	     * var greetFred = _.partial(greet, _, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     */
	    var partial = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partial));
	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
	    });

	    /**
	     * This method is like `_.partial` except that partially applied arguments
	     * are appended to the arguments it receives.
	     *
	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
	     * builds, may be used as a placeholder for partially applied arguments.
	     *
	     * **Note:** This method doesn't set the "length" property of partially
	     * applied functions.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Function
	     * @param {Function} func The function to partially apply arguments to.
	     * @param {...*} [partials] The arguments to be partially applied.
	     * @returns {Function} Returns the new partially applied function.
	     * @example
	     *
	     * function greet(greeting, name) {
	     *   return greeting + ' ' + name;
	     * }
	     *
	     * var greetFred = _.partialRight(greet, 'fred');
	     * greetFred('hi');
	     * // => 'hi fred'
	     *
	     * // Partially applied with placeholders.
	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
	     * sayHelloTo('fred');
	     * // => 'hello fred'
	     */
	    var partialRight = baseRest(function(func, partials) {
	      var holders = replaceHolders(partials, getHolder(partialRight));
	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
	    });

	    /**
	     * Creates a function that invokes `func` with arguments arranged according
	     * to the specified `indexes` where the argument value at the first index is
	     * provided as the first argument, the argument value at the second index is
	     * provided as the second argument, and so on.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Function
	     * @param {Function} func The function to rearrange arguments for.
	     * @param {...(number|number[])} indexes The arranged argument indexes.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var rearged = _.rearg(function(a, b, c) {
	     *   return [a, b, c];
	     * }, [2, 0, 1]);
	     *
	     * rearged('b', 'c', 'a')
	     * // => ['a', 'b', 'c']
	     */
	    var rearg = flatRest(function(func, indexes) {
	      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
	    });

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * created function and arguments from `start` and beyond provided as
	     * an array.
	     *
	     * **Note:** This method is based on the
	     * [rest parameter](https://mdn.io/rest_parameters).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to apply a rest parameter to.
	     * @param {number} [start=func.length-1] The start position of the rest parameter.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.rest(function(what, names) {
	     *   return what + ' ' + _.initial(names).join(', ') +
	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
	     * });
	     *
	     * say('hello', 'fred', 'barney', 'pebbles');
	     * // => 'hello fred, barney, & pebbles'
	     */
	    function rest(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start === undefined ? start : toInteger(start);
	      return baseRest(func, start);
	    }

	    /**
	     * Creates a function that invokes `func` with the `this` binding of the
	     * create function and an array of arguments much like
	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
	     *
	     * **Note:** This method is based on the
	     * [spread operator](https://mdn.io/spread_operator).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Function
	     * @param {Function} func The function to spread arguments over.
	     * @param {number} [start=0] The start position of the spread.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var say = _.spread(function(who, what) {
	     *   return who + ' says ' + what;
	     * });
	     *
	     * say(['fred', 'hello']);
	     * // => 'fred says hello'
	     *
	     * var numbers = Promise.all([
	     *   Promise.resolve(40),
	     *   Promise.resolve(36)
	     * ]);
	     *
	     * numbers.then(_.spread(function(x, y) {
	     *   return x + y;
	     * }));
	     * // => a Promise of 76
	     */
	    function spread(func, start) {
	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      start = start == null ? 0 : nativeMax(toInteger(start), 0);
	      return baseRest(function(args) {
	        var array = args[start],
	            otherArgs = castSlice(args, 0, start);

	        if (array) {
	          arrayPush(otherArgs, array);
	        }
	        return apply(func, this, otherArgs);
	      });
	    }

	    /**
	     * Creates a throttled function that only invokes `func` at most once per
	     * every `wait` milliseconds. The throttled function comes with a `cancel`
	     * method to cancel delayed `func` invocations and a `flush` method to
	     * immediately invoke them. Provide `options` to indicate whether `func`
	     * should be invoked on the leading and/or trailing edge of the `wait`
	     * timeout. The `func` is invoked with the last arguments provided to the
	     * throttled function. Subsequent calls to the throttled function return the
	     * result of the last `func` invocation.
	     *
	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
	     * invoked on the trailing edge of the timeout only if the throttled function
	     * is invoked more than once during the `wait` timeout.
	     *
	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
	     *
	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
	     * for details over the differences between `_.throttle` and `_.debounce`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {Function} func The function to throttle.
	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.leading=true]
	     *  Specify invoking on the leading edge of the timeout.
	     * @param {boolean} [options.trailing=true]
	     *  Specify invoking on the trailing edge of the timeout.
	     * @returns {Function} Returns the new throttled function.
	     * @example
	     *
	     * // Avoid excessively updating the position while scrolling.
	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
	     *
	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
	     * jQuery(element).on('click', throttled);
	     *
	     * // Cancel the trailing throttled invocation.
	     * jQuery(window).on('popstate', throttled.cancel);
	     */
	    function throttle(func, wait, options) {
	      var leading = true,
	          trailing = true;

	      if (typeof func != 'function') {
	        throw new TypeError(FUNC_ERROR_TEXT);
	      }
	      if (isObject(options)) {
	        leading = 'leading' in options ? !!options.leading : leading;
	        trailing = 'trailing' in options ? !!options.trailing : trailing;
	      }
	      return debounce(func, wait, {
	        'leading': leading,
	        'maxWait': wait,
	        'trailing': trailing
	      });
	    }

	    /**
	     * Creates a function that accepts up to one argument, ignoring any
	     * additional arguments.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Function
	     * @param {Function} func The function to cap arguments for.
	     * @returns {Function} Returns the new capped function.
	     * @example
	     *
	     * _.map(['6', '8', '10'], _.unary(parseInt));
	     * // => [6, 8, 10]
	     */
	    function unary(func) {
	      return ary(func, 1);
	    }

	    /**
	     * Creates a function that provides `value` to `wrapper` as its first
	     * argument. Any additional arguments provided to the function are appended
	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
	     * binding of the created function.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Function
	     * @param {*} value The value to wrap.
	     * @param {Function} [wrapper=identity] The wrapper function.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var p = _.wrap(_.escape, function(func, text) {
	     *   return '<p>' + func(text) + '</p>';
	     * });
	     *
	     * p('fred, barney, & pebbles');
	     * // => '<p>fred, barney, &amp; pebbles</p>'
	     */
	    function wrap(value, wrapper) {
	      return partial(castFunction(wrapper), value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Casts `value` as an array if it's not one.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.4.0
	     * @category Lang
	     * @param {*} value The value to inspect.
	     * @returns {Array} Returns the cast array.
	     * @example
	     *
	     * _.castArray(1);
	     * // => [1]
	     *
	     * _.castArray({ 'a': 1 });
	     * // => [{ 'a': 1 }]
	     *
	     * _.castArray('abc');
	     * // => ['abc']
	     *
	     * _.castArray(null);
	     * // => [null]
	     *
	     * _.castArray(undefined);
	     * // => [undefined]
	     *
	     * _.castArray();
	     * // => []
	     *
	     * var array = [1, 2, 3];
	     * console.log(_.castArray(array) === array);
	     * // => true
	     */
	    function castArray() {
	      if (!arguments.length) {
	        return [];
	      }
	      var value = arguments[0];
	      return isArray(value) ? value : [value];
	    }

	    /**
	     * Creates a shallow clone of `value`.
	     *
	     * **Note:** This method is loosely based on the
	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
	     * arrays. The own enumerable properties of `arguments` objects are cloned
	     * as plain objects. An empty object is returned for uncloneable values such
	     * as error objects, functions, DOM nodes, and WeakMaps.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeep
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var shallow = _.clone(objects);
	     * console.log(shallow[0] === objects[0]);
	     * // => true
	     */
	    function clone(value) {
	      return baseClone(value, CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.clone` except that it accepts `customizer` which
	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
	     * cloning is handled by the method instead. The `customizer` is invoked with
	     * up to four arguments; (value [, index|key, object, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the cloned value.
	     * @see _.cloneDeepWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(false);
	     *   }
	     * }
	     *
	     * var el = _.cloneWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 0
	     */
	    function cloneWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * This method is like `_.clone` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.clone
	     * @example
	     *
	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
	     *
	     * var deep = _.cloneDeep(objects);
	     * console.log(deep[0] === objects[0]);
	     * // => false
	     */
	    function cloneDeep(value) {
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
	    }

	    /**
	     * This method is like `_.cloneWith` except that it recursively clones `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to recursively clone.
	     * @param {Function} [customizer] The function to customize cloning.
	     * @returns {*} Returns the deep cloned value.
	     * @see _.cloneWith
	     * @example
	     *
	     * function customizer(value) {
	     *   if (_.isElement(value)) {
	     *     return value.cloneNode(true);
	     *   }
	     * }
	     *
	     * var el = _.cloneDeepWith(document.body, customizer);
	     *
	     * console.log(el === document.body);
	     * // => false
	     * console.log(el.nodeName);
	     * // => 'BODY'
	     * console.log(el.childNodes.length);
	     * // => 20
	     */
	    function cloneDeepWith(value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
	    }

	    /**
	     * Checks if `object` conforms to `source` by invoking the predicate
	     * properties of `source` with the corresponding property values of `object`.
	     *
	     * **Note:** This method is equivalent to `_.conforms` when `source` is
	     * partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
	     * // => true
	     *
	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
	     * // => false
	     */
	    function conformsTo(object, source) {
	      return source == null || baseConformsTo(object, source, keys(source));
	    }

	    /**
	     * Performs a
	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
	     * comparison between two values to determine if they are equivalent.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.eq(object, object);
	     * // => true
	     *
	     * _.eq(object, other);
	     * // => false
	     *
	     * _.eq('a', 'a');
	     * // => true
	     *
	     * _.eq('a', Object('a'));
	     * // => false
	     *
	     * _.eq(NaN, NaN);
	     * // => true
	     */
	    function eq(value, other) {
	      return value === other || (value !== value && other !== other);
	    }

	    /**
	     * Checks if `value` is greater than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
	     *  else `false`.
	     * @see _.lt
	     * @example
	     *
	     * _.gt(3, 1);
	     * // => true
	     *
	     * _.gt(3, 3);
	     * // => false
	     *
	     * _.gt(1, 3);
	     * // => false
	     */
	    var gt = createRelationalOperation(baseGt);

	    /**
	     * Checks if `value` is greater than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
	     *  `other`, else `false`.
	     * @see _.lte
	     * @example
	     *
	     * _.gte(3, 1);
	     * // => true
	     *
	     * _.gte(3, 3);
	     * // => true
	     *
	     * _.gte(1, 3);
	     * // => false
	     */
	    var gte = createRelationalOperation(function(value, other) {
	      return value >= other;
	    });

	    /**
	     * Checks if `value` is likely an `arguments` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArguments(function() { return arguments; }());
	     * // => true
	     *
	     * _.isArguments([1, 2, 3]);
	     * // => false
	     */
	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	        !propertyIsEnumerable.call(value, 'callee');
	    };

	    /**
	     * Checks if `value` is classified as an `Array` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	     * @example
	     *
	     * _.isArray([1, 2, 3]);
	     * // => true
	     *
	     * _.isArray(document.body.children);
	     * // => false
	     *
	     * _.isArray('abc');
	     * // => false
	     *
	     * _.isArray(_.noop);
	     * // => false
	     */
	    var isArray = Array.isArray;

	    /**
	     * Checks if `value` is classified as an `ArrayBuffer` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
	     * @example
	     *
	     * _.isArrayBuffer(new ArrayBuffer(2));
	     * // => true
	     *
	     * _.isArrayBuffer(new Array(2));
	     * // => false
	     */
	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

	    /**
	     * Checks if `value` is array-like. A value is considered array-like if it's
	     * not a function and has a `value.length` that's an integer greater than or
	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	     * @example
	     *
	     * _.isArrayLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLike(document.body.children);
	     * // => true
	     *
	     * _.isArrayLike('abc');
	     * // => true
	     *
	     * _.isArrayLike(_.noop);
	     * // => false
	     */
	    function isArrayLike(value) {
	      return value != null && isLength(value.length) && !isFunction(value);
	    }

	    /**
	     * This method is like `_.isArrayLike` except that it also checks if `value`
	     * is an object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an array-like object,
	     *  else `false`.
	     * @example
	     *
	     * _.isArrayLikeObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isArrayLikeObject(document.body.children);
	     * // => true
	     *
	     * _.isArrayLikeObject('abc');
	     * // => false
	     *
	     * _.isArrayLikeObject(_.noop);
	     * // => false
	     */
	    function isArrayLikeObject(value) {
	      return isObjectLike(value) && isArrayLike(value);
	    }

	    /**
	     * Checks if `value` is classified as a boolean primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
	     * @example
	     *
	     * _.isBoolean(false);
	     * // => true
	     *
	     * _.isBoolean(null);
	     * // => false
	     */
	    function isBoolean(value) {
	      return value === true || value === false ||
	        (isObjectLike(value) && baseGetTag(value) == boolTag);
	    }

	    /**
	     * Checks if `value` is a buffer.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	     * @example
	     *
	     * _.isBuffer(new Buffer(2));
	     * // => true
	     *
	     * _.isBuffer(new Uint8Array(2));
	     * // => false
	     */
	    var isBuffer = nativeIsBuffer || stubFalse;

	    /**
	     * Checks if `value` is classified as a `Date` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
	     * @example
	     *
	     * _.isDate(new Date);
	     * // => true
	     *
	     * _.isDate('Mon April 23 2012');
	     * // => false
	     */
	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

	    /**
	     * Checks if `value` is likely a DOM element.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
	     * @example
	     *
	     * _.isElement(document.body);
	     * // => true
	     *
	     * _.isElement('<body>');
	     * // => false
	     */
	    function isElement(value) {
	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
	    }

	    /**
	     * Checks if `value` is an empty object, collection, map, or set.
	     *
	     * Objects are considered empty if they have no own enumerable string keyed
	     * properties.
	     *
	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	     * jQuery-like collections are considered empty if they have a `length` of `0`.
	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	     * @example
	     *
	     * _.isEmpty(null);
	     * // => true
	     *
	     * _.isEmpty(true);
	     * // => true
	     *
	     * _.isEmpty(1);
	     * // => true
	     *
	     * _.isEmpty([1, 2, 3]);
	     * // => false
	     *
	     * _.isEmpty({ 'a': 1 });
	     * // => false
	     */
	    function isEmpty(value) {
	      if (value == null) {
	        return true;
	      }
	      if (isArrayLike(value) &&
	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
	        return !value.length;
	      }
	      var tag = getTag(value);
	      if (tag == mapTag || tag == setTag) {
	        return !value.size;
	      }
	      if (isPrototype(value)) {
	        return !baseKeys(value).length;
	      }
	      for (var key in value) {
	        if (hasOwnProperty.call(value, key)) {
	          return false;
	        }
	      }
	      return true;
	    }

	    /**
	     * Performs a deep comparison between two values to determine if they are
	     * equivalent.
	     *
	     * **Note:** This method supports comparing arrays, array buffers, booleans,
	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
	     * by their own, not inherited, enumerable properties. Functions and DOM
	     * nodes are compared by strict equality, i.e. `===`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     * var other = { 'a': 1 };
	     *
	     * _.isEqual(object, other);
	     * // => true
	     *
	     * object === other;
	     * // => false
	     */
	    function isEqual(value, other) {
	      return baseIsEqual(value, other);
	    }

	    /**
	     * This method is like `_.isEqual` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with up to
	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, othValue) {
	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var array = ['hello', 'goodbye'];
	     * var other = ['hi', 'goodbye'];
	     *
	     * _.isEqualWith(array, other, customizer);
	     * // => true
	     */
	    function isEqualWith(value, other, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      var result = customizer ? customizer(value, other) : undefined;
	      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
	    }

	    /**
	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
	     * `SyntaxError`, `TypeError`, or `URIError` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
	     * @example
	     *
	     * _.isError(new Error);
	     * // => true
	     *
	     * _.isError(Error);
	     * // => false
	     */
	    function isError(value) {
	      if (!isObjectLike(value)) {
	        return false;
	      }
	      var tag = baseGetTag(value);
	      return tag == errorTag || tag == domExcTag ||
	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
	    }

	    /**
	     * Checks if `value` is a finite primitive number.
	     *
	     * **Note:** This method is based on
	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
	     * @example
	     *
	     * _.isFinite(3);
	     * // => true
	     *
	     * _.isFinite(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isFinite(Infinity);
	     * // => false
	     *
	     * _.isFinite('3');
	     * // => false
	     */
	    function isFinite(value) {
	      return typeof value == 'number' && nativeIsFinite(value);
	    }

	    /**
	     * Checks if `value` is classified as a `Function` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	     * @example
	     *
	     * _.isFunction(_);
	     * // => true
	     *
	     * _.isFunction(/abc/);
	     * // => false
	     */
	    function isFunction(value) {
	      if (!isObject(value)) {
	        return false;
	      }
	      // The use of `Object#toString` avoids issues with the `typeof` operator
	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
	      var tag = baseGetTag(value);
	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
	    }

	    /**
	     * Checks if `value` is an integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
	     * @example
	     *
	     * _.isInteger(3);
	     * // => true
	     *
	     * _.isInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isInteger(Infinity);
	     * // => false
	     *
	     * _.isInteger('3');
	     * // => false
	     */
	    function isInteger(value) {
	      return typeof value == 'number' && value == toInteger(value);
	    }

	    /**
	     * Checks if `value` is a valid array-like length.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	     * @example
	     *
	     * _.isLength(3);
	     * // => true
	     *
	     * _.isLength(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isLength(Infinity);
	     * // => false
	     *
	     * _.isLength('3');
	     * // => false
	     */
	    function isLength(value) {
	      return typeof value == 'number' &&
	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is the
	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	     * @example
	     *
	     * _.isObject({});
	     * // => true
	     *
	     * _.isObject([1, 2, 3]);
	     * // => true
	     *
	     * _.isObject(_.noop);
	     * // => true
	     *
	     * _.isObject(null);
	     * // => false
	     */
	    function isObject(value) {
	      var type = typeof value;
	      return value != null && (type == 'object' || type == 'function');
	    }

	    /**
	     * Checks if `value` is object-like. A value is object-like if it's not `null`
	     * and has a `typeof` result of "object".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	     * @example
	     *
	     * _.isObjectLike({});
	     * // => true
	     *
	     * _.isObjectLike([1, 2, 3]);
	     * // => true
	     *
	     * _.isObjectLike(_.noop);
	     * // => false
	     *
	     * _.isObjectLike(null);
	     * // => false
	     */
	    function isObjectLike(value) {
	      return value != null && typeof value == 'object';
	    }

	    /**
	     * Checks if `value` is classified as a `Map` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
	     * @example
	     *
	     * _.isMap(new Map);
	     * // => true
	     *
	     * _.isMap(new WeakMap);
	     * // => false
	     */
	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

	    /**
	     * Performs a partial deep comparison between `object` and `source` to
	     * determine if `object` contains equivalent property values.
	     *
	     * **Note:** This method is equivalent to `_.matches` when `source` is
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2 };
	     *
	     * _.isMatch(object, { 'b': 2 });
	     * // => true
	     *
	     * _.isMatch(object, { 'b': 1 });
	     * // => false
	     */
	    function isMatch(object, source) {
	      return object === source || baseIsMatch(object, source, getMatchData(source));
	    }

	    /**
	     * This method is like `_.isMatch` except that it accepts `customizer` which
	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
	     * are handled by the method instead. The `customizer` is invoked with five
	     * arguments: (objValue, srcValue, index|key, object, source).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {Object} object The object to inspect.
	     * @param {Object} source The object of property values to match.
	     * @param {Function} [customizer] The function to customize comparisons.
	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
	     * @example
	     *
	     * function isGreeting(value) {
	     *   return /^h(?:i|ello)$/.test(value);
	     * }
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
	     *     return true;
	     *   }
	     * }
	     *
	     * var object = { 'greeting': 'hello' };
	     * var source = { 'greeting': 'hi' };
	     *
	     * _.isMatchWith(object, source, customizer);
	     * // => true
	     */
	    function isMatchWith(object, source, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return baseIsMatch(object, source, getMatchData(source), customizer);
	    }

	    /**
	     * Checks if `value` is `NaN`.
	     *
	     * **Note:** This method is based on
	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
	     * `undefined` and other non-number values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
	     * @example
	     *
	     * _.isNaN(NaN);
	     * // => true
	     *
	     * _.isNaN(new Number(NaN));
	     * // => true
	     *
	     * isNaN(undefined);
	     * // => true
	     *
	     * _.isNaN(undefined);
	     * // => false
	     */
	    function isNaN(value) {
	      // An `NaN` primitive is the only value that is not equal to itself.
	      // Perform the `toStringTag` check first to avoid errors with some
	      // ActiveX objects in IE.
	      return isNumber(value) && value != +value;
	    }

	    /**
	     * Checks if `value` is a pristine native function.
	     *
	     * **Note:** This method can't reliably detect native functions in the presence
	     * of the core-js package because core-js circumvents this kind of detection.
	     * Despite multiple requests, the core-js maintainer has made it clear: any
	     * attempt to fix the detection will be obstructed. As a result, we're left
	     * with little choice but to throw an error. Unfortunately, this also affects
	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
	     * which rely on core-js.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a native function,
	     *  else `false`.
	     * @example
	     *
	     * _.isNative(Array.prototype.push);
	     * // => true
	     *
	     * _.isNative(_);
	     * // => false
	     */
	    function isNative(value) {
	      if (isMaskable(value)) {
	        throw new Error(CORE_ERROR_TEXT);
	      }
	      return baseIsNative(value);
	    }

	    /**
	     * Checks if `value` is `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
	     * @example
	     *
	     * _.isNull(null);
	     * // => true
	     *
	     * _.isNull(void 0);
	     * // => false
	     */
	    function isNull(value) {
	      return value === null;
	    }

	    /**
	     * Checks if `value` is `null` or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
	     * @example
	     *
	     * _.isNil(null);
	     * // => true
	     *
	     * _.isNil(void 0);
	     * // => true
	     *
	     * _.isNil(NaN);
	     * // => false
	     */
	    function isNil(value) {
	      return value == null;
	    }

	    /**
	     * Checks if `value` is classified as a `Number` primitive or object.
	     *
	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
	     * classified as numbers, use the `_.isFinite` method.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
	     * @example
	     *
	     * _.isNumber(3);
	     * // => true
	     *
	     * _.isNumber(Number.MIN_VALUE);
	     * // => true
	     *
	     * _.isNumber(Infinity);
	     * // => true
	     *
	     * _.isNumber('3');
	     * // => false
	     */
	    function isNumber(value) {
	      return typeof value == 'number' ||
	        (isObjectLike(value) && baseGetTag(value) == numberTag);
	    }

	    /**
	     * Checks if `value` is a plain object, that is, an object created by the
	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.8.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * _.isPlainObject(new Foo);
	     * // => false
	     *
	     * _.isPlainObject([1, 2, 3]);
	     * // => false
	     *
	     * _.isPlainObject({ 'x': 0, 'y': 0 });
	     * // => true
	     *
	     * _.isPlainObject(Object.create(null));
	     * // => true
	     */
	    function isPlainObject(value) {
	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
	        return false;
	      }
	      var proto = getPrototype(value);
	      if (proto === null) {
	        return true;
	      }
	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
	        funcToString.call(Ctor) == objectCtorString;
	    }

	    /**
	     * Checks if `value` is classified as a `RegExp` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.1.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
	     * @example
	     *
	     * _.isRegExp(/abc/);
	     * // => true
	     *
	     * _.isRegExp('/abc/');
	     * // => false
	     */
	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

	    /**
	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
	     * double precision number which isn't the result of a rounded unsafe integer.
	     *
	     * **Note:** This method is based on
	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
	     * @example
	     *
	     * _.isSafeInteger(3);
	     * // => true
	     *
	     * _.isSafeInteger(Number.MIN_VALUE);
	     * // => false
	     *
	     * _.isSafeInteger(Infinity);
	     * // => false
	     *
	     * _.isSafeInteger('3');
	     * // => false
	     */
	    function isSafeInteger(value) {
	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
	    }

	    /**
	     * Checks if `value` is classified as a `Set` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
	     * @example
	     *
	     * _.isSet(new Set);
	     * // => true
	     *
	     * _.isSet(new WeakSet);
	     * // => false
	     */
	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

	    /**
	     * Checks if `value` is classified as a `String` primitive or object.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
	     * @example
	     *
	     * _.isString('abc');
	     * // => true
	     *
	     * _.isString(1);
	     * // => false
	     */
	    function isString(value) {
	      return typeof value == 'string' ||
	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
	    }

	    /**
	     * Checks if `value` is classified as a `Symbol` primitive or object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
	     * @example
	     *
	     * _.isSymbol(Symbol.iterator);
	     * // => true
	     *
	     * _.isSymbol('abc');
	     * // => false
	     */
	    function isSymbol(value) {
	      return typeof value == 'symbol' ||
	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
	    }

	    /**
	     * Checks if `value` is classified as a typed array.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
	     * @example
	     *
	     * _.isTypedArray(new Uint8Array);
	     * // => true
	     *
	     * _.isTypedArray([]);
	     * // => false
	     */
	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

	    /**
	     * Checks if `value` is `undefined`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
	     * @example
	     *
	     * _.isUndefined(void 0);
	     * // => true
	     *
	     * _.isUndefined(null);
	     * // => false
	     */
	    function isUndefined(value) {
	      return value === undefined;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakMap` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
	     * @example
	     *
	     * _.isWeakMap(new WeakMap);
	     * // => true
	     *
	     * _.isWeakMap(new Map);
	     * // => false
	     */
	    function isWeakMap(value) {
	      return isObjectLike(value) && getTag(value) == weakMapTag;
	    }

	    /**
	     * Checks if `value` is classified as a `WeakSet` object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.3.0
	     * @category Lang
	     * @param {*} value The value to check.
	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
	     * @example
	     *
	     * _.isWeakSet(new WeakSet);
	     * // => true
	     *
	     * _.isWeakSet(new Set);
	     * // => false
	     */
	    function isWeakSet(value) {
	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
	    }

	    /**
	     * Checks if `value` is less than `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than `other`,
	     *  else `false`.
	     * @see _.gt
	     * @example
	     *
	     * _.lt(1, 3);
	     * // => true
	     *
	     * _.lt(3, 3);
	     * // => false
	     *
	     * _.lt(3, 1);
	     * // => false
	     */
	    var lt = createRelationalOperation(baseLt);

	    /**
	     * Checks if `value` is less than or equal to `other`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.9.0
	     * @category Lang
	     * @param {*} value The value to compare.
	     * @param {*} other The other value to compare.
	     * @returns {boolean} Returns `true` if `value` is less than or equal to
	     *  `other`, else `false`.
	     * @see _.gte
	     * @example
	     *
	     * _.lte(1, 3);
	     * // => true
	     *
	     * _.lte(3, 3);
	     * // => true
	     *
	     * _.lte(3, 1);
	     * // => false
	     */
	    var lte = createRelationalOperation(function(value, other) {
	      return value <= other;
	    });

	    /**
	     * Converts `value` to an array.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the converted array.
	     * @example
	     *
	     * _.toArray({ 'a': 1, 'b': 2 });
	     * // => [1, 2]
	     *
	     * _.toArray('abc');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toArray(1);
	     * // => []
	     *
	     * _.toArray(null);
	     * // => []
	     */
	    function toArray(value) {
	      if (!value) {
	        return [];
	      }
	      if (isArrayLike(value)) {
	        return isString(value) ? stringToArray(value) : copyArray(value);
	      }
	      if (symIterator && value[symIterator]) {
	        return iteratorToArray(value[symIterator]());
	      }
	      var tag = getTag(value),
	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

	      return func(value);
	    }

	    /**
	     * Converts `value` to a finite number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.12.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted number.
	     * @example
	     *
	     * _.toFinite(3.2);
	     * // => 3.2
	     *
	     * _.toFinite(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toFinite(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toFinite('3.2');
	     * // => 3.2
	     */
	    function toFinite(value) {
	      if (!value) {
	        return value === 0 ? value : 0;
	      }
	      value = toNumber(value);
	      if (value === INFINITY || value === -INFINITY) {
	        var sign = (value < 0 ? -1 : 1);
	        return sign * MAX_INTEGER;
	      }
	      return value === value ? value : 0;
	    }

	    /**
	     * Converts `value` to an integer.
	     *
	     * **Note:** This method is loosely based on
	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toInteger(3.2);
	     * // => 3
	     *
	     * _.toInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toInteger(Infinity);
	     * // => 1.7976931348623157e+308
	     *
	     * _.toInteger('3.2');
	     * // => 3
	     */
	    function toInteger(value) {
	      var result = toFinite(value),
	          remainder = result % 1;

	      return result === result ? (remainder ? result - remainder : result) : 0;
	    }

	    /**
	     * Converts `value` to an integer suitable for use as the length of an
	     * array-like object.
	     *
	     * **Note:** This method is based on
	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toLength(3.2);
	     * // => 3
	     *
	     * _.toLength(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toLength(Infinity);
	     * // => 4294967295
	     *
	     * _.toLength('3.2');
	     * // => 3
	     */
	    function toLength(value) {
	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
	    }

	    /**
	     * Converts `value` to a number.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to process.
	     * @returns {number} Returns the number.
	     * @example
	     *
	     * _.toNumber(3.2);
	     * // => 3.2
	     *
	     * _.toNumber(Number.MIN_VALUE);
	     * // => 5e-324
	     *
	     * _.toNumber(Infinity);
	     * // => Infinity
	     *
	     * _.toNumber('3.2');
	     * // => 3.2
	     */
	    function toNumber(value) {
	      if (typeof value == 'number') {
	        return value;
	      }
	      if (isSymbol(value)) {
	        return NAN;
	      }
	      if (isObject(value)) {
	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
	        value = isObject(other) ? (other + '') : other;
	      }
	      if (typeof value != 'string') {
	        return value === 0 ? value : +value;
	      }
	      value = value.replace(reTrim, '');
	      var isBinary = reIsBinary.test(value);
	      return (isBinary || reIsOctal.test(value))
	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
	        : (reIsBadHex.test(value) ? NAN : +value);
	    }

	    /**
	     * Converts `value` to a plain object flattening inherited enumerable string
	     * keyed properties of `value` to own properties of the plain object.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {Object} Returns the converted plain object.
	     * @example
	     *
	     * function Foo() {
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.assign({ 'a': 1 }, new Foo);
	     * // => { 'a': 1, 'b': 2 }
	     *
	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
	     * // => { 'a': 1, 'b': 2, 'c': 3 }
	     */
	    function toPlainObject(value) {
	      return copyObject(value, keysIn(value));
	    }

	    /**
	     * Converts `value` to a safe integer. A safe integer can be compared and
	     * represented correctly.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.toSafeInteger(3.2);
	     * // => 3
	     *
	     * _.toSafeInteger(Number.MIN_VALUE);
	     * // => 0
	     *
	     * _.toSafeInteger(Infinity);
	     * // => 9007199254740991
	     *
	     * _.toSafeInteger('3.2');
	     * // => 3
	     */
	    function toSafeInteger(value) {
	      return value
	        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
	        : (value === 0 ? value : 0);
	    }

	    /**
	     * Converts `value` to a string. An empty string is returned for `null`
	     * and `undefined` values. The sign of `-0` is preserved.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Lang
	     * @param {*} value The value to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.toString(null);
	     * // => ''
	     *
	     * _.toString(-0);
	     * // => '-0'
	     *
	     * _.toString([1, 2, 3]);
	     * // => '1,2,3'
	     */
	    function toString(value) {
	      return value == null ? '' : baseToString(value);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Assigns own enumerable string keyed properties of source objects to the
	     * destination object. Source objects are applied from left to right.
	     * Subsequent sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object` and is loosely based on
	     * [`Object.assign`](https://mdn.io/Object/assign).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assignIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assign({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var assign = createAssigner(function(object, source) {
	      if (isPrototype(source) || isArrayLike(source)) {
	        copyObject(source, keys(source), object);
	        return;
	      }
	      for (var key in source) {
	        if (hasOwnProperty.call(source, key)) {
	          assignValue(object, key, source[key]);
	        }
	      }
	    });

	    /**
	     * This method is like `_.assign` except that it iterates over own and
	     * inherited source properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extend
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.assign
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     * }
	     *
	     * function Bar() {
	     *   this.c = 3;
	     * }
	     *
	     * Foo.prototype.b = 2;
	     * Bar.prototype.d = 4;
	     *
	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
	     */
	    var assignIn = createAssigner(function(object, source) {
	      copyObject(source, keysIn(source), object);
	    });

	    /**
	     * This method is like `_.assignIn` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias extendWith
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignInWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keysIn(source), object, customizer);
	    });

	    /**
	     * This method is like `_.assign` except that it accepts `customizer`
	     * which is invoked to produce the assigned values. If `customizer` returns
	     * `undefined`, assignment is handled by the method instead. The `customizer`
	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @see _.assignInWith
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   return _.isUndefined(objValue) ? srcValue : objValue;
	     * }
	     *
	     * var defaults = _.partialRight(_.assignWith, customizer);
	     *
	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
	      copyObject(source, keys(source), object, customizer);
	    });

	    /**
	     * Creates an array of values corresponding to `paths` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Array} Returns the picked values.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
	     *
	     * _.at(object, ['a[0].b.c', 'a[1]']);
	     * // => [3, 4]
	     */
	    var at = flatRest(baseAt);

	    /**
	     * Creates an object that inherits from the `prototype` object. If a
	     * `properties` object is given, its own enumerable string keyed properties
	     * are assigned to the created object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Object
	     * @param {Object} prototype The object to inherit from.
	     * @param {Object} [properties] The properties to assign to the object.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * function Shape() {
	     *   this.x = 0;
	     *   this.y = 0;
	     * }
	     *
	     * function Circle() {
	     *   Shape.call(this);
	     * }
	     *
	     * Circle.prototype = _.create(Shape.prototype, {
	     *   'constructor': Circle
	     * });
	     *
	     * var circle = new Circle;
	     * circle instanceof Circle;
	     * // => true
	     *
	     * circle instanceof Shape;
	     * // => true
	     */
	    function create(prototype, properties) {
	      var result = baseCreate(prototype);
	      return properties == null ? result : baseAssign(result, properties);
	    }

	    /**
	     * Assigns own and inherited enumerable string keyed properties of source
	     * objects to the destination object for all destination properties that
	     * resolve to `undefined`. Source objects are applied from left to right.
	     * Once a property is set, additional values of the same property are ignored.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaultsDeep
	     * @example
	     *
	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
	     * // => { 'a': 1, 'b': 2 }
	     */
	    var defaults = baseRest(function(args) {
	      args.push(undefined, customDefaultsAssignIn);
	      return apply(assignInWith, undefined, args);
	    });

	    /**
	     * This method is like `_.defaults` except that it recursively assigns
	     * default properties.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @see _.defaults
	     * @example
	     *
	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
	     * // => { 'a': { 'b': 2, 'c': 3 } }
	     */
	    var defaultsDeep = baseRest(function(args) {
	      args.push(undefined, customDefaultsMerge);
	      return apply(mergeWith, undefined, args);
	    });

	    /**
	     * This method is like `_.find` except that it returns the key of the first
	     * element `predicate` returns truthy for instead of the element itself.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findKey(users, function(o) { return o.age < 40; });
	     * // => 'barney' (iteration order is not guaranteed)
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findKey(users, { 'age': 1, 'active': true });
	     * // => 'pebbles'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findKey(users, 'active');
	     * // => 'barney'
	     */
	    function findKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
	    }

	    /**
	     * This method is like `_.findKey` except that it iterates over elements of
	     * a collection in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
	     * @returns {string|undefined} Returns the key of the matched element,
	     *  else `undefined`.
	     * @example
	     *
	     * var users = {
	     *   'barney':  { 'age': 36, 'active': true },
	     *   'fred':    { 'age': 40, 'active': false },
	     *   'pebbles': { 'age': 1,  'active': true }
	     * };
	     *
	     * _.findLastKey(users, function(o) { return o.age < 40; });
	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.findLastKey(users, { 'age': 36, 'active': true });
	     * // => 'barney'
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.findLastKey(users, ['active', false]);
	     * // => 'fred'
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.findLastKey(users, 'active');
	     * // => 'pebbles'
	     */
	    function findLastKey(object, predicate) {
	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
	    }

	    /**
	     * Iterates over own and inherited enumerable string keyed properties of an
	     * object and invokes `iteratee` for each property. The iteratee is invoked
	     * with three arguments: (value, key, object). Iteratee functions may exit
	     * iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forInRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forIn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
	     */
	    function forIn(object, iteratee) {
	      return object == null
	        ? object
	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * This method is like `_.forIn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forInRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
	     */
	    function forInRight(object, iteratee) {
	      return object == null
	        ? object
	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
	    }

	    /**
	     * Iterates over own enumerable string keyed properties of an object and
	     * invokes `iteratee` for each property. The iteratee is invoked with three
	     * arguments: (value, key, object). Iteratee functions may exit iteration
	     * early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwnRight
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwn(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
	     */
	    function forOwn(object, iteratee) {
	      return object && baseForOwn(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * This method is like `_.forOwn` except that it iterates over properties of
	     * `object` in the opposite order.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.0.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns `object`.
	     * @see _.forOwn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.forOwnRight(new Foo, function(value, key) {
	     *   console.log(key);
	     * });
	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
	     */
	    function forOwnRight(object, iteratee) {
	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
	    }

	    /**
	     * Creates an array of function property names from own enumerable properties
	     * of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functionsIn
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functions(new Foo);
	     * // => ['a', 'b']
	     */
	    function functions(object) {
	      return object == null ? [] : baseFunctions(object, keys(object));
	    }

	    /**
	     * Creates an array of function property names from own and inherited
	     * enumerable properties of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to inspect.
	     * @returns {Array} Returns the function names.
	     * @see _.functions
	     * @example
	     *
	     * function Foo() {
	     *   this.a = _.constant('a');
	     *   this.b = _.constant('b');
	     * }
	     *
	     * Foo.prototype.c = _.constant('c');
	     *
	     * _.functionsIn(new Foo);
	     * // => ['a', 'b', 'c']
	     */
	    function functionsIn(object) {
	      return object == null ? [] : baseFunctions(object, keysIn(object));
	    }

	    /**
	     * Gets the value at `path` of `object`. If the resolved value is
	     * `undefined`, the `defaultValue` is returned in its place.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.get(object, 'a[0].b.c');
	     * // => 3
	     *
	     * _.get(object, ['a', '0', 'b', 'c']);
	     * // => 3
	     *
	     * _.get(object, 'a.b.c', 'default');
	     * // => 'default'
	     */
	    function get(object, path, defaultValue) {
	      var result = object == null ? undefined : baseGet(object, path);
	      return result === undefined ? defaultValue : result;
	    }

	    /**
	     * Checks if `path` is a direct property of `object`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = { 'a': { 'b': 2 } };
	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.has(object, 'a');
	     * // => true
	     *
	     * _.has(object, 'a.b');
	     * // => true
	     *
	     * _.has(object, ['a', 'b']);
	     * // => true
	     *
	     * _.has(other, 'a');
	     * // => false
	     */
	    function has(object, path) {
	      return object != null && hasPath(object, path, baseHas);
	    }

	    /**
	     * Checks if `path` is a direct or inherited property of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path to check.
	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
	     * @example
	     *
	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
	     *
	     * _.hasIn(object, 'a');
	     * // => true
	     *
	     * _.hasIn(object, 'a.b');
	     * // => true
	     *
	     * _.hasIn(object, ['a', 'b']);
	     * // => true
	     *
	     * _.hasIn(object, 'b');
	     * // => false
	     */
	    function hasIn(object, path) {
	      return object != null && hasPath(object, path, baseHasIn);
	    }

	    /**
	     * Creates an object composed of the inverted keys and values of `object`.
	     * If `object` contains duplicate values, subsequent values overwrite
	     * property assignments of previous values.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invert(object);
	     * // => { '1': 'c', '2': 'b' }
	     */
	    var invert = createInverter(function(result, value, key) {
	      result[value] = key;
	    }, constant(identity));

	    /**
	     * This method is like `_.invert` except that the inverted object is generated
	     * from the results of running each element of `object` thru `iteratee`. The
	     * corresponding inverted value of each inverted key is an array of keys
	     * responsible for generating the inverted value. The iteratee is invoked
	     * with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.1.0
	     * @category Object
	     * @param {Object} object The object to invert.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {Object} Returns the new inverted object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
	     *
	     * _.invertBy(object);
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     *
	     * _.invertBy(object, function(value) {
	     *   return 'group' + value;
	     * });
	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
	     */
	    var invertBy = createInverter(function(result, value, key) {
	      if (hasOwnProperty.call(result, value)) {
	        result[value].push(key);
	      } else {
	        result[value] = [key];
	      }
	    }, getIteratee);

	    /**
	     * Invokes the method at `path` of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {*} Returns the result of the invoked method.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
	     *
	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
	     * // => [2, 3]
	     */
	    var invoke = baseRest(baseInvoke);

	    /**
	     * Creates an array of the own enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects. See the
	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
	     * for more details.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keys(new Foo);
	     * // => ['a', 'b'] (iteration order is not guaranteed)
	     *
	     * _.keys('hi');
	     * // => ['0', '1']
	     */
	    function keys(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
	    }

	    /**
	     * Creates an array of the own and inherited enumerable property names of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property names.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.keysIn(new Foo);
	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
	     */
	    function keysIn(object) {
	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
	    }

	    /**
	     * The opposite of `_.mapValues`; this method creates an object with the
	     * same values as `object` and keys generated by running each own enumerable
	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
	     * with three arguments: (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.8.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapValues
	     * @example
	     *
	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
	     *   return key + value;
	     * });
	     * // => { 'a1': 1, 'b2': 2 }
	     */
	    function mapKeys(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, iteratee(value, key, object), value);
	      });
	      return result;
	    }

	    /**
	     * Creates an object with the same keys as `object` and values generated
	     * by running each own enumerable string keyed property of `object` thru
	     * `iteratee`. The iteratee is invoked with three arguments:
	     * (value, key, object).
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Object} Returns the new mapped object.
	     * @see _.mapKeys
	     * @example
	     *
	     * var users = {
	     *   'fred':    { 'user': 'fred',    'age': 40 },
	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
	     * };
	     *
	     * _.mapValues(users, function(o) { return o.age; });
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.mapValues(users, 'age');
	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
	     */
	    function mapValues(object, iteratee) {
	      var result = {};
	      iteratee = getIteratee(iteratee, 3);

	      baseForOwn(object, function(value, key, object) {
	        baseAssignValue(result, key, iteratee(value, key, object));
	      });
	      return result;
	    }

	    /**
	     * This method is like `_.assign` except that it recursively merges own and
	     * inherited enumerable string keyed properties of source objects into the
	     * destination object. Source properties that resolve to `undefined` are
	     * skipped if a destination value exists. Array and plain object properties
	     * are merged recursively. Other objects and value types are overridden by
	     * assignment. Source objects are applied from left to right. Subsequent
	     * sources overwrite property assignments of previous sources.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.5.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} [sources] The source objects.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {
	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
	     * };
	     *
	     * var other = {
	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
	     * };
	     *
	     * _.merge(object, other);
	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
	     */
	    var merge = createAssigner(function(object, source, srcIndex) {
	      baseMerge(object, source, srcIndex);
	    });

	    /**
	     * This method is like `_.merge` except that it accepts `customizer` which
	     * is invoked to produce the merged values of the destination and source
	     * properties. If `customizer` returns `undefined`, merging is handled by the
	     * method instead. The `customizer` is invoked with six arguments:
	     * (objValue, srcValue, key, object, source, stack).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The destination object.
	     * @param {...Object} sources The source objects.
	     * @param {Function} customizer The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * function customizer(objValue, srcValue) {
	     *   if (_.isArray(objValue)) {
	     *     return objValue.concat(srcValue);
	     *   }
	     * }
	     *
	     * var object = { 'a': [1], 'b': [2] };
	     * var other = { 'a': [3], 'b': [4] };
	     *
	     * _.mergeWith(object, other, customizer);
	     * // => { 'a': [1, 3], 'b': [2, 4] }
	     */
	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
	      baseMerge(object, source, srcIndex, customizer);
	    });

	    /**
	     * The opposite of `_.pick`; this method creates an object composed of the
	     * own and inherited enumerable property paths of `object` that are not omitted.
	     *
	     * **Note:** This method is considerably slower than `_.pick`.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to omit.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omit(object, ['a', 'c']);
	     * // => { 'b': '2' }
	     */
	    var omit = flatRest(function(object, paths) {
	      var result = {};
	      if (object == null) {
	        return result;
	      }
	      var isDeep = false;
	      paths = arrayMap(paths, function(path) {
	        path = castPath(path, object);
	        isDeep || (isDeep = path.length > 1);
	        return path;
	      });
	      copyObject(object, getAllKeysIn(object), result);
	      if (isDeep) {
	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
	      }
	      var length = paths.length;
	      while (length--) {
	        baseUnset(result, paths[length]);
	      }
	      return result;
	    });

	    /**
	     * The opposite of `_.pickBy`; this method creates an object composed of
	     * the own and inherited enumerable string keyed properties of `object` that
	     * `predicate` doesn't return truthy for. The predicate is invoked with two
	     * arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.omitBy(object, _.isNumber);
	     * // => { 'b': '2' }
	     */
	    function omitBy(object, predicate) {
	      return pickBy(object, negate(getIteratee(predicate)));
	    }

	    /**
	     * Creates an object composed of the picked `object` properties.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {...(string|string[])} [paths] The property paths to pick.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pick(object, ['a', 'c']);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    var pick = flatRest(function(object, paths) {
	      return object == null ? {} : basePick(object, paths);
	    });

	    /**
	     * Creates an object composed of the `object` properties `predicate` returns
	     * truthy for. The predicate is invoked with two arguments: (value, key).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The source object.
	     * @param {Function} [predicate=_.identity] The function invoked per property.
	     * @returns {Object} Returns the new object.
	     * @example
	     *
	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
	     *
	     * _.pickBy(object, _.isNumber);
	     * // => { 'a': 1, 'c': 3 }
	     */
	    function pickBy(object, predicate) {
	      if (object == null) {
	        return {};
	      }
	      var props = arrayMap(getAllKeysIn(object), function(prop) {
	        return [prop];
	      });
	      predicate = getIteratee(predicate);
	      return basePickBy(object, props, function(value, path) {
	        return predicate(value, path[0]);
	      });
	    }

	    /**
	     * This method is like `_.get` except that if the resolved value is a
	     * function it's invoked with the `this` binding of its parent object and
	     * its result is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @param {Array|string} path The path of the property to resolve.
	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
	     *
	     * _.result(object, 'a[0].b.c1');
	     * // => 3
	     *
	     * _.result(object, 'a[0].b.c2');
	     * // => 4
	     *
	     * _.result(object, 'a[0].b.c3', 'default');
	     * // => 'default'
	     *
	     * _.result(object, 'a[0].b.c3', _.constant('default'));
	     * // => 'default'
	     */
	    function result(object, path, defaultValue) {
	      path = castPath(path, object);

	      var index = -1,
	          length = path.length;

	      // Ensure the loop is entered when path is empty.
	      if (!length) {
	        length = 1;
	        object = undefined;
	      }
	      while (++index < length) {
	        var value = object == null ? undefined : object[toKey(path[index])];
	        if (value === undefined) {
	          index = length;
	          value = defaultValue;
	        }
	        object = isFunction(value) ? value.call(object) : value;
	      }
	      return object;
	    }

	    /**
	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
	     * it's created. Arrays are created for missing index properties while objects
	     * are created for all other missing properties. Use `_.setWith` to customize
	     * `path` creation.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.set(object, 'a[0].b.c', 4);
	     * console.log(object.a[0].b.c);
	     * // => 4
	     *
	     * _.set(object, ['x', '0', 'y', 'z'], 5);
	     * console.log(object.x[0].y.z);
	     * // => 5
	     */
	    function set(object, path, value) {
	      return object == null ? object : baseSet(object, path, value);
	    }

	    /**
	     * This method is like `_.set` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {*} value The value to set.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.setWith(object, '[0][1]', 'a', Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function setWith(object, path, value, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseSet(object, path, value, customizer);
	    }

	    /**
	     * Creates an array of own enumerable string keyed-value pairs for `object`
	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
	     * entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entries
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairs(new Foo);
	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
	     */
	    var toPairs = createToPairs(keys);

	    /**
	     * Creates an array of own and inherited enumerable string keyed-value pairs
	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
	     * or set, its entries are returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @alias entriesIn
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the key-value pairs.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.toPairsIn(new Foo);
	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
	     */
	    var toPairsIn = createToPairs(keysIn);

	    /**
	     * An alternative to `_.reduce`; this method transforms `object` to a new
	     * `accumulator` object which is the result of running each of its own
	     * enumerable string keyed properties thru `iteratee`, with each invocation
	     * potentially mutating the `accumulator` object. If `accumulator` is not
	     * provided, a new object with the same `[[Prototype]]` will be used. The
	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
	     * Iteratee functions may exit iteration early by explicitly returning `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.3.0
	     * @category Object
	     * @param {Object} object The object to iterate over.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @param {*} [accumulator] The custom accumulator value.
	     * @returns {*} Returns the accumulated value.
	     * @example
	     *
	     * _.transform([2, 3, 4], function(result, n) {
	     *   result.push(n *= n);
	     *   return n % 2 == 0;
	     * }, []);
	     * // => [4, 9]
	     *
	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
	     *   (result[value] || (result[value] = [])).push(key);
	     * }, {});
	     * // => { '1': ['a', 'c'], '2': ['b'] }
	     */
	    function transform(object, iteratee, accumulator) {
	      var isArr = isArray(object),
	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

	      iteratee = getIteratee(iteratee, 4);
	      if (accumulator == null) {
	        var Ctor = object && object.constructor;
	        if (isArrLike) {
	          accumulator = isArr ? new Ctor : [];
	        }
	        else if (isObject(object)) {
	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
	        }
	        else {
	          accumulator = {};
	        }
	      }
	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
	        return iteratee(accumulator, value, index, object);
	      });
	      return accumulator;
	    }

	    /**
	     * Removes the property at `path` of `object`.
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to unset.
	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
	     * _.unset(object, 'a[0].b.c');
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     *
	     * _.unset(object, ['a', '0', 'b', 'c']);
	     * // => true
	     *
	     * console.log(object);
	     * // => { 'a': [{ 'b': {} }] };
	     */
	    function unset(object, path) {
	      return object == null ? true : baseUnset(object, path);
	    }

	    /**
	     * This method is like `_.set` except that accepts `updater` to produce the
	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
	     * is invoked with one argument: (value).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
	     *
	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
	     * console.log(object.a[0].b.c);
	     * // => 9
	     *
	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
	     * console.log(object.x[0].y.z);
	     * // => 0
	     */
	    function update(object, path, updater) {
	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
	    }

	    /**
	     * This method is like `_.update` except that it accepts `customizer` which is
	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
	     * path creation is handled by the method instead. The `customizer` is invoked
	     * with three arguments: (nsValue, key, nsObject).
	     *
	     * **Note:** This method mutates `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.6.0
	     * @category Object
	     * @param {Object} object The object to modify.
	     * @param {Array|string} path The path of the property to set.
	     * @param {Function} updater The function to produce the updated value.
	     * @param {Function} [customizer] The function to customize assigned values.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var object = {};
	     *
	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
	     * // => { '0': { '1': 'a' } }
	     */
	    function updateWith(object, path, updater, customizer) {
	      customizer = typeof customizer == 'function' ? customizer : undefined;
	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
	    }

	    /**
	     * Creates an array of the own enumerable string keyed property values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.values(new Foo);
	     * // => [1, 2] (iteration order is not guaranteed)
	     *
	     * _.values('hi');
	     * // => ['h', 'i']
	     */
	    function values(object) {
	      return object == null ? [] : baseValues(object, keys(object));
	    }

	    /**
	     * Creates an array of the own and inherited enumerable string keyed property
	     * values of `object`.
	     *
	     * **Note:** Non-object values are coerced to objects.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Object
	     * @param {Object} object The object to query.
	     * @returns {Array} Returns the array of property values.
	     * @example
	     *
	     * function Foo() {
	     *   this.a = 1;
	     *   this.b = 2;
	     * }
	     *
	     * Foo.prototype.c = 3;
	     *
	     * _.valuesIn(new Foo);
	     * // => [1, 2, 3] (iteration order is not guaranteed)
	     */
	    function valuesIn(object) {
	      return object == null ? [] : baseValues(object, keysIn(object));
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Number
	     * @param {number} number The number to clamp.
	     * @param {number} [lower] The lower bound.
	     * @param {number} upper The upper bound.
	     * @returns {number} Returns the clamped number.
	     * @example
	     *
	     * _.clamp(-10, -5, 5);
	     * // => -5
	     *
	     * _.clamp(10, -5, 5);
	     * // => 5
	     */
	    function clamp(number, lower, upper) {
	      if (upper === undefined) {
	        upper = lower;
	        lower = undefined;
	      }
	      if (upper !== undefined) {
	        upper = toNumber(upper);
	        upper = upper === upper ? upper : 0;
	      }
	      if (lower !== undefined) {
	        lower = toNumber(lower);
	        lower = lower === lower ? lower : 0;
	      }
	      return baseClamp(toNumber(number), lower, upper);
	    }

	    /**
	     * Checks if `n` is between `start` and up to, but not including, `end`. If
	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
	     * If `start` is greater than `end` the params are swapped to support
	     * negative ranges.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.3.0
	     * @category Number
	     * @param {number} number The number to check.
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
	     * @see _.range, _.rangeRight
	     * @example
	     *
	     * _.inRange(3, 2, 4);
	     * // => true
	     *
	     * _.inRange(4, 8);
	     * // => true
	     *
	     * _.inRange(4, 2);
	     * // => false
	     *
	     * _.inRange(2, 2);
	     * // => false
	     *
	     * _.inRange(1.2, 2);
	     * // => true
	     *
	     * _.inRange(5.2, 4);
	     * // => false
	     *
	     * _.inRange(-3, -2, -6);
	     * // => true
	     */
	    function inRange(number, start, end) {
	      start = toFinite(start);
	      if (end === undefined) {
	        end = start;
	        start = 0;
	      } else {
	        end = toFinite(end);
	      }
	      number = toNumber(number);
	      return baseInRange(number, start, end);
	    }

	    /**
	     * Produces a random number between the inclusive `lower` and `upper` bounds.
	     * If only one argument is provided a number between `0` and the given number
	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
	     * floats, a floating-point number is returned instead of an integer.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @memberOf _
	     * @since 0.7.0
	     * @category Number
	     * @param {number} [lower=0] The lower bound.
	     * @param {number} [upper=1] The upper bound.
	     * @param {boolean} [floating] Specify returning a floating-point number.
	     * @returns {number} Returns the random number.
	     * @example
	     *
	     * _.random(0, 5);
	     * // => an integer between 0 and 5
	     *
	     * _.random(5);
	     * // => also an integer between 0 and 5
	     *
	     * _.random(5, true);
	     * // => a floating-point number between 0 and 5
	     *
	     * _.random(1.2, 5.2);
	     * // => a floating-point number between 1.2 and 5.2
	     */
	    function random(lower, upper, floating) {
	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
	        upper = floating = undefined;
	      }
	      if (floating === undefined) {
	        if (typeof upper == 'boolean') {
	          floating = upper;
	          upper = undefined;
	        }
	        else if (typeof lower == 'boolean') {
	          floating = lower;
	          lower = undefined;
	        }
	      }
	      if (lower === undefined && upper === undefined) {
	        lower = 0;
	        upper = 1;
	      }
	      else {
	        lower = toFinite(lower);
	        if (upper === undefined) {
	          upper = lower;
	          lower = 0;
	        } else {
	          upper = toFinite(upper);
	        }
	      }
	      if (lower > upper) {
	        var temp = lower;
	        lower = upper;
	        upper = temp;
	      }
	      if (floating || lower % 1 || upper % 1) {
	        var rand = nativeRandom();
	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
	      }
	      return baseRandom(lower, upper);
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the camel cased string.
	     * @example
	     *
	     * _.camelCase('Foo Bar');
	     * // => 'fooBar'
	     *
	     * _.camelCase('--foo-bar--');
	     * // => 'fooBar'
	     *
	     * _.camelCase('__FOO_BAR__');
	     * // => 'fooBar'
	     */
	    var camelCase = createCompounder(function(result, word, index) {
	      word = word.toLowerCase();
	      return result + (index ? capitalize(word) : word);
	    });

	    /**
	     * Converts the first character of `string` to upper case and the remaining
	     * to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to capitalize.
	     * @returns {string} Returns the capitalized string.
	     * @example
	     *
	     * _.capitalize('FRED');
	     * // => 'Fred'
	     */
	    function capitalize(string) {
	      return upperFirst(toString(string).toLowerCase());
	    }

	    /**
	     * Deburrs `string` by converting
	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
	     * letters to basic Latin letters and removing
	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to deburr.
	     * @returns {string} Returns the deburred string.
	     * @example
	     *
	     * _.deburr('déjà vu');
	     * // => 'deja vu'
	     */
	    function deburr(string) {
	      string = toString(string);
	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
	    }

	    /**
	     * Checks if `string` ends with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=string.length] The position to search up to.
	     * @returns {boolean} Returns `true` if `string` ends with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.endsWith('abc', 'c');
	     * // => true
	     *
	     * _.endsWith('abc', 'b');
	     * // => false
	     *
	     * _.endsWith('abc', 'b', 2);
	     * // => true
	     */
	    function endsWith(string, target, position) {
	      string = toString(string);
	      target = baseToString(target);

	      var length = string.length;
	      position = position === undefined
	        ? length
	        : baseClamp(toInteger(position), 0, length);

	      var end = position;
	      position -= target.length;
	      return position >= 0 && string.slice(position, end) == target;
	    }

	    /**
	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
	     * corresponding HTML entities.
	     *
	     * **Note:** No other characters are escaped. To escape additional
	     * characters use a third-party library like [_he_](https://mths.be/he).
	     *
	     * Though the ">" character is escaped for symmetry, characters like
	     * ">" and "/" don't need escaping in HTML and have no special meaning
	     * unless they're part of a tag or unquoted attribute value. See
	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
	     * (under "semi-related fun fact") for more details.
	     *
	     * When working with HTML you should always
	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
	     * XSS vectors.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escape('fred, barney, & pebbles');
	     * // => 'fred, barney, &amp; pebbles'
	     */
	    function escape(string) {
	      string = toString(string);
	      return (string && reHasUnescapedHtml.test(string))
	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
	        : string;
	    }

	    /**
	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to escape.
	     * @returns {string} Returns the escaped string.
	     * @example
	     *
	     * _.escapeRegExp('[lodash](https://lodash.com/)');
	     * // => '\[lodash\]\(https://lodash\.com/\)'
	     */
	    function escapeRegExp(string) {
	      string = toString(string);
	      return (string && reHasRegExpChar.test(string))
	        ? string.replace(reRegExpChar, '\\$&')
	        : string;
	    }

	    /**
	     * Converts `string` to
	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the kebab cased string.
	     * @example
	     *
	     * _.kebabCase('Foo Bar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('fooBar');
	     * // => 'foo-bar'
	     *
	     * _.kebabCase('__FOO_BAR__');
	     * // => 'foo-bar'
	     */
	    var kebabCase = createCompounder(function(result, word, index) {
	      return result + (index ? '-' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts `string`, as space separated words, to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.lowerCase('--Foo-Bar--');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('fooBar');
	     * // => 'foo bar'
	     *
	     * _.lowerCase('__FOO_BAR__');
	     * // => 'foo bar'
	     */
	    var lowerCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toLowerCase();
	    });

	    /**
	     * Converts the first character of `string` to lower case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.lowerFirst('Fred');
	     * // => 'fred'
	     *
	     * _.lowerFirst('FRED');
	     * // => 'fRED'
	     */
	    var lowerFirst = createCaseFirst('toLowerCase');

	    /**
	     * Pads `string` on the left and right sides if it's shorter than `length`.
	     * Padding characters are truncated if they can't be evenly divided by `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.pad('abc', 8);
	     * // => '  abc   '
	     *
	     * _.pad('abc', 8, '_-');
	     * // => '_-abc_-_'
	     *
	     * _.pad('abc', 3);
	     * // => 'abc'
	     */
	    function pad(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      if (!length || strLength >= length) {
	        return string;
	      }
	      var mid = (length - strLength) / 2;
	      return (
	        createPadding(nativeFloor(mid), chars) +
	        string +
	        createPadding(nativeCeil(mid), chars)
	      );
	    }

	    /**
	     * Pads `string` on the right side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padEnd('abc', 6);
	     * // => 'abc   '
	     *
	     * _.padEnd('abc', 6, '_-');
	     * // => 'abc_-_'
	     *
	     * _.padEnd('abc', 3);
	     * // => 'abc'
	     */
	    function padEnd(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (string + createPadding(length - strLength, chars))
	        : string;
	    }

	    /**
	     * Pads `string` on the left side if it's shorter than `length`. Padding
	     * characters are truncated if they exceed `length`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to pad.
	     * @param {number} [length=0] The padding length.
	     * @param {string} [chars=' '] The string used as padding.
	     * @returns {string} Returns the padded string.
	     * @example
	     *
	     * _.padStart('abc', 6);
	     * // => '   abc'
	     *
	     * _.padStart('abc', 6, '_-');
	     * // => '_-_abc'
	     *
	     * _.padStart('abc', 3);
	     * // => 'abc'
	     */
	    function padStart(string, length, chars) {
	      string = toString(string);
	      length = toInteger(length);

	      var strLength = length ? stringSize(string) : 0;
	      return (length && strLength < length)
	        ? (createPadding(length - strLength, chars) + string)
	        : string;
	    }

	    /**
	     * Converts `string` to an integer of the specified radix. If `radix` is
	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
	     * hexadecimal, in which case a `radix` of `16` is used.
	     *
	     * **Note:** This method aligns with the
	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
	     *
	     * @static
	     * @memberOf _
	     * @since 1.1.0
	     * @category String
	     * @param {string} string The string to convert.
	     * @param {number} [radix=10] The radix to interpret `value` by.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {number} Returns the converted integer.
	     * @example
	     *
	     * _.parseInt('08');
	     * // => 8
	     *
	     * _.map(['6', '08', '10'], _.parseInt);
	     * // => [6, 8, 10]
	     */
	    function parseInt(string, radix, guard) {
	      if (guard || radix == null) {
	        radix = 0;
	      } else if (radix) {
	        radix = +radix;
	      }
	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
	    }

	    /**
	     * Repeats the given string `n` times.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to repeat.
	     * @param {number} [n=1] The number of times to repeat the string.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the repeated string.
	     * @example
	     *
	     * _.repeat('*', 3);
	     * // => '***'
	     *
	     * _.repeat('abc', 2);
	     * // => 'abcabc'
	     *
	     * _.repeat('abc', 0);
	     * // => ''
	     */
	    function repeat(string, n, guard) {
	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
	        n = 1;
	      } else {
	        n = toInteger(n);
	      }
	      return baseRepeat(toString(string), n);
	    }

	    /**
	     * Replaces matches for `pattern` in `string` with `replacement`.
	     *
	     * **Note:** This method is based on
	     * [`String#replace`](https://mdn.io/String/replace).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to modify.
	     * @param {RegExp|string} pattern The pattern to replace.
	     * @param {Function|string} replacement The match replacement.
	     * @returns {string} Returns the modified string.
	     * @example
	     *
	     * _.replace('Hi Fred', 'Fred', 'Barney');
	     * // => 'Hi Barney'
	     */
	    function replace() {
	      var args = arguments,
	          string = toString(args[0]);

	      return args.length < 3 ? string : string.replace(args[1], args[2]);
	    }

	    /**
	     * Converts `string` to
	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the snake cased string.
	     * @example
	     *
	     * _.snakeCase('Foo Bar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('fooBar');
	     * // => 'foo_bar'
	     *
	     * _.snakeCase('--FOO-BAR--');
	     * // => 'foo_bar'
	     */
	    var snakeCase = createCompounder(function(result, word, index) {
	      return result + (index ? '_' : '') + word.toLowerCase();
	    });

	    /**
	     * Splits `string` by `separator`.
	     *
	     * **Note:** This method is based on
	     * [`String#split`](https://mdn.io/String/split).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to split.
	     * @param {RegExp|string} separator The separator pattern to split by.
	     * @param {number} [limit] The length to truncate results to.
	     * @returns {Array} Returns the string segments.
	     * @example
	     *
	     * _.split('a-b-c', '-', 2);
	     * // => ['a', 'b']
	     */
	    function split(string, separator, limit) {
	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
	        separator = limit = undefined;
	      }
	      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
	      if (!limit) {
	        return [];
	      }
	      string = toString(string);
	      if (string && (
	            typeof separator == 'string' ||
	            (separator != null && !isRegExp(separator))
	          )) {
	        separator = baseToString(separator);
	        if (!separator && hasUnicode(string)) {
	          return castSlice(stringToArray(string), 0, limit);
	        }
	      }
	      return string.split(separator, limit);
	    }

	    /**
	     * Converts `string` to
	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
	     *
	     * @static
	     * @memberOf _
	     * @since 3.1.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the start cased string.
	     * @example
	     *
	     * _.startCase('--foo-bar--');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('fooBar');
	     * // => 'Foo Bar'
	     *
	     * _.startCase('__FOO_BAR__');
	     * // => 'FOO BAR'
	     */
	    var startCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + upperFirst(word);
	    });

	    /**
	     * Checks if `string` starts with the given target string.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {string} [target] The string to search for.
	     * @param {number} [position=0] The position to search from.
	     * @returns {boolean} Returns `true` if `string` starts with `target`,
	     *  else `false`.
	     * @example
	     *
	     * _.startsWith('abc', 'a');
	     * // => true
	     *
	     * _.startsWith('abc', 'b');
	     * // => false
	     *
	     * _.startsWith('abc', 'b', 1);
	     * // => true
	     */
	    function startsWith(string, target, position) {
	      string = toString(string);
	      position = position == null
	        ? 0
	        : baseClamp(toInteger(position), 0, string.length);

	      target = baseToString(target);
	      return string.slice(position, position + target.length) == target;
	    }

	    /**
	     * Creates a compiled template function that can interpolate data properties
	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
	     * properties may be accessed as free variables in the template. If a setting
	     * object is given, it takes precedence over `_.templateSettings` values.
	     *
	     * **Note:** In the development build `_.template` utilizes
	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
	     * for easier debugging.
	     *
	     * For more information on precompiling templates see
	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
	     *
	     * For more information on Chrome extension sandboxes see
	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category String
	     * @param {string} [string=''] The template string.
	     * @param {Object} [options={}] The options object.
	     * @param {RegExp} [options.escape=_.templateSettings.escape]
	     *  The HTML "escape" delimiter.
	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
	     *  The "evaluate" delimiter.
	     * @param {Object} [options.imports=_.templateSettings.imports]
	     *  An object to import into the template as free variables.
	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
	     *  The "interpolate" delimiter.
	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
	     *  The sourceURL of the compiled template.
	     * @param {string} [options.variable='obj']
	     *  The data object variable name.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Function} Returns the compiled template function.
	     * @example
	     *
	     * // Use the "interpolate" delimiter to create a compiled template.
	     * var compiled = _.template('hello <%= user %>!');
	     * compiled({ 'user': 'fred' });
	     * // => 'hello fred!'
	     *
	     * // Use the HTML "escape" delimiter to escape data property values.
	     * var compiled = _.template('<b><%- value %></b>');
	     * compiled({ 'value': '<script>' });
	     * // => '<b>&lt;script&gt;</b>'
	     *
	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the internal `print` function in "evaluate" delimiters.
	     * var compiled = _.template('<% print("hello " + user); %>!');
	     * compiled({ 'user': 'barney' });
	     * // => 'hello barney!'
	     *
	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
	     * // Disable support by replacing the "interpolate" delimiter.
	     * var compiled = _.template('hello ${ user }!');
	     * compiled({ 'user': 'pebbles' });
	     * // => 'hello pebbles!'
	     *
	     * // Use backslashes to treat delimiters as plain text.
	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
	     * compiled({ 'value': 'ignored' });
	     * // => '<%- value %>'
	     *
	     * // Use the `imports` option to import `jQuery` as `jq`.
	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
	     * compiled({ 'users': ['fred', 'barney'] });
	     * // => '<li>fred</li><li>barney</li>'
	     *
	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
	     * compiled(data);
	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
	     *
	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
	     * compiled.source;
	     * // => function(data) {
	     * //   var __t, __p = '';
	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
	     * //   return __p;
	     * // }
	     *
	     * // Use custom template delimiters.
	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
	     * var compiled = _.template('hello {{ user }}!');
	     * compiled({ 'user': 'mustache' });
	     * // => 'hello mustache!'
	     *
	     * // Use the `source` property to inline compiled templates for meaningful
	     * // line numbers in error messages and stack traces.
	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
	     *   var JST = {\
	     *     "main": ' + _.template(mainText).source + '\
	     *   };\
	     * ');
	     */
	    function template(string, options, guard) {
	      // Based on John Resig's `tmpl` implementation
	      // (http://ejohn.org/blog/javascript-micro-templating/)
	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
	      var settings = lodash.templateSettings;

	      if (guard && isIterateeCall(string, options, guard)) {
	        options = undefined;
	      }
	      string = toString(string);
	      options = assignInWith({}, options, settings, customDefaultsAssignIn);

	      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
	          importsKeys = keys(imports),
	          importsValues = baseValues(imports, importsKeys);

	      var isEscaping,
	          isEvaluating,
	          index = 0,
	          interpolate = options.interpolate || reNoMatch,
	          source = "__p += '";

	      // Compile the regexp to match each delimiter.
	      var reDelimiters = RegExp(
	        (options.escape || reNoMatch).source + '|' +
	        interpolate.source + '|' +
	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
	        (options.evaluate || reNoMatch).source + '|$'
	      , 'g');

	      // Use a sourceURL for easier debugging.
	      var sourceURL = '//# sourceURL=' +
	        ('sourceURL' in options
	          ? options.sourceURL
	          : ('lodash.templateSources[' + (++templateCounter) + ']')
	        ) + '\n';

	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
	        interpolateValue || (interpolateValue = esTemplateValue);

	        // Escape characters that can't be included in string literals.
	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

	        // Replace delimiters with snippets.
	        if (escapeValue) {
	          isEscaping = true;
	          source += "' +\n__e(" + escapeValue + ") +\n'";
	        }
	        if (evaluateValue) {
	          isEvaluating = true;
	          source += "';\n" + evaluateValue + ";\n__p += '";
	        }
	        if (interpolateValue) {
	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
	        }
	        index = offset + match.length;

	        // The JS engine embedded in Adobe products needs `match` returned in
	        // order to produce the correct `offset` value.
	        return match;
	      });

	      source += "';\n";

	      // If `variable` is not specified wrap a with-statement around the generated
	      // code to add the data object to the top of the scope chain.
	      var variable = options.variable;
	      if (!variable) {
	        source = 'with (obj) {\n' + source + '\n}\n';
	      }
	      // Cleanup code by stripping empty strings.
	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
	        .replace(reEmptyStringMiddle, '$1')
	        .replace(reEmptyStringTrailing, '$1;');

	      // Frame code as the function body.
	      source = 'function(' + (variable || 'obj') + ') {\n' +
	        (variable
	          ? ''
	          : 'obj || (obj = {});\n'
	        ) +
	        "var __t, __p = ''" +
	        (isEscaping
	           ? ', __e = _.escape'
	           : ''
	        ) +
	        (isEvaluating
	          ? ', __j = Array.prototype.join;\n' +
	            "function print() { __p += __j.call(arguments, '') }\n"
	          : ';\n'
	        ) +
	        source +
	        'return __p\n}';

	      var result = attempt(function() {
	        return Function(importsKeys, sourceURL + 'return ' + source)
	          .apply(undefined, importsValues);
	      });

	      // Provide the compiled function's source by its `toString` method or
	      // the `source` property as a convenience for inlining compiled templates.
	      result.source = source;
	      if (isError(result)) {
	        throw result;
	      }
	      return result;
	    }

	    /**
	     * Converts `string`, as a whole, to lower case just like
	     * [String#toLowerCase](https://mdn.io/toLowerCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the lower cased string.
	     * @example
	     *
	     * _.toLower('--Foo-Bar--');
	     * // => '--foo-bar--'
	     *
	     * _.toLower('fooBar');
	     * // => 'foobar'
	     *
	     * _.toLower('__FOO_BAR__');
	     * // => '__foo_bar__'
	     */
	    function toLower(value) {
	      return toString(value).toLowerCase();
	    }

	    /**
	     * Converts `string`, as a whole, to upper case just like
	     * [String#toUpperCase](https://mdn.io/toUpperCase).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.toUpper('--foo-bar--');
	     * // => '--FOO-BAR--'
	     *
	     * _.toUpper('fooBar');
	     * // => 'FOOBAR'
	     *
	     * _.toUpper('__foo_bar__');
	     * // => '__FOO_BAR__'
	     */
	    function toUpper(value) {
	      return toString(value).toUpperCase();
	    }

	    /**
	     * Removes leading and trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trim('  abc  ');
	     * // => 'abc'
	     *
	     * _.trim('-_-abc-_-', '_-');
	     * // => 'abc'
	     *
	     * _.map(['  foo  ', '  bar  '], _.trim);
	     * // => ['foo', 'bar']
	     */
	    function trim(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrim, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          chrSymbols = stringToArray(chars),
	          start = charsStartIndex(strSymbols, chrSymbols),
	          end = charsEndIndex(strSymbols, chrSymbols) + 1;

	      return castSlice(strSymbols, start, end).join('');
	    }

	    /**
	     * Removes trailing whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimEnd('  abc  ');
	     * // => '  abc'
	     *
	     * _.trimEnd('-_-abc-_-', '_-');
	     * // => '-_-abc'
	     */
	    function trimEnd(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimEnd, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

	      return castSlice(strSymbols, 0, end).join('');
	    }

	    /**
	     * Removes leading whitespace or specified characters from `string`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to trim.
	     * @param {string} [chars=whitespace] The characters to trim.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {string} Returns the trimmed string.
	     * @example
	     *
	     * _.trimStart('  abc  ');
	     * // => 'abc  '
	     *
	     * _.trimStart('-_-abc-_-', '_-');
	     * // => 'abc-_-'
	     */
	    function trimStart(string, chars, guard) {
	      string = toString(string);
	      if (string && (guard || chars === undefined)) {
	        return string.replace(reTrimStart, '');
	      }
	      if (!string || !(chars = baseToString(chars))) {
	        return string;
	      }
	      var strSymbols = stringToArray(string),
	          start = charsStartIndex(strSymbols, stringToArray(chars));

	      return castSlice(strSymbols, start).join('');
	    }

	    /**
	     * Truncates `string` if it's longer than the given maximum string length.
	     * The last characters of the truncated string are replaced with the omission
	     * string which defaults to "...".
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to truncate.
	     * @param {Object} [options={}] The options object.
	     * @param {number} [options.length=30] The maximum string length.
	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
	     * @returns {string} Returns the truncated string.
	     * @example
	     *
	     * _.truncate('hi-diddly-ho there, neighborino');
	     * // => 'hi-diddly-ho there, neighbo...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': ' '
	     * });
	     * // => 'hi-diddly-ho there,...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'length': 24,
	     *   'separator': /,? +/
	     * });
	     * // => 'hi-diddly-ho there...'
	     *
	     * _.truncate('hi-diddly-ho there, neighborino', {
	     *   'omission': ' [...]'
	     * });
	     * // => 'hi-diddly-ho there, neig [...]'
	     */
	    function truncate(string, options) {
	      var length = DEFAULT_TRUNC_LENGTH,
	          omission = DEFAULT_TRUNC_OMISSION;

	      if (isObject(options)) {
	        var separator = 'separator' in options ? options.separator : separator;
	        length = 'length' in options ? toInteger(options.length) : length;
	        omission = 'omission' in options ? baseToString(options.omission) : omission;
	      }
	      string = toString(string);

	      var strLength = string.length;
	      if (hasUnicode(string)) {
	        var strSymbols = stringToArray(string);
	        strLength = strSymbols.length;
	      }
	      if (length >= strLength) {
	        return string;
	      }
	      var end = length - stringSize(omission);
	      if (end < 1) {
	        return omission;
	      }
	      var result = strSymbols
	        ? castSlice(strSymbols, 0, end).join('')
	        : string.slice(0, end);

	      if (separator === undefined) {
	        return result + omission;
	      }
	      if (strSymbols) {
	        end += (result.length - end);
	      }
	      if (isRegExp(separator)) {
	        if (string.slice(end).search(separator)) {
	          var match,
	              substring = result;

	          if (!separator.global) {
	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
	          }
	          separator.lastIndex = 0;
	          while ((match = separator.exec(substring))) {
	            var newEnd = match.index;
	          }
	          result = result.slice(0, newEnd === undefined ? end : newEnd);
	        }
	      } else if (string.indexOf(baseToString(separator), end) != end) {
	        var index = result.lastIndexOf(separator);
	        if (index > -1) {
	          result = result.slice(0, index);
	        }
	      }
	      return result + omission;
	    }

	    /**
	     * The inverse of `_.escape`; this method converts the HTML entities
	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
	     * their corresponding characters.
	     *
	     * **Note:** No other HTML entities are unescaped. To unescape additional
	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
	     *
	     * @static
	     * @memberOf _
	     * @since 0.6.0
	     * @category String
	     * @param {string} [string=''] The string to unescape.
	     * @returns {string} Returns the unescaped string.
	     * @example
	     *
	     * _.unescape('fred, barney, &amp; pebbles');
	     * // => 'fred, barney, & pebbles'
	     */
	    function unescape(string) {
	      string = toString(string);
	      return (string && reHasEscapedHtml.test(string))
	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
	        : string;
	    }

	    /**
	     * Converts `string`, as space separated words, to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the upper cased string.
	     * @example
	     *
	     * _.upperCase('--foo-bar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('fooBar');
	     * // => 'FOO BAR'
	     *
	     * _.upperCase('__foo_bar__');
	     * // => 'FOO BAR'
	     */
	    var upperCase = createCompounder(function(result, word, index) {
	      return result + (index ? ' ' : '') + word.toUpperCase();
	    });

	    /**
	     * Converts the first character of `string` to upper case.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category String
	     * @param {string} [string=''] The string to convert.
	     * @returns {string} Returns the converted string.
	     * @example
	     *
	     * _.upperFirst('fred');
	     * // => 'Fred'
	     *
	     * _.upperFirst('FRED');
	     * // => 'FRED'
	     */
	    var upperFirst = createCaseFirst('toUpperCase');

	    /**
	     * Splits `string` into an array of its words.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category String
	     * @param {string} [string=''] The string to inspect.
	     * @param {RegExp|string} [pattern] The pattern to match words.
	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
	     * @returns {Array} Returns the words of `string`.
	     * @example
	     *
	     * _.words('fred, barney, & pebbles');
	     * // => ['fred', 'barney', 'pebbles']
	     *
	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
	     * // => ['fred', 'barney', '&', 'pebbles']
	     */
	    function words(string, pattern, guard) {
	      string = toString(string);
	      pattern = guard ? undefined : pattern;

	      if (pattern === undefined) {
	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
	      }
	      return string.match(pattern) || [];
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Attempts to invoke `func`, returning either the result or the caught error
	     * object. Any additional arguments are provided to `func` when it's invoked.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Function} func The function to attempt.
	     * @param {...*} [args] The arguments to invoke `func` with.
	     * @returns {*} Returns the `func` result or error object.
	     * @example
	     *
	     * // Avoid throwing errors for invalid selectors.
	     * var elements = _.attempt(function(selector) {
	     *   return document.querySelectorAll(selector);
	     * }, '>_>');
	     *
	     * if (_.isError(elements)) {
	     *   elements = [];
	     * }
	     */
	    var attempt = baseRest(function(func, args) {
	      try {
	        return apply(func, undefined, args);
	      } catch (e) {
	        return isError(e) ? e : new Error(e);
	      }
	    });

	    /**
	     * Binds methods of an object to the object itself, overwriting the existing
	     * method.
	     *
	     * **Note:** This method doesn't set the "length" property of bound functions.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Object} object The object to bind and assign the bound methods to.
	     * @param {...(string|string[])} methodNames The object method names to bind.
	     * @returns {Object} Returns `object`.
	     * @example
	     *
	     * var view = {
	     *   'label': 'docs',
	     *   'click': function() {
	     *     console.log('clicked ' + this.label);
	     *   }
	     * };
	     *
	     * _.bindAll(view, ['click']);
	     * jQuery(element).on('click', view.click);
	     * // => Logs 'clicked docs' when clicked.
	     */
	    var bindAll = flatRest(function(object, methodNames) {
	      arrayEach(methodNames, function(key) {
	        key = toKey(key);
	        baseAssignValue(object, key, bind(object[key], object));
	      });
	      return object;
	    });

	    /**
	     * Creates a function that iterates over `pairs` and invokes the corresponding
	     * function of the first predicate to return truthy. The predicate-function
	     * pairs are invoked with the `this` binding and arguments of the created
	     * function.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Array} pairs The predicate-function pairs.
	     * @returns {Function} Returns the new composite function.
	     * @example
	     *
	     * var func = _.cond([
	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
	     *   [_.stubTrue,                      _.constant('no match')]
	     * ]);
	     *
	     * func({ 'a': 1, 'b': 2 });
	     * // => 'matches A'
	     *
	     * func({ 'a': 0, 'b': 1 });
	     * // => 'matches B'
	     *
	     * func({ 'a': '1', 'b': '2' });
	     * // => 'no match'
	     */
	    function cond(pairs) {
	      var length = pairs == null ? 0 : pairs.length,
	          toIteratee = getIteratee();

	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
	        if (typeof pair[1] != 'function') {
	          throw new TypeError(FUNC_ERROR_TEXT);
	        }
	        return [toIteratee(pair[0]), pair[1]];
	      });

	      return baseRest(function(args) {
	        var index = -1;
	        while (++index < length) {
	          var pair = pairs[index];
	          if (apply(pair[0], this, args)) {
	            return apply(pair[1], this, args);
	          }
	        }
	      });
	    }

	    /**
	     * Creates a function that invokes the predicate properties of `source` with
	     * the corresponding property values of a given object, returning `true` if
	     * all predicates return truthy, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.conformsTo` with
	     * `source` partially applied.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {Object} source The object of property predicates to conform to.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 2, 'b': 1 },
	     *   { 'a': 1, 'b': 2 }
	     * ];
	     *
	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
	     * // => [{ 'a': 1, 'b': 2 }]
	     */
	    function conforms(source) {
	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that returns `value`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {*} value The value to return from the new function.
	     * @returns {Function} Returns the new constant function.
	     * @example
	     *
	     * var objects = _.times(2, _.constant({ 'a': 1 }));
	     *
	     * console.log(objects);
	     * // => [{ 'a': 1 }, { 'a': 1 }]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => true
	     */
	    function constant(value) {
	      return function() {
	        return value;
	      };
	    }

	    /**
	     * Checks `value` to determine whether a default value should be returned in
	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
	     * or `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.14.0
	     * @category Util
	     * @param {*} value The value to check.
	     * @param {*} defaultValue The default value.
	     * @returns {*} Returns the resolved value.
	     * @example
	     *
	     * _.defaultTo(1, 10);
	     * // => 1
	     *
	     * _.defaultTo(undefined, 10);
	     * // => 10
	     */
	    function defaultTo(value, defaultValue) {
	      return (value == null || value !== value) ? defaultValue : value;
	    }

	    /**
	     * Creates a function that returns the result of invoking the given functions
	     * with the `this` binding of the created function, where each successive
	     * invocation is supplied the return value of the previous.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flowRight
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flow([_.add, square]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flow = createFlow();

	    /**
	     * This method is like `_.flow` except that it creates a function that
	     * invokes the given functions from right to left.
	     *
	     * @static
	     * @since 3.0.0
	     * @memberOf _
	     * @category Util
	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
	     * @returns {Function} Returns the new composite function.
	     * @see _.flow
	     * @example
	     *
	     * function square(n) {
	     *   return n * n;
	     * }
	     *
	     * var addSquare = _.flowRight([square, _.add]);
	     * addSquare(1, 2);
	     * // => 9
	     */
	    var flowRight = createFlow(true);

	    /**
	     * This method returns the first argument it receives.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {*} value Any value.
	     * @returns {*} Returns `value`.
	     * @example
	     *
	     * var object = { 'a': 1 };
	     *
	     * console.log(_.identity(object) === object);
	     * // => true
	     */
	    function identity(value) {
	      return value;
	    }

	    /**
	     * Creates a function that invokes `func` with the arguments of the created
	     * function. If `func` is a property name, the created function returns the
	     * property value for a given element. If `func` is an array or object, the
	     * created function returns `true` for elements that contain the equivalent
	     * source properties, otherwise it returns `false`.
	     *
	     * @static
	     * @since 4.0.0
	     * @memberOf _
	     * @category Util
	     * @param {*} [func=_.identity] The value to convert to a callback.
	     * @returns {Function} Returns the callback.
	     * @example
	     *
	     * var users = [
	     *   { 'user': 'barney', 'age': 36, 'active': true },
	     *   { 'user': 'fred',   'age': 40, 'active': false }
	     * ];
	     *
	     * // The `_.matches` iteratee shorthand.
	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
	     *
	     * // The `_.matchesProperty` iteratee shorthand.
	     * _.filter(users, _.iteratee(['user', 'fred']));
	     * // => [{ 'user': 'fred', 'age': 40 }]
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.map(users, _.iteratee('user'));
	     * // => ['barney', 'fred']
	     *
	     * // Create custom iteratee shorthands.
	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
	     *     return func.test(string);
	     *   };
	     * });
	     *
	     * _.filter(['abc', 'def'], /ef/);
	     * // => ['def']
	     */
	    function iteratee(func) {
	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between a given
	     * object and `source`, returning `true` if the given object has equivalent
	     * property values, else `false`.
	     *
	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
	     * partially applied.
	     *
	     * Partial comparisons will match empty array and empty object `source`
	     * values against any array or object value, respectively. See `_.isEqual`
	     * for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} source The object of property values to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
	     */
	    function matches(source) {
	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that performs a partial deep comparison between the
	     * value at `path` of a given object to `srcValue`, returning `true` if the
	     * object value is equivalent, else `false`.
	     *
	     * **Note:** Partial comparisons will match empty array and empty object
	     * `srcValue` values against any array or object value, respectively. See
	     * `_.isEqual` for a list of supported value comparisons.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.2.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @param {*} srcValue The value to match.
	     * @returns {Function} Returns the new spec function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': 1, 'b': 2, 'c': 3 },
	     *   { 'a': 4, 'b': 5, 'c': 6 }
	     * ];
	     *
	     * _.find(objects, _.matchesProperty('a', 4));
	     * // => { 'a': 4, 'b': 5, 'c': 6 }
	     */
	    function matchesProperty(path, srcValue) {
	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
	    }

	    /**
	     * Creates a function that invokes the method at `path` of a given object.
	     * Any additional arguments are provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Array|string} path The path of the method to invoke.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': _.constant(2) } },
	     *   { 'a': { 'b': _.constant(1) } }
	     * ];
	     *
	     * _.map(objects, _.method('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(objects, _.method(['a', 'b']));
	     * // => [2, 1]
	     */
	    var method = baseRest(function(path, args) {
	      return function(object) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * The opposite of `_.method`; this method creates a function that invokes
	     * the method at a given path of `object`. Any additional arguments are
	     * provided to the invoked method.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.7.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @param {...*} [args] The arguments to invoke the method with.
	     * @returns {Function} Returns the new invoker function.
	     * @example
	     *
	     * var array = _.times(3, _.constant),
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
	     * // => [2, 0]
	     */
	    var methodOf = baseRest(function(object, args) {
	      return function(path) {
	        return baseInvoke(object, path, args);
	      };
	    });

	    /**
	     * Adds all own enumerable string keyed function properties of a source
	     * object to the destination object. If `object` is a function, then methods
	     * are added to its prototype as well.
	     *
	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
	     * avoid conflicts caused by modifying the original.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {Function|Object} [object=lodash] The destination object.
	     * @param {Object} source The object of functions to add.
	     * @param {Object} [options={}] The options object.
	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
	     * @returns {Function|Object} Returns `object`.
	     * @example
	     *
	     * function vowels(string) {
	     *   return _.filter(string, function(v) {
	     *     return /[aeiou]/i.test(v);
	     *   });
	     * }
	     *
	     * _.mixin({ 'vowels': vowels });
	     * _.vowels('fred');
	     * // => ['e']
	     *
	     * _('fred').vowels().value();
	     * // => ['e']
	     *
	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
	     * _('fred').vowels();
	     * // => ['e']
	     */
	    function mixin(object, source, options) {
	      var props = keys(source),
	          methodNames = baseFunctions(source, props);

	      if (options == null &&
	          !(isObject(source) && (methodNames.length || !props.length))) {
	        options = source;
	        source = object;
	        object = this;
	        methodNames = baseFunctions(source, keys(source));
	      }
	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
	          isFunc = isFunction(object);

	      arrayEach(methodNames, function(methodName) {
	        var func = source[methodName];
	        object[methodName] = func;
	        if (isFunc) {
	          object.prototype[methodName] = function() {
	            var chainAll = this.__chain__;
	            if (chain || chainAll) {
	              var result = object(this.__wrapped__),
	                  actions = result.__actions__ = copyArray(this.__actions__);

	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
	              result.__chain__ = chainAll;
	              return result;
	            }
	            return func.apply(object, arrayPush([this.value()], arguments));
	          };
	        }
	      });

	      return object;
	    }

	    /**
	     * Reverts the `_` variable to its previous value and returns a reference to
	     * the `lodash` function.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @returns {Function} Returns the `lodash` function.
	     * @example
	     *
	     * var lodash = _.noConflict();
	     */
	    function noConflict() {
	      if (root._ === this) {
	        root._ = oldDash;
	      }
	      return this;
	    }

	    /**
	     * This method returns `undefined`.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.3.0
	     * @category Util
	     * @example
	     *
	     * _.times(2, _.noop);
	     * // => [undefined, undefined]
	     */
	    function noop() {
	      // No operation performed.
	    }

	    /**
	     * Creates a function that gets the argument at index `n`. If `n` is negative,
	     * the nth argument from the end is returned.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [n=0] The index of the argument to return.
	     * @returns {Function} Returns the new pass-thru function.
	     * @example
	     *
	     * var func = _.nthArg(1);
	     * func('a', 'b', 'c', 'd');
	     * // => 'b'
	     *
	     * var func = _.nthArg(-2);
	     * func('a', 'b', 'c', 'd');
	     * // => 'c'
	     */
	    function nthArg(n) {
	      n = toInteger(n);
	      return baseRest(function(args) {
	        return baseNth(args, n);
	      });
	    }

	    /**
	     * Creates a function that invokes `iteratees` with the arguments it receives
	     * and returns their results.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
	     *  The iteratees to invoke.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.over([Math.max, Math.min]);
	     *
	     * func(1, 2, 3, 4);
	     * // => [4, 1]
	     */
	    var over = createOver(arrayMap);

	    /**
	     * Creates a function that checks if **all** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overEvery([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => false
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overEvery = createOver(arrayEvery);

	    /**
	     * Creates a function that checks if **any** of the `predicates` return
	     * truthy when invoked with the arguments it receives.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {...(Function|Function[])} [predicates=[_.identity]]
	     *  The predicates to check.
	     * @returns {Function} Returns the new function.
	     * @example
	     *
	     * var func = _.overSome([Boolean, isFinite]);
	     *
	     * func('1');
	     * // => true
	     *
	     * func(null);
	     * // => true
	     *
	     * func(NaN);
	     * // => false
	     */
	    var overSome = createOver(arraySome);

	    /**
	     * Creates a function that returns the value at `path` of a given object.
	     *
	     * @static
	     * @memberOf _
	     * @since 2.4.0
	     * @category Util
	     * @param {Array|string} path The path of the property to get.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var objects = [
	     *   { 'a': { 'b': 2 } },
	     *   { 'a': { 'b': 1 } }
	     * ];
	     *
	     * _.map(objects, _.property('a.b'));
	     * // => [2, 1]
	     *
	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
	     * // => [1, 2]
	     */
	    function property(path) {
	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
	    }

	    /**
	     * The opposite of `_.property`; this method creates a function that returns
	     * the value at a given path of `object`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.0.0
	     * @category Util
	     * @param {Object} object The object to query.
	     * @returns {Function} Returns the new accessor function.
	     * @example
	     *
	     * var array = [0, 1, 2],
	     *     object = { 'a': array, 'b': array, 'c': array };
	     *
	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
	     * // => [2, 0]
	     *
	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
	     * // => [2, 0]
	     */
	    function propertyOf(object) {
	      return function(path) {
	        return object == null ? undefined : baseGet(object, path);
	      };
	    }

	    /**
	     * Creates an array of numbers (positive and/or negative) progressing from
	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
	     * `start` is specified without an `end` or `step`. If `end` is not specified,
	     * it's set to `start` with `start` then set to `0`.
	     *
	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
	     * floating-point values which can produce unexpected results.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.rangeRight
	     * @example
	     *
	     * _.range(4);
	     * // => [0, 1, 2, 3]
	     *
	     * _.range(-4);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 5);
	     * // => [1, 2, 3, 4]
	     *
	     * _.range(0, 20, 5);
	     * // => [0, 5, 10, 15]
	     *
	     * _.range(0, -4, -1);
	     * // => [0, -1, -2, -3]
	     *
	     * _.range(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.range(0);
	     * // => []
	     */
	    var range = createRange();

	    /**
	     * This method is like `_.range` except that it populates values in
	     * descending order.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {number} [start=0] The start of the range.
	     * @param {number} end The end of the range.
	     * @param {number} [step=1] The value to increment or decrement by.
	     * @returns {Array} Returns the range of numbers.
	     * @see _.inRange, _.range
	     * @example
	     *
	     * _.rangeRight(4);
	     * // => [3, 2, 1, 0]
	     *
	     * _.rangeRight(-4);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 5);
	     * // => [4, 3, 2, 1]
	     *
	     * _.rangeRight(0, 20, 5);
	     * // => [15, 10, 5, 0]
	     *
	     * _.rangeRight(0, -4, -1);
	     * // => [-3, -2, -1, 0]
	     *
	     * _.rangeRight(1, 4, 0);
	     * // => [1, 1, 1]
	     *
	     * _.rangeRight(0);
	     * // => []
	     */
	    var rangeRight = createRange(true);

	    /**
	     * This method returns a new empty array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Array} Returns the new empty array.
	     * @example
	     *
	     * var arrays = _.times(2, _.stubArray);
	     *
	     * console.log(arrays);
	     * // => [[], []]
	     *
	     * console.log(arrays[0] === arrays[1]);
	     * // => false
	     */
	    function stubArray() {
	      return [];
	    }

	    /**
	     * This method returns `false`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `false`.
	     * @example
	     *
	     * _.times(2, _.stubFalse);
	     * // => [false, false]
	     */
	    function stubFalse() {
	      return false;
	    }

	    /**
	     * This method returns a new empty object.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {Object} Returns the new empty object.
	     * @example
	     *
	     * var objects = _.times(2, _.stubObject);
	     *
	     * console.log(objects);
	     * // => [{}, {}]
	     *
	     * console.log(objects[0] === objects[1]);
	     * // => false
	     */
	    function stubObject() {
	      return {};
	    }

	    /**
	     * This method returns an empty string.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {string} Returns the empty string.
	     * @example
	     *
	     * _.times(2, _.stubString);
	     * // => ['', '']
	     */
	    function stubString() {
	      return '';
	    }

	    /**
	     * This method returns `true`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.13.0
	     * @category Util
	     * @returns {boolean} Returns `true`.
	     * @example
	     *
	     * _.times(2, _.stubTrue);
	     * // => [true, true]
	     */
	    function stubTrue() {
	      return true;
	    }

	    /**
	     * Invokes the iteratee `n` times, returning an array of the results of
	     * each invocation. The iteratee is invoked with one argument; (index).
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {number} n The number of times to invoke `iteratee`.
	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
	     * @returns {Array} Returns the array of results.
	     * @example
	     *
	     * _.times(3, String);
	     * // => ['0', '1', '2']
	     *
	     *  _.times(4, _.constant(0));
	     * // => [0, 0, 0, 0]
	     */
	    function times(n, iteratee) {
	      n = toInteger(n);
	      if (n < 1 || n > MAX_SAFE_INTEGER) {
	        return [];
	      }
	      var index = MAX_ARRAY_LENGTH,
	          length = nativeMin(n, MAX_ARRAY_LENGTH);

	      iteratee = getIteratee(iteratee);
	      n -= MAX_ARRAY_LENGTH;

	      var result = baseTimes(length, iteratee);
	      while (++index < n) {
	        iteratee(index);
	      }
	      return result;
	    }

	    /**
	     * Converts `value` to a property path array.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Util
	     * @param {*} value The value to convert.
	     * @returns {Array} Returns the new property path array.
	     * @example
	     *
	     * _.toPath('a.b.c');
	     * // => ['a', 'b', 'c']
	     *
	     * _.toPath('a[0].b.c');
	     * // => ['a', '0', 'b', 'c']
	     */
	    function toPath(value) {
	      if (isArray(value)) {
	        return arrayMap(value, toKey);
	      }
	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
	    }

	    /**
	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Util
	     * @param {string} [prefix=''] The value to prefix the ID with.
	     * @returns {string} Returns the unique ID.
	     * @example
	     *
	     * _.uniqueId('contact_');
	     * // => 'contact_104'
	     *
	     * _.uniqueId();
	     * // => '105'
	     */
	    function uniqueId(prefix) {
	      var id = ++idCounter;
	      return toString(prefix) + id;
	    }

	    /*------------------------------------------------------------------------*/

	    /**
	     * Adds two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {number} augend The first number in an addition.
	     * @param {number} addend The second number in an addition.
	     * @returns {number} Returns the total.
	     * @example
	     *
	     * _.add(6, 4);
	     * // => 10
	     */
	    var add = createMathOperation(function(augend, addend) {
	      return augend + addend;
	    }, 0);

	    /**
	     * Computes `number` rounded up to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round up.
	     * @param {number} [precision=0] The precision to round up to.
	     * @returns {number} Returns the rounded up number.
	     * @example
	     *
	     * _.ceil(4.006);
	     * // => 5
	     *
	     * _.ceil(6.004, 2);
	     * // => 6.01
	     *
	     * _.ceil(6040, -2);
	     * // => 6100
	     */
	    var ceil = createRound('ceil');

	    /**
	     * Divide two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} dividend The first number in a division.
	     * @param {number} divisor The second number in a division.
	     * @returns {number} Returns the quotient.
	     * @example
	     *
	     * _.divide(6, 4);
	     * // => 1.5
	     */
	    var divide = createMathOperation(function(dividend, divisor) {
	      return dividend / divisor;
	    }, 1);

	    /**
	     * Computes `number` rounded down to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round down.
	     * @param {number} [precision=0] The precision to round down to.
	     * @returns {number} Returns the rounded down number.
	     * @example
	     *
	     * _.floor(4.006);
	     * // => 4
	     *
	     * _.floor(0.046, 2);
	     * // => 0.04
	     *
	     * _.floor(4060, -2);
	     * // => 4000
	     */
	    var floor = createRound('floor');

	    /**
	     * Computes the maximum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * _.max([4, 2, 8, 6]);
	     * // => 8
	     *
	     * _.max([]);
	     * // => undefined
	     */
	    function max(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseGt)
	        : undefined;
	    }

	    /**
	     * This method is like `_.max` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the maximum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.maxBy(objects, function(o) { return o.n; });
	     * // => { 'n': 2 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.maxBy(objects, 'n');
	     * // => { 'n': 2 }
	     */
	    function maxBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
	        : undefined;
	    }

	    /**
	     * Computes the mean of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * _.mean([4, 2, 8, 6]);
	     * // => 5
	     */
	    function mean(array) {
	      return baseMean(array, identity);
	    }

	    /**
	     * This method is like `_.mean` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be averaged.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the mean.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.meanBy(objects, function(o) { return o.n; });
	     * // => 5
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.meanBy(objects, 'n');
	     * // => 5
	     */
	    function meanBy(array, iteratee) {
	      return baseMean(array, getIteratee(iteratee, 2));
	    }

	    /**
	     * Computes the minimum value of `array`. If `array` is empty or falsey,
	     * `undefined` is returned.
	     *
	     * @static
	     * @since 0.1.0
	     * @memberOf _
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * _.min([4, 2, 8, 6]);
	     * // => 2
	     *
	     * _.min([]);
	     * // => undefined
	     */
	    function min(array) {
	      return (array && array.length)
	        ? baseExtremum(array, identity, baseLt)
	        : undefined;
	    }

	    /**
	     * This method is like `_.min` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the criterion by which
	     * the value is ranked. The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {*} Returns the minimum value.
	     * @example
	     *
	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
	     *
	     * _.minBy(objects, function(o) { return o.n; });
	     * // => { 'n': 1 }
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.minBy(objects, 'n');
	     * // => { 'n': 1 }
	     */
	    function minBy(array, iteratee) {
	      return (array && array.length)
	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
	        : undefined;
	    }

	    /**
	     * Multiply two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.7.0
	     * @category Math
	     * @param {number} multiplier The first number in a multiplication.
	     * @param {number} multiplicand The second number in a multiplication.
	     * @returns {number} Returns the product.
	     * @example
	     *
	     * _.multiply(6, 4);
	     * // => 24
	     */
	    var multiply = createMathOperation(function(multiplier, multiplicand) {
	      return multiplier * multiplicand;
	    }, 1);

	    /**
	     * Computes `number` rounded to `precision`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.10.0
	     * @category Math
	     * @param {number} number The number to round.
	     * @param {number} [precision=0] The precision to round to.
	     * @returns {number} Returns the rounded number.
	     * @example
	     *
	     * _.round(4.006);
	     * // => 4
	     *
	     * _.round(4.006, 2);
	     * // => 4.01
	     *
	     * _.round(4060, -2);
	     * // => 4100
	     */
	    var round = createRound('round');

	    /**
	     * Subtract two numbers.
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {number} minuend The first number in a subtraction.
	     * @param {number} subtrahend The second number in a subtraction.
	     * @returns {number} Returns the difference.
	     * @example
	     *
	     * _.subtract(6, 4);
	     * // => 2
	     */
	    var subtract = createMathOperation(function(minuend, subtrahend) {
	      return minuend - subtrahend;
	    }, 0);

	    /**
	     * Computes the sum of the values in `array`.
	     *
	     * @static
	     * @memberOf _
	     * @since 3.4.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * _.sum([4, 2, 8, 6]);
	     * // => 20
	     */
	    function sum(array) {
	      return (array && array.length)
	        ? baseSum(array, identity)
	        : 0;
	    }

	    /**
	     * This method is like `_.sum` except that it accepts `iteratee` which is
	     * invoked for each element in `array` to generate the value to be summed.
	     * The iteratee is invoked with one argument: (value).
	     *
	     * @static
	     * @memberOf _
	     * @since 4.0.0
	     * @category Math
	     * @param {Array} array The array to iterate over.
	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
	     * @returns {number} Returns the sum.
	     * @example
	     *
	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
	     *
	     * _.sumBy(objects, function(o) { return o.n; });
	     * // => 20
	     *
	     * // The `_.property` iteratee shorthand.
	     * _.sumBy(objects, 'n');
	     * // => 20
	     */
	    function sumBy(array, iteratee) {
	      return (array && array.length)
	        ? baseSum(array, getIteratee(iteratee, 2))
	        : 0;
	    }

	    /*------------------------------------------------------------------------*/

	    // Add methods that return wrapped values in chain sequences.
	    lodash.after = after;
	    lodash.ary = ary;
	    lodash.assign = assign;
	    lodash.assignIn = assignIn;
	    lodash.assignInWith = assignInWith;
	    lodash.assignWith = assignWith;
	    lodash.at = at;
	    lodash.before = before;
	    lodash.bind = bind;
	    lodash.bindAll = bindAll;
	    lodash.bindKey = bindKey;
	    lodash.castArray = castArray;
	    lodash.chain = chain;
	    lodash.chunk = chunk;
	    lodash.compact = compact;
	    lodash.concat = concat;
	    lodash.cond = cond;
	    lodash.conforms = conforms;
	    lodash.constant = constant;
	    lodash.countBy = countBy;
	    lodash.create = create;
	    lodash.curry = curry;
	    lodash.curryRight = curryRight;
	    lodash.debounce = debounce;
	    lodash.defaults = defaults;
	    lodash.defaultsDeep = defaultsDeep;
	    lodash.defer = defer;
	    lodash.delay = delay;
	    lodash.difference = difference;
	    lodash.differenceBy = differenceBy;
	    lodash.differenceWith = differenceWith;
	    lodash.drop = drop;
	    lodash.dropRight = dropRight;
	    lodash.dropRightWhile = dropRightWhile;
	    lodash.dropWhile = dropWhile;
	    lodash.fill = fill;
	    lodash.filter = filter;
	    lodash.flatMap = flatMap;
	    lodash.flatMapDeep = flatMapDeep;
	    lodash.flatMapDepth = flatMapDepth;
	    lodash.flatten = flatten;
	    lodash.flattenDeep = flattenDeep;
	    lodash.flattenDepth = flattenDepth;
	    lodash.flip = flip;
	    lodash.flow = flow;
	    lodash.flowRight = flowRight;
	    lodash.fromPairs = fromPairs;
	    lodash.functions = functions;
	    lodash.functionsIn = functionsIn;
	    lodash.groupBy = groupBy;
	    lodash.initial = initial;
	    lodash.intersection = intersection;
	    lodash.intersectionBy = intersectionBy;
	    lodash.intersectionWith = intersectionWith;
	    lodash.invert = invert;
	    lodash.invertBy = invertBy;
	    lodash.invokeMap = invokeMap;
	    lodash.iteratee = iteratee;
	    lodash.keyBy = keyBy;
	    lodash.keys = keys;
	    lodash.keysIn = keysIn;
	    lodash.map = map;
	    lodash.mapKeys = mapKeys;
	    lodash.mapValues = mapValues;
	    lodash.matches = matches;
	    lodash.matchesProperty = matchesProperty;
	    lodash.memoize = memoize;
	    lodash.merge = merge;
	    lodash.mergeWith = mergeWith;
	    lodash.method = method;
	    lodash.methodOf = methodOf;
	    lodash.mixin = mixin;
	    lodash.negate = negate;
	    lodash.nthArg = nthArg;
	    lodash.omit = omit;
	    lodash.omitBy = omitBy;
	    lodash.once = once;
	    lodash.orderBy = orderBy;
	    lodash.over = over;
	    lodash.overArgs = overArgs;
	    lodash.overEvery = overEvery;
	    lodash.overSome = overSome;
	    lodash.partial = partial;
	    lodash.partialRight = partialRight;
	    lodash.partition = partition;
	    lodash.pick = pick;
	    lodash.pickBy = pickBy;
	    lodash.property = property;
	    lodash.propertyOf = propertyOf;
	    lodash.pull = pull;
	    lodash.pullAll = pullAll;
	    lodash.pullAllBy = pullAllBy;
	    lodash.pullAllWith = pullAllWith;
	    lodash.pullAt = pullAt;
	    lodash.range = range;
	    lodash.rangeRight = rangeRight;
	    lodash.rearg = rearg;
	    lodash.reject = reject;
	    lodash.remove = remove;
	    lodash.rest = rest;
	    lodash.reverse = reverse;
	    lodash.sampleSize = sampleSize;
	    lodash.set = set;
	    lodash.setWith = setWith;
	    lodash.shuffle = shuffle;
	    lodash.slice = slice;
	    lodash.sortBy = sortBy;
	    lodash.sortedUniq = sortedUniq;
	    lodash.sortedUniqBy = sortedUniqBy;
	    lodash.split = split;
	    lodash.spread = spread;
	    lodash.tail = tail;
	    lodash.take = take;
	    lodash.takeRight = takeRight;
	    lodash.takeRightWhile = takeRightWhile;
	    lodash.takeWhile = takeWhile;
	    lodash.tap = tap;
	    lodash.throttle = throttle;
	    lodash.thru = thru;
	    lodash.toArray = toArray;
	    lodash.toPairs = toPairs;
	    lodash.toPairsIn = toPairsIn;
	    lodash.toPath = toPath;
	    lodash.toPlainObject = toPlainObject;
	    lodash.transform = transform;
	    lodash.unary = unary;
	    lodash.union = union;
	    lodash.unionBy = unionBy;
	    lodash.unionWith = unionWith;
	    lodash.uniq = uniq;
	    lodash.uniqBy = uniqBy;
	    lodash.uniqWith = uniqWith;
	    lodash.unset = unset;
	    lodash.unzip = unzip;
	    lodash.unzipWith = unzipWith;
	    lodash.update = update;
	    lodash.updateWith = updateWith;
	    lodash.values = values;
	    lodash.valuesIn = valuesIn;
	    lodash.without = without;
	    lodash.words = words;
	    lodash.wrap = wrap;
	    lodash.xor = xor;
	    lodash.xorBy = xorBy;
	    lodash.xorWith = xorWith;
	    lodash.zip = zip;
	    lodash.zipObject = zipObject;
	    lodash.zipObjectDeep = zipObjectDeep;
	    lodash.zipWith = zipWith;

	    // Add aliases.
	    lodash.entries = toPairs;
	    lodash.entriesIn = toPairsIn;
	    lodash.extend = assignIn;
	    lodash.extendWith = assignInWith;

	    // Add methods to `lodash.prototype`.
	    mixin(lodash, lodash);

	    /*------------------------------------------------------------------------*/

	    // Add methods that return unwrapped values in chain sequences.
	    lodash.add = add;
	    lodash.attempt = attempt;
	    lodash.camelCase = camelCase;
	    lodash.capitalize = capitalize;
	    lodash.ceil = ceil;
	    lodash.clamp = clamp;
	    lodash.clone = clone;
	    lodash.cloneDeep = cloneDeep;
	    lodash.cloneDeepWith = cloneDeepWith;
	    lodash.cloneWith = cloneWith;
	    lodash.conformsTo = conformsTo;
	    lodash.deburr = deburr;
	    lodash.defaultTo = defaultTo;
	    lodash.divide = divide;
	    lodash.endsWith = endsWith;
	    lodash.eq = eq;
	    lodash.escape = escape;
	    lodash.escapeRegExp = escapeRegExp;
	    lodash.every = every;
	    lodash.find = find;
	    lodash.findIndex = findIndex;
	    lodash.findKey = findKey;
	    lodash.findLast = findLast;
	    lodash.findLastIndex = findLastIndex;
	    lodash.findLastKey = findLastKey;
	    lodash.floor = floor;
	    lodash.forEach = forEach;
	    lodash.forEachRight = forEachRight;
	    lodash.forIn = forIn;
	    lodash.forInRight = forInRight;
	    lodash.forOwn = forOwn;
	    lodash.forOwnRight = forOwnRight;
	    lodash.get = get;
	    lodash.gt = gt;
	    lodash.gte = gte;
	    lodash.has = has;
	    lodash.hasIn = hasIn;
	    lodash.head = head;
	    lodash.identity = identity;
	    lodash.includes = includes;
	    lodash.indexOf = indexOf;
	    lodash.inRange = inRange;
	    lodash.invoke = invoke;
	    lodash.isArguments = isArguments;
	    lodash.isArray = isArray;
	    lodash.isArrayBuffer = isArrayBuffer;
	    lodash.isArrayLike = isArrayLike;
	    lodash.isArrayLikeObject = isArrayLikeObject;
	    lodash.isBoolean = isBoolean;
	    lodash.isBuffer = isBuffer;
	    lodash.isDate = isDate;
	    lodash.isElement = isElement;
	    lodash.isEmpty = isEmpty;
	    lodash.isEqual = isEqual;
	    lodash.isEqualWith = isEqualWith;
	    lodash.isError = isError;
	    lodash.isFinite = isFinite;
	    lodash.isFunction = isFunction;
	    lodash.isInteger = isInteger;
	    lodash.isLength = isLength;
	    lodash.isMap = isMap;
	    lodash.isMatch = isMatch;
	    lodash.isMatchWith = isMatchWith;
	    lodash.isNaN = isNaN;
	    lodash.isNative = isNative;
	    lodash.isNil = isNil;
	    lodash.isNull = isNull;
	    lodash.isNumber = isNumber;
	    lodash.isObject = isObject;
	    lodash.isObjectLike = isObjectLike;
	    lodash.isPlainObject = isPlainObject;
	    lodash.isRegExp = isRegExp;
	    lodash.isSafeInteger = isSafeInteger;
	    lodash.isSet = isSet;
	    lodash.isString = isString;
	    lodash.isSymbol = isSymbol;
	    lodash.isTypedArray = isTypedArray;
	    lodash.isUndefined = isUndefined;
	    lodash.isWeakMap = isWeakMap;
	    lodash.isWeakSet = isWeakSet;
	    lodash.join = join;
	    lodash.kebabCase = kebabCase;
	    lodash.last = last;
	    lodash.lastIndexOf = lastIndexOf;
	    lodash.lowerCase = lowerCase;
	    lodash.lowerFirst = lowerFirst;
	    lodash.lt = lt;
	    lodash.lte = lte;
	    lodash.max = max;
	    lodash.maxBy = maxBy;
	    lodash.mean = mean;
	    lodash.meanBy = meanBy;
	    lodash.min = min;
	    lodash.minBy = minBy;
	    lodash.stubArray = stubArray;
	    lodash.stubFalse = stubFalse;
	    lodash.stubObject = stubObject;
	    lodash.stubString = stubString;
	    lodash.stubTrue = stubTrue;
	    lodash.multiply = multiply;
	    lodash.nth = nth;
	    lodash.noConflict = noConflict;
	    lodash.noop = noop;
	    lodash.now = now;
	    lodash.pad = pad;
	    lodash.padEnd = padEnd;
	    lodash.padStart = padStart;
	    lodash.parseInt = parseInt;
	    lodash.random = random;
	    lodash.reduce = reduce;
	    lodash.reduceRight = reduceRight;
	    lodash.repeat = repeat;
	    lodash.replace = replace;
	    lodash.result = result;
	    lodash.round = round;
	    lodash.runInContext = runInContext;
	    lodash.sample = sample;
	    lodash.size = size;
	    lodash.snakeCase = snakeCase;
	    lodash.some = some;
	    lodash.sortedIndex = sortedIndex;
	    lodash.sortedIndexBy = sortedIndexBy;
	    lodash.sortedIndexOf = sortedIndexOf;
	    lodash.sortedLastIndex = sortedLastIndex;
	    lodash.sortedLastIndexBy = sortedLastIndexBy;
	    lodash.sortedLastIndexOf = sortedLastIndexOf;
	    lodash.startCase = startCase;
	    lodash.startsWith = startsWith;
	    lodash.subtract = subtract;
	    lodash.sum = sum;
	    lodash.sumBy = sumBy;
	    lodash.template = template;
	    lodash.times = times;
	    lodash.toFinite = toFinite;
	    lodash.toInteger = toInteger;
	    lodash.toLength = toLength;
	    lodash.toLower = toLower;
	    lodash.toNumber = toNumber;
	    lodash.toSafeInteger = toSafeInteger;
	    lodash.toString = toString;
	    lodash.toUpper = toUpper;
	    lodash.trim = trim;
	    lodash.trimEnd = trimEnd;
	    lodash.trimStart = trimStart;
	    lodash.truncate = truncate;
	    lodash.unescape = unescape;
	    lodash.uniqueId = uniqueId;
	    lodash.upperCase = upperCase;
	    lodash.upperFirst = upperFirst;

	    // Add aliases.
	    lodash.each = forEach;
	    lodash.eachRight = forEachRight;
	    lodash.first = head;

	    mixin(lodash, (function() {
	      var source = {};
	      baseForOwn(lodash, function(func, methodName) {
	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
	          source[methodName] = func;
	        }
	      });
	      return source;
	    }()), { 'chain': false });

	    /*------------------------------------------------------------------------*/

	    /**
	     * The semantic version number.
	     *
	     * @static
	     * @memberOf _
	     * @type {string}
	     */
	    lodash.VERSION = VERSION;

	    // Assign default placeholders.
	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
	      lodash[methodName].placeholder = lodash;
	    });

	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
	    arrayEach(['drop', 'take'], function(methodName, index) {
	      LazyWrapper.prototype[methodName] = function(n) {
	        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

	        var result = (this.__filtered__ && !index)
	          ? new LazyWrapper(this)
	          : this.clone();

	        if (result.__filtered__) {
	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
	        } else {
	          result.__views__.push({
	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
	          });
	        }
	        return result;
	      };

	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
	        return this.reverse()[methodName](n).reverse();
	      };
	    });

	    // Add `LazyWrapper` methods that accept an `iteratee` value.
	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
	      var type = index + 1,
	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

	      LazyWrapper.prototype[methodName] = function(iteratee) {
	        var result = this.clone();
	        result.__iteratees__.push({
	          'iteratee': getIteratee(iteratee, 3),
	          'type': type
	        });
	        result.__filtered__ = result.__filtered__ || isFilter;
	        return result;
	      };
	    });

	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
	    arrayEach(['head', 'last'], function(methodName, index) {
	      var takeName = 'take' + (index ? 'Right' : '');

	      LazyWrapper.prototype[methodName] = function() {
	        return this[takeName](1).value()[0];
	      };
	    });

	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
	    arrayEach(['initial', 'tail'], function(methodName, index) {
	      var dropName = 'drop' + (index ? '' : 'Right');

	      LazyWrapper.prototype[methodName] = function() {
	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
	      };
	    });

	    LazyWrapper.prototype.compact = function() {
	      return this.filter(identity);
	    };

	    LazyWrapper.prototype.find = function(predicate) {
	      return this.filter(predicate).head();
	    };

	    LazyWrapper.prototype.findLast = function(predicate) {
	      return this.reverse().find(predicate);
	    };

	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
	      if (typeof path == 'function') {
	        return new LazyWrapper(this);
	      }
	      return this.map(function(value) {
	        return baseInvoke(value, path, args);
	      });
	    });

	    LazyWrapper.prototype.reject = function(predicate) {
	      return this.filter(negate(getIteratee(predicate)));
	    };

	    LazyWrapper.prototype.slice = function(start, end) {
	      start = toInteger(start);

	      var result = this;
	      if (result.__filtered__ && (start > 0 || end < 0)) {
	        return new LazyWrapper(result);
	      }
	      if (start < 0) {
	        result = result.takeRight(-start);
	      } else if (start) {
	        result = result.drop(start);
	      }
	      if (end !== undefined) {
	        end = toInteger(end);
	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
	      }
	      return result;
	    };

	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
	      return this.reverse().takeWhile(predicate).reverse();
	    };

	    LazyWrapper.prototype.toArray = function() {
	      return this.take(MAX_ARRAY_LENGTH);
	    };

	    // Add `LazyWrapper` methods to `lodash.prototype`.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
	          isTaker = /^(?:head|last)$/.test(methodName),
	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
	          retUnwrapped = isTaker || /^find/.test(methodName);

	      if (!lodashFunc) {
	        return;
	      }
	      lodash.prototype[methodName] = function() {
	        var value = this.__wrapped__,
	            args = isTaker ? [1] : arguments,
	            isLazy = value instanceof LazyWrapper,
	            iteratee = args[0],
	            useLazy = isLazy || isArray(value);

	        var interceptor = function(value) {
	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
	          return (isTaker && chainAll) ? result[0] : result;
	        };

	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
	          isLazy = useLazy = false;
	        }
	        var chainAll = this.__chain__,
	            isHybrid = !!this.__actions__.length,
	            isUnwrapped = retUnwrapped && !chainAll,
	            onlyLazy = isLazy && !isHybrid;

	        if (!retUnwrapped && useLazy) {
	          value = onlyLazy ? value : new LazyWrapper(this);
	          var result = func.apply(value, args);
	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
	          return new LodashWrapper(result, chainAll);
	        }
	        if (isUnwrapped && onlyLazy) {
	          return func.apply(this, args);
	        }
	        result = this.thru(interceptor);
	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
	      };
	    });

	    // Add `Array` methods to `lodash.prototype`.
	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
	      var func = arrayProto[methodName],
	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

	      lodash.prototype[methodName] = function() {
	        var args = arguments;
	        if (retUnwrapped && !this.__chain__) {
	          var value = this.value();
	          return func.apply(isArray(value) ? value : [], args);
	        }
	        return this[chainName](function(value) {
	          return func.apply(isArray(value) ? value : [], args);
	        });
	      };
	    });

	    // Map minified method names to their real names.
	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
	      var lodashFunc = lodash[methodName];
	      if (lodashFunc) {
	        var key = (lodashFunc.name + ''),
	            names = realNames[key] || (realNames[key] = []);

	        names.push({ 'name': methodName, 'func': lodashFunc });
	      }
	    });

	    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
	      'name': 'wrapper',
	      'func': undefined
	    }];

	    // Add methods to `LazyWrapper`.
	    LazyWrapper.prototype.clone = lazyClone;
	    LazyWrapper.prototype.reverse = lazyReverse;
	    LazyWrapper.prototype.value = lazyValue;

	    // Add chain sequence methods to the `lodash` wrapper.
	    lodash.prototype.at = wrapperAt;
	    lodash.prototype.chain = wrapperChain;
	    lodash.prototype.commit = wrapperCommit;
	    lodash.prototype.next = wrapperNext;
	    lodash.prototype.plant = wrapperPlant;
	    lodash.prototype.reverse = wrapperReverse;
	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

	    // Add lazy aliases.
	    lodash.prototype.first = lodash.prototype.head;

	    if (symIterator) {
	      lodash.prototype[symIterator] = wrapperToIterator;
	    }
	    return lodash;
	  });

	  /*--------------------------------------------------------------------------*/

	  // Export lodash.
	  var _ = runInContext();

	  // Some AMD build optimizers, like r.js, check for condition patterns like:
	  if (true) {
	    // Expose Lodash on the global object to prevent errors when Lodash is
	    // loaded by a script tag in the presence of an AMD loader.
	    // See http://requirejs.org/docs/errors.html#mismatch for more details.
	    // Use `_.noConflict` to remove Lodash from the global object.
	    root._ = _;

	    // Define as an anonymous module so, through path mapping, it can be
	    // referenced as the "underscore" module.
	    !(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	  // Check for `exports` after `define` in case a build optimizer adds it.
	  else if (freeModule) {
	    // Export for Node.js.
	    (freeModule.exports = _)._ = _;
	    // Export for CommonJS support.
	    freeExports._ = _;
	  }
	  else {
	    // Export to the global object.
	    root._ = _;
	  }
	}.call(this));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(7)(module)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 8 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/16.
	 */

	module.exports = {
	  isArray: function(item) {
	    return Object.prototype.toString.call(item) == '[object Array]';
	  },

	  isString: function(item) {
	    return typeof item === 'string';
	  },

	  isExitsVariable: function(variable) {
	    try {
	      if(typeof(variable) === 'undefined') {
	        return false;
	      } else {
	        return true;
	      }
	    } catch(err) {
	      console.log(err);
	    }
	  }
	};


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 */

	var LngLat = __webpack_require__(10);
	var Bounds = __webpack_require__(11);
	var Pixel = __webpack_require__(12);
	var Size = __webpack_require__(13);
	var Map = __webpack_require__(14);
	var Marker = __webpack_require__(21);
	var event = __webpack_require__(17);
	var InfoWindow = __webpack_require__(23);
	var Polyline = __webpack_require__(24);
	var Polygon = __webpack_require__(25);
	var Circle = __webpack_require__(26);
	var MarkerClusterer = __webpack_require__(27);

	var GMap = {};

	GMap.event = event;

	GMap.LngLat = LngLat;
	GMap.Bounds = Bounds;
	GMap.Pixel = Pixel;
	GMap.Size = Size;

	GMap.Map = Map;
	GMap.Marker = Marker;
	GMap.InfoWindow = InfoWindow;
	GMap.Polyline = Polyline;
	GMap.Polygon = Polygon;
	GMap.Circle = Circle;
	GMap.MarkerClusterer = MarkerClusterer;

	module.exports = window.GMap = GMap;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 */

	var util = __webpack_require__(8);

	/**
	 * @constructor
	 * @lng {Number} lng
	 * @lat {Number} lat
	 * */
	function LngLat(lng, lat, inner) {

	  // 包装GMap的LngLat结构
	  if(inner) {
	    this._inner = inner;
	  }

	  // 构造函数模式
	  else {
	    if(arguments.length < 2) {

	      // 数组形式，前者为lng，后者为lat [116.397428, 39.90923] -- position
	      if(util.isArray(lng)){

	        if( typeof lng[0] === 'string' || typeof lng[1] === 'string' ) {
	          this.lng = parseFloat(lng[0]);
	          this.lat = parseFloat(lng[1]);
	        }

	        else {
	          this.lng = lng[0];
	          this.lat = lng[1];
	        }
	      }

	      // 对象形式，lng对应lng，lat对应lat (lng: 116.397428, lat: 39.90923)
	      else {
	        this.lng = lng.lng;
	        this.lat = lng.lat;
	      }
	    }

	    else {

	      // ("116.403322", "39.920255") string
	      if(util.isString(lng) || util.isString(lat)) {
	        this.lng = parseFloat(lng);
	        this.lat = parseFloat(lat);
	      }

	      // (116.403322, 39.920255) Number
	      else {
	        this.lng = lng;
	        this.lat = lat;
	      }
	    }

	    this._inner = new google.maps.LatLng({lng:this.lng, lat:this.lat});
	  }

	  this._type = 'LngLat';

	  return this;
	}

	LngLat.prototype = {
	  /**
	   * @function offset
	   * @param {Number} w
	   * @param {Number} s
	   * */
	  offset: function(w, s) {

	  },

	  distance: function() {

	  },

	  getLng: function() {
	    return this.lng;
	  },

	  getLat: function() {
	    return this.lat;
	  },

	  equals: function(lngLat) {

	  },

	  toString: function() {
	    return this._inner.toString();
	  }
	};

	module.exports = LngLat;





/***/ },
/* 11 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/15.
	 * @name Bounds 基础类
	 * 在Google Map里面对应LatLngBounds Class
	 * https://developers.google.com/maps/documentation/javascript/3.exp/reference#LatLngBounds
	 */

	/**
	 * @constructor
	 * @sw {LngLat} southWest
	 * @ne {LngLat} northEast
	 * */
	function Bounds(sw, ne, inner) {

	  if(inner) {
	    this._inner = inner;
	  } else {
	    this._inner = new google.maps.LatLngBounds(sw, ne);
	  }

	  this._type = 'Bounds';

	  return this;
	}

	Bounds.prototype = {
	  /**
	   * @param {LngLat} point
	   * */
	  contains: function(point) {
	    return this._inner.contains(point._inner);
	  },

	  getCenter: function() {
	    return LngLat.wrap(this._inner.getCenter());
	  },

	  getSouthWest: function() {
	    return this._inner.getSouthWest();
	  },
	  getNorthEast: function() {
	    return this._inner.getNorthEast();
	  },
	  toString: function() {
	    console.log("toString");
	    return this._inner.toString();
	  }
	};

	module.exports = Bounds;


/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/15.
	 * @constructor Pixel
	 * 在google map里面对应的是Point
	 * https://developers.google.com/maps/documentation/javascript/reference#Point
	 */


	/**
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * */
	function Pixel(x, y, inner) {
	  if(inner) {
	    this._inner = inner;
	  } else {
	    this._inner = new google.maps.Point(x,y);
	  }

	  this._type = 'Pixel';
	  return this;
	}

	Pixel.prototype = {
	  getX: function() {
	    return this._inner.x;
	  },
	  getY: function() {
	    return this._inner.y;
	  },

	  /**
	   * @param {Pixel} point
	   * */
	  equals: function(point) {
	    return this._inner.equals(point);
	  },

	  toString: function() {
	    return this._inner.toString();
	  }
	};




	module.exports = Pixel;


/***/ },
/* 13 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/15.
	 */


	/**
	 * @constructor
	 * @param {Number} width
	 * @param {Number} height
	 * */
	function Size(width, height, inner) {
	  if(inner) {
	    this._inner = inner;
	  } else {
	    this._inner = new google.maps.Size();
	  }

	  this._type = 'Size';
	  return this;
	}

	Size.prototype = {
	  getWidth: function() {
	    return this._inner.width;
	  },
	  getHeight: function() {
	    return this._inner.height;
	  },
	  toString: function() {
	    return this._inner.toString();
	  }
	};




	module.exports = Size;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @constructor of Map
	 * @return our map object
	 */

	var config = __webpack_require__(15);
	var Bounds = __webpack_require__(11);
	var onOff = __webpack_require__(16);
	var formatOpts = __webpack_require__(20);

	/**
	 * @constructor
	 * @elem {Object}
	 * @opts {Object}
	 * */
	function Map(id,opts) {
	  var elem, newOpts;

	  this._type = 'Map';
	  elem = document.getElementById(id);
	  newOpts = formatOpts.map(opts);

	  this._inner = new google.maps.Map(elem, newOpts);
	  this._inner._smap = this;
	  this._overLayers = {
	    MarkerClusterer: [],
	    Marker: [],
	    InfoWindow: [],
	    Polygon: [],
	    Polyline: [],
	    Circle: []
	  };
	}

	Map.prototype = {

	  plugin : mapPlugin,

	  clearMap: clearMap,

	  // TODO: setFitView
	  setFitView: function() {

	  },

	  /**
	   * @param {LngLat} position
	   * */
	  panTo: function(position) {
	    this._inner.panTo(position._inner);
	  },

	  destroy: function() {

	  },

	  /**
	   * @param {Number} zoom
	   * */
	  setZoom: function(zoom) {
	    this._inner.setZoom(zoom);
	  },

	  getBounds: function() {
	    return new Bounds('','',this._inner.getBounds());
	  },

	  // todo:
	  setBounds: function() {

	  },

	  on: onOff.on,
	  off: onOff.off
	};

	function mapPlugin(plugins, fn) {
	  if(plugins.length < 1) return;

	  plugins.forEach( function(plugin) {

	    console.log(plugin);
	    if(plugin === 'GMap.MarkerClusterer') {
	      $.getScript(config.GMap_MarkerClusterer, function() {
	        fn();
	      });
	    }

	  })
	}

	function clearMap() {
	  var overLayers = this._overLayers;

	  for(var type in overLayers) {

	    switch (type) {
	      case 'Marker':
	      case 'Circle':
	      case 'Polygon':
	      case 'Polyline':
	      case 'InfoWindow':
	        if(overLayers[type].length > 0) {
	          overLayers[type].forEach( function(item) {
	            item._inner.setMap(null);
	            item._inner = null;
	            item = null;
	          });
	          overLayers.lenght = 0;
	        }
	        break;
	      case 'MarkerClusterer':
	        if(overLayers.MarkerClusterer.length > 0) {
	          overLayers.MarkerClusterer.forEach( function(item) {
	            item._inner.clearMarkers();
	            item._inner = null;
	            item = null;
	          });
	          overLayers.MarkerClusterer.length = 0;
	        }
	        break;
	    }

	  }
	}

	module.exports = Map;


/***/ },
/* 15 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/15.
	 * @config for SMap.
	 * @target 引用一个SMap.js 将会自动帮你加载地图API
	 */

	module.exports = {

	  // 谷歌地图API的url和key
	  GMap_key: 'AIzaSyCjPUco3l_6-f8ZexAesZrYFzpGtRQHvSo',
	  GMap_url: 'https://maps.googleapis.com/maps/api/js?key=',

	  // 高德地图API的url和key
	  AMap_key: '319766fcdf57589d1da6e0dfc89770d2',
	  AMap_url: 'http://webapi.amap.com/maps?v=1.3&key=',

	  // 百度地图API的url和key
	  DMap_key: 'h733PD7WQgKZYRotiD19oK0w0y6sz0QC',
	  DMap_url: 'http://api.map.baidu.com/api?v=2.0&ak=',


	  /**********************************地图插件地址域名url****************************/
	  SMap_plugin_url: 'http://192.168.60.206:9000/src/components/map/',

	  /**********************************百度插件地址***********************************/
	  DMap_MarkerClusterer: 'http://192.168.60.206:9000/src/components/map/bmap/lib/markerclusterer.js',
	  DMap_TextIconOverlay: 'http://192.168.60.206:9000/src/components/map/bmap/lib/TextIconOverlay.js',
	  DMap_AreaRestriction: 'http://192.168.60.206:9000/src/components/map/bmap/lib/AreaRestriction.js',

	  /**********************************谷歌插件地址***********************************/
	  GMap_MarkerClusterer: 'http://192.168.60.206:9000/src/components/map/google/markerclusterer.js'

	};


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/14.
	 * @onOff 基类，覆盖物的实例都具有on和off方法，都直接来自于此
	 */

	var event = __webpack_require__(17);
	var onOff = {};

	/**
	 * @function addEventListener 的简便方法
	 *
	 * @param {String} eventName 事件名称
	 * @param {Function} handler 回调函数
	 * @param {Object} context 上下文
	 * */
	onOff.on = function(eventName, handler, context) {
	  var listener, eventListener;

	  listener = event.addListener(this, eventName, handler, context);

	  eventListener = {
	    eventName: eventName,
	    handler: handler,
	    context: context,
	    listener: listener
	  };

	  if(!this._eventListener) this._eventListener = [];

	  this._eventListener.push(eventListener);
	  return listener;
	};

	/**
	 * @function
	 * @param {String} eventName 事件名称
	 * @param {Function} handler 回调函数
	 * @param {Object} context 上下文
	 *
	 * @attention 要想移除对应的事件，必须保证eventName，handler，context一致。
	 * */
	onOff.off = function(eventName, handler, context) {
	  if(!this._eventListener) return;

	  var filterResult = this._eventListener.filter( function(item, index) {
	    if(eventName === item.eventName) return true;
	    return false;
	  });

	  if(filterResult && filterResult.length > 0) {
	    filterResult.forEach( function(item) {
	      if( item.handler === handler &&
	        item.context === context ) {
	        event.removeListener(item.listener);
	      }
	    })
	  }

	};

	module.exports = onOff;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/14.
	 */

	var SMapEvent = __webpack_require__(18);

	var event = {};

	event.map = __webpack_require__(19);

	event.getSMapEvent = function(e) {
	  return new SMapEvent(e);
	};

	event.addDomListener = function(instance, eventName, handler, context) {
	  var listener = {};

	  if(context) {
	    listener = google.maps.event.addDomListener(instance, eventName, function(e) {
	      handler.call(context, e);
	    });
	  } else {
	    listener = google.maps.event.addDomListener(instance, eventName, handler);
	  }
	  return listener;
	};

	event.addListener = function(instance, eventName, handler, context) {
	  var listener = {}, relevantEvent, realInstance;

	  realInstance = instance._inner;
	  relevantEvent = event.getRelevantEvent(instance, eventName);

	  if(context) {
	    listener = google.maps.event.addListener(realInstance, relevantEvent, function(e) {
	      handler.call(context, event.getSMapEvent(e));
	    });
	  } else {
	    listener = google.maps.event.addListener(realInstance, relevantEvent, function(e) {
	      handler(event.getSMapEvent(e));
	    });
	  }
	  return listener;
	};

	event.addListenerOnce = function(instance, eventName, handler, context) {
	  var listener = {}, relevantEvent, realInstance;

	  realInstance = instance._inner;

	  relevantEvent = event.getRelevantEvent(instance, eventName);

	  if(context) {
	    listener = google.maps.event.addListenerOnce(realInstance, relevantEvent, function (e) {
	      handler.call(context, event.getSMapEvent(e));
	    });
	  } else {
	    listener = google.maps.event.addListenerOnce(realInstance, relevantEvent, function(e) {
	      handler(event.getSMapEvent(e));
	    });
	  }
	  return listener;
	};

	event.removeListener = function(listener) {
	  google.maps.event.removeListener(listener);
	};

	event.triggerListener = function(instance, eventName, extArgs) {
	  var relevantEvent = event.getRelevantEvent(instance, eventName);

	  google.maps.event.trigger(instance, relevantEvent, extArgs);
	};

	event.getRelevantEvent = function(instance, eventName) {
	  if(instance._type in event.map) {
	    if(eventName in event.map[instance._type]) {
	      return event.map[instance._type][eventName];
	    } else {
	      return eventName;
	    }
	  } else {
	    return eventName;
	  }
	};

	event.getSMapEventObject = function(e) {

	};

	module.exports = event;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/20.
	 * @constructor for google map event Object.
	 * Wrap event and return our new event object just like gaode AMap event.
	 */

	var LngLat = __webpack_require__(10);

	/**
	 * 包装Google的事件触发时的event对象
	 *
	 * @constructor
	 * @param {Object} e event object
	 * */
	function SMapEvent(e) {
	  this._inner = e;
	  this._type = 'Event';

	  this.lnglat = new LngLat(e.latLng.lng(), e.latLng.lat());
	  this.lnglat.I = e.latLng.lng();
	  this.lnglat.L = e.latLng.lat();

	  this.pixel = {
	    x: e.pixel.x,
	    y: e.pixel.y
	  };
	}

	module.exports = SMapEvent;


/***/ },
/* 19 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/16.
	 *
	 */

	module.exports = {
	  Marker: {
	    click: 'click',

	  },

	  InfoWindow: {
	    change: 'content_changed',
	    open: 'domready',
	    chose: 'choseClick'
	  }
	};


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/14.
	 */

	var LngLat = __webpack_require__(10);

	module.exports = {
	  map: formatOptsUni,

	  infoWindow: formatOptsUni,

	  marker: formatOptsUni,

	  polyline: formatOptsUni,

	  polygon: formatOptsUni,

	  circle: formatOptsUni,

	  markerClusterer: formatMarkerClusterer
	};

	function formatOptsUni(opts) {

	  if('position' in opts) {
	    opts.position = new LngLat(opts.position);
	  }

	  if(opts.path) {
	    opts.path = transfromPathToPaths(opts.path);
	  }

	  if(opts.center) {
	    opts.center = new LngLat(opts.center);
	  }

	  if(opts.map) {
	    opts.map = opts.map._inner;
	  }

	  return opts;
	}

	function transfromPathToPaths(path) {
	  var paths = [];
	  path.forEach( function(item, index) {
	    paths.push(arrCreateLngLat(item));
	  });
	  return paths;
	}

	function arrCreateLngLat(arr) {
	  return new google.maps.LatLng({lng: arr[0], lat: arr[1]});
	}


	/**************************************************
	 * markerClusterer
	 * ***********************************************/
	function formatMarkerClusterer(map, markers, opts) {
	  var newOpts = {};

	  if(map._inner) {
	    newOpts.map = map._inner;
	  } else {
	    newOpts.map = map;
	  }

	  newOpts.markers = markers.map( function(item) {
	    return item._inner;
	  });

	  newOpts.opts = formatMarkerClustererOpts(opts);

	  return newOpts;
	}

	/**
	 * @param {Object} opts
	 * @diff : minClusterSize : minimumClusterSize
	 * */
	function formatMarkerClustererOpts(opts) {
	  if(opts.minClusterSize) {
	    opts.minimumClusterSize = opts.minClusterSize;
	  }

	  if(opts.styles) {

	    if(opts.styles) {
	      var styles = opts.styles;
	      if(styles.size) {
	        styles.width = styles.getWidth();
	        styles.height = styles.getHeight();
	      }
	    }

	  }
	}


	// var flightPlanCoordinates = [
	//   {lat: 37.772, lng: -122.214},
	//   {lat: 21.291, lng: -157.821},
	//   {lat: -18.142, lng: 178.431},
	//   {lat: -27.467, lng: 153.027}
	// ];

	// var lineArr = [
	//   [116.368904, 39.913423],
	//   [116.382122, 39.901176],
	//   [116.387271, 39.912501],
	//   [116.398258, 39.904600]
	// ];


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @Class Marker
	 */
	var obc = __webpack_require__(22);
	var onOff = __webpack_require__(16);
	var formatOpts = __webpack_require__(20);

	/**
	 * Represents a Marker
	 * @constructor
	 * @param {Object} opts
	 * @param {Object} inner
	 * @return an object, inner is prime google map Marker instance.
	 * */
	function Marker(opts, inner) {

	  this._type = 'Marker';

	  if(inner) {
	    this._inner = inner;
	  } else {
	    // 在opts转换之前就要判断添加overlay
	    obc.addOverlay(opts, this);
	    var newOpts = formatOpts.marker(opts);
	    this._inner = new google.maps.Marker(newOpts);
	    if(opts.map) {
	      this._inner._smap = opts.map;
	    }
	  }
	}

	Marker.prototype = {
	  setMap: obc.setMap,
	  getMap: obc.getMap,
	  hide: obc.hide,
	  show: obc.show,
	  on: onOff.on,
	  off: onOff.off
	};

	module.exports = Marker;





/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/17.
	 */

	module.exports = {
	  setMap: function(map) {
	    if(map !== null) {
	      this._inner._smap = map;
	      map._overLayers[this._type].push(this);
	      this._inner.setMap(map._inner);
	    } else {
	      this._inner.setMap(null);
	    }
	  },

	  getMap: function() {
	    return this._inner._smap;
	  },

	  hide: function() {
	    this._inner.setVisible(false);
	  },

	  show: function() {
	    this._inner.setVisible(true);
	  },

	  addOverlay: function(opts, self) {
	    if('map' in opts) {
	      opts.map._overLayers[self._type].push(self);
	    }
	  }
	};


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/14.
	 */
	var onOff = __webpack_require__(16);
	var formatOpts = __webpack_require__(20);
	var obc = __webpack_require__(22);

	/**
	 * @constructor
	 * @opts {Object} opts
	 * */
	function InfoWindow(opts) {
	  this._type = 'InfoWindow';
	  obc.addOverlay(opts, this);

	  var fmOpts = formatOpts.infoWindow(opts);
	  this._inner = new google.maps.InfoWindow(fmOpts);
	}

	InfoWindow.prototype = {
	  /**
	   * @function open a infoWindow in the position
	   * @map {Map} map required
	   * @pos {LngLat} position lngLat
	   * */
	  open: function(map, pos) {
	    if(pos) {
	      this._inner.setPosition(pos);
	    }
	    this._inner.open(map._inner);
	    this._inner._smap = map;
	    map._overLayers.InfoWindow.push(this);
	    this._isOpen = true;
	  },

	  close: function() {
	    this._inner.close();
	    this._isOpen = false;
	    var infoWindows = this._inner._smap._overLayers.InfoWindow;
	    infoWindows.filter( function(item, index) {
	      if(item == this) {
	        infoWindows.splice(index, 1);
	      }
	    });
	  },

	  getIsOpen: function() {
	    return this._isOpen;
	  },

	  /**
	   * @function setContent
	   * @content {String|htmlDOM} content
	   * */
	  setContent: function(content) {
	    this._inner.setContent(content);
	  },

	  getContent: function() {
	    return this._inner.getContent();
	  },

	  setPosition: function(lngLat) {
	    this._inner.setPosition(lngLat);
	  },

	  getPosition: function() {
	    return this._inner.getPosition();
	  },

	  // todo: google 不支持
	  setSize: function(size) {

	  },

	  // todo: google 不支持
	  getSize: function() {

	  },

	  on: onOff.on,
	  off: onOff.off
	};



	module.exports = InfoWindow;





/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @constructor Polyline
	 */

	var obc = __webpack_require__(22);
	var onOff = __webpack_require__(16);
	var formatOpts = __webpack_require__(20);

	/**
	 * @constructor
	 * @opts {Object} options
	 * @return an object, inner is prime google map Polyline instance.
	 * */
	function Polyline(opts) {
	  this._type = 'Polyline';
	  obc.addOverlay(opts, this);

	  var newOpts = formatOpts.polyline(opts);
	  this._inner = new google.maps.Polyline(newOpts);
	  // this._inner._self = this;
	}

	Polyline.prototype = {
	  setPath: function() {},
	  getPath: function() {},
	  setOptions: function() {},
	  getOptions: function() {},
	  getLength: function() {},

	  getBounds: function() {},

	  hide: obc.hide,
	  show: obc.show,
	  setMap: obc.setMap,

	  /**
	   * @ext {any} extData
	   * */
	  setExtData: function(ext) {
	    this._inner.extDate = ext;
	  },

	  getExtData: function() {
	    return this._inner.extDate;
	  },

	  on: onOff.on,
	  off: onOff.off
	};

	var PolylineEventMap = {

	};

	module.exports = Polyline;





/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @constructor Polygon
	 */

	// var event = require('./event');
	var onOff = __webpack_require__(16);
	var formatOpts = __webpack_require__(20);
	var obc = __webpack_require__(22);

	/**
	 * @constructor
	 * @param {Object} opts
	 * @return an object, inner is prime google map Polygon instance.
	 * */
	function Polygon(opts) {
	  this._type = 'Polygon';
	  obc.addOverlay(opts, this);

	  var newOpts = formatOpts.polygon(opts);
	  this._inner = new google.maps.Polygon(newOpts);

	}

	Polygon.prototype = {

	  setMap: obc.setMap,

	  /**
	   * @param {path:Array LngLat | Array lngLat} path
	   * */
	  setPath: function(path) {
	    this._inner.setPath( path );
	  },
	  getPath: function() {},

	  setOptions: function() {
	    this._inner.setOptions( formatOpts.polygon(opts) );
	  },

	  getOptions: function() {},

	  getBounds: function() {},

	  getArea: function() {},

	  hide: obc.hide,

	  show: obc.show,



	  /**
	   * @param {any} ext extData
	   * */
	  setExtData: function(ext) {
	    this._inner.extDate = ext;
	  },

	  getExtData: function() {
	    return this._inner.extDate;
	  },

	  /**
	   * @function judge whether a point in the polygon inner
	   * @param {LngLat} point
	   * */
	  contains: function(point) {

	  },

	  on: onOff.on,
	  off: onOff.off
	};

	module.exports = Polygon;





/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @constructor Circle
	 */

	// var event = require('./event');
	var onOff = __webpack_require__(16);
	var formatOpts = __webpack_require__(20);
	var obc = __webpack_require__(22);
	var LngLat = __webpack_require__(10);

	/**
	 * @constructor
	 * @opts {Object} opts
	 * @return an object, inner is prime google map Circle instance.
	 * */
	function Circle(opts) {
	  this._type = 'Circle';
	  obc.addOverlay(opts, this);

	  var newOpts = formatOpts.circle(opts);
	  this._inner = new google.maps.Circle(newOpts);
	}

	Circle.prototype = {

	  setMap: obc.setMap,

	  setCenter: function(center) {
	    this._inner.setCenter(center);
	  },

	  getCenter: function() {
	    return new LngLat(' ',' ',this._inner.getCenter());
	  },

	  getBounds: function() {

	  },

	  /**
	   * @param {Number} radius
	   * */
	  setRadius: function(radius) {
	    this._inner.setRadius(radius);
	  },

	  getRadius: function() {
	    return this._inner.getRadius();
	  },

	  setOptions: function() {
	    this._inner.setOptions( formatOpts.polygon(opts) );
	  },

	  getOptions: function() {},

	  getArea: function() {},

	  hide: obc.hide,

	  show: obc.show,

	  /**
	   * @ext {any} extData
	   * */
	  setExtData: function(ext) {
	    this._inner.extDate = ext;
	  },

	  getExtData: function() {
	    return this._inner.extDate;
	  },

	  /**
	   * @function judge whether a point in the polygon inner
	   * @point {LngLat}
	   * @return {Boolean} true or false
	   * */
	  contains: function(point) {

	  },

	  on: onOff.on,
	  off: onOff.off
	};

	var CircleEventMap = {

	};

	module.exports = Circle;





/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/15.
	 */

	var formatOpts = __webpack_require__(20);
	var obc = __webpack_require__(22)

	/**
	 * @constructor
	 * @map {Map.Object}
	 * @marker {Marker}
	 * @opts {MarkerClustererOptions}
	 * */
	function Clusterer(map, markers, opts) {
	  if(markers.length < 1) return;

	  this._type = 'MarkerClusterer';
	  obc.addOverlay({map: map}, this);

	  var newOpts = formatOpts.markerClusterer(map, markers, opts);
	  this._inner = new MarkerClusterer(newOpts.map, newOpts.markers, newOpts.opts);
	  this._inner._smap = map;
	}

	Clusterer.prototype = {
	  getSize: function() {},

	  setMap: obc.setMap,

	  getMap: function() {
	    return this._inner.getMap();
	  },

	  addMarker: function() {},
	  removeMarker: function() {},

	  /**
	   * @param {Array} styles
	   * */
	  setStyles: function(styles) {

	  }
	};

	module.exports = Clusterer;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 */

	var LngLat = __webpack_require__(29);
	var Bounds = __webpack_require__(30);
	var Pixel = __webpack_require__(31);
	var Size = __webpack_require__(32);
	var Map = __webpack_require__(33);
	var Marker = __webpack_require__(39);
	var event = __webpack_require__(35);
	var InfoWindow = __webpack_require__(41);
	var Polyline = __webpack_require__(42);
	var Polygon = __webpack_require__(43);
	var Circle = __webpack_require__(44);
	var MarkerClusterer = __webpack_require__(45);

	var DMap = {};

	DMap.event = event;

	DMap.LngLat = LngLat;
	DMap.Bounds = Bounds;
	DMap.Pixel = Pixel;
	DMap.Size = Size;

	DMap.Map = Map;
	DMap.Marker = Marker;
	DMap.InfoWindow = InfoWindow;
	DMap.Polyline = Polyline;
	DMap.Polygon = Polygon;
	DMap.Circle = Circle;
	DMap.MarkerClusterer = MarkerClusterer;

	module.exports = window.DMap = DMap;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @constructor LngLat
	 * @attention 百度地图没有LngLat这个基础类，而是叫Point类。
	 */

	var util = __webpack_require__(8);

	/**
	 * @constructor
	 * @lng {Number} lng
	 * @lat {Number} lat
	 * */
	function LngLat(lng, lat, inner) {

	  // 包装现有实例模式。BMap的LngLat结构，这个传进来的inner是百度地图的Point实例。
	  if(inner) {
	    this._inner = inner;
	  }

	  // 构造函数模式
	  else {
	    if(arguments.length < 2) {

	      // 数组形式，前者为lng，后者为lat [116.397428, 39.90923] -- position
	      if(util.isArray(lng)){
	        // 数组里面的元素为String
	        if( typeof lng[0] === 'string' || typeof lng[1] === 'string' ) {
	          this.lng = parseFloat(lng[0]);
	          this.lat = parseFloat(lng[1]);
	        }

	        // 数组里面的元素为Number
	        else {
	          this.lng = lng[0];
	          this.lat = lng[1];
	        }
	      }

	      // 对象形式，lng对应lng，lat对应lat (lng: 116.397428, lat: 39.90923)
	      else {
	        this.lng = lng.lng;
	        this.lat = lng.lat;
	      }
	    }

	    // 对象字面量
	    else {

	      // ("116.403322", "39.920255") string
	      if(util.isString(lng) || util.isString(lat)) {
	        this.lng = parseFloat(lng);
	        this.lat = parseFloat(lat);
	      }

	      // (116.403322, 39.920255) Number
	      else {
	        this.lng = lng;
	        this.lat = lat;
	      }
	    }

	    this._inner = new BMap.Point(this.lng, this.lat);
	  }

	  this._type = 'LngLat';
	}

	LngLat.prototype = {
	  /**
	   * @todo 百度地图模拟lnglat的offset
	   * @function offset
	   * @param {Number} w
	   * @param {Number} s
	   * */
	  offset: function(w, s) {

	  },

	  // TODO:百度地图没有这个功能
	  distance: function() {

	  },

	  getLng: function() { return this._inner.lng; },
	  getLat: function() { return this._inner.lat; },
	  getlng: function() { return this._inner.lng; },
	  getlat: function() { return this._inner.lat; },

	  /**
	   * @function 判断两个点是否相等
	   * @param {LngLat} point
	   * @return Boolean
	   * */
	  equals: function(point) {
	    return this._inner.equals(point._inner);
	  },

	  toString: function() {
	    return this._inner.toString();
	  }
	};

	module.exports = LngLat;





/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/15.
	 * @name Bounds 基础类
	 * 在Google Map里面对应LatLngBounds Class
	 * https://developers.google.com/maps/documentation/javascript/3.exp/reference#LatLngBounds
	 */

	var LngLat = __webpack_require__(29);
	var util = __webpack_require__(8);

	/**
	 * @constructor
	 * @sw {LngLat} southWest 西南角坐标
	 * @ne {LngLat} northEast 东北角坐标
	 * */
	function Bounds(sw, ne, inner) {

	  if(util.isArray(sw)) {
	    sw = new LngLat(sw);
	    ne = new LngLat(ne);
	  }

	  if(inner) {
	    this._inner = inner;
	  } else {
	    // 输入SMap.LngLat实例
	    if(sw._type){
	      this._inner = new BMap.Bounds(sw._inner, ne._inner);
	    }
	    // 输入{lng, lat}
	    else {
	      this._inner = new BMap.Bounds(sw, ne);
	    }
	  }

	  this._type = 'Bounds';
	}

	Bounds.prototype = {
	  /**
	   * @public
	   * @param {LngLat} point
	   * */
	  contains: function(point) {
	    return this._inner.contains(point._inner);
	  },

	  getCenter: function() {
	    return new LngLat('', '', this._inner.getCenter());
	  },

	  getSouthWest: function() {
	    return new LngLat('', '', this._inner.getSouthWest());
	  },
	  getNorthEast: function() {
	    return new LngLat('', '', this._inner.getNorthEast());
	  },
	  toString: function() {
	    return this._inner.toString();
	  }
	};

	module.exports = Bounds;


/***/ },
/* 31 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/15.
	 * @constructor Pixel
	 * 在google map里面对应的是Point
	 * https://developers.google.com/maps/documentation/javascript/reference#Point
	 */


	/**
	 * @constructor
	 * @param {Number} x
	 * @param {Number} y
	 * */
	function Pixel(x, y, inner) {
	  if(inner) {
	    this._inner = inner;
	  } else {
	    this._inner = new BMap.Pixel(x,y);
	  }

	  this._type = 'Pixel';
	}

	Pixel.prototype = {
	  getX: function() {
	    return this._inner.x;
	  },
	  getY: function() {
	    return this._inner.y;
	  },

	  /**
	   * @param {Pixel} point
	   * */
	  equals: function(point) {
	    return this._inner.equals(point._inner);
	  },

	  toString: function() {
	    return this._inner.toString();
	  }
	};




	module.exports = Pixel;


/***/ },
/* 32 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/15.
	 */

	/**
	 * @constructor
	 * @param {Number} width
	 * @param {Number} height
	 * */
	function Size(width, height, inner) {
	  if(inner) {
	    this._inner = inner;
	  } else {
	    // 百度的Size 没有getWidth和getHeight两个方法
	    // 这里自己加上
	    this._width = width;
	    this._height = height;

	    this._inner = new BMap.Size(width, height);
	  }

	  this._type = 'Size';
	  return this;
	}

	Size.prototype = {
	  getWidth: function() {
	    return this._width;
	  },
	  getHeight: function() {
	    return this._height;
	  },
	  // TODO 百度没有这个toString
	  toString: function() {
	    return this._inner.toString();
	  }
	};

	module.exports = Size;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizzstack@gmail.com on 2017/2/13.
	 * @constructor of Map
	 * @return our map object
	 *
	 * @attention 百度地图已经占掉了BMap这个顶级命名空间了，所以这里我们使用DMap来命名我们的顶级空间
	 */

	var config = __webpack_require__(15);
	var Bounds = __webpack_require__(30);
	var onOff = __webpack_require__(34);
	var formatOpts = __webpack_require__(38);

	/**
	 * @constructor
	 * @param {HTMLElement} id
	 * @param {Object} opts
	 * */
	function Map(id,opts) {
	  var elem, newOpts = {};

	  this._type = 'Map';

	  if(opts) {
	    newOpts = formatOpts.map(opts);
	  }

	  this._inner = new BMap.Map(id, newOpts);

	  this._init(newOpts);

	  this._inner._smap = this;

	  this._overLayers = {
	    MarkerClusterer: [],
	    Marker: [],
	    InfoWindow: [],
	    Polygon: [],
	    Polyline: [],
	    Circle: []
	  };
	}

	Map.prototype = {
	  /**
	   * 百度Map方法调用之后需要
	   * 调用centerAndZoom来进行初始化
	   * @param {object} opts
	   */
	  _init: function(opts) {
	    if(opts.center) {
	      if(opts.zoom) {
	        this._inner.centerAndZoom(opts.center, opts.zoom);
	      }
	    }

	    this._inner.enableScrollWheelZoom();
	  },

	  plugin : mapPlugin,

	  setFitView: function() {

	  },

	  clearMap: clearMap,

	  clearInfoWindow: function() {
	    var iws = this._overLayers.InfoWindow;
	    iws.forEach( function(item) {
	      item._inner.hide();
	    })
	  },

	  /**
	   * @param {LngLat} position
	   * */
	  panTo: function(position) {
	    this._inner.panTo(position._inner);
	  },


	  /**
	   * @param {Number} zoom
	   * */
	  setZoom: function(zoom) {
	    this._inner.setZoom(zoom);
	  },

	  getBounds: function() {
	    return new Bounds('','',this._inner.getBounds());
	  },

		/**
	   * @param {Bounds} bounds
	   * */
	  setBounds: function(bounds) {
	    var self = this;
	    if(typeof BMapLib.AreaRestriction === 'undefined') {
	      console.warn('您还没有引入 BMapLib.AreaRestriction 哦~');
	    }
	    BMapLib.AreaRestriction.setBounds(self._inner, bounds._inner);
	  },

	  on: onOff.on,
	  off: onOff.off
	};

	/**
	 * @public
	 *
	 * @param {Array} plugins
	 * @param {Function} fn callback function
	 * */
	function mapPlugin(plugins, fn) {
	  if(plugins.length < 1) return;

	  plugins.forEach( function(plugin) {
	    if(plugin === 'DMap.MarkerClusterer') {
	      // 这里改为在使用百度地图之前加载插件代码
	      // 因为原来的业务代码中有同步代码，如果使用getScript异步加载，会导致错误发生
	      fn();
	    }
	    if(plugin === 'DMap.MarkerClusterer') {}
	  })
	}

	function clearMap() {
	  var self = this;
	  var overLayers = this._overLayers;

	  for(var type in overLayers) {

	    switch (type) {
	      case 'Marker':
	      case 'Circle':
	      case 'Polygon':
	      case 'Polyline':
	      case 'InfoWindow':
	        if(overLayers[type].length > 0) {
	          overLayers[type].forEach( function(item) {
	            item._inner.hide();
	            // self._inner.removeOverlay(item._inner);
	          });
	          // overLayers.lenght = 0;
	        }
	        break;
	      case 'MarkerClusterer':
	        if(overLayers.MarkerClusterer.length > 0) {
	          overLayers.MarkerClusterer.forEach( function(item) {
	            item._inner.clearMarkers();
	            // self._inner.removeOverlay(item._inner);
	            // item._inner = null;
	            // item = null;
	          });
	          // overLayers.MarkerClusterer.length = 0;
	        }
	        break;
	    }

	  }
	}

	module.exports = Map;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/14.
	 * @onOff 基类，覆盖物的实例都具有on和off方法，都直接来自于此
	 */

	var event = __webpack_require__(35);
	var onOff = {};

	/**
	 * @function addEventListener 的简便方法
	 *
	 * @param {String} eventName 事件名称
	 * @param {Function} handler 回调函数
	 * @param {Object} context 上下文
	 * */
	onOff.on = function(eventName, handler, context) {
	  var listener, eventListener;

	  listener = event.addListener(this, eventName, handler, context);

	  eventListener = {
	    eventName: eventName,
	    handler: handler,
	    context: context,
	    listener: listener
	  };

	  if(!this._eventListener) this._eventListener = [];

	  this._eventListener.push(eventListener);
	  return listener;
	};

	/**
	 * @function
	 * @param {String} eventName 事件名称
	 * @param {Function} handler 回调函数
	 * @param {Object} context 上下文
	 *
	 * @attention 要想移除对应的事件，必须保证eventName，handler，context一致。
	 * */
	onOff.off = function(eventName, handler, context) {
	  if(!this._eventListener) return;

	  var filterResult = this._eventListener.filter( function(item, index) {
	    if(eventName === item.eventName) return true;
	    return false;
	  });

	  if(filterResult && filterResult.length > 0) {
	    filterResult.forEach( function(item) {
	      if( item.handler === handler &&
	        item.context === context ) {
	        event.removeListener(item.listener);
	      }
	    })
	  }

	};

	module.exports = onOff;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/14.
	 * @event base Object
	 *
	 * @attention 百度的事件绑定非常简单，只有两个：addEventListener和removeEventListener
	 * @BMapLib EventWrapper()
	 * @url: http://api.map.baidu.com/library/EventWrapper/1.2/docs/symbols/BMapLib.EventWrapper.html
	 */

	var SMapEvent = __webpack_require__(36);

	var event = {};

	event.map = __webpack_require__(37);

	event.listeners = [];

	event.getSMapEvent = function(e) {
	  return new SMapEvent(e);
	};

	/**
	 * @function
	 * @param {Object} instance DOM对象
	 * @param {String} eventName 事件名
	 * @param {Function} handler 事件处理函数
	 * @param {Object} context 上下文
	 * @return 返回一个 EventListener 对象实例
	 * */
	event.addDomListener = function(instance, eventName, handler, context) {
	  var callback;

	  if(context) {
	    callback = event._createCallback(handler, context);
	  } else {
	    callback = handler;
	  }

	  if(instance.addEventListener) {
	    instance.addEventListener(eventName, callback, false);
	  }
	  else if( instance.attachEvent ) {
	    instance.attachEvent('on' + eventName, callback);
	  }
	  else {
	    instance['on' + eventName] = callback;
	  }

	  return new MapsEventListener(instance, eventName, handler, context, MapsEventListener.DOM_EVENT, callback);
	};

	event._createCallback = function(handler, context) {
	  if(context) {
	    return function (e) {
	      console.log('event Object', e);
	      handler.call(context, event.getSMapEvent(e));
	    };
	  }
	  else {
	    return function (e) {
	      // console.log(e);
	      handler(event.getSMapEvent(e));
	    };
	  }
	};

	event.addListener = function(instance, eventName, handler, context) {
	  if(!instance._inner) return;

	  var realInstance = instance._inner,
	      relevantEvent = event.getRelevantEvent(instance, eventName),
	      callback;

	  if(context) {
	    // 这个addEventListener是百度地图自己提供的那个绑定事件API
	    callback = event._createCallback(handler, context);
	    if(!realInstance.addEventListener) {return;}
	    realInstance.addEventListener(relevantEvent, callback);
	  }
	  else {
	    callback = event._createCallback(handler);
	    realInstance.addEventListener(relevantEvent, callback);
	  }

	  return new MapsEventListener(instance, eventName, handler, context, MapsEventListener.MAP_EVENT, callback);
	};

	event.addListenerOnce = function(instance, eventName, handler, context) {
	  var listener = event.addListener(instance, eventName, function(){
	    event.removeListener(listener);
	    return handler.apply(this, arguments);
	  }, context);
	  return listener;
	};

	/**
	 * @function 移除特定的事件监听函数
	 * @param {MapsEventListener} listener
	 * @return none
	 * */
	event.removeListener = function(listener) {
	  var instance = listener._instance,
	      eventName = listener._eventName,
	      handler = listener._handler,
	      context = listener._context,
	      callback = listener._callback,
	      listeners = instance._e_ || {};

	  for( var i in listeners ) {
	    if( listeners[i]._guid == listener._guid) {
	      // DOM事件, instance 对应的是DOM对象
	      if(listener._eventType == MapsEventListener.DOM_EVENT) {
	        if(instance.removeEventListener) {
	          instance.removeEventListener(eventName, handler, false);
	        }
	        else if (instance.detachEvent) {
	          instance.detachEvent('on' + eventName, handler);
	        }
	        else {
	          instance['on' + eventName] = null;
	        }
	      }
	      else if (listener._eventType == MapsEventListener.MAP_EVENT) {
	        if(callback) {
	          instance._inner.removeEventListener(eventName, callback);
	        }
	        else {
	          instance._inner.removeEventListener(eventName, handler);
	        }
	      }

	      delete listeners[i];
	    }
	  }
	};

	event.trigger = function(instance, eventName, extArgs) {
	  var listeners = instance._e_ || {};
	  for(var i in listeners) {
	    if(listeners[i].eventName == eventName) {
	      var args = Array.prototype.slice.call(arguments, 2);
	      listeners[i]._handler.apply(instance, args);
	    }
	  }
	};

	/**
	 * @constructor
	 * @param {HTMLElement} instance DOM 元素
	 * @param {String} eventName
	 * @param {Function} handler
	 * @param {Object} context
	 * @param {String||Number} eventType
	 * @return mapsEventListener object
	 * */
	function MapsEventListener(instance, eventName, handler, context, eventType, callback) {
	  this._instance = instance;
	  this._eventName = eventName;
	  this._handler = handler;
	  this._context = context;
	  this._callback = callback;
	  this._eventType = eventType;
	  this._guid = MapsEventListener._guid++ ;
	  this._instance._e_ = this._instance._e_ || {};
	  this._instance._e_[this._guid] = this;
	}

	MapsEventListener._guid = 1;
	MapsEventListener.DOM_EVENT = 1;
	MapsEventListener.MAP_EVENT = 2;
	event._MapsEventListener = MapsEventListener;

	/**
	 * @function 输入高德事件名，返回对应的百度事件名
	 * @param {DomObject} instance
	 * @param {String} eventName
	 * @return eventName
	 * */
	event.getRelevantEvent = function(instance, eventName) {
	  if(instance._type in event.map) {
	    if(eventName in event.map[instance._type]) {
	      return event.map[instance._type][eventName];
	    } else {
	      return eventName;
	    }
	  } else {
	    return eventName;
	  }
	};

	module.exports = event;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/20.
	 * @Class for BMap map event Object.
	 * 包装百度事件对象
	 */

	var LngLat = __webpack_require__(29);
	var Pixel = __webpack_require__(31);

	/**
	 * 包装Google的事件触发时的event对象
	 *
	 * @constructor
	 * @param {Object} e event object
	 * */
	function SMapEvent(e) {

	  this._inner = e;
	  this._type = 'Event';
	  this.target = e.target;

	  if(e.pixel) {
	    this.pixel = new Pixel(e.pixel.x, e.pixel.y);
	  }
	  if(e.point) {
	    this.lnglat = new LngLat(e.point.lng, e.point.lat);
	    this.lnglat.I = e.point.lng;
	    this.lnglat.L = e.point.lat;
	  }
	  // TODO: 百度event对象的overlay怎么用
	  if(e.overlay) {

	  }
	  // TODO: 百度event对象的zoom也没什么用吧
	  if(e.zoom) {

	  }
		// TODO: 百度event对象的spots也没什么用吧
	  if(e.spots) {

	  }
	}

	module.exports = SMapEvent;


/***/ },
/* 37 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/16.
	 * @Module 高德地图和百度地图之间的映射
	 * 因为高德地图和百度地图之间的事件名可能有些不同，因此需要对事件进行事件映射
	 */

	module.exports = {
	  Marker: {
	    click: 'click'

	  },

	  InfoWindow: {

	  }
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/14.
	 */

	var LngLat = __webpack_require__(29);

	module.exports = {

	  map: formatOptsUni,

	  infoWindow: formatOptsUni,

	  marker: formatOptsUni,

	  polyline: formatOptsUni,

	  polygon: formatOptsUni,

	  circle: formatOptsUni,

	  markerClusterer: formatMarkerClusterer,

	  path: canvertPath
	};

	function formatOptsUni(opts) {
	  if(!opts) return;

	  if(typeof opts.position != 'undefined') {
	    opts.position = (new LngLat(opts.position))._inner;
	  }

	  if(opts.path) {
	    opts.path = transfromPathToPaths(opts.path);
	  }

	  if(opts.center) {
	    opts.center = (new LngLat(opts.center))._inner;
	  }

	  if(opts.map) {
	    opts.smap = opts.map;
	    opts.map = opts.map._inner;
	  }

	  return opts;
	}

	function transfromPathToPaths(path) {
	  var paths = [];
	  path.forEach( function(item, index) {
	    paths.push(arrCreateLngLat(item));
	  });
	  return paths;
	}

	function arrCreateLngLat(arr) {
	  return new BMap.Point( parseFloat(arr[0]), parseFloat(arr[1]) );
	}


	/**
	 * @transfer
	 * @param {MapObject} map
	 * @param {Array} markers
	 * @param {Object} opts
	 *
	 * @return {Object}
	 *
	 *   newOpts
	 *     .map map._inner
	 *     .opts{
	 *       markers:
	 *       styles:
	 *     }
	 *
	 *   *"<b>styles</b>":{Array<IconStyle>} 一组图标风格。单个图表风格包括以下几个属性：<br />
	 *   url	{String}	 图片的url地址。(必选)<br />
	 *   size {Size}	图片的大小。（必选）<br />
	 *   anchor {Size} 图标定位在地图上的位置相对于图标左上角的偏移值，默认偏移值为图标的中心位置。（可选）<br />
	 *   offset {Size} 图片相对于可视区域的偏移值，此功能的作用等同于CSS中的background-position属性。（可选）<br />
	 *   textSize {Number} 文字的大小。（可选，默认10）<br />
	 *   textColor {String} 文字的颜色。（可选，默认black）<br />
	 * */
	function formatMarkerClusterer(map, markers, opts) {
	  var newOpts = {};

	  if(map._inner) {
	    newOpts.map = map._inner;
	  } else {
	    newOpts.map = map;
	  }

	  newOpts.opts = formatMarkerClustererOpts(opts);

	  console.log(newOpts.opts);

	  newOpts.opts.markers = markers.map( function(item) {
	    return item._inner;
	  });

	  return newOpts;
	}

	/**
	 * @param {Object} opts
	 * @diff : 百度 anchor 对应 imageOffset
	 * */
	function formatMarkerClustererOpts(opts) {
	  if(opts.styles) {
	    var styles = opts.styles;
	    styles.forEach(function(item) {
	      if(item.imageOffset) {
	        item.anchor = item.imageOffset;
	      }
	      if(item.size) {
	        item.size = item.size._inner;
	      }
	    })
	  }
	  return opts;
	}

	function canvertPath(path) {
	  // TODO: 如何处理这个path还未定
	  return path;
	}


	// var flightPlanCoordinates = [
	//   {lat: 37.772, lng: -122.214},
	//   {lat: 21.291, lng: -157.821},
	//   {lat: -18.142, lng: 178.431},
	//   {lat: -27.467, lng: 153.027}
	// ];

	// var lineArr = [
	//   [116.368904, 39.913423],
	//   [116.382122, 39.901176],
	//   [116.387271, 39.912501],
	//   [116.398258, 39.904600]
	// ];


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @author fizzstack@gmail.com on 2017/2/13.
	 * @Class Marker
	 * @options
	 * @高德： http://lbs.amap.com/api/javascript-api/reference/overlay#MarkerOptions
	 * @百度： http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_reference.html#a3b3
	 *
	 * @Marker的Options.label 高德有，百度没有。
	 *
	 */

	var obc = __webpack_require__(40);
	var onOff = __webpack_require__(34);
	var formatOpts = __webpack_require__(38);
	var LngLat = __webpack_require__(29);

	/**
	 * Represents a Marker
	 * @constructor
	 * @param {Object} opts
	 * @param {Object} inner
	 * @return an object, inner is prime google map Marker instance.
	 * */
	function Marker(opts, inner) {

	  this._type = 'Marker';
	  this._isInMapOverlay = false;

	  if(inner) {
	    this._inner = inner;
	  } else {
	    // 在opts转换之前就要判断添加overlay
	    obc.addOverlay(opts, this);

	    var newOpts = formatOpts.marker(opts);

	    this._inner = new BMap.Marker(newOpts.position, newOpts);

	    this._init(newOpts);
	  }
	}

	Marker.prototype = {
	  _init: obc._init,
	  setMap: obc.setMap,
	  getMap: obc.getMap,
	  hide: obc.hide,
	  show: obc.show,

	  getPosition: function() {
	    return new LngLat('', '', this._inner.getPosition());
	  },

	  on: onOff.on,
	  off: onOff.off
	};

	module.exports = Marker;





/***/ },
/* 40 */
/***/ function(module, exports) {

	/**
	 * Created by fizz on 2017/2/17.
	 * @baseClass overlay 不可实例化的基类
	 */

	module.exports = {
	  setMap: function(map) {
	    if(map !== null) {
	      // console.log(this);
	      this._inner._smap = map;

	      if(!this._isInMapOverlay) {
	        map._overLayers[this._type].push(this);
	        this._isInMapOverlay = true;
	      }

	      map._inner.addOverlay( this._inner );
	    } else {
	      map._inner.removeOverlay( this._inner );
	    }
	  },

	  getMap: function() {
	    return this._inner._smap;
	  },

	  hide: function() {
	    this._inner.hide();
	  },

	  show: function() {
	    this._inner.show();
	  },

	  addOverlay: function(opts, self) {
	    if('map' in opts) {
	      if(!self._isInMapOverlay) {
	        opts.map._overLayers[self._type].push(self);
	        self._isInMapOverlay = true;
	      }
	    }
	  },

	  _init: function(opts){
	    if(opts.smap) {
	      this._inner._smap = opts.smap;
	      opts.smap._inner.addOverlay( this._inner );
	    }
	  }
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/14.
	 * @constructor InfoWindow
	 *
	 * 高德有 change 事件，百度没有
	 */
	var onOff = __webpack_require__(34);
	var formatOpts = __webpack_require__(38);
	var obc = __webpack_require__(40);
	var LngLat = __webpack_require__(29);

	/**
	 * @constructor
	 * @param {Object} opts
	 * */
	function InfoWindow(opts) {
	  this._type = 'InfoWindow';
	  // 当实例被添加到Map对象的时候，会被设为true
	  this._isInMapOverlay = false;

	  obc.addOverlay(opts, this);

	  var newOpts = formatOpts.infoWindow(opts);
	  this._inner = new BMap.InfoWindow(newOpts.content, newOpts);

	  // 保存一下opts，百度地图中InfoWindow没有getOpts这个函数，此处为自己模拟
	  this._opts = newOpts;
	}

	InfoWindow.prototype = {
	  /**
	   * @function open a infoWindow in the position
	   * @param {Map} map required
	   * @param {LngLat} pos lngLat
	   * */
	  open: function(map, pos) {
	    if(pos) {
	      map._inner.openInfoWindow(this._inner, pos._inner);
	    } else {
	      map._inner.openInfoWindow(this._inner, new LngLat(this._opts.position)._inner);
	    }

	    this._inner._smap = map;
	    this._isOpen = true;

	    if(!this._isInMapOverlay) {
	      map._overLayers.InfoWindow.push(this);
	    }
	  },

	  close: function() {
	    this._inner.hide();
	    this._isOpen = false;
	  },

	  getIsOpen: function() {
	    return this._inner.isOpen();
	  },

	  /**
	   * @function setContent
	   * @content {String|htmlDOM} content
	   * */
	  setContent: function(content) {
	    this._inner.setContent(content);
	  },

	  getContent: function() {
	    return this._inner.getContent();
	  },

	  setPosition: function(lngLat) {
	    console.warn('啊哦，百度暂不支持这个API哦，详情请查看这里:' +
	      'http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_' +
	      'reference.html#a3b7');
	  },

	  getPosition: function() {
	    return new LngLat('', '', this._inner.getPosition());
	  },

	  // todo: 百度能支持setWidth 和 setHeight
	  setSize: function(size) {
	    console.warn('啊哦，百度暂不支持这个API哦，详情请查看这里:' +
	      'http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_' +
	      'reference.html#a3b7');
	  },

	  // todo: 百度 不支持
	  getSize: function() {
	    console.warn('啊哦，百度暂不支持这个API哦，详情请查看这里:' +
	      'http://lbsyun.baidu.com/cms/jsapi/reference/jsapi_' +
	      'reference.html#a3b7');
	  },

	  on: onOff.on,
	  off: onOff.off
	};



	module.exports = InfoWindow;





/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @constructor Polyline
	 *
	 * @diff:
	 * @zIndex 百度Polyline 没有zIndex这个属性，高德有
	 */

	var obc = __webpack_require__(40);
	var onOff = __webpack_require__(34);
	var formatOpts = __webpack_require__(38);
	var Bounds = __webpack_require__(30);

	/**
	 * @constructor
	 * @opts {Object} options
	 * @return an object, inner is prime google map Polyline instance.
	 * */
	function Polyline(opts) {
	  this._type = 'Polyline';
	  this._isInMapOverlay = false;
	  obc.addOverlay(opts, this);

	  var newOpts = formatOpts.polyline(opts);
	  this._inner = new BMap.Polyline(newOpts.path, newOpts);
	  this._init(newOpts);
	}

	Polyline.prototype = {
	  _init: obc._init,

	  /**
	   * @param {Array} path
	   * */
	  setPath: function(path) {
	    this._inner.setPath(formatOpts.path(path));
	  },

	  getPath: function() {
	    return this._inner.getPath();
	  },

	  // TODO： 百度没有setOptions
	  setOptions: function() {},
	  getOptions: function() {},

	  getLength: function() {},

	  getBounds: function() {
	    return new Bounds('', '', this._inner.getBounds());
	  },

	  hide: obc.hide,
	  show: obc.show,
	  setMap: obc.setMap,

	  /**
	   * @ext {any} extData
	   * */
	  setExtData: function(ext) {
	    this._inner.extDate = ext;
	  },

	  getExtData: function() {
	    return this._inner.extDate;
	  },

	  on: onOff.on,
	  off: onOff.off
	};

	var PolylineEventMap = {

	};

	module.exports = Polyline;





/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @constructor Polygon
	 */

	// var event = require('./event');
	var onOff = __webpack_require__(34);
	var formatOpts = __webpack_require__(38);
	var obc = __webpack_require__(40);

	/**
	 * @constructor
	 * @param {Object} opts
	 * @return an object, inner is prime google map Polygon instance.
	 * */
	function Polygon(opts) {
	  this._type = 'Polygon';
	  this._isInMapOverlay = false;
	  obc.addOverlay(opts, this);

	  var newOpts = formatOpts.polygon(opts);
	  this._inner = new BMap.Polygon(newOpts.path, newOpts);
	  this._init(newOpts);
	}

	Polygon.prototype = {
	  _init: obc._init,

	  setMap: obc.setMap,

	  /**
	   * @param {path:Array LngLat | Array lngLat} path
	   * */
	  setPath: function(path) {
	    this._inner.setPath( path );
	  },
	  getPath: function() {},

	  setOptions: function() {
	    this._inner.setOptions( formatOpts.polygon(opts) );
	  },

	  getOptions: function() {},

	  getBounds: function() {},

	  getArea: function() {},

	  hide: obc.hide,

	  show: obc.show,



	  /**
	   * @param {any} ext extData
	   * */
	  setExtData: function(ext) {
	    this._inner.extDate = ext;
	  },

	  getExtData: function() {
	    return this._inner.extDate;
	  },

	  /**
	   * @function judge whether a point in the polygon inner
	   * @param {LngLat} point
	   * */
	  contains: function(point) {

	  },

	  on: onOff.on,
	  off: onOff.off
	};

	module.exports = Polygon;





/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/13.
	 * @Class Circle
	 */

	// var event = require('./event');
	var onOff = __webpack_require__(34);
	var formatOpts = __webpack_require__(38);
	var obc = __webpack_require__(40);
	var LngLat = __webpack_require__(29);

	/**
	 * @constructor
	 * @param {Object} opts
	 * @return an object, inner is prime google map Circle instance.
	 * */
	function Circle(opts) {
	  this._type = 'Circle';
	  this._isInMapOverlay = false;
	  obc.addOverlay(opts, this);

	  var newOpts = formatOpts.circle(opts);
	  this._inner = new BMap.Circle(newOpts.center, newOpts.radius, newOpts);
	  this._opts = newOpts;
	  this._init(newOpts);
	}

	Circle.prototype = {
	  _init: obc._init,

	  setMap: obc.setMap,

	  setCenter: function(center) {
	    this._inner.setCenter(center);
	  },

	  getCenter: function() {
	    return new LngLat(' ',' ',this._inner.getCenter());
	  },

	  getBounds: function() {

	  },

	  /**
	   * @function 设置圆半径
	   * @param {Number} radius
	   * */
	  setRadius: function(radius) {
	    this._inner.setRadius(radius);
	  },

	  getRadius: function() {
	    return this._inner.getRadius();
	  },

	  /**
	   * @attention 百度地图没有直接的setOptions，此处为模拟
	   * @param {Object} opts
	   * */
	  setOptions: function(opts) {
	    this._inner.setOptions( formatOpts.polygon(opts) );
	  },

	  getOptions: function() {

	  },

	  hide: obc.hide,

	  show: obc.show,

	  /**
	   * @ext {any} extData
	   * */
	  setExtData: function(ext) {
	    this._inner.extDate = ext;
	  },

	  getExtData: function() {
	    return this._inner.extDate;
	  },

	  /**
	   * @TODO:
	   * @attention 百度没有这个API，可能需要自己模拟
	   *
	   * @function judge whether a point in the polygon inner
	   * @point {LngLat}
	   * @return {Boolean} true or false
	   * */
	  contains: function(point) {

	  },

	  on: onOff.on,
	  off: onOff.off
	};

	module.exports = Circle;





/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by fizz on 2017/2/15.
	 * @Class MarkerClusterer
	 */

	var formatOpts = __webpack_require__(38);
	var obc = __webpack_require__(40);

	/**
	 * @constructor
	 * @map {Map.Object}
	 * @marker {Marker}
	 * @opts {MarkerClustererOptions}
	 *
	 * @MarkerClustererOptions
	 * */
	function Clusterer(map, markers, opts) {
	  console.log(map, markers, opts);

	  this._isInMapOverlay = false;
	  this._type = 'MarkerClusterer';
	  obc.addOverlay({map: map}, this);

	  if(markers.length < 1) return;
	  var newOpts = formatOpts.markerClusterer(map, markers, opts);
	  this._inner = new BMapLib.MarkerClusterer(newOpts.map, newOpts.opts);
	  this._inner._smap = map;
	}

	Clusterer.prototype = {
	  getSize: function() {},

	  setMap: obc.setMap,

	  getMap: function() {
	    return this._inner.getMap();
	  },

	  addMarker: function() {},

	  removeMarker: function(test) {},

	  clearMarkers: function() {
	    this._inner.clearMarkers();
	  },

	  /**
	   * @param {Array} styles
	   * */
	  setStyles: function(styles) {

	  }
	};

	module.exports = Clusterer;


/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * @Module 动态文件加载器
	 * @core 一个类promise状态机
	 * */


	module.exports = (function() {

	  var group_queue  = [];      // group list

	  //// url_item = {url:str, start: false, finished：false}

	  var log = function(msg) {
	    return;
	    console.log(msg);
	  }

	  var isFunc = function(obj) {
	    return Object.prototype.toString.call(obj) == "[object Function]";
	  }

	  var isArray = function(obj) {
	    return Object.prototype.toString.call(obj) == "[object Array]";
	  }

	  var isAllStart = function(url_items) {
	    for (var idx=0; idx<url_items.length; ++idx) {
	      if (url_items[idx].start == false )
	        return false;
	    }
	    return true;
	  }

	  var isAnyStart = function(url_items) {
	    for (var idx=0; idx<url_items.length; ++idx) {
	      if (url_items[idx].start == true )
	        return true;
	    }
	    return false;
	  }

	  var isAllFinished = function(url_items) {
	    for (var idx=0; idx<url_items.length; ++idx) {
	      if (url_items[idx].finished == false )
	        return false;
	    }
	    return true;
	  }

	  var isAnyFinished = function(url_items) {
	    for (var idx=0; idx<url_items.length; ++idx) {
	      if (url_items[idx].finished == true )
	        return true;
	    }
	    return false;
	  }

	  var loadFinished = function() {
	    nextGroup();
	  };

	  var showGroupInfo = function() {
	    for (var idx=0; idx<group_queue.length; idx++) {
	      group = group_queue[idx];
	      if (isArray(group)) {
	        log('**********************');
	        for (var i=0; i<group.length; i++) {
	          log('url:     '+group[i].url);
	          log('start:   '+group[i].start);
	          log('finished:'+group[i].finished);
	          log('-------------------');
	        }
	        log('isAllStart: ' + isAllStart(group));
	        log('isAnyStart: ' + isAnyStart(group));
	        log('isAllFinished: ' + isAllFinished(group));
	        log('isAnyFinished: ' + isAnyFinished(group));
	        log('**********************');
	      }
	    }
	  };

	  var nextGroup = function() {
	    while (group_queue.length > 0) {
	      showGroupInfo();
	      // is Func
	      if (isFunc(group_queue[0])) {
	        log('## nextGroup: exec func');
	        group_queue[0]();  // exec
	        group_queue.shift();
	        continue;
	        // is Array
	      } else if (isAllFinished(group_queue[0])) {
	        log('## current group all finished');
	        group_queue.shift();
	        continue;
	      } else if (!isAnyStart(group_queue[0])) {
	        log('## current group no one start!');
	        loadGroup();
	        break;
	      } else {
	        break;
	      }
	    }
	  };

	  var loadError = function(oError) {
	    console.error("The script " + oError.target.src + " is not accessible.");
	  };

	  var loadScript = function(url_item) {
	    log("load "+url_item.url);
	    url = url_item.url;
	    url_item.start = true;
	    var script = document.createElement('script');
	    script.type = "text/javascript";

	    if (script.readyState){  //IE
	      script.onreadystatechange = function() {
	        if (script.readyState == "loaded" ||
	          script.readyState == "complete") {
	          script.onreadystatechange = null;
	          url_item.finished = true;
	          loadFinished();
	        }
	      };
	    } else {  //Others
	      script.onload = function(){
	        url_item.finished = true;
	        loadFinished();
	      };
	    }

	    script.onerror = loadError;

	    // script.src = url+'?'+'time='+Date.parse(new Date());
	    script.src = url;
	    document.body.appendChild(script);
	  };

	  var loadGroup = function() {
	    for (var idx=0; idx < group_queue[0].length; idx++) {
	      loadScript(group_queue[0][idx]);
	    }
	  };

	  var addGroup = function(url_array) {
	    log('add :' + url_array);
	    if (url_array.length > 0) {
	      group = [];
	      for (var idx=0; idx<url_array.length; idx++) {
	        url_item = {
	          url: url_array[idx],
	          start: false,
	          finished: false,
	        };
	        group.push(url_item);
	      }
	      group_queue.push(group);
	    }
	    nextGroup();
	  };

	  var addFunc = function(callback) {
	    callback && isFunc(callback) &&  group_queue.push(callback);
	    log(group_queue);
	    nextGroup();
	  };

	  var instanceAPI = {
	    /**
	     * @public 加载文件的方法
	     * */
	    load : function() {
	      addGroup([].slice.call(arguments));
	      return instanceAPI;
	    },

	    /**
	     * @public 加载文件完成，执行回调函数
	     * */
	    wait : function(callback) {
	      addFunc(callback);
	      return instanceAPI;
	    }
	  };

	  return instanceAPI;

	})();



/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by jesse on 2017/2/23.
	 */
	__webpack_require__(48);
	__webpack_require__(49);

/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * 命名大意：
	 * dom    用户定义承载树的dom
	 * html   树的html
	 * item   data的每一条,可以是node也可以是child
	 * child  树的叶子;子元素;成员
	 * node   树的节点;文件夹;部门
	 * layer  树的层级,包含同一层的item(node,child);
	 * _      带有下划线的是插件需要的方法属性，用户不需要使用
	 *
	 *
	 *
	 *
	 * 思路:
	 * 1.node的id和child的id可以重复,因为实际场景可能是两种数据比如,部门和人员.对于省份和城市可能本身就不会重复
	 * 2.选择数据,用户需要的结果是:1.所有child.2.node+child
	 * 3.is_trigger如果是true,是为input框设计的,会去读取input框的宽度作为自身的宽度
	 * 4.这里html的input显示的时候根据data决定是否check，
	 * 5.每次的点击input产生的变化是html变了，然后data也变。
	 * 6.4，5导致容易出错,但我觉得应该是根据操作data数据发生变化，变化完毕，统一一个方法决定html结构的变化，不过效率不一定更高
	 * 7.only_child为true必然不会node_merge
	 * 8.代码中还有一些根据标签(div,span)来做的判断,都不太靠谱
	 *
	 *
	 */

	;(function ($) {

	    window.xTree = function (opt) {
	        return new tree(opt);
	    };

	    var defOpt = {
	        dom: '',  //jqueryDom
	        is_trigger: false,  //是否需要触发? 否则直接显示
	        has_search: false,
	        only_child: true,//是否结果只要 child
	        node_merge: true,//结果只显示最上层  比如   中国被选中  四川,成都则不会显示  否则 每个被勾选的节点都显示
	        zIndex: 1,
	        choose: false,  //哪些是选中的？优先级高于data  {nodeId:[1,2,3],id:[1,2,3]}
	        // node_first:false,//是否需要节点排在前面  否则按照data的顺序
	        is_multi: true,//是否多选
	        expand: false, //是否展开，false、true、num  //todo expand
	        width: null,
	        maxHeight: 300,
	        data: [],//{id:1,name:'xx',nodeId:'0',is_node:true,is_check:false},
	        sel_ids: '',
	        onInit: function () {
	        },
	        onOpen: function () {
	        }, //触发时
	        onBeforeOpen: function () {
	        },
	        onClose: function (has_chg) {
	            //has_chg  是否发生变化
	        },
	        onCheck: function (item, dom, childrenItem) {
	            //item 点击的item
	            //dom 点击的dom
	            //childrenItem  所有影响的子节点
	        },
	        onCancel: function (item, dom, childrenItem) {
	        },
	        onChange: function (item, dom, childrenItem) {
	        }
	    };


	    var tree = function (opt) {
	        this._init(opt);
	        return this;
	        /**
	         * return {
	         *     'start':this.start,
	         *     'end':this.end
	         * };  //todo  这样会导致 this 没有 别的方法 到底 还是不能正常使用
	         */


	    };


	    /**
	     *
	     * @var opt  用户传进来的option
	     * @var dom 打开tree的载体jquery dom
	     * @var data  做tree的data
	     * @var html tree的html
	     */


	    tree.prototype = {
	        _is_open: false,  //是否open
	        _originId: {nodeId: [], id: []},   //上次打开时候选中了哪一些id
	        _searchTimer: '',   //搜索框的定时器
	        _is_first: true,  //是不是第一次打开
	        _init: function (opt) {
	            var res = checkData(opt.data);
	            if (!res) {
	                return false;
	            }

	            this.opt = $.extend(true, {}, defOpt, opt);
	            this.data = _initData(this.opt.data);
	            this.rootId = _getRootId(this.data);
	            if (this.opt.sel_ids) {
	                _selData(this.data, this.opt.sel_ids);
	            }

	            this._originId = this.getId();

	            this.dom = this.opt.dom;
	            this.dom.css({'position': 'relative'});
	            this.html = this._makePanel();

	            this.opt.onInit();

	            var that = this;

	            if (this.opt.is_trigger) {
	                this.dom.off('click.xTree');
	                this.dom.on('click.xTree', function (e) {
	                    $('.xTreePanel').hide();
	                    that.start();
	                    e.stopPropagation();
	                });
	                $(document).on('click.xTree', function () {
	                    that.end();
	                });
	            } else {
	                this.start();
	            }
	        },

	        /**
	         *      方法
	         *
	         */
	        start: function () {
	            this.opt.onBeforeOpen();
	            this._showPanel();
	            this._showData();
	            this._expand();
	            this._is_open = true;

	            this.html.find('.x-tree-search').focus();
	            this.opt.onOpen();
	            return this;
	        },
	        end: function () {
	            if (this._is_open) {
	                this.html.hide();
	                var ids = this.getId();

	                this._is_open = false;
	                this.opt.onClose(JSON.stringify(ids) !== JSON.stringify(this._originId));
	                this._originId = ids;
	            }
	        },

	        getName: function () {
	            var text = [];
	            var data = this.data;
	            if (this.opt.only_child) {
	                $.each(data, function (i, n) {
	                    if (n.is_check && !n.is_node) {
	                        text.push(n.name);
	                    }
	                });
	            } else {
	                if (this.opt.node_merge) {
	                    var nodes = [];
	                    $.each(data, function (i, n) {
	                        if (n.is_check && n.is_node) {
	                            nodes.push(n.id);
	                        }
	                    });

	                    var clone = $.extend(true, [], data); //直接赋值传的是引用
	                    $.each(clone, function (i, n) {
	                        if ((n.is_check && $.inArray(n.nodeId, nodes) != -1) || !n.is_check) {
	                            clone[i] = null;
	                        }
	                    });

	                    $.each(clone, function (i, n) {
	                        if (n) {
	                            text.push(n.name);
	                        }
	                    });
	                } else {
	                    $.each(data, function (i, n) {
	                        if (n.is_check) {
	                            text.push(n.name);
	                        }
	                    });
	                }
	            }

	            return text.join();
	        },
	        getId: function () {
	            var id = [];
	            var nodeId = [];
	            var data = this.data;

	            if (this.opt.only_child) {
	                $.each(data, function (i, n) {
	                    if (n.is_check && !n.is_node) {
	                        id.push(n.id);
	                    }
	                });

	            } else {

	                if (this.opt.node_merge) {
	                    var node = [];
	                    $.each(data, function (i, n) {
	                        if (n.is_check && n.is_node) {
	                            node.push(n.id);
	//                            text.push( n.name);  //nodefirst
	                        }
	                    });

	                    var clone = $.extend(true, [], data);
	                    $.each(clone, function (i, n) {
	                        if ((n.is_check && $.inArray(n.nodeId, node) != -1) || !n.is_check) {
	                            clone[i] = null;
	                        }
	                    });


	                    $.each(clone, function (i, n) {
	                        if (n) {
	                            if (n.is_node) {
	                                nodeId.push(n.id);
	                            } else {
	                                id.push(n.id);
	                            }
	                        }
	                    });
	                } else {
	                    $.each(data, function (i, n) {
	                        if (n.is_check) {
	                            if (n.is_node) {
	                                nodeId.push(n.id);
	                            } else {
	                                id.push(n.id);
	                            }
	                        }
	                    });
	                }


	                id = {'id': id, 'nodeId': nodeId};
	            }
	            return id;
	        },
	        cancelItem: function (id, type) {
	            var item = {};
	            var dom = this.html.find('input[data-isNode="' + parseInt(type) + '"][data-id="' + id + '"]').prop('checked', false);
	            $.each(this.data, function (i, n) {
	                if (n.id == id && n.is_node == type) {
	                    item = n;
	                    item.is_check = false;
	                }
	            });

	            this._chgItem(item, dom);

	        },
	        cancelAll: function () {
	            $.each(this.data, function (index, item) {
	                item.is_check = false;
	            });
	            this.html.find('input').prop("checked", false);
	            this.opt.onCancel();
	        },
	        checkItem: function (id, type) {
	            var item = {};
	            var dom = this.html.find('input[data-isNode="' + parseInt(type) + '"][data-i="' + id + '"]').prop('checked', true);
	            $.each(this.data, function (i, n) {
	                if (n.id == id && n.is_node == type) {
	                    item = n;
	                    item.is_check = true;
	                }
	            });

	            this._chgItem(item, dom);

	        },
	        checkAll: function () {
	            if (this.opt.is_multi) {
	                $.each(this.data, function (index, item) {
	                    item.is_check = true;
	                });
	                this.html.find('input').prop("checked", true);
	                this.opt.onCheck();
	            }
	        },
	        getItem: function () {
	            var arr = [];
	            var data = this.data;
	            if (this.opt.only_child) {
	                $.each(data, function (i, n) {
	                    if (n.is_check && !n.is_node) {
	                        arr.push(n);
	                    }
	                });
	            } else {

	                if (this.opt.node_merge) {
	                    var node = [];
	                    $.each(data, function (i, n) {
	                        if (n.is_check && n.is_node) {
	                            node.push(n.id);
	//                            text.push( n.name);  //nodefirst
	                        }
	                    });

	                    var clone = $.extend(true, [], data);
	                    $.each(clone, function (i, n) {
	                        if ((n.is_check && $.inArray(n.nodeId, node) != -1) || !n.is_check) {
	                            clone[i] = null;
	                        }
	                    });


	                    $.each(clone, function (i, n) {
	                        if (n) {
	                            arr.push(n);
	                        }
	                    });
	                } else {
	                    $.each(data, function (i, n) {
	                        if (n.is_check) {
	                            arr.push(n);
	                        }
	                    });
	                }


	            }
	            return arr;
	        },
	        search: function (val) {
	            this._removeLayer(this.rootId);

	            if (val === '') {
	                this.html.find('div[node-id="' + this.rootId + '"]').remove();
	                this._showLayer(this.rootId);
	            } else {
	                for (var i in this.data) {
	                    if (!this.data[i].is_node && this.data[i].name.indexOf(val) != -1) {
	                        this.html.find('div[node-id="' + this.rootId + '"]').append(this._makeItem(this.data[i]));
	                    }
	                }
	            }
	        },


	        /**
	         *      数据方法
	         */
	        _getLayerData: function (parent) {
	            var res = [];
	            for (var i in this.data) {
	                if (this.data[i].nodeId == parent) {
	//                if(data[i].is_node){
	//                    res.unshift(data[i])
	//                }else{
	//                    res.push(data[i]);
	//                }

	                    res.push(this.data[i]);  //原序
	                }
	            }
	            return res;
	        },

	        _chgItem: function (item, dom) {

	            if (this.opt.is_multi) {
	                if (item.is_node) {
	                    dom.parent().parent().find('label > input').prop('checked', item.is_check);
	                    this._chgAllChildren(item.id, item.is_check);
	                }

	                if (!item.is_check) {
	                    this._cancelParentNode(item.nodeId);
	                } else {
	                    this._checkParentNode(item.nodeId);
	                }
	            } else {
	//                    this.html.find('input').prop("checked",false);
	//                    $(this).prop('checked',true);
	            }


	            var childItem = [];
	            this._getChild(item, childItem);


	            if (!item.is_check) {
	                this.opt.onCancel(item, dom, childItem);
	            } else {
	                this.opt.onCheck(item, dom, childItem);
	            }
	            this.opt.onChange();


	        },
	        _getChild: function (node, cont) {
	            if (node.is_node && node.has_children) {
	                var that = this;
	                $.each(that.data, function (i, n) {
	                    if (n.nodeId == node.id) {
	                        cont.push(n);
	                        if (n.is_node && node.has_children) {
	                            that._getChild(n, cont);
	                        }
	                    }
	                })
	            }

	        },
	        _cancelParentNode: function (id) {
	            var obj = this;
	            $.each(obj.data, function (i, n) {
	                if (n.id == id && n.is_node && n.is_check) {
	                    n.is_check = false;
	                    obj.html.find('input[data-isNode="1"][data-id="' + id + '"]').prop('checked', false);
	                    obj._cancelParentNode(n.nodeId);
	                }
	            })
	        },
	        _checkParentNode: function (id) {
	            var obj = this;
	            var allChildrenChecked = true;
	            $.each(obj.data, function (i, n) {
	                if (n.nodeId == id && !n.is_check) {
	                    allChildrenChecked = false;
	                }
	            });
	            $.each(obj.data, function (i, n) {
	                if (n.id == id && n.is_node && !n.is_check && allChildrenChecked) {
	                    n.is_check = true;
	                    obj.html.find('input[data-isNode="1"][data-id="' + id + '"]').prop('checked', true);
	                    obj._checkParentNode(n.nodeId);
	                }
	            });
	        },
	        _chgAllChildren: function (nodeid, bol) {
	            var obj = this;
	            $.each($.extend(true, [], this.data), function (i, n) {   //这句话 看起来 好像 不用 extend
	                if (n.nodeId == nodeid) {
	                    obj.data[i].is_check = bol;
	                    if (n.is_node && n.has_children) {
	                        obj._chgAllChildren(n.id, bol);
	                    }
	                }
	            });
	        },


	        /**
	         * 构造html内部方法
	         */
	        _makePanel: function () {
	            var html = '<div></div>';

	            if (this.opt.has_search) {
	                html = this._makeSearch(html);
	            }

	            var css;
	            if (this.opt.is_trigger) {
	                css = {
	                    'font-family': 'Microsoft YaHei',
	                    'z-index': this.opt.zIndex,
	                    border: '1px solid #5d5d5d',
	                    'background': '#fff',
	                    position: 'absolute',
	                    maxHeight: this.opt.maxHeight,
	                    padding: '0 1%',
	                    'white-space': 'nowrap',
	                    'overflow': 'auto'
	                };
	            } else {
	                css = {
	                    'font-family': 'Microsoft YaHei',
	                    'background': '#fff',
	                    maxHeight: this.opt.maxHeight,
	                    padding: '0 1%',
	                    'white-space': 'nowrap',
	                    'overflow': 'auto'
	                };
	            }


	            return $(html).css(css);
	        },
	        _makeSearch: function (html) {
	            var search = '<input class="x-tree-search" type="text" placeholder="搜索"/></div>';
	            search = $(search).css({
	                'border': 'none',
	                'padding': '4px 0',
	                'margin': '5px auto 0 auto',
	                'width': '98%',
	                'display': 'block'
	            });

	            var obj = this;
	            $(search).on('keyup paste', function () {
	                var dom = this;
	                clearTimeout(obj._searchTimer);
	                obj._searchTimer = setTimeout(function () {
	                    obj.search(dom.value);
	                }, 100);
	            });

	            return $(html).append(search);

	        },
	        _makeNode: function (item) {
	            var $html;
	            if (this.opt.is_multi) {
	                $html = $('<div node-id="' + item.id + '">' + makeExpand() + '<label><input type="checkbox" data-isNode="1" data-id="' + item.id + '" ' + (item.is_check ? 'checked' : '') + ' data-name="' + item.name + '"/><span>' + item.name + '</span></label></div>');
	            }
	            else {
	                if (this.opt.only_child) {
	                    $html = $('<div node-id="' + item.id + '">' + makeExpand() + '<span>' + item.name + '</span></div>');
	                }
	                else {
	                    $html = $('<div node-id="' + item.id + '">' + makeExpand() + '<label><input type="radio" name="' + this.dom.selector + '" data-isNode="1" data-id="' + item.id + '" ' + (item.is_check ? 'checked' : '') + ' data-name="' + item.name + '"/><span>' + item.name + '</span></label></div>');
	                }
	            }
	            $html.find('span').css({
	                'cursor': 'pointer',
	                'user-select': 'none',
	                '-webkit-user-select': 'none',
	                '-moz-user-select': 'none',
	                '-ms-user-select': 'none'
	            });
	            $html.find('input').css({
	                'vertical-align': 'middle'
	            });
	            var obj = this;
	            $html.find('i').on('click', function (e) {
	                if ($(this).hasClass('icon-jia1')) {
	                    obj._showLayer(item.id);
	                } else {
	                    obj._removeLayer(item.id);
	                }
	            });
	            return $html;
	        },
	        _makeChild: function (item) {
	            var $html;
	            if (this.opt.is_multi) {
	                $html = $('<div><span></span><label><input type="checkbox" data-id="' + item.id + '" data-isNode="0" data-name="' + item.name + '" ' + (item.is_check ? 'checked' : '') + '/>' + item.name + '</label></div>');
	            }
	            else {
	                $html = $('<div>' + (this.opt.only_child ? '' : '<span></span>') + '<label><input type="radio" name="' + this.dom.selector + '" data-id="' + item.id + '" data-isNode="0" data-name="' + item.name + '" />' + item.name + '</label></div>');
	            }
	            $html.find('span').css({
	                'width': '16px',
	                'user-select': 'none',
	                '-webkit-user-select': 'none',
	                '-moz-user-select': 'none',
	                '-ms-user-select': 'none',
	                'display': 'inline-block'
	            });
	            $html.find('input').css({
	                'vertical-align': 'middle'
	            });
	            return $html;
	        },
	        _makeItem: function (item) {
	            var $html;
	            if (item.is_node && item.has_children) {
	                $html = this._makeNode(item);
	            } else {
	                $html = this._makeChild(item);
	            }

	            var obj = this;
	            $html.find('input').on('click', function () {
	                if (obj.opt.is_multi) {
	                    item.is_check = !item.is_check;
	                } else {
	                    $.each(obj.data, function (index, item) {
	                        item.is_check = false;
	                    });
	                    item.is_check = true;
	                }


	                obj._chgItem(item, $(this));

	            });

	            return $html;
	        },
	        /**
	         *      视图方法
	         */

	        _showPanel: function () {
	            if (this.opt.is_trigger) {
	                this.html.css({
	                    top: this.dom.outerHeight(),
	                    left: 0,
	                    minWidth: this.opt.width ? this.opt.width : this.dom.outerWidth() * 0.98
	                });

	                this.html.addClass('xTreePanel');

	                this.html.on('click', function (e) {
	                    e.stopPropagation();
	                });
	            }
	            this.dom.append(this.html);

	        },
	        _showData: function () {
	            if (this._is_first) {
	                this._showLayer(this.rootId);
	                this._is_first = false;
	            } else {
	                this.html.show();
	            }
	        },
	        _expand: function () {
	            var obj = this;
	            if (obj.opt.expand === true) {
	                $.each(obj.data, function (index, item) {
	                    if (item.is_node && item.has_children) {
	                        obj.html.find('i').filter('.icon-jia1').click();
	                    }
	                });
	            } else if (obj.opt.expand) {
	                var expandId = [];
	                expandId.push(obj.rootId);
	                for (var i = 0; i < obj.opt.expand; i++) {
	                    expandId = obj._expandLevel(expandId);
	                }
	            }
	        },
	        _expandLevel: function (id) {
	            var obj = this;
	            var expandId = [];
	            $.each(id, function (index, item) {
	                $.each(obj.data, function (index2, item2) {
	                    if (item2.nodeId === item) {
	                        expandId.push(item2.id);
	                        obj.html.find('div[node-id="' + item2.nodeId + '"] > i').filter('.icon-jia1').click();
	                    }
	                });
	            });
	            return expandId;
	        },
	        _showLayer: function (layerId) {
	            var showData = this._getLayerData(layerId);
	            var itemDiv = makeLayer();


	            //这里 0节点的结构 和 子节点的结构 没有处理好    以后尽量让node-id 和  itemdiv 分开
	            if (layerId === this.rootId) {
	                itemDiv = $(itemDiv).attr('node-id', this.rootId);
	                this.html.append(itemDiv);
	                //itemDiv.parent().attr('node-id',0);

	            } else {
	                toShrink(this.html.find('div[node-id="' + layerId + '"] i'));
	                this.html.find('div[node-id="' + layerId + '"]').append(itemDiv);
	            }

	            for (var i in showData) {
	                itemDiv.append(this._makeItem(showData[i]));
	            }
	        },
	        _removeLayer: function (layerId) {
	            this.html.find('div[node-id="' + layerId + '"]>div').remove();
	            toExpand(this.html.find('div[node-id="' + layerId + '"] i'));
	        },


	    };


	    function makeLayer() {
	        var html = '<div></div>';

	        return $(html).css({
	            'margin-left': '13px'
	        });
	    }

	    function makeExpand() {
	        // var html='<span data-icon="expand">＋</span>';
	        var html = '<i class="iconfont icon-jia1"></i>';

	        return $(html).css({
	            'font-size': '12px',
	            'vertical-align': 'base-line',
	            'padding-right': '0px',
	            'cursor': 'pointer'
	        })[0].outerHTML;
	    }

	    function toShrink(dom) {
	        dom.removeClass('icon-jia1');
	        dom.addClass('icon-jian1');
	    }

	    function toExpand(dom) {
	        dom.removeClass('icon-jian1');
	        dom.addClass('icon-jia1');
	    }


	    function checkData(data) {
	        for (var i in data) {
	            return typeof data[i] == 'object';
	        }
	        return false;
	    }

	    function _initData(data) {
	        var clone = $.extend(true, [], data);
	        var len = clone.length;

	        for (var k = 0; k < len; k++) {
	            clone[k].has_children = false;
	        }

	        for (var i = 0; i < len; i++) {
	            for (var j = i; j < len; j++) {
	                if (clone[i].is_node && clone[i].id === clone[j].nodeId) {
	                    clone[i].has_children = true;
	                }
	                if (clone[i].nodeId === clone[j].id && clone[j].is_node) {
	                    clone[j].has_children = true;
	                }
	            }
	        }

	        return clone;
	    }

	    //选中的数据
	    function _selData(data, selected) {
	        var sel_ids = selected.split(',');
	        for (var i = 0; i < sel_ids.length; i++) {
	            for (var j = 0; j < data.length; j++) {
	                if (data[j].id == sel_ids[i]) {
	                    data[j].is_check = true;
	                    _selParent(data, data[j].nodeId);
	                    if (data[j].is_node && data[i].has_children) {
	                        _selChildren(data, data[j].id);
	                    }
	                }
	            }
	        }
	        return data;
	    }

	    function _selParent(data, nid) {
	        if (!nid) {
	            return false;
	        }
	        var selParent = true;
	        var sel_p = {};
	        for (var i = 0; i < data.length; i++) {
	            if (data[i].id == nid) {
	                sel_p = data[i];
	            }
	            if (data[i].nodeId == nid && !data[i].is_check) {
	                selParent = false;
	                return false;
	            }

	        }

	        if (selParent) {
	            sel_p.is_check = true;
	            if (sel_p.nodeId) {
	                _selParent(data, sel_p.nodeId);
	            }
	        }
	    }

	    function _selChildren(data, id) {
	        if (!id) {
	            return false;
	        }
	        for (var i = 0; i < data.length; i++) {
	            if (data[i].nodeId === id) {
	                data[i].is_check = true;
	                if (data[i].is_node && data[i].has_children) {
	                    _selChildren(data, data[i].id);
	                }
	            }

	        }
	    }

	    function _getRootId(_data) {
	        var rootId = [];
	        var clone = $.extend(true, [], _data);
	        for (var i = 0, len = _data.length; i < len; i++) {
	            for (var j = i; j < len; j++) {
	                if (_data[i].id === _data[j].nodeId) {
	                    clone[j] = null;
	                }
	                if (_data[i].nodeId === _data[j].id) {
	                    clone[i] = null;
	                }
	            }
	        }
	        $.each(clone, function (i, t) {
	            if (t) {
	                rootId.push(t.nodeId);
	            }
	        });

	        // //去除数组重复值
	        // function unique(array){
	        //     var n = [];
	        //     for(var i = 0; i < array.length; i++){
	        //         if (n.indexOf(array[i]) == -1) n.push(array[i]);
	        //     }
	        //     return n;
	        // }
	        //
	        // function unique(array){
	        //     var r = [];
	        //     for(var i = 0, l = array.length; i < l; i++) {
	        //         for(var j = i + 1; j < l; j++){
	        //             if (array[i] === array[j]) {
	        //                 j = ++i;
	        //             }
	        //         }
	        //         r.push(array[i]);
	        //     }
	        //     return r;
	        // }
	        // rootId = unique(rootId);

	        return rootId[0];
	    }


	})(jQuery);






/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
	 * Created by Administrator on 2016/11/4.
	 */


	;(function (factory) {
	    if ("function" === 'function' && __webpack_require__(50)['amd']) {
	        // AMD. Register as an anonymous module.
	        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(51)], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	    } else {
	        // Browser globals
	        factory(jQuery);
	    }
	})(function ($) {
	    var global, dialog, view, view_ctrl, ctrl_right, ctrl_left, ctrl_close, detail;
	    var ctrl_magnify, ctrl_shrink, ctrl_rotate, ctrl_recover;   //放大缩小旋转回复 按钮

	    var loading;   //等待图片
	    var imgDom;   //imgDom
	    var showWidth, showHeight;   //图像在view 中显示的宽高
	    var imgs = [];   //要显示的图像们
	    var infoDom;  //要显示的信息
	    var imageObj = new Image(); //用来加载图片的对象
	    var index = 1;   //展示第几个图片
	    var maxWeight; //图片最大放大系数  //由于图片可能一show 就被缩小了  而我们的放大系数是针对原图大小
	    var weight = 1;  //图片放大缩小系数
	    var rotate = 0;  //图片旋转度数
	    var isNotMove = true;   //拖拽图片时 不响应点击事件 的开关
	    var dragTime;   //拖拽图片时 定时器
	    var startX, startY;  //拖拽图片

	    var zIndex;  //还未投入使用
	    var onSwitch = function () {
	    };  //切换图片的函数


	    function calcuImgTop() {
	        var offset = view.height() - imgDom.height();
	        return offset / 2;
	    }

	    function calcuImgWH() {
	//            //计算在view中的  图像的宽高  （可能是原图大小  可能是被max-height max-width 处理过的）
	//            if(image.width>view.width()){
	//                showWidth=view.width();
	//                showHeight=image.height*view.width()/image.width;
	//            }else if(image.height>view.height()){
	//                showHeight=view.height();
	//                showWidth=image.width*view.height()/image.height;
	//            }else{
	//                showHeight=image.height;
	//                showWidth=image.width;
	//            }
	        showHeight = imgDom.height();
	        showWidth = imgDom.width();
	    }

	    function dragImg(e) {
	        var offsetY = startY - e.pageY;
	        var offsetX = startX - e.pageX;

	        imgDom.css('margin-top', -offsetY);
	        imgDom.css('margin-left', -offsetX);
	    }

	    function bindEVent() {
	        //图片读取
	        imageObj.onload = function () {
	            imgDom.show();
	            loading.hide();
	            imgDom.prop('src', imageObj.src);
	            imgDom.css({
	                'margin-top': calcuImgTop()
	            });
	            maxWeight = (imageObj.width / imgDom.width()) * 1.5;
	            calcuImgWH();
	        };

	        //隐藏imgview
	        global.click(function (e) {
	            if (isNotMove) {
	                if (this === e.target) {
	                    $(this).hide();
	                    imageObj.src = "";

	                }
	            }
	        });
	        ctrl_close.click(function (e) {
	            if (isNotMove) {
	                if (this === e.target) {
	                    global.hide();
	                    imageObj.src = "";

	                }
	            }
	        });

	        //拖拽
	        imgDom.bind('mousedown', function (e) {
	            e.preventDefault();
	            startX = e.pageX - parseInt(imgDom.css('margin-left'));
	            startY = e.pageY - parseInt(imgDom.css('margin-top'));
	            $(document).bind('mousemove', function (e) {
	                e.preventDefault();
	                $('body').css('cursor', 'move');
	                isNotMove = false;
	                dragImg(e);
	            });
	            $(document).bind('mouseup', function (e) {
	                $(document).unbind('mousemove');
	                $('body').css('cursor', 'initial');
	                clearTimeout(dragTime);
	                dragTime = setTimeout(function () {
	                    isNotMove = true;
	                }, 100);
	            });
	        });


	        //切换
	        imgDom.click(function (e) {
	            if (isNotMove) {
	                if (!showImg(++index)) {
	                    index--;
	                }
	            }
	        });


	        ctrl_right.click(function (e) {
	            if (!showImg(++index)) {
	                index--;
	            }
	            e.stopPropagation();

	        });


	        ctrl_left.click(function (e) {
	            if (!showImg(--index)) {
	                index++;
	            }
	            e.stopPropagation();
	        });


	        imgDom.bind('mousewheel', function (event) {
	            event.preventDefault();
	            var direction = event.originalEvent.wheelDelta;

	            if (direction == 120) {
	                if (weight < maxWeight) {
	                    weight += 0.1;
	                }
	            } else if (direction == -120) {
	                if (weight > 0.5) {
	                    weight -= 0.1;
	                }
	            }

	            handlerImgScale();


	//                console.log(event.deltaY, event.deltaFactor, event.originalEvent.deltaMode, event.originalEvent.wheelDelta);
	        });


	        ctrl_recover.click(function () {
	            handerImgRecover();
	        });

	        ctrl_magnify.click(function () {
	            if (weight < maxWeight) {
	                weight += 0.1;
	            }
	            handlerImgScale();
	        });

	        ctrl_shrink.click(function () {
	            if (weight > 0.5) {
	                weight -= 0.1;
	            }
	            handlerImgScale();
	        });

	        ctrl_rotate.click(function () {
	            fnRotateScale(imgDom[0], rotate += 90);
	        });


	    }

	    function handlerImgScale() {
	        imgDom.css('width', showWidth * weight);
	        imgDom.css('height', showHeight * weight);
	        imgDom.css('max-width', 'none');
	        imgDom.css('max-height', 'none');
	        imgDom.css('margin-top', calcuImgTop());
	    }


	    function buildHtml() {
	        global = $('<div>').appendTo("body");
	        global.css({
	            'background': 'rgba(0,0,0,0.5)',
	            'position': 'fixed',
	            'top': '0',
	            'bottom': '0',
	            'left': '0',
	            'right': '0',
	            'z-index': '9999',
	            'display': 'none'
	        });

	        dialog = $('<div>').appendTo(global);
	        dialog.css({
	            'width': '70%',
	            'position': 'relative',
	            'min-width': '500px',
	            'margin': '0% auto',
	            'padding': '10px 0',
	            'height': '100%'
	        });


	        detail = $('<div>').appendTo(dialog);
	        detail.css({
	            'width': '30%',
	            'background': '#ddd',
	            'display': 'none',
	//                'overflow':'hidden',
	            'height': '100%',
	            'float': 'left',
	            'box-sizing': 'border-box',
	            'padding': '1%'
	        });

	        view = $('<div>').appendTo(dialog);
	        view.css({
	            'background': '#000',
	            'width': '100%',
	            'padding': '1% 1% 50px 1%',
	            'box-sizing': 'border-box',
	            'overflow': 'hidden',
	            'height': '100%',
	            'user-select': 'none',
	            'text-align': 'center',
	            'position': 'relative',
	            'line-height': '100%'
	        });


	        imgDom = $('<img>').appendTo(view);
	        imgDom.css({
	            'transition': 'transform 0.5s',
	            'cursor': 'pointer'
	        });

	        view_ctrl = $('<div>').appendTo(view);
	        view_ctrl.css({
	            'position': 'absolute',
	            'bottom': '5px',
	            'background': '#000',
	            'width': '98%'
	        });


	        ctrl_recover = $('<span class="x-imgView-recover">').appendTo(view_ctrl);
	        ctrl_recover.css({
	            'display': 'inline-block',
	            'width': '22px',
	            'height': '19px',
	            'margin': '10px',
	            'cursor': 'pointer'
	        });

	        ctrl_magnify = $('<span class="x-imgView-magnify">').appendTo(view_ctrl);
	        ctrl_magnify.css({
	            'display': 'inline-block',
	            'width': '22px',
	            'height': '20px',
	            'margin': '10px',
	            'cursor': 'pointer'
	        });

	        ctrl_shrink = $('<span class="x-imgView-shrink">').appendTo(view_ctrl);
	        ctrl_shrink.css({
	            'display': 'inline-block',
	            'width': '21px',
	            'height': '20px',
	            'margin': '10px',
	            'cursor': 'pointer'
	        });

	        ctrl_rotate = $('<span class="x-imgView-rotate">').appendTo(view_ctrl);
	        ctrl_rotate.css({
	            'display': 'inline-block',
	            'width': '20px',
	            'height': '20px',
	            'margin': '10px',
	            'cursor': 'pointer'
	        });


	        ctrl_left = $('<span class="x-imgView-left">').appendTo(view);
	        ctrl_left.css({
	            'display': 'inline-block',
	            'position': 'absolute',
	            'width': '25px',
	            'height': '43px',
	            'left': '1%',
	            'top': '48%',
	            'cursor': 'pointer'
	        });

	        ctrl_right = $('<span class="x-imgView-right">').appendTo(view);
	        ctrl_right.css({
	            'display': 'inline-block',
	            'position': 'absolute',
	            'width': '25px',
	            'height': '43px',
	            'cursor': 'pointer',
	            'right': '1%',
	            'top': '48%'
	        });

	        ctrl_close = $('<span class="x-imgView-close">').appendTo(dialog);
	        ctrl_close.css({
	            'display': 'inline-block',
	            'position': 'absolute',
	            'width': '30px',
	            'height': '30px',
	            'cursor': 'pointer',
	            'right': '-14px',
	            'top': '0'
	        });


	        loading = $('<span class="x-imgView-loading">').appendTo(view);
	        loading.css({
	            'position': 'absolute',
	            'top': '48%',
	            'left': '50%',
	            'width': '40px',
	            'height': '40px',
	            'margin-left': '-30px',
	            'display': 'none'
	        });


	    }

	    function handerImgRecover() {
	        //重新调整到初始位置
	        imgDom.css({
	            'max-height': '100%',
	            'max-width': '100%',
	            'margin-left': '0',
	            'width': 'initial',
	            'height': 'initial'
	        });
	        //改变宽高之后才能算出正确的 margin-top
	        imgDom.css({
	            'margin-top': calcuImgTop()
	        });
	        weight = 1;
	        fnRotateScale(imgDom[0], rotate = 0);
	    }

	    var _is_init = false;

	    function init() {
	        if (!_is_init) {
	            buildHtml();
	            bindEVent();
	            _is_init = true;
	        }
	    }


	    //应该是load img   load完了应该才是 showimg
	    function showImg(index) {
	        if (!imgs[index]) {
	            return false;
	        }

	        handerImgRecover();
	        //判断左右两个按钮
	        if (imgs.length == 0) {
	            ctrl_right.hide();
	            ctrl_left.hide();

	        } else if (imgs.length == 1) {
	            ctrl_right.hide();
	            ctrl_left.hide();
	        } else if (index == 0) {
	            ctrl_left.hide();
	            ctrl_right.show();
	        } else if (index == imgs.length - 1) {
	            ctrl_right.hide();
	            ctrl_left.show();
	        } else {
	            ctrl_left.show();
	            ctrl_right.show();
	        }

	        global.show();
	        if (imgs.length) {
	            loading.show();
	        }
	        imgDom.hide();
	        onSwitch(index);
	        imageObj.src = imgs[index];
	        return true;

	    }


	    function fnRotateScale(dom, angle, scale) {
	        if (dom && dom.nodeType === 1) {
	            angle = parseFloat(angle) || 0;
	            scale = parseFloat(scale) || 1;
	            if (typeof(angle) === "number") {
	                //IE
	                var rad = angle * (Math.PI / 180);
	                var m11 = Math.cos(rad) * scale, m12 = -1 * Math.sin(rad) * scale, m21 = Math.sin(rad) * scale;
	                dom.style.filter = "progid:DXImageTransform.Microsoft.Matrix(M11=" + m11 + ",M12=" + m12 + ",M21=" + m21 + ",M22=" + m11 + ",SizingMethod='auto expand')";
	                //Modern
	                dom.style.MozTransform = "rotate(" + angle + "deg) scale(" + scale + ")";
	                dom.style.WebkitTransform = "rotate(" + angle + "deg) scale(" + scale + ")";
	                dom.style.OTransform = "rotate(" + angle + "deg) scale(" + scale + ")";
	                dom.style.Transform = "rotate(" + angle + "deg) scale(" + scale + ")";
	            }
	        }
	    }


	    window.xImgView = function (option) {
	        init();
	        imgs = option.imgs;
	        zIndex = option.zIndex || 2000;
	        infoDom = option.infoDom;
	        if (infoDom) {
	            detail.show();
	            detail.html(infoDom);
	            $(infoDom).show();
	            view.css('width', '70%');
	        }
	        onSwitch = option.onSwitch || function () {
	            };
	        showImg(index = 0);
	    };


	    $(document).ready(function () {
	        //自动定义
	        $('body').on('click', '.x-imgView .x-imgView-item', function () {
	            init();
	            imgs = [];
	            $.each($(this).parent().children(), function (i) {
	                imgs[i] = $(this).attr('x-imgView-src');
	            });
	            showImg(index = $(this).index());
	        });


	    });


	});

/***/ },
/* 50 */
/***/ function(module, exports) {

	module.exports = function() { throw new Error("define cannot be used indirect"); };


/***/ },
/* 51 */
/***/ function(module, exports) {

	module.exports = window.$;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by jesse on 2017/2/23.
	 */
	__webpack_require__(53);
	__webpack_require__(55);
	__webpack_require__(57);
	__webpack_require__(59);
	__webpack_require__(61);
	__webpack_require__(63);


/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Administrator on 2017/2/17.
	 */


	__webpack_require__(54);

	$.fn.extend({
	    hoverTips : function (){
	        var self = $(this);

	        var content = self.find('.x-tip-container').attr("data-tips");
	        var htmlDom = $("<div class='x-tip-dialog'>")
	            .html("<p class='x-tip-content'></p>"
	                + "<p class='x-tip-cor'></p>");
	        htmlDom.find(".x-tip-content").html( content );

	        self.on("mouseenter",function(){
	            self.append( htmlDom );
	            var top = htmlDom.outerHeight() + parseInt(htmlDom.find(".x-tip-cor").css("border-width"));
	            htmlDom.css({"left":0,"top":-top,"display":"block"});
	            htmlDom.stop().animate({ "top" : -top ,"opacity" : 1},300);
	        });

	        self.on("mouseleave",function(){
	             iTime = setTimeout(function(){
	                htmlDom.remove();
	            },500);
	        });

	        $('body').on("mouseenter",'.x-tip-dialog',function(){
	            clearTimeout(iTime);
	        });

	    }
	});



/***/ },
/* 54 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Administrator on 2017/2/17.
	 */

	__webpack_require__(56);

	$('.x-tab-nav li').click(function(){
	    var i = $(this).index();
	    $(this).addClass('x-active').siblings().removeClass('x-active');
	    $('.x-tab-content').eq(i).addClass('x-active').siblings().removeClass('x-active');
	});




/***/ },
/* 56 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Administrator on 2017/2/17.
	 */

	__webpack_require__(58);

	//导航-侧边栏
	$(".x-nav-head").click(function() {
	    $(this).next('ul').slideToggle(300).parent().siblings('li').find('ul').slideUp();
	    $(this).toggleClass('x-cur').parent().siblings('li').find('a.x-nav-head').removeClass('x-cur');

	    if($(this).hasClass('x-cur')){
	        $(this).find('i').removeClass('icon-xiangxia1').addClass('icon-xiangshang2');
	        $(this).parent().siblings('li').find('i').addClass('icon-xiangxia1').removeClass('icon-xiangshang2');
	    }else{
	        $(this).find('i').addClass('icon-xiangxia1').removeClass('icon-xiangshang2');
	    }
	});

	//导航-水平
	$('.x-nav-item').click(function(){
	    $(this).addClass('x-active').siblings('li').removeClass('x-active');
	});

/***/ },
/* 58 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Administrator on 2017/2/17.
	 */

	__webpack_require__(60);

	$('.x-form-radio').click(function(){
	    $(this).addClass('x-checked').siblings().removeClass('x-checked');
	});


	$('.x-form-checkbox').click(function(){
	    if($(this).find("input").is(':checked')){
	        $(this).addClass('x-checked');
	    }else{
	        $(this).removeClass('x-checked')
	    }
	});


	$('.x-form-switch').click(function(){
	    if($(this).find("input").is(':checked')){
	        $(this).addClass('x-form-onswitch');
	        $(this).find('span').text('开启');
	    }else{
	        $(this).removeClass('x-form-onswitch');
	        $(this).find('span').text('关闭');
	    }
	});

/***/ },
/* 60 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Administrator on 2016/12/27.
	 */

	__webpack_require__(62);

	module.exports = window.xPopUp = function(type,option,time) {
	    var layerDom; //底部遮罩层
	    var mainDom; //主体内容
	    var closeDom; //关闭按钮
	    var contentDom; //内容



	    //关闭弹窗
	    function onClose(){
	        mainDom.remove();
	        layerDom.remove();
	        $('body').css({overflow:'auto'});
	    }

	    //初始化操作
	    function init(){

	        option = {
	            p_width:600,
	            p_height:150,
	            title:'提示',
	            content:'',
	            btn:'',
	            isClose:true, //是否关闭
	            confirmfn:function(){},
	            closefn:function(){}
	        };

	        $('body').css({overflow:'hidden'});

	        //遮罩层
	        layerDom = $('<div class="x-pop-layer"></div>');
	        layerDom.appendTo('body');


	        //弹窗主体
	        mainDom = $('<div class="x-pop-main"></div>');

	        mainDom.appendTo('body');


	        //关闭按钮
	        closeDom = $('<div class="x-pop-close"><i class="iconfont icon-cuowu"></i></div>');

	        closeDom.appendTo(mainDom);

	        layerDom.click(function(){
	            onClose();
	        });
	        closeDom.click(function(){
	            onClose();
	        });

	        return mainDom;
	    }

	    //弹窗初始化位置
	    function initPosition(mainDom){
	        var cW = $(window).width();
	        var cH = $(window).height();

	        var popWidth = mainDom.width()+30;
	        var popHeight = mainDom.height()+30;


	        var pl = (cW-popWidth) / 2;
	        var pt = $(document).scrollTop()-popHeight/2+cH/2;

	        mainDom.css({
	            left:pl,
	            top:pt
	        });

	        window.onresize = function(){
	            initPosition(mainDom);
	        };
	    }

	    //提示
	    function promptPop(option,time){

	        mainDom = init();

	        mainDom.css({
	            width:option.p_width,
	            height:option.p_height
	        });

	        if(option.btn){
	            var btnHtml = '';
	            $.each(option.btn,function(i,n){
	                btnHtml+='<button class="x-button '+n.classStr+'">'+n.name+'</button>'
	            });
	        }


	        contentDom = $('<div><div class="x-pop-title">提示</div>'+
	            '<div class="x-pop-content"></div>'+
	            '<div class="x-pop-button"></div></div>');
	        contentDom.appendTo(mainDom);

	        var pop_con = contentDom.find('.x-pop-content');
	        var pop_btn = contentDom.find('.x-pop-button');

	        pop_con.html(option.content);
	        pop_btn.html(btnHtml);

	        initPosition(mainDom);

	        pop_btn.find('button').click(function(){
	            onClose();
	        });

	        if(time){
	            setTimeout(onClose,time)
	        }
	    }

	    //确定
	    function confirmPop(option){
	        mainDom = init();

	        mainDom.css({
	            width:option.p_width,
	            height:option.p_height
	        });

	        contentDom = $('<div><div class="x-pop-title">提示</div>'+
	            '<div class="x-pop-content"></div>'+
	            '<div class="x-pop-button"><button class="x-button x-confirm">确定</button><button class="x-button cancel">取消</button></div></div>');
	        contentDom.appendTo(mainDom);


	        var pop_con = contentDom.find('.x-pop-content');
	        var pop_btn = contentDom.find('.x-pop-button');

	        pop_con.html(option.content);


	        initPosition(mainDom);

	        pop_btn.find('.x-confirm').click(function(){
	            if(!option.isClose){
	                if(typeof option.confirmfn == 'function'){
	                    option.confirmfn();
	                    onClose();
	                }else{
	                    onClose();
	                }
	            }else{
	                onClose();
	            }

	        });

	        pop_btn.find('.cancel').click(function(){
	            if(!option.isClose){
	                if(typeof option.closefn == 'function'){

	                    option.closefn();
	                    onClose();
	                }else{
	                    onClose();
	                }
	            }else{
	                onClose();
	            }

	        });



	    }

	    //自定义
	    function userDefined(option){

	        mainDom = init();

	        mainDom.css({
	            width:option.p_width,
	            height:option.p_height
	        });

	        if(option.btn){
	            var btnHtml = '';
	            $.each(option.btn,function(i,n){
	                btnHtml+='<button class="x-button '+n.classStr+'">'+n.name+'</button>'
	            });
	        }


	        contentDom = $('<div><div class="x-pop-title"></div>'+
	            '<div class="x-pop-content"></div>'+
	            '<div class="x-pop-button" style="text-align:right;"></div></div>');
	        contentDom.appendTo(mainDom);

	        var pop_tit = contentDom.find('.x-pop-title');
	        var pop_con = contentDom.find('.x-pop-content');
	        var pop_btn = contentDom.find('.x-pop-button');



	        pop_tit.html(option.title);
	        pop_con.html(option.content);
	        pop_btn.html(btnHtml);


	        var pop_btn2 = contentDom.find('.x-pop-button button');
	        initPosition(mainDom);

	        $.each(option.btn,function(i,n){
	            pop_btn2.eq(i).click(function() {
	                if(!n.isClose){
	                    if(n.opra){
	                        n.opra();
	                    }
	                }else{
	                    if(n.opra){
	                        n.opra();
	                        onClose();
	                    }else{
	                        onClose();
	                    }

	                }
	            })

	        })

	    }

	    if (type === 'prompt') {
	        promptPop(option,time);
	    } else if (type === 'confirm') {
	        confirmPop(option);
	    } else {
	        userDefined(option);
	    }
	};

/***/ },
/* 62 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by Administrator on 2017/2/28.
	 */

	__webpack_require__(64);

	var count = 0;
	$('.x-table th').click(function(){
	    var iconDom = $(this).find('i');
	    if(count % 3 == 0){
	        iconDom.removeClass('x-table-arrow').addClass('x-table-arrowUp')
	    }else if(count % 3 == 1){
	        iconDom.removeClass('x-table-arrowUp').addClass('x-table-arrowDown');
	    }else{
	        iconDom.removeClass('x-table-arrowDown').addClass('x-table-arrow')
	    }
	    count++;
	});




/***/ },
/* 64 */
/***/ function(module, exports) {

	// removed by extract-text-webpack-plugin

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Created by jesse on 2017/2/23.
	 */
	__webpack_require__(66);
	__webpack_require__(67)

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	(function webpackUniversalModuleDefinition(root, factory) {
		if(true)
			module.exports = factory();
		else if(typeof define === 'function' && define.amd)
			define([], factory);
		else if(typeof exports === 'object')
			exports["echarts"] = factory();
		else
			root["echarts"] = factory();
	})(this, function() {
	return /******/ (function(modules) { // webpackBootstrap
	/******/ 	// The module cache
	/******/ 	var installedModules = {};

	/******/ 	// The require function
	/******/ 	function __webpack_require__(moduleId) {

	/******/ 		// Check if module is in cache
	/******/ 		if(installedModules[moduleId])
	/******/ 			return installedModules[moduleId].exports;

	/******/ 		// Create a new module (and put it into the cache)
	/******/ 		var module = installedModules[moduleId] = {
	/******/ 			exports: {},
	/******/ 			id: moduleId,
	/******/ 			loaded: false
	/******/ 		};

	/******/ 		// Execute the module function
	/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

	/******/ 		// Flag the module as loaded
	/******/ 		module.loaded = true;

	/******/ 		// Return the exports of the module
	/******/ 		return module.exports;
	/******/ 	}


	/******/ 	// expose the modules object (__webpack_modules__)
	/******/ 	__webpack_require__.m = modules;

	/******/ 	// expose the module cache
	/******/ 	__webpack_require__.c = installedModules;

	/******/ 	// __webpack_public_path__
	/******/ 	__webpack_require__.p = "";

	/******/ 	// Load entry module and return exports
	/******/ 	return __webpack_require__(0);
	/******/ })
	/************************************************************************/
	/******/ ([
	/* 0 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Export echarts as CommonJS module
		 */
		module.exports = __webpack_require__(1);

		// Import all charts and components
		__webpack_require__(100);
		__webpack_require__(135);
		__webpack_require__(140);
		__webpack_require__(149);
		__webpack_require__(153);

		__webpack_require__(163);
		__webpack_require__(184);
		__webpack_require__(196);
		__webpack_require__(217);
		__webpack_require__(221);
		__webpack_require__(225);
		__webpack_require__(240);
		__webpack_require__(246);
		__webpack_require__(253);
		__webpack_require__(259);
		__webpack_require__(263);
		__webpack_require__(271);

		__webpack_require__(275);
		__webpack_require__(113);
		__webpack_require__(276);
		__webpack_require__(282);
		__webpack_require__(286);
		__webpack_require__(297);
		__webpack_require__(226);
		__webpack_require__(300);
		__webpack_require__(306);

		__webpack_require__(317);

		__webpack_require__(318);
		__webpack_require__(332);

		__webpack_require__(347);
		__webpack_require__(353);
		__webpack_require__(356);

		__webpack_require__(359);
		__webpack_require__(368);

		__webpack_require__(381);


	/***/ },
	/* 1 */
	/***/ function(module, exports, __webpack_require__) {

		// Enable DEV mode when using source code without build. which has no __DEV__ variable
		// In build process 'typeof __DEV__' will be replace with 'boolean'
		// So this code will be removed or disabled anyway after built.
		if (false) {
		    // In browser
		    if (typeof window !== 'undefined') {
		        window.__DEV__ = true;
		    }
		    // In node
		    else if (typeof global !== 'undefined') {
		        global.__DEV__ = true;
		    }
		}

		/*!
		 * ECharts, a javascript interactive chart library.
		 *
		 * Copyright (c) 2015, Baidu Inc.
		 * All rights reserved.
		 *
		 * LICENSE
		 * https://github.com/ecomfe/echarts/blob/master/LICENSE.txt
		 */

		/**
		 * @module echarts
		 */


		    var env = __webpack_require__(2);

		    var GlobalModel = __webpack_require__(3);
		    var ExtensionAPI = __webpack_require__(25);
		    var CoordinateSystemManager = __webpack_require__(26);
		    var OptionManager = __webpack_require__(27);

		    var ComponentModel = __webpack_require__(19);
		    var SeriesModel = __webpack_require__(28);

		    var ComponentView = __webpack_require__(29);
		    var ChartView = __webpack_require__(42);
		    var graphic = __webpack_require__(43);
		    var modelUtil = __webpack_require__(5);
		    var throttle = __webpack_require__(81);

		    var zrender = __webpack_require__(82);
		    var zrUtil = __webpack_require__(4);
		    var colorTool = __webpack_require__(39);
		    var Eventful = __webpack_require__(33);
		    var timsort = __webpack_require__(86);

		    var each = zrUtil.each;

		    var PRIORITY_PROCESSOR_FILTER = 1000;
		    var PRIORITY_PROCESSOR_STATISTIC = 5000;


		    var PRIORITY_VISUAL_LAYOUT = 1000;
		    var PRIORITY_VISUAL_GLOBAL = 2000;
		    var PRIORITY_VISUAL_CHART = 3000;
		    var PRIORITY_VISUAL_COMPONENT = 4000;
		    var PRIORITY_VISUAL_BRUSH = 5000;

		    // Main process have three entries: `setOption`, `dispatchAction` and `resize`,
		    // where they must not be invoked nestedly, except the only case: invoke
		    // dispatchAction with updateMethod "none" in main process.
		    // This flag is used to carry out this rule.
		    // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).
		    var IN_MAIN_PROCESS = '__flagInMainProcess';
		    var HAS_GRADIENT_OR_PATTERN_BG = '__hasGradientOrPatternBg';
		    var OPTION_UPDATED = '__optionUpdated';

		    function createRegisterEventWithLowercaseName(method) {
		        return function (eventName, handler, context) {
		            // Event name is all lowercase
		            eventName = eventName && eventName.toLowerCase();
		            Eventful.prototype[method].call(this, eventName, handler, context);
		        };
		    }

		    /**
		     * @module echarts~MessageCenter
		     */
		    function MessageCenter() {
		        Eventful.call(this);
		    }
		    MessageCenter.prototype.on = createRegisterEventWithLowercaseName('on');
		    MessageCenter.prototype.off = createRegisterEventWithLowercaseName('off');
		    MessageCenter.prototype.one = createRegisterEventWithLowercaseName('one');
		    zrUtil.mixin(MessageCenter, Eventful);

		    /**
		     * @module echarts~ECharts
		     */
		    function ECharts (dom, theme, opts) {
		        opts = opts || {};

		        // Get theme by name
		        if (typeof theme === 'string') {
		            theme = themeStorage[theme];
		        }

		        /**
		         * @type {string}
		         */
		        this.id;
		        /**
		         * Group id
		         * @type {string}
		         */
		        this.group;
		        /**
		         * @type {HTMLDomElement}
		         * @private
		         */
		        this._dom = dom;
		        /**
		         * @type {module:zrender/ZRender}
		         * @private
		         */
		        var zr = this._zr = zrender.init(dom, {
		            renderer: opts.renderer || 'canvas',
		            devicePixelRatio: opts.devicePixelRatio,
		            width: opts.width,
		            height: opts.height
		        });

		        /**
		         * Expect 60 pfs.
		         * @type {Function}
		         * @private
		         */
		        this._throttledZrFlush = throttle.throttle(zrUtil.bind(zr.flush, zr), 17);

		        /**
		         * @type {Object}
		         * @private
		         */
		        this._theme = zrUtil.clone(theme);

		        /**
		         * @type {Array.<module:echarts/view/Chart>}
		         * @private
		         */
		        this._chartsViews = [];

		        /**
		         * @type {Object.<string, module:echarts/view/Chart>}
		         * @private
		         */
		        this._chartsMap = {};

		        /**
		         * @type {Array.<module:echarts/view/Component>}
		         * @private
		         */
		        this._componentsViews = [];

		        /**
		         * @type {Object.<string, module:echarts/view/Component>}
		         * @private
		         */
		        this._componentsMap = {};

		        /**
		         * @type {module:echarts/ExtensionAPI}
		         * @private
		         */
		        this._api = new ExtensionAPI(this);

		        /**
		         * @type {module:echarts/CoordinateSystem}
		         * @private
		         */
		        this._coordSysMgr = new CoordinateSystemManager();

		        Eventful.call(this);

		        /**
		         * @type {module:echarts~MessageCenter}
		         * @private
		         */
		        this._messageCenter = new MessageCenter();

		        // Init mouse events
		        this._initEvents();

		        // In case some people write `window.onresize = chart.resize`
		        this.resize = zrUtil.bind(this.resize, this);

		        // Can't dispatch action during rendering procedure
		        this._pendingActions = [];
		        // Sort on demand
		        function prioritySortFunc(a, b) {
		            return a.prio - b.prio;
		        }
		        timsort(visualFuncs, prioritySortFunc);
		        timsort(dataProcessorFuncs, prioritySortFunc);

		        zr.animation.on('frame', this._onframe, this);
		    }

		    var echartsProto = ECharts.prototype;

		    echartsProto._onframe = function () {
		        // Lazy update
		        if (this[OPTION_UPDATED]) {

		            this[IN_MAIN_PROCESS] = true;

		            updateMethods.prepareAndUpdate.call(this);

		            this[IN_MAIN_PROCESS] = false;

		            this[OPTION_UPDATED] = false;
		        }
		    };
		    /**
		     * @return {HTMLDomElement}
		     */
		    echartsProto.getDom = function () {
		        return this._dom;
		    };

		    /**
		     * @return {module:zrender~ZRender}
		     */
		    echartsProto.getZr = function () {
		        return this._zr;
		    };

		    /**
		     * @param {Object} option
		     * @param {boolean} notMerge
		     * @param {boolean} [lazyUpdate=false] Useful when setOption frequently.
		     */
		    echartsProto.setOption = function (option, notMerge, lazyUpdate) {
		        if (true) {
		            zrUtil.assert(!this[IN_MAIN_PROCESS], '`setOption` should not be called during main process.');
		        }

		        this[IN_MAIN_PROCESS] = true;

		        if (!this._model || notMerge) {
		            var optionManager = new OptionManager(this._api);
		            var theme = this._theme;
		            var ecModel = this._model = new GlobalModel(null, null, theme, optionManager);
		            ecModel.init(null, null, theme, optionManager);
		        }

		        // FIXME
		        // ugly
		        this.__lastOnlyGraphic = !!(option && option.graphic);
		        zrUtil.each(option, function (o, mainType) {
		            mainType !== 'graphic' && (this.__lastOnlyGraphic = false);
		        }, this);

		        this._model.setOption(option, optionPreprocessorFuncs);

		        if (lazyUpdate) {
		            this[OPTION_UPDATED] = true;
		        }
		        else {
		            updateMethods.prepareAndUpdate.call(this);
		            // Ensure zr refresh sychronously, and then pixel in canvas can be
		            // fetched after `setOption`.
		            this._zr.flush();
		            this[OPTION_UPDATED] = false;
		        }

		        this[IN_MAIN_PROCESS] = false;

		        flushPendingActions.call(this, false);
		    };

		    /**
		     * @DEPRECATED
		     */
		    echartsProto.setTheme = function () {
		        console.log('ECharts#setTheme() is DEPRECATED in ECharts 3.0');
		    };

		    /**
		     * @return {module:echarts/model/Global}
		     */
		    echartsProto.getModel = function () {
		        return this._model;
		    };

		    /**
		     * @return {Object}
		     */
		    echartsProto.getOption = function () {
		        return this._model && this._model.getOption();
		    };

		    /**
		     * @return {number}
		     */
		    echartsProto.getWidth = function () {
		        return this._zr.getWidth();
		    };

		    /**
		     * @return {number}
		     */
		    echartsProto.getHeight = function () {
		        return this._zr.getHeight();
		    };

		    /**
		     * Get canvas which has all thing rendered
		     * @param {Object} opts
		     * @param {string} [opts.backgroundColor]
		     */
		    echartsProto.getRenderedCanvas = function (opts) {
		        if (!env.canvasSupported) {
		            return;
		        }
		        opts = opts || {};
		        opts.pixelRatio = opts.pixelRatio || 1;
		        opts.backgroundColor = opts.backgroundColor
		            || this._model.get('backgroundColor');
		        var zr = this._zr;
		        var list = zr.storage.getDisplayList();
		        // Stop animations
		        zrUtil.each(list, function (el) {
		            el.stopAnimation(true);
		        });
		        return zr.painter.getRenderedCanvas(opts);
		    };
		    /**
		     * @return {string}
		     * @param {Object} opts
		     * @param {string} [opts.type='png']
		     * @param {string} [opts.pixelRatio=1]
		     * @param {string} [opts.backgroundColor]
		     * @param {string} [opts.excludeComponents]
		     */
		    echartsProto.getDataURL = function (opts) {
		        opts = opts || {};
		        var excludeComponents = opts.excludeComponents;
		        var ecModel = this._model;
		        var excludesComponentViews = [];
		        var self = this;

		        each(excludeComponents, function (componentType) {
		            ecModel.eachComponent({
		                mainType: componentType
		            }, function (component) {
		                var view = self._componentsMap[component.__viewId];
		                if (!view.group.ignore) {
		                    excludesComponentViews.push(view);
		                    view.group.ignore = true;
		                }
		            });
		        });

		        var url = this.getRenderedCanvas(opts).toDataURL(
		            'image/' + (opts && opts.type || 'png')
		        );

		        each(excludesComponentViews, function (view) {
		            view.group.ignore = false;
		        });
		        return url;
		    };


		    /**
		     * @return {string}
		     * @param {Object} opts
		     * @param {string} [opts.type='png']
		     * @param {string} [opts.pixelRatio=1]
		     * @param {string} [opts.backgroundColor]
		     */
		    echartsProto.getConnectedDataURL = function (opts) {
		        if (!env.canvasSupported) {
		            return;
		        }
		        var groupId = this.group;
		        var mathMin = Math.min;
		        var mathMax = Math.max;
		        var MAX_NUMBER = Infinity;
		        if (connectedGroups[groupId]) {
		            var left = MAX_NUMBER;
		            var top = MAX_NUMBER;
		            var right = -MAX_NUMBER;
		            var bottom = -MAX_NUMBER;
		            var canvasList = [];
		            var dpr = (opts && opts.pixelRatio) || 1;

		            zrUtil.each(instances, function (chart, id) {
		                if (chart.group === groupId) {
		                    var canvas = chart.getRenderedCanvas(
		                        zrUtil.clone(opts)
		                    );
		                    var boundingRect = chart.getDom().getBoundingClientRect();
		                    left = mathMin(boundingRect.left, left);
		                    top = mathMin(boundingRect.top, top);
		                    right = mathMax(boundingRect.right, right);
		                    bottom = mathMax(boundingRect.bottom, bottom);
		                    canvasList.push({
		                        dom: canvas,
		                        left: boundingRect.left,
		                        top: boundingRect.top
		                    });
		                }
		            });

		            left *= dpr;
		            top *= dpr;
		            right *= dpr;
		            bottom *= dpr;
		            var width = right - left;
		            var height = bottom - top;
		            var targetCanvas = zrUtil.createCanvas();
		            targetCanvas.width = width;
		            targetCanvas.height = height;
		            var zr = zrender.init(targetCanvas);

		            each(canvasList, function (item) {
		                var img = new graphic.Image({
		                    style: {
		                        x: item.left * dpr - left,
		                        y: item.top * dpr - top,
		                        image: item.dom
		                    }
		                });
		                zr.add(img);
		            });
		            zr.refreshImmediately();

		            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'));
		        }
		        else {
		            return this.getDataURL(opts);
		        }
		    };

		    /**
		     * Convert from logical coordinate system to pixel coordinate system.
		     * See CoordinateSystem#convertToPixel.
		     * @param {string|Object} finder
		     *        If string, e.g., 'geo', means {geoIndex: 0}.
		     *        If Object, could contain some of these properties below:
		     *        {
		     *            seriesIndex / seriesId / seriesName,
		     *            geoIndex / geoId, geoName,
		     *            bmapIndex / bmapId / bmapName,
		     *            xAxisIndex / xAxisId / xAxisName,
		     *            yAxisIndex / yAxisId / yAxisName,
		     *            gridIndex / gridId / gridName,
		     *            ... (can be extended)
		     *        }
		     * @param {Array|number} value
		     * @return {Array|number} result
		     */
		    echartsProto.convertToPixel = zrUtil.curry(doConvertPixel, 'convertToPixel');

		    /**
		     * Convert from pixel coordinate system to logical coordinate system.
		     * See CoordinateSystem#convertFromPixel.
		     * @param {string|Object} finder
		     *        If string, e.g., 'geo', means {geoIndex: 0}.
		     *        If Object, could contain some of these properties below:
		     *        {
		     *            seriesIndex / seriesId / seriesName,
		     *            geoIndex / geoId / geoName,
		     *            bmapIndex / bmapId / bmapName,
		     *            xAxisIndex / xAxisId / xAxisName,
		     *            yAxisIndex / yAxisId / yAxisName
		     *            gridIndex / gridId / gridName,
		     *            ... (can be extended)
		     *        }
		     * @param {Array|number} value
		     * @return {Array|number} result
		     */
		    echartsProto.convertFromPixel = zrUtil.curry(doConvertPixel, 'convertFromPixel');

		    function doConvertPixel(methodName, finder, value) {
		        var ecModel = this._model;
		        var coordSysList = this._coordSysMgr.getCoordinateSystems();
		        var result;

		        finder = modelUtil.parseFinder(ecModel, finder);

		        for (var i = 0; i < coordSysList.length; i++) {
		            var coordSys = coordSysList[i];
		            if (coordSys[methodName]
		                && (result = coordSys[methodName](ecModel, finder, value)) != null
		            ) {
		                return result;
		            }
		        }

		        if (true) {
		            console.warn(
		                'No coordinate system that supports ' + methodName + ' found by the given finder.'
		            );
		        }
		    }

		    /**
		     * Is the specified coordinate systems or components contain the given pixel point.
		     * @param {string|Object} finder
		     *        If string, e.g., 'geo', means {geoIndex: 0}.
		     *        If Object, could contain some of these properties below:
		     *        {
		     *            seriesIndex / seriesId / seriesName,
		     *            geoIndex / geoId / geoName,
		     *            bmapIndex / bmapId / bmapName,
		     *            xAxisIndex / xAxisId / xAxisName,
		     *            yAxisIndex / yAxisId / yAxisName
		     *            gridIndex / gridId / gridName,
		     *            ... (can be extended)
		     *        }
		     * @param {Array|number} value
		     * @return {boolean} result
		     */
		    echartsProto.containPixel = function (finder, value) {
		        var ecModel = this._model;
		        var result;

		        finder = modelUtil.parseFinder(ecModel, finder);

		        zrUtil.each(finder, function (models, key) {
		            key.indexOf('Models') >= 0 && zrUtil.each(models, function (model) {
		                var coordSys = model.coordinateSystem;
		                if (coordSys && coordSys.containPoint) {
		                    result |= !!coordSys.containPoint(value);
		                }
		                else if (key === 'seriesModels') {
		                    var view = this._chartsMap[model.__viewId];
		                    if (view && view.containPoint) {
		                        result |= view.containPoint(value, model);
		                    }
		                    else {
		                        if (true) {
		                            console.warn(key + ': ' + (view
		                                ? 'The found component do not support containPoint.'
		                                : 'No view mapping to the found component.'
		                            ));
		                        }
		                    }
		                }
		                else {
		                    if (true) {
		                        console.warn(key + ': containPoint is not supported');
		                    }
		                }
		            }, this);
		        }, this);

		        return !!result;
		    };

		    /**
		     * Get visual from series or data.
		     * @param {string|Object} finder
		     *        If string, e.g., 'series', means {seriesIndex: 0}.
		     *        If Object, could contain some of these properties below:
		     *        {
		     *            seriesIndex / seriesId / seriesName,
		     *            dataIndex / dataIndexInside
		     *        }
		     *        If dataIndex is not specified, series visual will be fetched,
		     *        but not data item visual.
		     *        If all of seriesIndex, seriesId, seriesName are not specified,
		     *        visual will be fetched from first series.
		     * @param {string} visualType 'color', 'symbol', 'symbolSize'
		     */
		    echartsProto.getVisual = function (finder, visualType) {
		        var ecModel = this._model;

		        finder = modelUtil.parseFinder(ecModel, finder, {defaultMainType: 'series'});

		        var seriesModel = finder.seriesModel;

		        if (true) {
		            if (!seriesModel) {
		                console.warn('There is no specified seires model');
		            }
		        }

		        var data = seriesModel.getData();

		        var dataIndexInside = finder.hasOwnProperty('dataIndexInside')
		            ? finder.dataIndexInside
		            : finder.hasOwnProperty('dataIndex')
		            ? data.indexOfRawIndex(finder.dataIndex)
		            : null;

		        return dataIndexInside != null
		            ? data.getItemVisual(dataIndexInside, visualType)
		            : data.getVisual(visualType);
		    };


		    var updateMethods = {

		        /**
		         * @param {Object} payload
		         * @private
		         */
		        update: function (payload) {
		            // console.time && console.time('update');

		            var ecModel = this._model;
		            var api = this._api;
		            var coordSysMgr = this._coordSysMgr;
		            var zr = this._zr;
		            // update before setOption
		            if (!ecModel) {
		                return;
		            }

		            // Fixme First time update ?
		            ecModel.restoreData();

		            // TODO
		            // Save total ecModel here for undo/redo (after restoring data and before processing data).
		            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.

		            // Create new coordinate system each update
		            // In LineView may save the old coordinate system and use it to get the orignal point
		            coordSysMgr.create(this._model, this._api);

		            processData.call(this, ecModel, api);

		            stackSeriesData.call(this, ecModel);

		            coordSysMgr.update(ecModel, api);

		            doVisualEncoding.call(this, ecModel, payload);

		            doRender.call(this, ecModel, payload);

		            // Set background
		            var backgroundColor = ecModel.get('backgroundColor') || 'transparent';

		            var painter = zr.painter;
		            // TODO all use clearColor ?
		            if (painter.isSingleCanvas && painter.isSingleCanvas()) {
		                zr.configLayer(0, {
		                    clearColor: backgroundColor
		                });
		            }
		            else {
		                // In IE8
		                if (!env.canvasSupported) {
		                    var colorArr = colorTool.parse(backgroundColor);
		                    backgroundColor = colorTool.stringify(colorArr, 'rgb');
		                    if (colorArr[3] === 0) {
		                        backgroundColor = 'transparent';
		                    }
		                }
		                if (backgroundColor.colorStops || backgroundColor.image) {
		                    // Gradient background
		                    // FIXME Fixed layer？
		                    zr.configLayer(0, {
		                        clearColor: backgroundColor
		                    });
		                    this[HAS_GRADIENT_OR_PATTERN_BG] = true;

		                    this._dom.style.background = 'transparent';
		                }
		                else {
		                    if (this[HAS_GRADIENT_OR_PATTERN_BG]) {
		                        zr.configLayer(0, {
		                            clearColor: null
		                        });
		                    }
		                    this[HAS_GRADIENT_OR_PATTERN_BG] = false;

		                    this._dom.style.background = backgroundColor;
		                }
		            }

		            // console.time && console.timeEnd('update');
		        },

		        // PENDING
		        /**
		         * @param {Object} payload
		         * @private
		         */
		        updateView: function (payload) {
		            var ecModel = this._model;

		            // update before setOption
		            if (!ecModel) {
		                return;
		            }

		            ecModel.eachSeries(function (seriesModel) {
		                seriesModel.getData().clearAllVisual();
		            });

		            doVisualEncoding.call(this, ecModel, payload);

		            invokeUpdateMethod.call(this, 'updateView', ecModel, payload);
		        },

		        /**
		         * @param {Object} payload
		         * @private
		         */
		        updateVisual: function (payload) {
		            var ecModel = this._model;

		            // update before setOption
		            if (!ecModel) {
		                return;
		            }

		            ecModel.eachSeries(function (seriesModel) {
		                seriesModel.getData().clearAllVisual();
		            });

		            doVisualEncoding.call(this, ecModel, payload);

		            invokeUpdateMethod.call(this, 'updateVisual', ecModel, payload);
		        },

		        /**
		         * @param {Object} payload
		         * @private
		         */
		        updateLayout: function (payload) {
		            var ecModel = this._model;

		            // update before setOption
		            if (!ecModel) {
		                return;
		            }

		            doLayout.call(this, ecModel, payload);

		            invokeUpdateMethod.call(this, 'updateLayout', ecModel, payload);
		        },

		        /**
		         * @param {Object} payload
		         * @private
		         */
		        highlight: function (payload) {
		            toggleHighlight.call(this, 'highlight', payload);
		        },

		        /**
		         * @param {Object} payload
		         * @private
		         */
		        downplay: function (payload) {
		            toggleHighlight.call(this, 'downplay', payload);
		        },

		        /**
		         * @param {Object} payload
		         * @private
		         */
		        prepareAndUpdate: function (payload) {
		            var ecModel = this._model;

		            prepareView.call(this, 'component', ecModel);

		            prepareView.call(this, 'chart', ecModel);

		            // FIXME
		            // ugly
		            if (this.__lastOnlyGraphic) {
		                each(this._componentsViews, function (componentView) {
		                    var componentModel = componentView.__model;
		                    if (componentModel && componentModel.mainType === 'graphic') {
		                        componentView.render(componentModel, ecModel, this._api, payload);
		                        updateZ(componentModel, componentView);
		                    }
		                }, this);
		                this.__lastOnlyGraphic = false;
		            }
		            else {
		                updateMethods.update.call(this, payload);
		            }
		        }
		    };

		    /**
		     * @param {Object} payload
		     * @private
		     */
		    function toggleHighlight(method, payload) {
		        var ecModel = this._model;

		        // dispatchAction before setOption
		        if (!ecModel) {
		            return;
		        }

		        ecModel.eachComponent(
		            {mainType: 'series', query: payload},
		            function (seriesModel, index) {
		                var chartView = this._chartsMap[seriesModel.__viewId];
		                if (chartView && chartView.__alive) {
		                    chartView[method](
		                        seriesModel, ecModel, this._api, payload
		                    );
		                }
		            },
		            this
		        );
		    }

		    /**
		     * Resize the chart
		     * @param {Object} opts
		     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
		     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
		     */
		    echartsProto.resize = function (opts) {
		        if (true) {
		            zrUtil.assert(!this[IN_MAIN_PROCESS], '`resize` should not be called during main process.');
		        }

		        this[IN_MAIN_PROCESS] = true;

		        this._zr.resize(opts);

		        var optionChanged = this._model && this._model.resetOption('media');
		        updateMethods[optionChanged ? 'prepareAndUpdate' : 'update'].call(this);

		        // Resize loading effect
		        this._loadingFX && this._loadingFX.resize();

		        this[IN_MAIN_PROCESS] = false;

		        flushPendingActions.call(this);
		    };

		    /**
		     * Show loading effect
		     * @param  {string} [name='default']
		     * @param  {Object} [cfg]
		     */
		    echartsProto.showLoading = function (name, cfg) {
		        if (zrUtil.isObject(name)) {
		            cfg = name;
		            name = '';
		        }
		        name = name || 'default';

		        this.hideLoading();
		        if (!loadingEffects[name]) {
		            if (true) {
		                console.warn('Loading effects ' + name + ' not exists.');
		            }
		            return;
		        }
		        var el = loadingEffects[name](this._api, cfg);
		        var zr = this._zr;
		        this._loadingFX = el;

		        zr.add(el);
		    };

		    /**
		     * Hide loading effect
		     */
		    echartsProto.hideLoading = function () {
		        this._loadingFX && this._zr.remove(this._loadingFX);
		        this._loadingFX = null;
		    };

		    /**
		     * @param {Object} eventObj
		     * @return {Object}
		     */
		    echartsProto.makeActionFromEvent = function (eventObj) {
		        var payload = zrUtil.extend({}, eventObj);
		        payload.type = eventActionMap[eventObj.type];
		        return payload;
		    };

		    /**
		     * @pubilc
		     * @param {Object} payload
		     * @param {string} [payload.type] Action type
		     * @param {Object|boolean} [opt] If pass boolean, means opt.silent
		     * @param {boolean} [opt.silent=false] Whether trigger events.
		     * @param {boolean} [opt.flush=undefined]
		     *                  true: Flush immediately, and then pixel in canvas can be fetched
		     *                      immediately. Caution: it might affect performance.
		     *                  false: Not not flush.
		     *                  undefined: Auto decide whether perform flush.
		     */
		    echartsProto.dispatchAction = function (payload, opt) {
		        if (!zrUtil.isObject(opt)) {
		            opt = {silent: !!opt};
		        }

		        if (!actions[payload.type]) {
		            return;
		        }

		        // if (__DEV__) {
		        //     zrUtil.assert(
		        //         !this[IN_MAIN_PROCESS],
		        //         '`dispatchAction` should not be called during main process.'
		        //         + 'unless updateMathod is "none".'
		        //     );
		        // }

		        // May dispatchAction in rendering procedure
		        if (this[IN_MAIN_PROCESS]) {
		            this._pendingActions.push(payload);
		            return;
		        }

		        doDispatchAction.call(this, payload, opt.silent);

		        if (opt.flush) {
		            this._zr.flush(true);
		        }
		        else if (opt.flush !== false && env.browser.weChat) {
		            // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`
		            // hang when sliding page (on touch event), which cause that zr does not
		            // refresh util user interaction finished, which is not expected.
		            // But `dispatchAction` may be called too frequently when pan on touch
		            // screen, which impacts performance if do not throttle them.
		            this._throttledZrFlush();
		        }

		        flushPendingActions.call(this, opt.silent);
		    };

		    function doDispatchAction(payload, silent) {
		        var actionWrap = actions[payload.type];
		        var actionInfo = actionWrap.actionInfo;
		        var updateMethod = actionInfo.update || 'update';

		        this[IN_MAIN_PROCESS] = true;

		        var payloads = [payload];
		        var batched = false;
		        // Batch action
		        if (payload.batch) {
		            batched = true;
		            payloads = zrUtil.map(payload.batch, function (item) {
		                item = zrUtil.defaults(zrUtil.extend({}, item), payload);
		                item.batch = null;
		                return item;
		            });
		        }

		        var eventObjBatch = [];
		        var eventObj;
		        var isHighlightOrDownplay = payload.type === 'highlight' || payload.type === 'downplay';
		        for (var i = 0; i < payloads.length; i++) {
		            var batchItem = payloads[i];
		            // Action can specify the event by return it.
		            eventObj = actionWrap.action(batchItem, this._model);
		            // Emit event outside
		            eventObj = eventObj || zrUtil.extend({}, batchItem);
		            // Convert type to eventType
		            eventObj.type = actionInfo.event || eventObj.type;
		            eventObjBatch.push(eventObj);

		            // Highlight and downplay are special.
		            isHighlightOrDownplay && updateMethods[updateMethod].call(this, batchItem);
		        }

		        if (updateMethod !== 'none' && !isHighlightOrDownplay) {
		            // Still dirty
		            if (this[OPTION_UPDATED]) {
		                // FIXME Pass payload ?
		                updateMethods.prepareAndUpdate.call(this, payload);
		                this[OPTION_UPDATED] = false;
		            }
		            else {
		                updateMethods[updateMethod].call(this, payload);
		            }
		        }

		        // Follow the rule of action batch
		        if (batched) {
		            eventObj = {
		                type: actionInfo.event || payload.type,
		                batch: eventObjBatch
		            };
		        }
		        else {
		            eventObj = eventObjBatch[0];
		        }

		        this[IN_MAIN_PROCESS] = false;

		        !silent && this._messageCenter.trigger(eventObj.type, eventObj);
		    }

		    function flushPendingActions(silent) {
		        var pendingActions = this._pendingActions;
		        while (pendingActions.length) {
		            var payload = pendingActions.shift();
		            doDispatchAction.call(this, payload, silent);
		        }
		    }

		    /**
		     * Register event
		     * @method
		     */
		    echartsProto.on = createRegisterEventWithLowercaseName('on');
		    echartsProto.off = createRegisterEventWithLowercaseName('off');
		    echartsProto.one = createRegisterEventWithLowercaseName('one');

		    /**
		     * @param {string} methodName
		     * @private
		     */
		    function invokeUpdateMethod(methodName, ecModel, payload) {
		        var api = this._api;

		        // Update all components
		        each(this._componentsViews, function (component) {
		            var componentModel = component.__model;
		            component[methodName](componentModel, ecModel, api, payload);

		            updateZ(componentModel, component);
		        }, this);

		        // Upate all charts
		        ecModel.eachSeries(function (seriesModel, idx) {
		            var chart = this._chartsMap[seriesModel.__viewId];
		            chart[methodName](seriesModel, ecModel, api, payload);

		            updateZ(seriesModel, chart);

		            updateProgressiveAndBlend(seriesModel, chart);
		        }, this);

		        // If use hover layer
		        updateHoverLayerStatus(this._zr, ecModel);
		    }

		    /**
		     * Prepare view instances of charts and components
		     * @param  {module:echarts/model/Global} ecModel
		     * @private
		     */
		    function prepareView(type, ecModel) {
		        var isComponent = type === 'component';
		        var viewList = isComponent ? this._componentsViews : this._chartsViews;
		        var viewMap = isComponent ? this._componentsMap : this._chartsMap;
		        var zr = this._zr;

		        for (var i = 0; i < viewList.length; i++) {
		            viewList[i].__alive = false;
		        }

		        ecModel[isComponent ? 'eachComponent' : 'eachSeries'](function (componentType, model) {
		            if (isComponent) {
		                if (componentType === 'series') {
		                    return;
		                }
		            }
		            else {
		                model = componentType;
		            }

		            // Consider: id same and type changed.
		            var viewId = model.id + '_' + model.type;
		            var view = viewMap[viewId];
		            if (!view) {
		                var classType = ComponentModel.parseClassType(model.type);
		                var Clazz = isComponent
		                    ? ComponentView.getClass(classType.main, classType.sub)
		                    : ChartView.getClass(classType.sub);
		                if (Clazz) {
		                    view = new Clazz();
		                    view.init(ecModel, this._api);
		                    viewMap[viewId] = view;
		                    viewList.push(view);
		                    zr.add(view.group);
		                }
		                else {
		                    // Error
		                    return;
		                }
		            }

		            model.__viewId = viewId;
		            view.__alive = true;
		            view.__id = viewId;
		            view.__model = model;
		        }, this);

		        for (var i = 0; i < viewList.length;) {
		            var view = viewList[i];
		            if (!view.__alive) {
		                zr.remove(view.group);
		                view.dispose(ecModel, this._api);
		                viewList.splice(i, 1);
		                delete viewMap[view.__id];
		            }
		            else {
		                i++;
		            }
		        }
		    }

		    /**
		     * Processor data in each series
		     *
		     * @param {module:echarts/model/Global} ecModel
		     * @private
		     */
		    function processData(ecModel, api) {
		        each(dataProcessorFuncs, function (process) {
		            process.func(ecModel, api);
		        });
		    }

		    /**
		     * @private
		     */
		    function stackSeriesData(ecModel) {
		        var stackedDataMap = {};
		        ecModel.eachSeries(function (series) {
		            var stack = series.get('stack');
		            var data = series.getData();
		            if (stack && data.type === 'list') {
		                var previousStack = stackedDataMap[stack];
		                if (previousStack) {
		                    data.stackedOn = previousStack;
		                }
		                stackedDataMap[stack] = data;
		            }
		        });
		    }

		    /**
		     * Layout before each chart render there series, special visual encoding stage
		     *
		     * @param {module:echarts/model/Global} ecModel
		     * @private
		     */
		    function doLayout(ecModel, payload) {
		        var api = this._api;
		        each(visualFuncs, function (visual) {
		            if (visual.isLayout) {
		                visual.func(ecModel, api, payload);
		            }
		        });
		    }

		    /**
		     * Encode visual infomation from data after data processing
		     *
		     * @param {module:echarts/model/Global} ecModel
		     * @private
		     */
		    function doVisualEncoding(ecModel, payload) {
		        var api = this._api;
		        ecModel.clearColorPalette();
		        ecModel.eachSeries(function (seriesModel) {
		            seriesModel.clearColorPalette();
		        });
		        each(visualFuncs, function (visual) {
		            visual.func(ecModel, api, payload);
		        });
		    }

		    /**
		     * Render each chart and component
		     * @private
		     */
		    function doRender(ecModel, payload) {
		        var api = this._api;
		        // Render all components
		        each(this._componentsViews, function (componentView) {
		            var componentModel = componentView.__model;
		            componentView.render(componentModel, ecModel, api, payload);

		            updateZ(componentModel, componentView);
		        }, this);

		        each(this._chartsViews, function (chart) {
		            chart.__alive = false;
		        }, this);

		        // Render all charts
		        ecModel.eachSeries(function (seriesModel, idx) {
		            var chartView = this._chartsMap[seriesModel.__viewId];
		            chartView.__alive = true;
		            chartView.render(seriesModel, ecModel, api, payload);

		            chartView.group.silent = !!seriesModel.get('silent');

		            updateZ(seriesModel, chartView);

		            updateProgressiveAndBlend(seriesModel, chartView);

		        }, this);

		        // If use hover layer
		        updateHoverLayerStatus(this._zr, ecModel);

		        // Remove groups of unrendered charts
		        each(this._chartsViews, function (chart) {
		            if (!chart.__alive) {
		                chart.remove(ecModel, api);
		            }
		        }, this);
		    }

		    var MOUSE_EVENT_NAMES = [
		        'click', 'dblclick', 'mouseover', 'mouseout', 'mousemove',
		        'mousedown', 'mouseup', 'globalout', 'contextmenu'
		    ];
		    /**
		     * @private
		     */
		    echartsProto._initEvents = function () {
		        each(MOUSE_EVENT_NAMES, function (eveName) {
		            this._zr.on(eveName, function (e) {
		                var ecModel = this.getModel();
		                var el = e.target;
		                var params;

		                // no e.target when 'globalout'.
		                if (eveName === 'globalout') {
		                    params = {};
		                }
		                else if (el && el.dataIndex != null) {
		                    var dataModel = el.dataModel || ecModel.getSeriesByIndex(el.seriesIndex);
		                    params = dataModel && dataModel.getDataParams(el.dataIndex, el.dataType) || {};
		                }
		                // If element has custom eventData of components
		                else if (el && el.eventData) {
		                    params = zrUtil.extend({}, el.eventData);
		                }

		                if (params) {
		                    params.event = e;
		                    params.type = eveName;
		                    this.trigger(eveName, params);
		                }

		            }, this);
		        }, this);

		        each(eventActionMap, function (actionType, eventType) {
		            this._messageCenter.on(eventType, function (event) {
		                this.trigger(eventType, event);
		            }, this);
		        }, this);
		    };

		    /**
		     * @return {boolean}
		     */
		    echartsProto.isDisposed = function () {
		        return this._disposed;
		    };

		    /**
		     * Clear
		     */
		    echartsProto.clear = function () {
		        this.setOption({ series: [] }, true);
		    };
		    /**
		     * Dispose instance
		     */
		    echartsProto.dispose = function () {
		        if (this._disposed) {
		            if (true) {
		                console.warn('Instance ' + this.id + ' has been disposed');
		            }
		            return;
		        }
		        this._disposed = true;

		        var api = this._api;
		        var ecModel = this._model;

		        each(this._componentsViews, function (component) {
		            component.dispose(ecModel, api);
		        });
		        each(this._chartsViews, function (chart) {
		            chart.dispose(ecModel, api);
		        });

		        // Dispose after all views disposed
		        this._zr.dispose();

		        delete instances[this.id];
		    };

		    zrUtil.mixin(ECharts, Eventful);

		    function updateHoverLayerStatus(zr, ecModel) {
		        var storage = zr.storage;
		        var elCount = 0;
		        storage.traverse(function (el) {
		            if (!el.isGroup) {
		                elCount++;
		            }
		        });
		        if (elCount > ecModel.get('hoverLayerThreshold') && !env.node) {
		            storage.traverse(function (el) {
		                if (!el.isGroup) {
		                    el.useHoverLayer = true;
		                }
		            });
		        }
		    }
		    /**
		     * Update chart progressive and blend.
		     * @param {module:echarts/model/Series|module:echarts/model/Component} model
		     * @param {module:echarts/view/Component|module:echarts/view/Chart} view
		     */
		    function updateProgressiveAndBlend(seriesModel, chartView) {
		        // Progressive configuration
		        var elCount = 0;
		        chartView.group.traverse(function (el) {
		            if (el.type !== 'group' && !el.ignore) {
		                elCount++;
		            }
		        });
		        var frameDrawNum = +seriesModel.get('progressive');
		        var needProgressive = elCount > seriesModel.get('progressiveThreshold') && frameDrawNum && !env.node;
		        if (needProgressive) {
		            chartView.group.traverse(function (el) {
		                // FIXME marker and other components
		                if (!el.isGroup) {
		                    el.progressive = needProgressive ?
		                        Math.floor(elCount++ / frameDrawNum) : -1;
		                    if (needProgressive) {
		                        el.stopAnimation(true);
		                    }
		                }
		            });
		        }

		        // Blend configration
		        var blendMode = seriesModel.get('blendMode') || null;
		        if (true) {
		            if (!env.canvasSupported && blendMode && blendMode !== 'source-over') {
		                console.warn('Only canvas support blendMode');
		            }
		        }
		        chartView.group.traverse(function (el) {
		            // FIXME marker and other components
		            if (!el.isGroup) {
		                el.setStyle('blend', blendMode);
		            }
		        });
		    }
		    /**
		     * @param {module:echarts/model/Series|module:echarts/model/Component} model
		     * @param {module:echarts/view/Component|module:echarts/view/Chart} view
		     */
		    function updateZ(model, view) {
		        var z = model.get('z');
		        var zlevel = model.get('zlevel');
		        // Set z and zlevel
		        view.group.traverse(function (el) {
		            if (el.type !== 'group') {
		                z != null && (el.z = z);
		                zlevel != null && (el.zlevel = zlevel);
		            }
		        });
		    }
		    /**
		     * @type {Array.<Function>}
		     * @inner
		     */
		    var actions = [];

		    /**
		     * Map eventType to actionType
		     * @type {Object}
		     */
		    var eventActionMap = {};

		    /**
		     * Data processor functions of each stage
		     * @type {Array.<Object.<string, Function>>}
		     * @inner
		     */
		    var dataProcessorFuncs = [];

		    /**
		     * @type {Array.<Function>}
		     * @inner
		     */
		    var optionPreprocessorFuncs = [];

		    /**
		     * Visual encoding functions of each stage
		     * @type {Array.<Object.<string, Function>>}
		     * @inner
		     */
		    var visualFuncs = [];
		    /**
		     * Theme storage
		     * @type {Object.<key, Object>}
		     */
		    var themeStorage = {};
		    /**
		     * Loading effects
		     */
		    var loadingEffects = {};


		    var instances = {};
		    var connectedGroups = {};

		    var idBase = new Date() - 0;
		    var groupIdBase = new Date() - 0;
		    var DOM_ATTRIBUTE_KEY = '_echarts_instance_';
		    /**
		     * @alias module:echarts
		     */
		    var echarts = {
		        /**
		         * @type {number}
		         */
		        version: '3.3.2',
		        dependencies: {
		            zrender: '3.2.2'
		        }
		    };

		    function enableConnect(chart) {

		        var STATUS_PENDING = 0;
		        var STATUS_UPDATING = 1;
		        var STATUS_UPDATED = 2;
		        var STATUS_KEY = '__connectUpdateStatus';
		        function updateConnectedChartsStatus(charts, status) {
		            for (var i = 0; i < charts.length; i++) {
		                var otherChart = charts[i];
		                otherChart[STATUS_KEY] = status;
		            }
		        }
		        zrUtil.each(eventActionMap, function (actionType, eventType) {
		            chart._messageCenter.on(eventType, function (event) {
		                if (connectedGroups[chart.group] && chart[STATUS_KEY] !== STATUS_PENDING) {
		                    var action = chart.makeActionFromEvent(event);
		                    var otherCharts = [];

		                    zrUtil.each(instances, function (otherChart) {
		                        if (otherChart !== chart && otherChart.group === chart.group) {
		                            otherCharts.push(otherChart);
		                        }
		                    });

		                    updateConnectedChartsStatus(otherCharts, STATUS_PENDING);
		                    each(otherCharts, function (otherChart) {
		                        if (otherChart[STATUS_KEY] !== STATUS_UPDATING) {
		                            otherChart.dispatchAction(action);
		                        }
		                    });
		                    updateConnectedChartsStatus(otherCharts, STATUS_UPDATED);
		                }
		            });
		        });

		    }
		    /**
		     * @param {HTMLDomElement} dom
		     * @param {Object} [theme]
		     * @param {Object} opts
		     * @param {number} [opts.devicePixelRatio] Use window.devicePixelRatio by default
		     * @param {string} [opts.renderer] Currently only 'canvas' is supported.
		     * @param {number} [opts.width] Use clientWidth of the input `dom` by default.
		     *                              Can be 'auto' (the same as null/undefined)
		     * @param {number} [opts.height] Use clientHeight of the input `dom` by default.
		     *                               Can be 'auto' (the same as null/undefined)
		     */
		    echarts.init = function (dom, theme, opts) {
		        if (true) {
		            // Check version
		            if ((zrender.version.replace('.', '') - 0) < (echarts.dependencies.zrender.replace('.', '') - 0)) {
		                throw new Error(
		                    'ZRender ' + zrender.version
		                    + ' is too old for ECharts ' + echarts.version
		                    + '. Current version need ZRender '
		                    + echarts.dependencies.zrender + '+'
		                );
		            }
		            if (!dom) {
		                throw new Error('Initialize failed: invalid dom.');
		            }
		            if (zrUtil.isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth || !dom.clientHeight)) {
		                console.warn('Can\'t get dom width or height');
		            }
		        }

		        var chart = new ECharts(dom, theme, opts);
		        chart.id = 'ec_' + idBase++;
		        instances[chart.id] = chart;

		        dom.setAttribute &&
		            dom.setAttribute(DOM_ATTRIBUTE_KEY, chart.id);

		        enableConnect(chart);

		        return chart;
		    };

		    /**
		     * @return {string|Array.<module:echarts~ECharts>} groupId
		     */
		    echarts.connect = function (groupId) {
		        // Is array of charts
		        if (zrUtil.isArray(groupId)) {
		            var charts = groupId;
		            groupId = null;
		            // If any chart has group
		            zrUtil.each(charts, function (chart) {
		                if (chart.group != null) {
		                    groupId = chart.group;
		                }
		            });
		            groupId = groupId || ('g_' + groupIdBase++);
		            zrUtil.each(charts, function (chart) {
		                chart.group = groupId;
		            });
		        }
		        connectedGroups[groupId] = true;
		        return groupId;
		    };

		    /**
		     * @return {string} groupId
		     */
		    echarts.disConnect = function (groupId) {
		        connectedGroups[groupId] = false;
		    };

		    /**
		     * Dispose a chart instance
		     * @param  {module:echarts~ECharts|HTMLDomElement|string} chart
		     */
		    echarts.dispose = function (chart) {
		        if (zrUtil.isDom(chart)) {
		            chart = echarts.getInstanceByDom(chart);
		        }
		        else if (typeof chart === 'string') {
		            chart = instances[chart];
		        }
		        if ((chart instanceof ECharts) && !chart.isDisposed()) {
		            chart.dispose();
		        }
		    };

		    /**
		     * @param  {HTMLDomElement} dom
		     * @return {echarts~ECharts}
		     */
		    echarts.getInstanceByDom = function (dom) {
		        var key = dom.getAttribute(DOM_ATTRIBUTE_KEY);
		        return instances[key];
		    };
		    /**
		     * @param {string} key
		     * @return {echarts~ECharts}
		     */
		    echarts.getInstanceById = function (key) {
		        return instances[key];
		    };

		    /**
		     * Register theme
		     */
		    echarts.registerTheme = function (name, theme) {
		        themeStorage[name] = theme;
		    };

		    /**
		     * Register option preprocessor
		     * @param {Function} preprocessorFunc
		     */
		    echarts.registerPreprocessor = function (preprocessorFunc) {
		        optionPreprocessorFuncs.push(preprocessorFunc);
		    };

		    /**
		     * @param {number} [priority=1000]
		     * @param {Function} processorFunc
		     */
		    echarts.registerProcessor = function (priority, processorFunc) {
		        if (typeof priority === 'function') {
		            processorFunc = priority;
		            priority = PRIORITY_PROCESSOR_FILTER;
		        }
		        if (true) {
		            if (isNaN(priority)) {
		                throw new Error('Unkown processor priority');
		            }
		        }
		        dataProcessorFuncs.push({
		            prio: priority,
		            func: processorFunc
		        });
		    };

		    /**
		     * Usage:
		     * registerAction('someAction', 'someEvent', function () { ... });
		     * registerAction('someAction', function () { ... });
		     * registerAction(
		     *     {type: 'someAction', event: 'someEvent', update: 'updateView'},
		     *     function () { ... }
		     * );
		     *
		     * @param {(string|Object)} actionInfo
		     * @param {string} actionInfo.type
		     * @param {string} [actionInfo.event]
		     * @param {string} [actionInfo.update]
		     * @param {string} [eventName]
		     * @param {Function} action
		     */
		    echarts.registerAction = function (actionInfo, eventName, action) {
		        if (typeof eventName === 'function') {
		            action = eventName;
		            eventName = '';
		        }
		        var actionType = zrUtil.isObject(actionInfo)
		            ? actionInfo.type
		            : ([actionInfo, actionInfo = {
		                event: eventName
		            }][0]);

		        // Event name is all lowercase
		        actionInfo.event = (actionInfo.event || actionType).toLowerCase();
		        eventName = actionInfo.event;

		        if (!actions[actionType]) {
		            actions[actionType] = {action: action, actionInfo: actionInfo};
		        }
		        eventActionMap[eventName] = actionType;
		    };

		    /**
		     * @param {string} type
		     * @param {*} CoordinateSystem
		     */
		    echarts.registerCoordinateSystem = function (type, CoordinateSystem) {
		        CoordinateSystemManager.register(type, CoordinateSystem);
		    };

		    /**
		     * Layout is a special stage of visual encoding
		     * Most visual encoding like color are common for different chart
		     * But each chart has it's own layout algorithm
		     *
		     * @param {number} [priority=1000]
		     * @param {Function} layoutFunc
		     */
		    echarts.registerLayout = function (priority, layoutFunc) {
		        if (typeof priority === 'function') {
		            layoutFunc = priority;
		            priority = PRIORITY_VISUAL_LAYOUT;
		        }
		        if (true) {
		            if (isNaN(priority)) {
		                throw new Error('Unkown layout priority');
		            }
		        }
		        visualFuncs.push({
		            prio: priority,
		            func: layoutFunc,
		            isLayout: true
		        });
		    };

		    /**
		     * @param {number} [priority=3000]
		     * @param {Function} visualFunc
		     */
		    echarts.registerVisual = function (priority, visualFunc) {
		        if (typeof priority === 'function') {
		            visualFunc = priority;
		            priority = PRIORITY_VISUAL_CHART;
		        }
		        if (true) {
		            if (isNaN(priority)) {
		                throw new Error('Unkown visual priority');
		            }
		        }
		        visualFuncs.push({
		            prio: priority,
		            func: visualFunc
		        });
		    };

		    /**
		     * @param {string} name
		     */
		    echarts.registerLoading = function (name, loadingFx) {
		        loadingEffects[name] = loadingFx;
		    };


		    var parseClassType = ComponentModel.parseClassType;
		    /**
		     * @param {Object} opts
		     * @param {string} [superClass]
		     */
		    echarts.extendComponentModel = function (opts, superClass) {
		        var Clazz = ComponentModel;
		        if (superClass) {
		            var classType = parseClassType(superClass);
		            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
		        }
		        return Clazz.extend(opts);
		    };

		    /**
		     * @param {Object} opts
		     * @param {string} [superClass]
		     */
		    echarts.extendComponentView = function (opts, superClass) {
		        var Clazz = ComponentView;
		        if (superClass) {
		            var classType = parseClassType(superClass);
		            Clazz = ComponentView.getClass(classType.main, classType.sub, true);
		        }
		        return Clazz.extend(opts);
		    };

		    /**
		     * @param {Object} opts
		     * @param {string} [superClass]
		     */
		    echarts.extendSeriesModel = function (opts, superClass) {
		        var Clazz = SeriesModel;
		        if (superClass) {
		            superClass = 'series.' + superClass.replace('series.', '');
		            var classType = parseClassType(superClass);
		            Clazz = ComponentModel.getClass(classType.main, classType.sub, true);
		        }
		        return Clazz.extend(opts);
		    };

		    /**
		     * @param {Object} opts
		     * @param {string} [superClass]
		     */
		    echarts.extendChartView = function (opts, superClass) {
		        var Clazz = ChartView;
		        if (superClass) {
		            superClass.replace('series.', '');
		            var classType = parseClassType(superClass);
		            Clazz = ChartView.getClass(classType.main, true);
		        }
		        return Clazz.extend(opts);
		    };

		    /**
		     * ZRender need a canvas context to do measureText.
		     * But in node environment canvas may be created by node-canvas.
		     * So we need to specify how to create a canvas instead of using document.createElement('canvas')
		     *
		     * Be careful of using it in the browser.
		     *
		     * @param {Function} creator
		     * @example
		     *     var Canvas = require('canvas');
		     *     var echarts = require('echarts');
		     *     echarts.setCanvasCreator(function () {
		     *         // Small size is enough.
		     *         return new Canvas(32, 32);
		     *     });
		     */
		    echarts.setCanvasCreator = function (creator) {
		        zrUtil.createCanvas = creator;
		    };

		    echarts.registerVisual(PRIORITY_VISUAL_GLOBAL, __webpack_require__(94));
		    echarts.registerPreprocessor(__webpack_require__(95));
		    echarts.registerLoading('default', __webpack_require__(97));

		    // Default action
		    echarts.registerAction({
		        type: 'highlight',
		        event: 'highlight',
		        update: 'highlight'
		    }, zrUtil.noop);
		    echarts.registerAction({
		        type: 'downplay',
		        event: 'downplay',
		        update: 'downplay'
		    }, zrUtil.noop);


		    // --------
		    // Exports
		    // --------
		    //
		    echarts.List = __webpack_require__(98);
		    echarts.Model = __webpack_require__(12);

		    echarts.graphic = __webpack_require__(43);
		    echarts.number = __webpack_require__(7);
		    echarts.format = __webpack_require__(6);
		    echarts.matrix = __webpack_require__(11);
		    echarts.vector = __webpack_require__(10);
		    echarts.color = __webpack_require__(39);

		    echarts.util = {};
		    each([
		            'map', 'each', 'filter', 'indexOf', 'inherits', 'reduce', 'filter',
		            'bind', 'curry', 'isArray', 'isString', 'isObject', 'isFunction',
		            'extend', 'defaults', 'clone'
		        ],
		        function (name) {
		            echarts.util[name] = zrUtil[name];
		        }
		    );

		    // PRIORITY
		    echarts.PRIORITY = {
		        PROCESSOR: {
		            FILTER: PRIORITY_PROCESSOR_FILTER,
		            STATISTIC: PRIORITY_PROCESSOR_STATISTIC
		        },
		        VISUAL: {
		            LAYOUT: PRIORITY_VISUAL_LAYOUT,
		            GLOBAL: PRIORITY_VISUAL_GLOBAL,
		            CHART: PRIORITY_VISUAL_CHART,
		            COMPONENT: PRIORITY_VISUAL_COMPONENT,
		            BRUSH: PRIORITY_VISUAL_BRUSH
		        }
		    };

		    module.exports = echarts;


	/***/ },
	/* 2 */
	/***/ function(module, exports) {

		/**
		 * echarts设备环境识别
		 *
		 * @desc echarts基于Canvas，纯Javascript图表库，提供直观，生动，可交互，可个性化定制的数据统计图表。
		 * @author firede[firede@firede.us]
		 * @desc thanks zepto.
		 */

		    var env = {};
		    if (typeof navigator === 'undefined') {
		        // In node
		        env = {
		            browser: {},
		            os: {},
		            node: true,
		            // Assume canvas is supported
		            canvasSupported: true
		        };
		    }
		    else {
		        env = detect(navigator.userAgent);
		    }

		    module.exports = env;

		    // Zepto.js
		    // (c) 2010-2013 Thomas Fuchs
		    // Zepto.js may be freely distributed under the MIT license.

		    function detect(ua) {
		        var os = {};
		        var browser = {};
		        // var webkit = ua.match(/Web[kK]it[\/]{0,1}([\d.]+)/);
		        // var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/);
		        // var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
		        // var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
		        // var iphone = !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/);
		        // var webos = ua.match(/(webOS|hpwOS)[\s\/]([\d.]+)/);
		        // var touchpad = webos && ua.match(/TouchPad/);
		        // var kindle = ua.match(/Kindle\/([\d.]+)/);
		        // var silk = ua.match(/Silk\/([\d._]+)/);
		        // var blackberry = ua.match(/(BlackBerry).*Version\/([\d.]+)/);
		        // var bb10 = ua.match(/(BB10).*Version\/([\d.]+)/);
		        // var rimtabletos = ua.match(/(RIM\sTablet\sOS)\s([\d.]+)/);
		        // var playbook = ua.match(/PlayBook/);
		        // var chrome = ua.match(/Chrome\/([\d.]+)/) || ua.match(/CriOS\/([\d.]+)/);
		        var firefox = ua.match(/Firefox\/([\d.]+)/);
		        // var safari = webkit && ua.match(/Mobile\//) && !chrome;
		        // var webview = ua.match(/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/) && !chrome;
		        var ie = ua.match(/MSIE\s([\d.]+)/)
		            // IE 11 Trident/7.0; rv:11.0
		            || ua.match(/Trident\/.+?rv:(([\d.]+))/);
		        var edge = ua.match(/Edge\/([\d.]+)/); // IE 12 and 12+

		        var weChat = (/micromessenger/i).test(ua);

		        // Todo: clean this up with a better OS/browser seperation:
		        // - discern (more) between multiple browsers on android
		        // - decide if kindle fire in silk mode is android or not
		        // - Firefox on Android doesn't specify the Android version
		        // - possibly devide in os, device and browser hashes

		        // if (browser.webkit = !!webkit) browser.version = webkit[1];

		        // if (android) os.android = true, os.version = android[2];
		        // if (iphone && !ipod) os.ios = os.iphone = true, os.version = iphone[2].replace(/_/g, '.');
		        // if (ipad) os.ios = os.ipad = true, os.version = ipad[2].replace(/_/g, '.');
		        // if (ipod) os.ios = os.ipod = true, os.version = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
		        // if (webos) os.webos = true, os.version = webos[2];
		        // if (touchpad) os.touchpad = true;
		        // if (blackberry) os.blackberry = true, os.version = blackberry[2];
		        // if (bb10) os.bb10 = true, os.version = bb10[2];
		        // if (rimtabletos) os.rimtabletos = true, os.version = rimtabletos[2];
		        // if (playbook) browser.playbook = true;
		        // if (kindle) os.kindle = true, os.version = kindle[1];
		        // if (silk) browser.silk = true, browser.version = silk[1];
		        // if (!silk && os.android && ua.match(/Kindle Fire/)) browser.silk = true;
		        // if (chrome) browser.chrome = true, browser.version = chrome[1];
		        if (firefox) {
		            browser.firefox = true;
		            browser.version = firefox[1];
		        }
		        // if (safari && (ua.match(/Safari/) || !!os.ios)) browser.safari = true;
		        // if (webview) browser.webview = true;

		        if (ie) {
		            browser.ie = true;
		            browser.version = ie[1];
		        }

		        if (edge) {
		            browser.edge = true;
		            browser.version = edge[1];
		        }

		        // It is difficult to detect WeChat in Win Phone precisely, because ua can
		        // not be set on win phone. So we do not consider Win Phone.
		        if (weChat) {
		            browser.weChat = true;
		        }

		        // os.tablet = !!(ipad || playbook || (android && !ua.match(/Mobile/)) ||
		        //     (firefox && ua.match(/Tablet/)) || (ie && !ua.match(/Phone/) && ua.match(/Touch/)));
		        // os.phone  = !!(!os.tablet && !os.ipod && (android || iphone || webos ||
		        //     (chrome && ua.match(/Android/)) || (chrome && ua.match(/CriOS\/([\d.]+)/)) ||
		        //     (firefox && ua.match(/Mobile/)) || (ie && ua.match(/Touch/))));

		        return {
		            browser: browser,
		            os: os,
		            node: false,
		            // 原生canvas支持，改极端点了
		            // canvasSupported : !(browser.ie && parseFloat(browser.version) < 9)
		            canvasSupported : document.createElement('canvas').getContext ? true : false,
		            // @see <http://stackoverflow.com/questions/4817029/whats-the-best-way-to-detect-a-touch-screen-device-using-javascript>
		            // works on most browsers
		            // IE10/11 does not support touch event, and MS Edge supports them but not by
		            // default, so we dont check navigator.maxTouchPoints for them here.
		            touchEventsSupported: 'ontouchstart' in window && !browser.ie && !browser.edge,
		            // <http://caniuse.com/#search=pointer%20event>.
		            pointerEventsSupported: 'onpointerdown' in window
		                // Firefox supports pointer but not by default,
		                // only MS browsers are reliable on pointer events currently.
		                && (browser.edge || (browser.ie && browser.version >= 10))
		        };
		    }


	/***/ },
	/* 3 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * ECharts global model
		 *
		 * @module {echarts/model/Global}
		 */



		    /**
		     * Caution: If the mechanism should be changed some day, these cases
		     * should be considered:
		     *
		     * (1) In `merge option` mode, if using the same option to call `setOption`
		     * many times, the result should be the same (try our best to ensure that).
		     * (2) In `merge option` mode, if a component has no id/name specified, it
		     * will be merged by index, and the result sequence of the components is
		     * consistent to the original sequence.
		     * (3) `reset` feature (in toolbox). Find detailed info in comments about
		     * `mergeOption` in module:echarts/model/OptionManager.
		     */

		    var zrUtil = __webpack_require__(4);
		    var modelUtil = __webpack_require__(5);
		    var Model = __webpack_require__(12);
		    var each = zrUtil.each;
		    var filter = zrUtil.filter;
		    var map = zrUtil.map;
		    var isArray = zrUtil.isArray;
		    var indexOf = zrUtil.indexOf;
		    var isObject = zrUtil.isObject;

		    var ComponentModel = __webpack_require__(19);

		    var globalDefault = __webpack_require__(23);

		    var OPTION_INNER_KEY = '\0_ec_inner';

		    /**
		     * @alias module:echarts/model/Global
		     *
		     * @param {Object} option
		     * @param {module:echarts/model/Model} parentModel
		     * @param {Object} theme
		     */
		    var GlobalModel = Model.extend({

		        constructor: GlobalModel,

		        init: function (option, parentModel, theme, optionManager) {
		            theme = theme || {};

		            this.option = null; // Mark as not initialized.

		            /**
		             * @type {module:echarts/model/Model}
		             * @private
		             */
		            this._theme = new Model(theme);

		            /**
		             * @type {module:echarts/model/OptionManager}
		             */
		            this._optionManager = optionManager;
		        },

		        setOption: function (option, optionPreprocessorFuncs) {
		            zrUtil.assert(
		                !(OPTION_INNER_KEY in option),
		                'please use chart.getOption()'
		            );

		            this._optionManager.setOption(option, optionPreprocessorFuncs);

		            this.resetOption();
		        },

		        /**
		         * @param {string} type null/undefined: reset all.
		         *                      'recreate': force recreate all.
		         *                      'timeline': only reset timeline option
		         *                      'media': only reset media query option
		         * @return {boolean} Whether option changed.
		         */
		        resetOption: function (type) {
		            var optionChanged = false;
		            var optionManager = this._optionManager;

		            if (!type || type === 'recreate') {
		                var baseOption = optionManager.mountOption(type === 'recreate');

		                if (!this.option || type === 'recreate') {
		                    initBase.call(this, baseOption);
		                }
		                else {
		                    this.restoreData();
		                    this.mergeOption(baseOption);
		                }
		                optionChanged = true;
		            }

		            if (type === 'timeline' || type === 'media') {
		                this.restoreData();
		            }

		            if (!type || type === 'recreate' || type === 'timeline') {
		                var timelineOption = optionManager.getTimelineOption(this);
		                timelineOption && (this.mergeOption(timelineOption), optionChanged = true);
		            }

		            if (!type || type === 'recreate' || type === 'media') {
		                var mediaOptions = optionManager.getMediaOption(this, this._api);
		                if (mediaOptions.length) {
		                    each(mediaOptions, function (mediaOption) {
		                        this.mergeOption(mediaOption, optionChanged = true);
		                    }, this);
		                }
		            }

		            return optionChanged;
		        },

		        /**
		         * @protected
		         */
		        mergeOption: function (newOption) {
		            var option = this.option;
		            var componentsMap = this._componentsMap;
		            var newCptTypes = [];

		            // 如果不存在对应的 component model 则直接 merge
		            each(newOption, function (componentOption, mainType) {
		                if (componentOption == null) {
		                    return;
		                }

		                if (!ComponentModel.hasClass(mainType)) {
		                    option[mainType] = option[mainType] == null
		                        ? zrUtil.clone(componentOption)
		                        : zrUtil.merge(option[mainType], componentOption, true);
		                }
		                else {
		                    newCptTypes.push(mainType);
		                }
		            });

		            // FIXME OPTION 同步是否要改回原来的
		            ComponentModel.topologicalTravel(
		                newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this
		            );

		            this._seriesIndices = this._seriesIndices || [];

		            function visitComponent(mainType, dependencies) {
		                var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);

		                var mapResult = modelUtil.mappingToExists(
		                    componentsMap[mainType], newCptOptionList
		                );

		                modelUtil.makeIdAndName(mapResult);

		                // Set mainType and complete subType.
		                each(mapResult, function (item, index) {
		                    var opt = item.option;
		                    if (isObject(opt)) {
		                        item.keyInfo.mainType = mainType;
		                        item.keyInfo.subType = determineSubType(mainType, opt, item.exist);
		                    }
		                });

		                var dependentModels = getComponentsByTypes(
		                    componentsMap, dependencies
		                );

		                option[mainType] = [];
		                componentsMap[mainType] = [];

		                each(mapResult, function (resultItem, index) {
		                    var componentModel = resultItem.exist;
		                    var newCptOption = resultItem.option;

		                    zrUtil.assert(
		                        isObject(newCptOption) || componentModel,
		                        'Empty component definition'
		                    );

		                    // Consider where is no new option and should be merged using {},
		                    // see removeEdgeAndAdd in topologicalTravel and
		                    // ComponentModel.getAllClassMainTypes.
		                    if (!newCptOption) {
		                        componentModel.mergeOption({}, this);
		                        componentModel.optionUpdated({}, false);
		                    }
		                    else {
		                        var ComponentModelClass = ComponentModel.getClass(
		                            mainType, resultItem.keyInfo.subType, true
		                        );

		                        if (componentModel && componentModel instanceof ComponentModelClass) {
		                            componentModel.name = resultItem.keyInfo.name;
		                            componentModel.mergeOption(newCptOption, this);
		                            componentModel.optionUpdated(newCptOption, false);
		                        }
		                        else {
		                            // PENDING Global as parent ?
		                            var extraOpt = zrUtil.extend(
		                                {
		                                    dependentModels: dependentModels,
		                                    componentIndex: index
		                                },
		                                resultItem.keyInfo
		                            );
		                            componentModel = new ComponentModelClass(
		                                newCptOption, this, this, extraOpt
		                            );
		                            zrUtil.extend(componentModel, extraOpt);
		                            componentModel.init(newCptOption, this, this, extraOpt);
		                            // Call optionUpdated after init.
		                            // newCptOption has been used as componentModel.option
		                            // and may be merged with theme and default, so pass null
		                            // to avoid confusion.
		                            componentModel.optionUpdated(null, true);
		                        }
		                    }

		                    componentsMap[mainType][index] = componentModel;
		                    option[mainType][index] = componentModel.option;
		                }, this);

		                // Backup series for filtering.
		                if (mainType === 'series') {
		                    this._seriesIndices = createSeriesIndices(componentsMap.series);
		                }
		            }
		        },

		        /**
		         * Get option for output (cloned option and inner info removed)
		         * @public
		         * @return {Object}
		         */
		        getOption: function () {
		            var option = zrUtil.clone(this.option);

		            each(option, function (opts, mainType) {
		                if (ComponentModel.hasClass(mainType)) {
		                    var opts = modelUtil.normalizeToArray(opts);
		                    for (var i = opts.length - 1; i >= 0; i--) {
		                        // Remove options with inner id.
		                        if (modelUtil.isIdInner(opts[i])) {
		                            opts.splice(i, 1);
		                        }
		                    }
		                    option[mainType] = opts;
		                }
		            });

		            delete option[OPTION_INNER_KEY];

		            return option;
		        },

		        /**
		         * @return {module:echarts/model/Model}
		         */
		        getTheme: function () {
		            return this._theme;
		        },

		        /**
		         * @param {string} mainType
		         * @param {number} [idx=0]
		         * @return {module:echarts/model/Component}
		         */
		        getComponent: function (mainType, idx) {
		            var list = this._componentsMap[mainType];
		            if (list) {
		                return list[idx || 0];
		            }
		        },

		        /**
		         * @param {Object} condition
		         * @param {string} condition.mainType
		         * @param {string} [condition.subType] If ignore, only query by mainType
		         * @param {number|Array.<number>} [condition.index] Either input index or id or name.
		         * @param {string|Array.<string>} [condition.id] Either input index or id or name.
		         * @param {string|Array.<string>} [condition.name] Either input index or id or name.
		         * @return {Array.<module:echarts/model/Component>}
		         */
		        queryComponents: function (condition) {
		            var mainType = condition.mainType;
		            if (!mainType) {
		                return [];
		            }

		            var index = condition.index;
		            var id = condition.id;
		            var name = condition.name;

		            var cpts = this._componentsMap[mainType];

		            if (!cpts || !cpts.length) {
		                return [];
		            }

		            var result;

		            if (index != null) {
		                if (!isArray(index)) {
		                    index = [index];
		                }
		                result = filter(map(index, function (idx) {
		                    return cpts[idx];
		                }), function (val) {
		                    return !!val;
		                });
		            }
		            else if (id != null) {
		                var isIdArray = isArray(id);
		                result = filter(cpts, function (cpt) {
		                    return (isIdArray && indexOf(id, cpt.id) >= 0)
		                        || (!isIdArray && cpt.id === id);
		                });
		            }
		            else if (name != null) {
		                var isNameArray = isArray(name);
		                result = filter(cpts, function (cpt) {
		                    return (isNameArray && indexOf(name, cpt.name) >= 0)
		                        || (!isNameArray && cpt.name === name);
		                });
		            }
		            else {
		                // Return all components with mainType
		                result = cpts;
		            }

		            return filterBySubType(result, condition);
		        },

		        /**
		         * The interface is different from queryComponents,
		         * which is convenient for inner usage.
		         *
		         * @usage
		         * var result = findComponents(
		         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
		         * );
		         * var result = findComponents(
		         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
		         * );
		         * var result = findComponents(
		         *     {mainType: 'series'},
		         *     function (model, index) {...}
		         * );
		         * // result like [component0, componnet1, ...]
		         *
		         * @param {Object} condition
		         * @param {string} condition.mainType Mandatory.
		         * @param {string} [condition.subType] Optional.
		         * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},
		         *        where xxx is mainType.
		         *        If query attribute is null/undefined or has no index/id/name,
		         *        do not filtering by query conditions, which is convenient for
		         *        no-payload situations or when target of action is global.
		         * @param {Function} [condition.filter] parameter: component, return boolean.
		         * @return {Array.<module:echarts/model/Component>}
		         */
		        findComponents: function (condition) {
		            var query = condition.query;
		            var mainType = condition.mainType;

		            var queryCond = getQueryCond(query);
		            var result = queryCond
		                ? this.queryComponents(queryCond)
		                : this._componentsMap[mainType];

		            return doFilter(filterBySubType(result, condition));

		            function getQueryCond(q) {
		                var indexAttr = mainType + 'Index';
		                var idAttr = mainType + 'Id';
		                var nameAttr = mainType + 'Name';
		                return q && (
		                        q.hasOwnProperty(indexAttr)
		                        || q.hasOwnProperty(idAttr)
		                        || q.hasOwnProperty(nameAttr)
		                    )
		                    ? {
		                        mainType: mainType,
		                        // subType will be filtered finally.
		                        index: q[indexAttr],
		                        id: q[idAttr],
		                        name: q[nameAttr]
		                    }
		                    : null;
		            }

		            function doFilter(res) {
		                return condition.filter
		                     ? filter(res, condition.filter)
		                     : res;
		            }
		        },

		        /**
		         * @usage
		         * eachComponent('legend', function (legendModel, index) {
		         *     ...
		         * });
		         * eachComponent(function (componentType, model, index) {
		         *     // componentType does not include subType
		         *     // (componentType is 'xxx' but not 'xxx.aa')
		         * });
		         * eachComponent(
		         *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},
		         *     function (model, index) {...}
		         * );
		         * eachComponent(
		         *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},
		         *     function (model, index) {...}
		         * );
		         *
		         * @param {string|Object=} mainType When mainType is object, the definition
		         *                                  is the same as the method 'findComponents'.
		         * @param {Function} cb
		         * @param {*} context
		         */
		        eachComponent: function (mainType, cb, context) {
		            var componentsMap = this._componentsMap;

		            if (typeof mainType === 'function') {
		                context = cb;
		                cb = mainType;
		                each(componentsMap, function (components, componentType) {
		                    each(components, function (component, index) {
		                        cb.call(context, componentType, component, index);
		                    });
		                });
		            }
		            else if (zrUtil.isString(mainType)) {
		                each(componentsMap[mainType], cb, context);
		            }
		            else if (isObject(mainType)) {
		                var queryResult = this.findComponents(mainType);
		                each(queryResult, cb, context);
		            }
		        },

		        /**
		         * @param {string} name
		         * @return {Array.<module:echarts/model/Series>}
		         */
		        getSeriesByName: function (name) {
		            var series = this._componentsMap.series;
		            return filter(series, function (oneSeries) {
		                return oneSeries.name === name;
		            });
		        },

		        /**
		         * @param {number} seriesIndex
		         * @return {module:echarts/model/Series}
		         */
		        getSeriesByIndex: function (seriesIndex) {
		            return this._componentsMap.series[seriesIndex];
		        },

		        /**
		         * @param {string} subType
		         * @return {Array.<module:echarts/model/Series>}
		         */
		        getSeriesByType: function (subType) {
		            var series = this._componentsMap.series;
		            return filter(series, function (oneSeries) {
		                return oneSeries.subType === subType;
		            });
		        },

		        /**
		         * @return {Array.<module:echarts/model/Series>}
		         */
		        getSeries: function () {
		            return this._componentsMap.series.slice();
		        },

		        /**
		         * After filtering, series may be different
		         * frome raw series.
		         *
		         * @param {Function} cb
		         * @param {*} context
		         */
		        eachSeries: function (cb, context) {
		            assertSeriesInitialized(this);
		            each(this._seriesIndices, function (rawSeriesIndex) {
		                var series = this._componentsMap.series[rawSeriesIndex];
		                cb.call(context, series, rawSeriesIndex);
		            }, this);
		        },

		        /**
		         * Iterate raw series before filtered.
		         *
		         * @param {Function} cb
		         * @param {*} context
		         */
		        eachRawSeries: function (cb, context) {
		            each(this._componentsMap.series, cb, context);
		        },

		        /**
		         * After filtering, series may be different.
		         * frome raw series.
		         *
		         * @parma {string} subType
		         * @param {Function} cb
		         * @param {*} context
		         */
		        eachSeriesByType: function (subType, cb, context) {
		            assertSeriesInitialized(this);
		            each(this._seriesIndices, function (rawSeriesIndex) {
		                var series = this._componentsMap.series[rawSeriesIndex];
		                if (series.subType === subType) {
		                    cb.call(context, series, rawSeriesIndex);
		                }
		            }, this);
		        },

		        /**
		         * Iterate raw series before filtered of given type.
		         *
		         * @parma {string} subType
		         * @param {Function} cb
		         * @param {*} context
		         */
		        eachRawSeriesByType: function (subType, cb, context) {
		            return each(this.getSeriesByType(subType), cb, context);
		        },

		        /**
		         * @param {module:echarts/model/Series} seriesModel
		         */
		        isSeriesFiltered: function (seriesModel) {
		            assertSeriesInitialized(this);
		            return zrUtil.indexOf(this._seriesIndices, seriesModel.componentIndex) < 0;
		        },

		        /**
		         * @param {Function} cb
		         * @param {*} context
		         */
		        filterSeries: function (cb, context) {
		            assertSeriesInitialized(this);
		            var filteredSeries = filter(
		                this._componentsMap.series, cb, context
		            );
		            this._seriesIndices = createSeriesIndices(filteredSeries);
		        },

		        restoreData: function () {
		            var componentsMap = this._componentsMap;

		            this._seriesIndices = createSeriesIndices(componentsMap.series);

		            var componentTypes = [];
		            each(componentsMap, function (components, componentType) {
		                componentTypes.push(componentType);
		            });

		            ComponentModel.topologicalTravel(
		                componentTypes,
		                ComponentModel.getAllClassMainTypes(),
		                function (componentType, dependencies) {
		                    each(componentsMap[componentType], function (component) {
		                        component.restoreData();
		                    });
		                }
		            );
		        }

		    });

		    /**
		     * @inner
		     */
		    function mergeTheme(option, theme) {
		        zrUtil.each(theme, function (themeItem, name) {
		            // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理
		            if (!ComponentModel.hasClass(name)) {
		                if (typeof themeItem === 'object') {
		                    option[name] = !option[name]
		                        ? zrUtil.clone(themeItem)
		                        : zrUtil.merge(option[name], themeItem, false);
		                }
		                else {
		                    if (option[name] == null) {
		                        option[name] = themeItem;
		                    }
		                }
		            }
		        });
		    }

		    function initBase(baseOption) {
		        baseOption = baseOption;

		        // Using OPTION_INNER_KEY to mark that this option can not be used outside,
		        // i.e. `chart.setOption(chart.getModel().option);` is forbiden.
		        this.option = {};
		        this.option[OPTION_INNER_KEY] = 1;

		        /**
		         * @type {Object.<string, Array.<module:echarts/model/Model>>}
		         * @private
		         */
		        this._componentsMap = {};

		        /**
		         * Mapping between filtered series list and raw series list.
		         * key: filtered series indices, value: raw series indices.
		         * @type {Array.<nubmer>}
		         * @private
		         */
		        this._seriesIndices = null;

		        mergeTheme(baseOption, this._theme.option);

		        // TODO Needs clone when merging to the unexisted property
		        zrUtil.merge(baseOption, globalDefault, false);

		        this.mergeOption(baseOption);
		    }

		    /**
		     * @inner
		     * @param {Array.<string>|string} types model types
		     * @return {Object} key: {string} type, value: {Array.<Object>} models
		     */
		    function getComponentsByTypes(componentsMap, types) {
		        if (!zrUtil.isArray(types)) {
		            types = types ? [types] : [];
		        }

		        var ret = {};
		        each(types, function (type) {
		            ret[type] = (componentsMap[type] || []).slice();
		        });

		        return ret;
		    }

		    /**
		     * @inner
		     */
		    function determineSubType(mainType, newCptOption, existComponent) {
		        var subType = newCptOption.type
		            ? newCptOption.type
		            : existComponent
		            ? existComponent.subType
		            // Use determineSubType only when there is no existComponent.
		            : ComponentModel.determineSubType(mainType, newCptOption);

		        // tooltip, markline, markpoint may always has no subType
		        return subType;
		    }

		    /**
		     * @inner
		     */
		    function createSeriesIndices(seriesModels) {
		        return map(seriesModels, function (series) {
		            return series.componentIndex;
		        }) || [];
		    }

		    /**
		     * @inner
		     */
		    function filterBySubType(components, condition) {
		        // Using hasOwnProperty for restrict. Consider
		        // subType is undefined in user payload.
		        return condition.hasOwnProperty('subType')
		            ? filter(components, function (cpt) {
		                return cpt.subType === condition.subType;
		            })
		            : components;
		    }

		    /**
		     * @inner
		     */
		    function assertSeriesInitialized(ecModel) {
		        // Components that use _seriesIndices should depends on series component,
		        // which make sure that their initialization is after series.
		        if (true) {
		            if (!ecModel._seriesIndices) {
		                throw new Error('Series has not been initialized yet.');
		            }
		        }
		    }

		    zrUtil.mixin(GlobalModel, __webpack_require__(24));

		    module.exports = GlobalModel;


	/***/ },
	/* 4 */
	/***/ function(module, exports) {

		/**
		 * @module zrender/core/util
		 */


		    // 用于处理merge时无法遍历Date等对象的问题
		    var BUILTIN_OBJECT = {
		        '[object Function]': 1,
		        '[object RegExp]': 1,
		        '[object Date]': 1,
		        '[object Error]': 1,
		        '[object CanvasGradient]': 1,
		        '[object CanvasPattern]': 1,
		        // For node-canvas
		        '[object Image]': 1,
		        '[object Canvas]': 1
		    };

		    var TYPED_ARRAY = {
		        '[object Int8Array]': 1,
		        '[object Uint8Array]': 1,
		        '[object Uint8ClampedArray]': 1,
		        '[object Int16Array]': 1,
		        '[object Uint16Array]': 1,
		        '[object Int32Array]': 1,
		        '[object Uint32Array]': 1,
		        '[object Float32Array]': 1,
		        '[object Float64Array]': 1
		    };

		    var objToString = Object.prototype.toString;

		    var arrayProto = Array.prototype;
		    var nativeForEach = arrayProto.forEach;
		    var nativeFilter = arrayProto.filter;
		    var nativeSlice = arrayProto.slice;
		    var nativeMap = arrayProto.map;
		    var nativeReduce = arrayProto.reduce;

		    /**
		     * Those data types can be cloned:
		     *     Plain object, Array, TypedArray, number, string, null, undefined.
		     * Those data types will be assgined using the orginal data:
		     *     BUILTIN_OBJECT
		     * Instance of user defined class will be cloned to a plain object, without
		     * properties in prototype.
		     * Other data types is not supported (not sure what will happen).
		     *
		     * Caution: do not support clone Date, for performance consideration.
		     * (There might be a large number of date in `series.data`).
		     * So date should not be modified in and out of echarts.
		     *
		     * @param {*} source
		     * @return {*} new
		     */
		    function clone(source) {
		        if (source == null || typeof source != 'object') {
		            return source;
		        }

		        var result = source;
		        var typeStr = objToString.call(source);

		        if (typeStr === '[object Array]') {
		            result = [];
		            for (var i = 0, len = source.length; i < len; i++) {
		                result[i] = clone(source[i]);
		            }
		        }
		        else if (TYPED_ARRAY[typeStr]) {
		            result = source.constructor.from(source);
		        }
		        else if (!BUILTIN_OBJECT[typeStr] && !isDom(source)) {
		            result = {};
		            for (var key in source) {
		                if (source.hasOwnProperty(key)) {
		                    result[key] = clone(source[key]);
		                }
		            }
		        }

		        return result;
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {*} target
		     * @param {*} source
		     * @param {boolean} [overwrite=false]
		     */
		    function merge(target, source, overwrite) {
		        // We should escapse that source is string
		        // and enter for ... in ...
		        if (!isObject(source) || !isObject(target)) {
		            return overwrite ? clone(source) : target;
		        }

		        for (var key in source) {
		            if (source.hasOwnProperty(key)) {
		                var targetProp = target[key];
		                var sourceProp = source[key];

		                if (isObject(sourceProp)
		                    && isObject(targetProp)
		                    && !isArray(sourceProp)
		                    && !isArray(targetProp)
		                    && !isDom(sourceProp)
		                    && !isDom(targetProp)
		                    && !isBuildInObject(sourceProp)
		                    && !isBuildInObject(targetProp)
		                ) {
		                    // 如果需要递归覆盖，就递归调用merge
		                    merge(targetProp, sourceProp, overwrite);
		                }
		                else if (overwrite || !(key in target)) {
		                    // 否则只处理overwrite为true，或者在目标对象中没有此属性的情况
		                    // NOTE，在 target[key] 不存在的时候也是直接覆盖
		                    target[key] = clone(source[key], true);
		                }
		            }
		        }

		        return target;
		    }

		    /**
		     * @param {Array} targetAndSources The first item is target, and the rests are source.
		     * @param {boolean} [overwrite=false]
		     * @return {*} target
		     */
		    function mergeAll(targetAndSources, overwrite) {
		        var result = targetAndSources[0];
		        for (var i = 1, len = targetAndSources.length; i < len; i++) {
		            result = merge(result, targetAndSources[i], overwrite);
		        }
		        return result;
		    }

		    /**
		     * @param {*} target
		     * @param {*} source
		     * @memberOf module:zrender/core/util
		     */
		    function extend(target, source) {
		        for (var key in source) {
		            if (source.hasOwnProperty(key)) {
		                target[key] = source[key];
		            }
		        }
		        return target;
		    }

		    /**
		     * @param {*} target
		     * @param {*} source
		     * @param {boolen} [overlay=false]
		     * @memberOf module:zrender/core/util
		     */
		    function defaults(target, source, overlay) {
		        for (var key in source) {
		            if (source.hasOwnProperty(key)
		                && (overlay ? source[key] != null : target[key] == null)
		            ) {
		                target[key] = source[key];
		            }
		        }
		        return target;
		    }

		    function createCanvas() {
		        return document.createElement('canvas');
		    }
		    // FIXME
		    var _ctx;
		    function getContext() {
		        if (!_ctx) {
		            // Use util.createCanvas instead of createCanvas
		            // because createCanvas may be overwritten in different environment
		            _ctx = util.createCanvas().getContext('2d');
		        }
		        return _ctx;
		    }

		    /**
		     * 查询数组中元素的index
		     * @memberOf module:zrender/core/util
		     */
		    function indexOf(array, value) {
		        if (array) {
		            if (array.indexOf) {
		                return array.indexOf(value);
		            }
		            for (var i = 0, len = array.length; i < len; i++) {
		                if (array[i] === value) {
		                    return i;
		                }
		            }
		        }
		        return -1;
		    }

		    /**
		     * 构造类继承关系
		     *
		     * @memberOf module:zrender/core/util
		     * @param {Function} clazz 源类
		     * @param {Function} baseClazz 基类
		     */
		    function inherits(clazz, baseClazz) {
		        var clazzPrototype = clazz.prototype;
		        function F() {}
		        F.prototype = baseClazz.prototype;
		        clazz.prototype = new F();

		        for (var prop in clazzPrototype) {
		            clazz.prototype[prop] = clazzPrototype[prop];
		        }
		        clazz.prototype.constructor = clazz;
		        clazz.superClass = baseClazz;
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {Object|Function} target
		     * @param {Object|Function} sorce
		     * @param {boolean} overlay
		     */
		    function mixin(target, source, overlay) {
		        target = 'prototype' in target ? target.prototype : target;
		        source = 'prototype' in source ? source.prototype : source;

		        defaults(target, source, overlay);
		    }

		    /**
		     * @param {Array|TypedArray} data
		     */
		    function isArrayLike(data) {
		        if (! data) {
		            return;
		        }
		        if (typeof data == 'string') {
		            return false;
		        }
		        return typeof data.length == 'number';
		    }

		    /**
		     * 数组或对象遍历
		     * @memberOf module:zrender/core/util
		     * @param {Object|Array} obj
		     * @param {Function} cb
		     * @param {*} [context]
		     */
		    function each(obj, cb, context) {
		        if (!(obj && cb)) {
		            return;
		        }
		        if (obj.forEach && obj.forEach === nativeForEach) {
		            obj.forEach(cb, context);
		        }
		        else if (obj.length === +obj.length) {
		            for (var i = 0, len = obj.length; i < len; i++) {
		                cb.call(context, obj[i], i, obj);
		            }
		        }
		        else {
		            for (var key in obj) {
		                if (obj.hasOwnProperty(key)) {
		                    cb.call(context, obj[key], key, obj);
		                }
		            }
		        }
		    }

		    /**
		     * 数组映射
		     * @memberOf module:zrender/core/util
		     * @param {Array} obj
		     * @param {Function} cb
		     * @param {*} [context]
		     * @return {Array}
		     */
		    function map(obj, cb, context) {
		        if (!(obj && cb)) {
		            return;
		        }
		        if (obj.map && obj.map === nativeMap) {
		            return obj.map(cb, context);
		        }
		        else {
		            var result = [];
		            for (var i = 0, len = obj.length; i < len; i++) {
		                result.push(cb.call(context, obj[i], i, obj));
		            }
		            return result;
		        }
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {Array} obj
		     * @param {Function} cb
		     * @param {Object} [memo]
		     * @param {*} [context]
		     * @return {Array}
		     */
		    function reduce(obj, cb, memo, context) {
		        if (!(obj && cb)) {
		            return;
		        }
		        if (obj.reduce && obj.reduce === nativeReduce) {
		            return obj.reduce(cb, memo, context);
		        }
		        else {
		            for (var i = 0, len = obj.length; i < len; i++) {
		                memo = cb.call(context, memo, obj[i], i, obj);
		            }
		            return memo;
		        }
		    }

		    /**
		     * 数组过滤
		     * @memberOf module:zrender/core/util
		     * @param {Array} obj
		     * @param {Function} cb
		     * @param {*} [context]
		     * @return {Array}
		     */
		    function filter(obj, cb, context) {
		        if (!(obj && cb)) {
		            return;
		        }
		        if (obj.filter && obj.filter === nativeFilter) {
		            return obj.filter(cb, context);
		        }
		        else {
		            var result = [];
		            for (var i = 0, len = obj.length; i < len; i++) {
		                if (cb.call(context, obj[i], i, obj)) {
		                    result.push(obj[i]);
		                }
		            }
		            return result;
		        }
		    }

		    /**
		     * 数组项查找
		     * @memberOf module:zrender/core/util
		     * @param {Array} obj
		     * @param {Function} cb
		     * @param {*} [context]
		     * @return {Array}
		     */
		    function find(obj, cb, context) {
		        if (!(obj && cb)) {
		            return;
		        }
		        for (var i = 0, len = obj.length; i < len; i++) {
		            if (cb.call(context, obj[i], i, obj)) {
		                return obj[i];
		            }
		        }
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {Function} func
		     * @param {*} context
		     * @return {Function}
		     */
		    function bind(func, context) {
		        var args = nativeSlice.call(arguments, 2);
		        return function () {
		            return func.apply(context, args.concat(nativeSlice.call(arguments)));
		        };
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {Function} func
		     * @return {Function}
		     */
		    function curry(func) {
		        var args = nativeSlice.call(arguments, 1);
		        return function () {
		            return func.apply(this, args.concat(nativeSlice.call(arguments)));
		        };
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {*} value
		     * @return {boolean}
		     */
		    function isArray(value) {
		        return objToString.call(value) === '[object Array]';
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {*} value
		     * @return {boolean}
		     */
		    function isFunction(value) {
		        return typeof value === 'function';
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {*} value
		     * @return {boolean}
		     */
		    function isString(value) {
		        return objToString.call(value) === '[object String]';
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {*} value
		     * @return {boolean}
		     */
		    function isObject(value) {
		        // Avoid a V8 JIT bug in Chrome 19-20.
		        // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
		        var type = typeof value;
		        return type === 'function' || (!!value && type == 'object');
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {*} value
		     * @return {boolean}
		     */
		    function isBuildInObject(value) {
		        return !!BUILTIN_OBJECT[objToString.call(value)];
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {*} value
		     * @return {boolean}
		     */
		    function isDom(value) {
		        return typeof value === 'object'
		            && typeof value.nodeType === 'number'
		            && typeof value.ownerDocument === 'object';
		    }

		    /**
		     * If value1 is not null, then return value1, otherwise judget rest of values.
		     * @memberOf module:zrender/core/util
		     * @return {*} Final value
		     */
		    function retrieve(values) {
		        for (var i = 0, len = arguments.length; i < len; i++) {
		            if (arguments[i] != null) {
		                return arguments[i];
		            }
		        }
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {Array} arr
		     * @param {number} startIndex
		     * @param {number} endIndex
		     * @return {Array}
		     */
		    function slice() {
		        return Function.call.apply(nativeSlice, arguments);
		    }

		    /**
		     * @memberOf module:zrender/core/util
		     * @param {boolean} condition
		     * @param {string} message
		     */
		    function assert(condition, message) {
		        if (!condition) {
		            throw new Error(message);
		        }
		    }

		    var util = {
		        inherits: inherits,
		        mixin: mixin,
		        clone: clone,
		        merge: merge,
		        mergeAll: mergeAll,
		        extend: extend,
		        defaults: defaults,
		        getContext: getContext,
		        createCanvas: createCanvas,
		        indexOf: indexOf,
		        slice: slice,
		        find: find,
		        isArrayLike: isArrayLike,
		        each: each,
		        map: map,
		        reduce: reduce,
		        filter: filter,
		        bind: bind,
		        curry: curry,
		        isArray: isArray,
		        isString: isString,
		        isObject: isObject,
		        isFunction: isFunction,
		        isBuildInObject: isBuildInObject,
		        isDom: isDom,
		        retrieve: retrieve,
		        assert: assert,
		        noop: function () {}
		    };
		    module.exports = util;



	/***/ },
	/* 5 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var formatUtil = __webpack_require__(6);
		    var nubmerUtil = __webpack_require__(7);
		    var Model = __webpack_require__(12);
		    var zrUtil = __webpack_require__(4);
		    var each = zrUtil.each;
		    var isObject = zrUtil.isObject;

		    var modelUtil = {};

		    /**
		     * If value is not array, then translate it to array.
		     * @param  {*} value
		     * @return {Array} [value] or value
		     */
		    modelUtil.normalizeToArray = function (value) {
		        return value instanceof Array
		            ? value
		            : value == null
		            ? []
		            : [value];
		    };

		    /**
		     * Sync default option between normal and emphasis like `position` and `show`
		     * In case some one will write code like
		     *     label: {
		     *         normal: {
		     *             show: false,
		     *             position: 'outside',
		     *             textStyle: {
		     *                 fontSize: 18
		     *             }
		     *         },
		     *         emphasis: {
		     *             show: true
		     *         }
		     *     }
		     * @param {Object} opt
		     * @param {Array.<string>} subOpts
		     */
		     modelUtil.defaultEmphasis = function (opt, subOpts) {
		        if (opt) {
		            var emphasisOpt = opt.emphasis = opt.emphasis || {};
		            var normalOpt = opt.normal = opt.normal || {};

		            // Default emphasis option from normal
		            each(subOpts, function (subOptName) {
		                var val = zrUtil.retrieve(emphasisOpt[subOptName], normalOpt[subOptName]);
		                if (val != null) {
		                    emphasisOpt[subOptName] = val;
		                }
		            });
		        }
		    };

		    modelUtil.LABEL_OPTIONS = ['position', 'show', 'textStyle', 'distance', 'formatter'];

		    /**
		     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
		     * This helper method retieves value from data.
		     * @param {string|number|Date|Array|Object} dataItem
		     * @return {number|string|Date|Array.<number|string|Date>}
		     */
		    modelUtil.getDataItemValue = function (dataItem) {
		        // Performance sensitive.
		        return dataItem && (dataItem.value == null ? dataItem : dataItem.value);
		    };

		    /**
		     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
		     * This helper method determine if dataItem has extra option besides value
		     * @param {string|number|Date|Array|Object} dataItem
		     */
		    modelUtil.isDataItemOption = function (dataItem) {
		        return isObject(dataItem)
		            && !(dataItem instanceof Array);
		            // // markLine data can be array
		            // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
		    };

		    /**
		     * This helper method convert value in data.
		     * @param {string|number|Date} value
		     * @param {Object|string} [dimInfo] If string (like 'x'), dimType defaults 'number'.
		     */
		    modelUtil.converDataValue = function (value, dimInfo) {
		        // Performance sensitive.
		        var dimType = dimInfo && dimInfo.type;
		        if (dimType === 'ordinal') {
		            return value;
		        }

		        if (dimType === 'time' && !isFinite(value) && value != null && value !== '-') {
		            value = +nubmerUtil.parseDate(value);
		        }

		        // dimType defaults 'number'.
		        // If dimType is not ordinal and value is null or undefined or NaN or '-',
		        // parse to NaN.
		        return (value == null || value === '')
		            ? NaN : +value; // If string (like '-'), using '+' parse to NaN
		    };

		    /**
		     * Create a model proxy to be used in tooltip for edge data, markLine data, markPoint data.
		     * @param {module:echarts/data/List} data
		     * @param {Object} opt
		     * @param {string} [opt.seriesIndex]
		     * @param {Object} [opt.name]
		     * @param {Object} [opt.mainType]
		     * @param {Object} [opt.subType]
		     */
		    modelUtil.createDataFormatModel = function (data, opt) {
		        var model = new Model();
		        zrUtil.mixin(model, modelUtil.dataFormatMixin);
		        model.seriesIndex = opt.seriesIndex;
		        model.name = opt.name || '';
		        model.mainType = opt.mainType;
		        model.subType = opt.subType;

		        model.getData = function () {
		            return data;
		        };
		        return model;
		    };

		    // PENDING A little ugly
		    modelUtil.dataFormatMixin = {
		        /**
		         * Get params for formatter
		         * @param {number} dataIndex
		         * @param {string} [dataType]
		         * @return {Object}
		         */
		        getDataParams: function (dataIndex, dataType) {
		            var data = this.getData(dataType);

		            var seriesIndex = this.seriesIndex;
		            var seriesName = this.name;

		            var rawValue = this.getRawValue(dataIndex, dataType);
		            var rawDataIndex = data.getRawIndex(dataIndex);
		            var name = data.getName(dataIndex, true);
		            var itemOpt = data.getRawDataItem(dataIndex);

		            return {
		                componentType: this.mainType,
		                componentSubType: this.subType,
		                seriesType: this.mainType === 'series' ? this.subType : null,
		                seriesIndex: seriesIndex,
		                seriesName: seriesName,
		                name: name,
		                dataIndex: rawDataIndex,
		                data: itemOpt,
		                dataType: dataType,
		                value: rawValue,
		                color: data.getItemVisual(dataIndex, 'color'),

		                // Param name list for mapping `a`, `b`, `c`, `d`, `e`
		                $vars: ['seriesName', 'name', 'value']
		            };
		        },

		        /**
		         * Format label
		         * @param {number} dataIndex
		         * @param {string} [status='normal'] 'normal' or 'emphasis'
		         * @param {string} [dataType]
		         * @param {number} [dimIndex]
		         * @return {string}
		         */
		        getFormattedLabel: function (dataIndex, status, dataType, dimIndex) {
		            status = status || 'normal';
		            var data = this.getData(dataType);
		            var itemModel = data.getItemModel(dataIndex);

		            var params = this.getDataParams(dataIndex, dataType);
		            if (dimIndex != null && (params.value instanceof Array)) {
		                params.value = params.value[dimIndex];
		            }

		            var formatter = itemModel.get(['label', status, 'formatter']);

		            if (typeof formatter === 'function') {
		                params.status = status;
		                return formatter(params);
		            }
		            else if (typeof formatter === 'string') {
		                return formatUtil.formatTpl(formatter, params);
		            }
		        },

		        /**
		         * Get raw value in option
		         * @param {number} idx
		         * @param {string} [dataType]
		         * @return {Object}
		         */
		        getRawValue: function (idx, dataType) {
		            var data = this.getData(dataType);
		            var dataItem = data.getRawDataItem(idx);
		            if (dataItem != null) {
		                return (isObject(dataItem) && !(dataItem instanceof Array))
		                    ? dataItem.value : dataItem;
		            }
		        },

		        /**
		         * Should be implemented.
		         * @param {number} dataIndex
		         * @param {boolean} [multipleSeries=false]
		         * @param {number} [dataType]
		         * @return {string} tooltip string
		         */
		        formatTooltip: zrUtil.noop
		    };

		    /**
		     * Mapping to exists for merge.
		     *
		     * @public
		     * @param {Array.<Object>|Array.<module:echarts/model/Component>} exists
		     * @param {Object|Array.<Object>} newCptOptions
		     * @return {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
		     *                          index of which is the same as exists.
		     */
		    modelUtil.mappingToExists = function (exists, newCptOptions) {
		        // Mapping by the order by original option (but not order of
		        // new option) in merge mode. Because we should ensure
		        // some specified index (like xAxisIndex) is consistent with
		        // original option, which is easy to understand, espatially in
		        // media query. And in most case, merge option is used to
		        // update partial option but not be expected to change order.
		        newCptOptions = (newCptOptions || []).slice();

		        var result = zrUtil.map(exists || [], function (obj, index) {
		            return {exist: obj};
		        });

		        // Mapping by id or name if specified.
		        each(newCptOptions, function (cptOption, index) {
		            if (!isObject(cptOption)) {
		                return;
		            }

		            // id has highest priority.
		            for (var i = 0; i < result.length; i++) {
		                if (!result[i].option // Consider name: two map to one.
		                    && cptOption.id != null
		                    && result[i].exist.id === cptOption.id + ''
		                ) {
		                    result[i].option = cptOption;
		                    newCptOptions[index] = null;
		                    return;
		                }
		            }

		            for (var i = 0; i < result.length; i++) {
		                var exist = result[i].exist;
		                if (!result[i].option // Consider name: two map to one.
		                    // Can not match when both ids exist but different.
		                    && (exist.id == null || cptOption.id == null)
		                    && cptOption.name != null
		                    && !modelUtil.isIdInner(cptOption)
		                    && !modelUtil.isIdInner(exist)
		                    && exist.name === cptOption.name + ''
		                ) {
		                    result[i].option = cptOption;
		                    newCptOptions[index] = null;
		                    return;
		                }
		            }
		        });

		        // Otherwise mapping by index.
		        each(newCptOptions, function (cptOption, index) {
		            if (!isObject(cptOption)) {
		                return;
		            }

		            var i = 0;
		            for (; i < result.length; i++) {
		                var exist = result[i].exist;
		                if (!result[i].option
		                    // Existing model that already has id should be able to
		                    // mapped to (because after mapping performed model may
		                    // be assigned with a id, whish should not affect next
		                    // mapping), except those has inner id.
		                    && !modelUtil.isIdInner(exist)
		                    // Caution:
		                    // Do not overwrite id. But name can be overwritten,
		                    // because axis use name as 'show label text'.
		                    // 'exist' always has id and name and we dont
		                    // need to check it.
		                    && cptOption.id == null
		                ) {
		                    result[i].option = cptOption;
		                    break;
		                }
		            }

		            if (i >= result.length) {
		                result.push({option: cptOption});
		            }
		        });

		        return result;
		    };

		    /**
		     * Make id and name for mapping result (result of mappingToExists)
		     * into `keyInfo` field.
		     *
		     * @public
		     * @param {Array.<Object>} Result, like [{exist: ..., option: ...}, {}],
		     *                          which order is the same as exists.
		     * @return {Array.<Object>} The input.
		     */
		    modelUtil.makeIdAndName = function (mapResult) {
		        // We use this id to hash component models and view instances
		        // in echarts. id can be specified by user, or auto generated.

		        // The id generation rule ensures new view instance are able
		        // to mapped to old instance when setOption are called in
		        // no-merge mode. So we generate model id by name and plus
		        // type in view id.

		        // name can be duplicated among components, which is convenient
		        // to specify multi components (like series) by one name.

		        // Ensure that each id is distinct.
		        var idMap = {};

		        each(mapResult, function (item, index) {
		            var existCpt = item.exist;
		            existCpt && (idMap[existCpt.id] = item);
		        });

		        each(mapResult, function (item, index) {
		            var opt = item.option;

		            zrUtil.assert(
		                !opt || opt.id == null || !idMap[opt.id] || idMap[opt.id] === item,
		                'id duplicates: ' + (opt && opt.id)
		            );

		            opt && opt.id != null && (idMap[opt.id] = item);
		            !item.keyInfo && (item.keyInfo = {});
		        });

		        // Make name and id.
		        each(mapResult, function (item, index) {
		            var existCpt = item.exist;
		            var opt = item.option;
		            var keyInfo = item.keyInfo;

		            if (!isObject(opt)) {
		                return;
		            }

		            // name can be overwitten. Consider case: axis.name = '20km'.
		            // But id generated by name will not be changed, which affect
		            // only in that case: setOption with 'not merge mode' and view
		            // instance will be recreated, which can be accepted.
		            keyInfo.name = opt.name != null
		                ? opt.name + ''
		                : existCpt
		                ? existCpt.name
		                : '\0-';

		            if (existCpt) {
		                keyInfo.id = existCpt.id;
		            }
		            else if (opt.id != null) {
		                keyInfo.id = opt.id + '';
		            }
		            else {
		                // Consider this situatoin:
		                //  optionA: [{name: 'a'}, {name: 'a'}, {..}]
		                //  optionB [{..}, {name: 'a'}, {name: 'a'}]
		                // Series with the same name between optionA and optionB
		                // should be mapped.
		                var idNum = 0;
		                do {
		                    keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++;
		                }
		                while (idMap[keyInfo.id]);
		            }

		            idMap[keyInfo.id] = item;
		        });
		    };

		    /**
		     * @public
		     * @param {Object} cptOption
		     * @return {boolean}
		     */
		    modelUtil.isIdInner = function (cptOption) {
		        return isObject(cptOption)
		            && cptOption.id
		            && (cptOption.id + '').indexOf('\0_ec_\0') === 0;
		    };

		    /**
		     * A helper for removing duplicate items between batchA and batchB,
		     * and in themselves, and categorize by series.
		     *
		     * @param {Array.<Object>} batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
		     * @param {Array.<Object>} batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
		     * @return {Array.<Array.<Object>, Array.<Object>>} result: [resultBatchA, resultBatchB]
		     */
		    modelUtil.compressBatches = function (batchA, batchB) {
		        var mapA = {};
		        var mapB = {};

		        makeMap(batchA || [], mapA);
		        makeMap(batchB || [], mapB, mapA);

		        return [mapToArray(mapA), mapToArray(mapB)];

		        function makeMap(sourceBatch, map, otherMap) {
		            for (var i = 0, len = sourceBatch.length; i < len; i++) {
		                var seriesId = sourceBatch[i].seriesId;
		                var dataIndices = modelUtil.normalizeToArray(sourceBatch[i].dataIndex);
		                var otherDataIndices = otherMap && otherMap[seriesId];

		                for (var j = 0, lenj = dataIndices.length; j < lenj; j++) {
		                    var dataIndex = dataIndices[j];

		                    if (otherDataIndices && otherDataIndices[dataIndex]) {
		                        otherDataIndices[dataIndex] = null;
		                    }
		                    else {
		                        (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1;
		                    }
		                }
		            }
		        }

		        function mapToArray(map, isData) {
		            var result = [];
		            for (var i in map) {
		                if (map.hasOwnProperty(i) && map[i] != null) {
		                    if (isData) {
		                        result.push(+i);
		                    }
		                    else {
		                        var dataIndices = mapToArray(map[i], true);
		                        dataIndices.length && result.push({seriesId: i, dataIndex: dataIndices});
		                    }
		                }
		            }
		            return result;
		        }
		    };

		    /**
		     * @param {module:echarts/data/List} data
		     * @param {Object} payload Contains dataIndex (means rawIndex) / dataIndexInside / name
		     *                         each of which can be Array or primary type.
		     * @return {number|Array.<number>} dataIndex If not found, return undefined/null.
		     */
		    modelUtil.queryDataIndex = function (data, payload) {
		        if (payload.dataIndexInside != null) {
		            return payload.dataIndexInside;
		        }
		        else if (payload.dataIndex != null) {
		            return zrUtil.isArray(payload.dataIndex)
		                ? zrUtil.map(payload.dataIndex, function (value) {
		                    return data.indexOfRawIndex(value);
		                })
		                : data.indexOfRawIndex(payload.dataIndex);
		        }
		        else if (payload.name != null) {
		            return zrUtil.isArray(payload.name)
		                ? zrUtil.map(payload.name, function (value) {
		                    return data.indexOfName(value);
		                })
		                : data.indexOfName(payload.name);
		        }
		    };

		    /**
		     * @param {module:echarts/model/Global} ecModel
		     * @param {string|Object} finder
		     *        If string, e.g., 'geo', means {geoIndex: 0}.
		     *        If Object, could contain some of these properties below:
		     *        {
		     *            seriesIndex, seriesId, seriesName,
		     *            geoIndex, geoId, goeName,
		     *            bmapIndex, bmapId, bmapName,
		     *            xAxisIndex, xAxisId, xAxisName,
		     *            yAxisIndex, yAxisId, yAxisName,
		     *            gridIndex, gridId, gridName,
		     *            ... (can be extended)
		     *        }
		     *        Each properties can be number|string|Array.<number>|Array.<string>
		     *        For example, a finder could be
		     *        {
		     *            seriesIndex: 3,
		     *            geoId: ['aa', 'cc'],
		     *            gridName: ['xx', 'rr']
		     *        }
		     * @param {Object} [opt]
		     * @param {string} [opt.defaultMainType]
		     * @return {Object} result like:
		     *        {
		     *            seriesModels: [seriesModel1, seriesModel2],
		     *            seriesModel: seriesModel1, // The first model
		     *            geoModels: [geoModel1, geoModel2],
		     *            geoModel: geoModel1, // The first model
		     *            ...
		     *        }
		     */
		    modelUtil.parseFinder = function (ecModel, finder, opt) {
		        if (zrUtil.isString(finder)) {
		            var obj = {};
		            obj[finder + 'Index'] = 0;
		            finder = obj;
		        }

		        var defaultMainType = opt && opt.defaultMainType;
		        if (defaultMainType
		            && !has(finder, defaultMainType + 'Index')
		            && !has(finder, defaultMainType + 'Id')
		            && !has(finder, defaultMainType + 'Name')
		        ) {
		            finder[defaultMainType + 'Index'] = 0;
		        }

		        var result = {};

		        each(finder, function (value, key) {
		            var value = finder[key];

		            // Exclude 'dataIndex' and other illgal keys.
		            if (key === 'dataIndex' || key === 'dataIndexInside') {
		                result[key] = value;
		                return;
		            }

		            var parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || [];
		            var mainType = parsedKey[1];
		            var queryType = parsedKey[2];

		            if (!mainType || !queryType) {
		                return;
		            }

		            var queryParam = {mainType: mainType};
		            queryParam[queryType.toLowerCase()] = value;
		            var models = ecModel.queryComponents(queryParam);
		            result[mainType + 'Models'] = models;
		            result[mainType + 'Model'] = models[0];
		        });

		        return result;
		    };

		    function has(obj, prop) {
		        return obj && obj.hasOwnProperty(prop);
		    }

		    module.exports = modelUtil;


	/***/ },
	/* 6 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var numberUtil = __webpack_require__(7);
		    var textContain = __webpack_require__(8);

		    var formatUtil = {};
		    /**
		     * 每三位默认加,格式化
		     * @type {string|number} x
		     */
		    formatUtil.addCommas = function (x) {
		        if (isNaN(x)) {
		            return '-';
		        }
		        x = (x + '').split('.');
		        return x[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g,'$1,')
		               + (x.length > 1 ? ('.' + x[1]) : '');
		    };

		    /**
		     * @param {string} str
		     * @param {boolean} [upperCaseFirst=false]
		     * @return {string} str
		     */
		    formatUtil.toCamelCase = function (str, upperCaseFirst) {
		        str = (str || '').toLowerCase().replace(/-(.)/g, function(match, group1) {
		            return group1.toUpperCase();
		        });

		        if (upperCaseFirst && str) {
		            str = str.charAt(0).toUpperCase() + str.slice(1);
		        }

		        return str;
		    };

		    /**
		     * Normalize css liked array configuration
		     * e.g.
		     *  3 => [3, 3, 3, 3]
		     *  [4, 2] => [4, 2, 4, 2]
		     *  [4, 3, 2] => [4, 3, 2, 3]
		     * @param {number|Array.<number>} val
		     */
		    formatUtil.normalizeCssArray = function (val) {
		        var len = val.length;
		        if (typeof (val) === 'number') {
		            return [val, val, val, val];
		        }
		        else if (len === 2) {
		            // vertical | horizontal
		            return [val[0], val[1], val[0], val[1]];
		        }
		        else if (len === 3) {
		            // top | horizontal | bottom
		            return [val[0], val[1], val[2], val[1]];
		        }
		        return val;
		    };

		    formatUtil.encodeHTML = function (source) {
		        return String(source)
		            .replace(/&/g, '&amp;')
		            .replace(/</g, '&lt;')
		            .replace(/>/g, '&gt;')
		            .replace(/"/g, '&quot;')
		            .replace(/'/g, '&#39;');
		    };

		    var TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g'];

		    var wrapVar = function (varName, seriesIdx) {
		        return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}';
		    };

		    /**
		     * Template formatter
		     * @param  {string} tpl
		     * @param  {Array.<Object>|Object} paramsList
		     * @return {string}
		     */
		    formatUtil.formatTpl = function (tpl, paramsList) {
		        if (!zrUtil.isArray(paramsList)) {
		            paramsList = [paramsList];
		        }
		        var seriesLen = paramsList.length;
		        if (!seriesLen) {
		            return '';
		        }

		        var $vars = paramsList[0].$vars || [];
		        for (var i = 0; i < $vars.length; i++) {
		            var alias = TPL_VAR_ALIAS[i];
		            tpl = tpl.replace(wrapVar(alias),  wrapVar(alias, 0));
		        }
		        for (var seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
		            for (var k = 0; k < $vars.length; k++) {
		                tpl = tpl.replace(
		                    wrapVar(TPL_VAR_ALIAS[k], seriesIdx),
		                    paramsList[seriesIdx][$vars[k]]
		                );
		            }
		        }

		        return tpl;
		    };


		    /**
		     * @param {string} str
		     * @return {string}
		     * @inner
		     */
		    var s2d = function (str) {
		        return str < 10 ? ('0' + str) : str;
		    };

		    /**
		     * ISO Date format
		     * @param {string} tpl
		     * @param {number} value
		     * @inner
		     */
		    formatUtil.formatTime = function (tpl, value) {
		        if (tpl === 'week'
		            || tpl === 'month'
		            || tpl === 'quarter'
		            || tpl === 'half-year'
		            || tpl === 'year'
		        ) {
		            tpl = 'MM-dd\nyyyy';
		        }

		        var date = numberUtil.parseDate(value);
		        var y = date.getFullYear();
		        var M = date.getMonth() + 1;
		        var d = date.getDate();
		        var h = date.getHours();
		        var m = date.getMinutes();
		        var s = date.getSeconds();

		        tpl = tpl.replace('MM', s2d(M))
		            .toLowerCase()
		            .replace('yyyy', y)
		            .replace('yy', y % 100)
		            .replace('dd', s2d(d))
		            .replace('d', d)
		            .replace('hh', s2d(h))
		            .replace('h', h)
		            .replace('mm', s2d(m))
		            .replace('m', m)
		            .replace('ss', s2d(s))
		            .replace('s', s);

		        return tpl;
		    };

		    /**
		     * Capital first
		     * @param {string} str
		     * @return {string}
		     */
		    formatUtil.capitalFirst = function (str) {
		        return str ? str.charAt(0).toUpperCase() + str.substr(1) : str;
		    };

		    formatUtil.truncateText = textContain.truncateText;

		    module.exports = formatUtil;


	/***/ },
	/* 7 */
	/***/ function(module, exports) {

		/**
		 * 数值处理模块
		 * @module echarts/util/number
		 */



		    var number = {};

		    var RADIAN_EPSILON = 1e-4;

		    function _trim(str) {
		        return str.replace(/^\s+/, '').replace(/\s+$/, '');
		    }

		    /**
		     * Linear mapping a value from domain to range
		     * @memberOf module:echarts/util/number
		     * @param  {(number|Array.<number>)} val
		     * @param  {Array.<number>} domain Domain extent domain[0] can be bigger than domain[1]
		     * @param  {Array.<number>} range  Range extent range[0] can be bigger than range[1]
		     * @param  {boolean} clamp
		     * @return {(number|Array.<number>}
		     */
		    number.linearMap = function (val, domain, range, clamp) {
		        var subDomain = domain[1] - domain[0];
		        var subRange = range[1] - range[0];

		        if (subDomain === 0) {
		            return subRange === 0
		                ? range[0]
		                : (range[0] + range[1]) / 2;
		        }

		        // Avoid accuracy problem in edge, such as
		        // 146.39 - 62.83 === 83.55999999999999.
		        // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
		        // It is a little verbose for efficiency considering this method
		        // is a hotspot.
		        if (clamp) {
		            if (subDomain > 0) {
		                if (val <= domain[0]) {
		                    return range[0];
		                }
		                else if (val >= domain[1]) {
		                    return range[1];
		                }
		            }
		            else {
		                if (val >= domain[0]) {
		                    return range[0];
		                }
		                else if (val <= domain[1]) {
		                    return range[1];
		                }
		            }
		        }
		        else {
		            if (val === domain[0]) {
		                return range[0];
		            }
		            if (val === domain[1]) {
		                return range[1];
		            }
		        }

		        return (val - domain[0]) / subDomain * subRange + range[0];
		    };

		    /**
		     * Convert a percent string to absolute number.
		     * Returns NaN if percent is not a valid string or number
		     * @memberOf module:echarts/util/number
		     * @param {string|number} percent
		     * @param {number} all
		     * @return {number}
		     */
		    number.parsePercent = function(percent, all) {
		        switch (percent) {
		            case 'center':
		            case 'middle':
		                percent = '50%';
		                break;
		            case 'left':
		            case 'top':
		                percent = '0%';
		                break;
		            case 'right':
		            case 'bottom':
		                percent = '100%';
		                break;
		        }
		        if (typeof percent === 'string') {
		            if (_trim(percent).match(/%$/)) {
		                return parseFloat(percent) / 100 * all;
		            }

		            return parseFloat(percent);
		        }

		        return percent == null ? NaN : +percent;
		    };

		    /**
		     * Fix rounding error of float numbers
		     * @param {number} x
		     * @return {number}
		     */
		    number.round = function (x, precision) {
		        if (precision == null) {
		            precision = 10;
		        }
		        // Avoid range error
		        precision = Math.min(Math.max(0, precision), 20);
		        return +(+x).toFixed(precision);
		    };

		    number.asc = function (arr) {
		        arr.sort(function (a, b) {
		            return a - b;
		        });
		        return arr;
		    };

		    /**
		     * Get precision
		     * @param {number} val
		     */
		    number.getPrecision = function (val) {
		        val = +val;
		        if (isNaN(val)) {
		            return 0;
		        }
		        // It is much faster than methods converting number to string as follows
		        //      var tmp = val.toString();
		        //      return tmp.length - 1 - tmp.indexOf('.');
		        // especially when precision is low
		        var e = 1;
		        var count = 0;
		        while (Math.round(val * e) / e !== val) {
		            e *= 10;
		            count++;
		        }
		        return count;
		    };

		    number.getPrecisionSafe = function (val) {
		        var str = val.toString();
		        var dotIndex = str.indexOf('.');
		        if (dotIndex < 0) {
		            return 0;
		        }
		        return str.length - 1 - dotIndex;
		    };

		    /**
		     * @param {Array.<number>} dataExtent
		     * @param {Array.<number>} pixelExtent
		     * @return {number}  precision
		     */
		    number.getPixelPrecision = function (dataExtent, pixelExtent) {
		        var log = Math.log;
		        var LN10 = Math.LN10;
		        var dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10);
		        var sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10);
		        return Math.max(
		            -dataQuantity + sizeQuantity,
		            0
		        );
		    };

		    // Number.MAX_SAFE_INTEGER, ie do not support.
		    number.MAX_SAFE_INTEGER = 9007199254740991;

		    /**
		     * To 0 - 2 * PI, considering negative radian.
		     * @param {number} radian
		     * @return {number}
		     */
		    number.remRadian = function (radian) {
		        var pi2 = Math.PI * 2;
		        return (radian % pi2 + pi2) % pi2;
		    };

		    /**
		     * @param {type} radian
		     * @return {boolean}
		     */
		    number.isRadianAroundZero = function (val) {
		        return val > -RADIAN_EPSILON && val < RADIAN_EPSILON;
		    };

		    /**
		     * @param {string|Date|number} value
		     * @return {Date} date
		     */
		    number.parseDate = function (value) {
		        if (value instanceof Date) {
		            return value;
		        }
		        else if (typeof value === 'string') {
		            // Treat as ISO format. See issue #3623
		            var ret = new Date(value);
		            if (isNaN(+ret)) {
		                // FIXME new Date('1970-01-01') is UTC, new Date('1970/01/01') is local
		                ret = new Date(new Date(value.replace(/-/g, '/')) - new Date('1970/01/01'));
		            }
		            return ret;
		        }

		        return new Date(Math.round(value));
		    };

		    /**
		     * Quantity of a number. e.g. 0.1, 1, 10, 100
		     * @param  {number} val
		     * @return {number}
		     */
		    number.quantity = function (val) {
		        return Math.pow(10, Math.floor(Math.log(val) / Math.LN10));
		    };

		    // "Nice Numbers for Graph Labels" of Graphic Gems
		    /**
		     * find a “nice” number approximately equal to x. Round the number if round = true, take ceiling if round = false
		     * The primary observation is that the “nicest” numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
		     * @param  {number} val
		     * @param  {boolean} round
		     * @return {number}
		     */
		    number.nice = function (val, round) {
		        var exp10 = number.quantity(val);
		        var f = val / exp10; // between 1 and 10
		        var nf;
		        if (round) {
		            if (f < 1.5) { nf = 1; }
		            else if (f < 2.5) { nf = 2; }
		            else if (f < 4) { nf = 3; }
		            else if (f < 7) { nf = 5; }
		            else { nf = 10; }
		        }
		        else {
		            if (f < 1) { nf = 1; }
		            else if (f < 2) { nf = 2; }
		            else if (f < 3) { nf = 3; }
		            else if (f < 5) { nf = 5; }
		            else { nf = 10; }
		        }
		        return nf * exp10;
		    };

		    /**
		     * Order intervals asc, and split them when overlap.
		     * expect(numberUtil.reformIntervals([
		     *     {interval: [18, 62], close: [1, 1]},
		     *     {interval: [-Infinity, -70], close: [0, 0]},
		     *     {interval: [-70, -26], close: [1, 1]},
		     *     {interval: [-26, 18], close: [1, 1]},
		     *     {interval: [62, 150], close: [1, 1]},
		     *     {interval: [106, 150], close: [1, 1]},
		     *     {interval: [150, Infinity], close: [0, 0]}
		     * ])).toEqual([
		     *     {interval: [-Infinity, -70], close: [0, 0]},
		     *     {interval: [-70, -26], close: [1, 1]},
		     *     {interval: [-26, 18], close: [0, 1]},
		     *     {interval: [18, 62], close: [0, 1]},
		     *     {interval: [62, 150], close: [0, 1]},
		     *     {interval: [150, Infinity], close: [0, 0]}
		     * ]);
		     * @param {Array.<Object>} list, where `close` mean open or close
		     *        of the interval, and Infinity can be used.
		     * @return {Array.<Object>} The origin list, which has been reformed.
		     */
		    number.reformIntervals = function (list) {
		        list.sort(function (a, b) {
		            return littleThan(a, b, 0) ? -1 : 1;
		        });

		        var curr = -Infinity;
		        var currClose = 1;
		        for (var i = 0; i < list.length;) {
		            var interval = list[i].interval;
		            var close = list[i].close;

		            for (var lg = 0; lg < 2; lg++) {
		                if (interval[lg] <= curr) {
		                    interval[lg] = curr;
		                    close[lg] = !lg ? 1 - currClose : 1;
		                }
		                curr = interval[lg];
		                currClose = close[lg];
		            }

		            if (interval[0] === interval[1] && close[0] * close[1] !== 1) {
		                list.splice(i, 1);
		            }
		            else {
		                i++;
		            }
		        }

		        return list;

		        function littleThan(a, b, lg) {
		            return a.interval[lg] < b.interval[lg]
		                || (
		                    a.interval[lg] === b.interval[lg]
		                    && (
		                        (a.close[lg] - b.close[lg] === (!lg ? 1 : -1))
		                        || (!lg && littleThan(a, b, 1))
		                    )
		                );
		        }
		    };

		    module.exports = number;


	/***/ },
	/* 8 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var textWidthCache = {};
		    var textWidthCacheCounter = 0;
		    var TEXT_CACHE_MAX = 5000;

		    var util = __webpack_require__(4);
		    var BoundingRect = __webpack_require__(9);
		    var retrieve = util.retrieve;

		    function getTextWidth(text, textFont) {
		        var key = text + ':' + textFont;
		        if (textWidthCache[key]) {
		            return textWidthCache[key];
		        }

		        var textLines = (text + '').split('\n');
		        var width = 0;

		        for (var i = 0, l = textLines.length; i < l; i++) {
		            // measureText 可以被覆盖以兼容不支持 Canvas 的环境
		            width = Math.max(textContain.measureText(textLines[i], textFont).width, width);
		        }

		        if (textWidthCacheCounter > TEXT_CACHE_MAX) {
		            textWidthCacheCounter = 0;
		            textWidthCache = {};
		        }
		        textWidthCacheCounter++;
		        textWidthCache[key] = width;

		        return width;
		    }

		    function getTextRect(text, textFont, textAlign, textBaseline) {
		        var textLineLen = ((text || '') + '').split('\n').length;

		        var width = getTextWidth(text, textFont);
		        // FIXME 高度计算比较粗暴
		        var lineHeight = getTextWidth('国', textFont);
		        var height = textLineLen * lineHeight;

		        var rect = new BoundingRect(0, 0, width, height);
		        // Text has a special line height property
		        rect.lineHeight = lineHeight;

		        switch (textBaseline) {
		            case 'bottom':
		            case 'alphabetic':
		                rect.y -= lineHeight;
		                break;
		            case 'middle':
		                rect.y -= lineHeight / 2;
		                break;
		            // case 'hanging':
		            // case 'top':
		        }

		        // FIXME Right to left language
		        switch (textAlign) {
		            case 'end':
		            case 'right':
		                rect.x -= rect.width;
		                break;
		            case 'center':
		                rect.x -= rect.width / 2;
		                break;
		            // case 'start':
		            // case 'left':
		        }

		        return rect;
		    }

		    function adjustTextPositionOnRect(textPosition, rect, textRect, distance) {

		        var x = rect.x;
		        var y = rect.y;

		        var height = rect.height;
		        var width = rect.width;

		        var textHeight = textRect.height;

		        var halfHeight = height / 2 - textHeight / 2;

		        var textAlign = 'left';

		        switch (textPosition) {
		            case 'left':
		                x -= distance;
		                y += halfHeight;
		                textAlign = 'right';
		                break;
		            case 'right':
		                x += distance + width;
		                y += halfHeight;
		                textAlign = 'left';
		                break;
		            case 'top':
		                x += width / 2;
		                y -= distance + textHeight;
		                textAlign = 'center';
		                break;
		            case 'bottom':
		                x += width / 2;
		                y += height + distance;
		                textAlign = 'center';
		                break;
		            case 'inside':
		                x += width / 2;
		                y += halfHeight;
		                textAlign = 'center';
		                break;
		            case 'insideLeft':
		                x += distance;
		                y += halfHeight;
		                textAlign = 'left';
		                break;
		            case 'insideRight':
		                x += width - distance;
		                y += halfHeight;
		                textAlign = 'right';
		                break;
		            case 'insideTop':
		                x += width / 2;
		                y += distance;
		                textAlign = 'center';
		                break;
		            case 'insideBottom':
		                x += width / 2;
		                y += height - textHeight - distance;
		                textAlign = 'center';
		                break;
		            case 'insideTopLeft':
		                x += distance;
		                y += distance;
		                textAlign = 'left';
		                break;
		            case 'insideTopRight':
		                x += width - distance;
		                y += distance;
		                textAlign = 'right';
		                break;
		            case 'insideBottomLeft':
		                x += distance;
		                y += height - textHeight - distance;
		                break;
		            case 'insideBottomRight':
		                x += width - distance;
		                y += height - textHeight - distance;
		                textAlign = 'right';
		                break;
		        }

		        return {
		            x: x,
		            y: y,
		            textAlign: textAlign,
		            textBaseline: 'top'
		        };
		    }

		    /**
		     * Show ellipsis if overflow.
		     *
		     * @param  {string} text
		     * @param  {string} containerWidth
		     * @param  {string} textFont
		     * @param  {number} [ellipsis='...']
		     * @param  {Object} [options]
		     * @param  {number} [options.maxIterations=3]
		     * @param  {number} [options.minChar=0] If truncate result are less
		     *                  then minChar, ellipsis will not show, which is
		     *                  better for user hint in some cases.
		     * @param  {number} [options.placeholder=''] When all truncated, use the placeholder.
		     * @return {string}
		     */
		    function truncateText(text, containerWidth, textFont, ellipsis, options) {
		        if (!containerWidth) {
		            return '';
		        }

		        options = options || {};

		        ellipsis = retrieve(ellipsis, '...');
		        var maxIterations = retrieve(options.maxIterations, 2);
		        var minChar = retrieve(options.minChar, 0);
		        // FIXME
		        // Other languages?
		        var cnCharWidth = getTextWidth('国', textFont);
		        // FIXME
		        // Consider proportional font?
		        var ascCharWidth = getTextWidth('a', textFont);
		        var placeholder = retrieve(options.placeholder, '');

		        // Example 1: minChar: 3, text: 'asdfzxcv', truncate result: 'asdf', but not: 'a...'.
		        // Example 2: minChar: 3, text: '维度', truncate result: '维', but not: '...'.
		        var contentWidth = containerWidth = Math.max(0, containerWidth - 1); // Reserve some gap.
		        for (var i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
		            contentWidth -= ascCharWidth;
		        }

		        var ellipsisWidth = getTextWidth(ellipsis);
		        if (ellipsisWidth > contentWidth) {
		            ellipsis = '';
		            ellipsisWidth = 0;
		        }

		        contentWidth = containerWidth - ellipsisWidth;

		        var textLines = (text + '').split('\n');

		        for (var i = 0, len = textLines.length; i < len; i++) {
		            var textLine = textLines[i];
		            var lineWidth = getTextWidth(textLine, textFont);

		            if (lineWidth <= containerWidth) {
		                continue;
		            }

		            for (var j = 0;; j++) {
		                if (lineWidth <= contentWidth || j >= maxIterations) {
		                    textLine += ellipsis;
		                    break;
		                }

		                var subLength = j === 0
		                    ? estimateLength(textLine, contentWidth, ascCharWidth, cnCharWidth)
		                    : lineWidth > 0
		                    ? Math.floor(textLine.length * contentWidth / lineWidth)
		                    : 0;

		                textLine = textLine.substr(0, subLength);
		                lineWidth = getTextWidth(textLine, textFont);
		            }

		            if (textLine === '') {
		                textLine = placeholder;
		            }

		            textLines[i] = textLine;
		        }

		        return textLines.join('\n');
		    }

		    function estimateLength(text, contentWidth, ascCharWidth, cnCharWidth) {
		        var width = 0;
		        var i = 0;
		        for (var len = text.length; i < len && width < contentWidth; i++) {
		            var charCode = text.charCodeAt(i);
		            width += (0 <= charCode && charCode <= 127) ? ascCharWidth : cnCharWidth;
		        }
		        return i;
		    }

		    var textContain = {

		        getWidth: getTextWidth,

		        getBoundingRect: getTextRect,

		        adjustTextPositionOnRect: adjustTextPositionOnRect,

		        truncateText: truncateText,

		        measureText: function (text, textFont) {
		            var ctx = util.getContext();
		            ctx.font = textFont || '12px sans-serif';
		            return ctx.measureText(text);
		        }
		    };

		    module.exports = textContain;


	/***/ },
	/* 9 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * @module echarts/core/BoundingRect
		 */


		    var vec2 = __webpack_require__(10);
		    var matrix = __webpack_require__(11);

		    var v2ApplyTransform = vec2.applyTransform;
		    var mathMin = Math.min;
		    var mathMax = Math.max;
		    /**
		     * @alias module:echarts/core/BoundingRect
		     */
		    function BoundingRect(x, y, width, height) {

		        if (width < 0) {
		            x = x + width;
		            width = -width;
		        }
		        if (height < 0) {
		            y = y + height;
		            height = -height;
		        }

		        /**
		         * @type {number}
		         */
		        this.x = x;
		        /**
		         * @type {number}
		         */
		        this.y = y;
		        /**
		         * @type {number}
		         */
		        this.width = width;
		        /**
		         * @type {number}
		         */
		        this.height = height;
		    }

		    BoundingRect.prototype = {

		        constructor: BoundingRect,

		        /**
		         * @param {module:echarts/core/BoundingRect} other
		         */
		        union: function (other) {
		            var x = mathMin(other.x, this.x);
		            var y = mathMin(other.y, this.y);

		            this.width = mathMax(
		                    other.x + other.width,
		                    this.x + this.width
		                ) - x;
		            this.height = mathMax(
		                    other.y + other.height,
		                    this.y + this.height
		                ) - y;
		            this.x = x;
		            this.y = y;
		        },

		        /**
		         * @param {Array.<number>} m
		         * @methods
		         */
		        applyTransform: (function () {
		            var lt = [];
		            var rb = [];
		            var lb = [];
		            var rt = [];
		            return function (m) {
		                // In case usage like this
		                // el.getBoundingRect().applyTransform(el.transform)
		                // And element has no transform
		                if (!m) {
		                    return;
		                }
		                lt[0] = lb[0] = this.x;
		                lt[1] = rt[1] = this.y;
		                rb[0] = rt[0] = this.x + this.width;
		                rb[1] = lb[1] = this.y + this.height;

		                v2ApplyTransform(lt, lt, m);
		                v2ApplyTransform(rb, rb, m);
		                v2ApplyTransform(lb, lb, m);
		                v2ApplyTransform(rt, rt, m);

		                this.x = mathMin(lt[0], rb[0], lb[0], rt[0]);
		                this.y = mathMin(lt[1], rb[1], lb[1], rt[1]);
		                var maxX = mathMax(lt[0], rb[0], lb[0], rt[0]);
		                var maxY = mathMax(lt[1], rb[1], lb[1], rt[1]);
		                this.width = maxX - this.x;
		                this.height = maxY - this.y;
		            };
		        })(),

		        /**
		         * Calculate matrix of transforming from self to target rect
		         * @param  {module:zrender/core/BoundingRect} b
		         * @return {Array.<number>}
		         */
		        calculateTransform: function (b) {
		            var a = this;
		            var sx = b.width / a.width;
		            var sy = b.height / a.height;

		            var m = matrix.create();

		            // 矩阵右乘
		            matrix.translate(m, m, [-a.x, -a.y]);
		            matrix.scale(m, m, [sx, sy]);
		            matrix.translate(m, m, [b.x, b.y]);

		            return m;
		        },

		        /**
		         * @param {(module:echarts/core/BoundingRect|Object)} b
		         * @return {boolean}
		         */
		        intersect: function (b) {
		            if (!b) {
		                return false;
		            }

		            if (!(b instanceof BoundingRect)) {
		                // Normalize negative width/height.
		                b = BoundingRect.create(b);
		            }

		            var a = this;
		            var ax0 = a.x;
		            var ax1 = a.x + a.width;
		            var ay0 = a.y;
		            var ay1 = a.y + a.height;

		            var bx0 = b.x;
		            var bx1 = b.x + b.width;
		            var by0 = b.y;
		            var by1 = b.y + b.height;

		            return ! (ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0);
		        },

		        contain: function (x, y) {
		            var rect = this;
		            return x >= rect.x
		                && x <= (rect.x + rect.width)
		                && y >= rect.y
		                && y <= (rect.y + rect.height);
		        },

		        /**
		         * @return {module:echarts/core/BoundingRect}
		         */
		        clone: function () {
		            return new BoundingRect(this.x, this.y, this.width, this.height);
		        },

		        /**
		         * Copy from another rect
		         */
		        copy: function (other) {
		            this.x = other.x;
		            this.y = other.y;
		            this.width = other.width;
		            this.height = other.height;
		        },

		        plain: function () {
		            return {
		                x: this.x,
		                y: this.y,
		                width: this.width,
		                height: this.height
		            };
		        }
		    };

		    /**
		     * @param {Object|module:zrender/core/BoundingRect} rect
		     * @param {number} rect.x
		     * @param {number} rect.y
		     * @param {number} rect.width
		     * @param {number} rect.height
		     * @return {module:zrender/core/BoundingRect}
		     */
		    BoundingRect.create = function (rect) {
		        return new BoundingRect(rect.x, rect.y, rect.width, rect.height);
		    };

		    module.exports = BoundingRect;


	/***/ },
	/* 10 */
	/***/ function(module, exports) {

		
		    var ArrayCtor = typeof Float32Array === 'undefined'
		        ? Array
		        : Float32Array;

		    /**
		     * @typedef {Float32Array|Array.<number>} Vector2
		     */
		    /**
		     * 二维向量类
		     * @exports zrender/tool/vector
		     */
		    var vector = {
		        /**
		         * 创建一个向量
		         * @param {number} [x=0]
		         * @param {number} [y=0]
		         * @return {Vector2}
		         */
		        create: function (x, y) {
		            var out = new ArrayCtor(2);
		            if (x == null) {
		                x = 0;
		            }
		            if (y == null) {
		                y = 0;
		            }
		            out[0] = x;
		            out[1] = y;
		            return out;
		        },

		        /**
		         * 复制向量数据
		         * @param {Vector2} out
		         * @param {Vector2} v
		         * @return {Vector2}
		         */
		        copy: function (out, v) {
		            out[0] = v[0];
		            out[1] = v[1];
		            return out;
		        },

		        /**
		         * 克隆一个向量
		         * @param {Vector2} v
		         * @return {Vector2}
		         */
		        clone: function (v) {
		            var out = new ArrayCtor(2);
		            out[0] = v[0];
		            out[1] = v[1];
		            return out;
		        },

		        /**
		         * 设置向量的两个项
		         * @param {Vector2} out
		         * @param {number} a
		         * @param {number} b
		         * @return {Vector2} 结果
		         */
		        set: function (out, a, b) {
		            out[0] = a;
		            out[1] = b;
		            return out;
		        },

		        /**
		         * 向量相加
		         * @param {Vector2} out
		         * @param {Vector2} v1
		         * @param {Vector2} v2
		         */
		        add: function (out, v1, v2) {
		            out[0] = v1[0] + v2[0];
		            out[1] = v1[1] + v2[1];
		            return out;
		        },

		        /**
		         * 向量缩放后相加
		         * @param {Vector2} out
		         * @param {Vector2} v1
		         * @param {Vector2} v2
		         * @param {number} a
		         */
		        scaleAndAdd: function (out, v1, v2, a) {
		            out[0] = v1[0] + v2[0] * a;
		            out[1] = v1[1] + v2[1] * a;
		            return out;
		        },

		        /**
		         * 向量相减
		         * @param {Vector2} out
		         * @param {Vector2} v1
		         * @param {Vector2} v2
		         */
		        sub: function (out, v1, v2) {
		            out[0] = v1[0] - v2[0];
		            out[1] = v1[1] - v2[1];
		            return out;
		        },

		        /**
		         * 向量长度
		         * @param {Vector2} v
		         * @return {number}
		         */
		        len: function (v) {
		            return Math.sqrt(this.lenSquare(v));
		        },

		        /**
		         * 向量长度平方
		         * @param {Vector2} v
		         * @return {number}
		         */
		        lenSquare: function (v) {
		            return v[0] * v[0] + v[1] * v[1];
		        },

		        /**
		         * 向量乘法
		         * @param {Vector2} out
		         * @param {Vector2} v1
		         * @param {Vector2} v2
		         */
		        mul: function (out, v1, v2) {
		            out[0] = v1[0] * v2[0];
		            out[1] = v1[1] * v2[1];
		            return out;
		        },

		        /**
		         * 向量除法
		         * @param {Vector2} out
		         * @param {Vector2} v1
		         * @param {Vector2} v2
		         */
		        div: function (out, v1, v2) {
		            out[0] = v1[0] / v2[0];
		            out[1] = v1[1] / v2[1];
		            return out;
		        },

		        /**
		         * 向量点乘
		         * @param {Vector2} v1
		         * @param {Vector2} v2
		         * @return {number}
		         */
		        dot: function (v1, v2) {
		            return v1[0] * v2[0] + v1[1] * v2[1];
		        },

		        /**
		         * 向量缩放
		         * @param {Vector2} out
		         * @param {Vector2} v
		         * @param {number} s
		         */
		        scale: function (out, v, s) {
		            out[0] = v[0] * s;
		            out[1] = v[1] * s;
		            return out;
		        },

		        /**
		         * 向量归一化
		         * @param {Vector2} out
		         * @param {Vector2} v
		         */
		        normalize: function (out, v) {
		            var d = vector.len(v);
		            if (d === 0) {
		                out[0] = 0;
		                out[1] = 0;
		            }
		            else {
		                out[0] = v[0] / d;
		                out[1] = v[1] / d;
		            }
		            return out;
		        },

		        /**
		         * 计算向量间距离
		         * @param {Vector2} v1
		         * @param {Vector2} v2
		         * @return {number}
		         */
		        distance: function (v1, v2) {
		            return Math.sqrt(
		                (v1[0] - v2[0]) * (v1[0] - v2[0])
		                + (v1[1] - v2[1]) * (v1[1] - v2[1])
		            );
		        },

		        /**
		         * 向量距离平方
		         * @param {Vector2} v1
		         * @param {Vector2} v2
		         * @return {number}
		         */
		        distanceSquare: function (v1, v2) {
		            return (v1[0] - v2[0]) * (v1[0] - v2[0])
		                + (v1[1] - v2[1]) * (v1[1] - v2[1]);
		        },

		        /**
		         * 求负向量
		         * @param {Vector2} out
		         * @param {Vector2} v
		         */
		        negate: function (out, v) {
		            out[0] = -v[0];
		            out[1] = -v[1];
		            return out;
		        },

		        /**
		         * 插值两个点
		         * @param {Vector2} out
		         * @param {Vector2} v1
		         * @param {Vector2} v2
		         * @param {number} t
		         */
		        lerp: function (out, v1, v2, t) {
		            out[0] = v1[0] + t * (v2[0] - v1[0]);
		            out[1] = v1[1] + t * (v2[1] - v1[1]);
		            return out;
		        },

		        /**
		         * 矩阵左乘向量
		         * @param {Vector2} out
		         * @param {Vector2} v
		         * @param {Vector2} m
		         */
		        applyTransform: function (out, v, m) {
		            var x = v[0];
		            var y = v[1];
		            out[0] = m[0] * x + m[2] * y + m[4];
		            out[1] = m[1] * x + m[3] * y + m[5];
		            return out;
		        },
		        /**
		         * 求两个向量最小值
		         * @param  {Vector2} out
		         * @param  {Vector2} v1
		         * @param  {Vector2} v2
		         */
		        min: function (out, v1, v2) {
		            out[0] = Math.min(v1[0], v2[0]);
		            out[1] = Math.min(v1[1], v2[1]);
		            return out;
		        },
		        /**
		         * 求两个向量最大值
		         * @param  {Vector2} out
		         * @param  {Vector2} v1
		         * @param  {Vector2} v2
		         */
		        max: function (out, v1, v2) {
		            out[0] = Math.max(v1[0], v2[0]);
		            out[1] = Math.max(v1[1], v2[1]);
		            return out;
		        }
		    };

		    vector.length = vector.len;
		    vector.lengthSquare = vector.lenSquare;
		    vector.dist = vector.distance;
		    vector.distSquare = vector.distanceSquare;

		    module.exports = vector;



	/***/ },
	/* 11 */
	/***/ function(module, exports) {

		
		    var ArrayCtor = typeof Float32Array === 'undefined'
		        ? Array
		        : Float32Array;
		    /**
		     * 3x2矩阵操作类
		     * @exports zrender/tool/matrix
		     */
		    var matrix = {
		        /**
		         * 创建一个单位矩阵
		         * @return {Float32Array|Array.<number>}
		         */
		        create : function() {
		            var out = new ArrayCtor(6);
		            matrix.identity(out);

		            return out;
		        },
		        /**
		         * 设置矩阵为单位矩阵
		         * @param {Float32Array|Array.<number>} out
		         */
		        identity : function(out) {
		            out[0] = 1;
		            out[1] = 0;
		            out[2] = 0;
		            out[3] = 1;
		            out[4] = 0;
		            out[5] = 0;
		            return out;
		        },
		        /**
		         * 复制矩阵
		         * @param {Float32Array|Array.<number>} out
		         * @param {Float32Array|Array.<number>} m
		         */
		        copy: function(out, m) {
		            out[0] = m[0];
		            out[1] = m[1];
		            out[2] = m[2];
		            out[3] = m[3];
		            out[4] = m[4];
		            out[5] = m[5];
		            return out;
		        },
		        /**
		         * 矩阵相乘
		         * @param {Float32Array|Array.<number>} out
		         * @param {Float32Array|Array.<number>} m1
		         * @param {Float32Array|Array.<number>} m2
		         */
		        mul : function (out, m1, m2) {
		            // Consider matrix.mul(m, m2, m);
		            // where out is the same as m2.
		            // So use temp variable to escape error.
		            var out0 = m1[0] * m2[0] + m1[2] * m2[1];
		            var out1 = m1[1] * m2[0] + m1[3] * m2[1];
		            var out2 = m1[0] * m2[2] + m1[2] * m2[3];
		            var out3 = m1[1] * m2[2] + m1[3] * m2[3];
		            var out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4];
		            var out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5];
		            out[0] = out0;
		            out[1] = out1;
		            out[2] = out2;
		            out[3] = out3;
		            out[4] = out4;
		            out[5] = out5;
		            return out;
		        },
		        /**
		         * 平移变换
		         * @param {Float32Array|Array.<number>} out
		         * @param {Float32Array|Array.<number>} a
		         * @param {Float32Array|Array.<number>} v
		         */
		        translate : function(out, a, v) {
		            out[0] = a[0];
		            out[1] = a[1];
		            out[2] = a[2];
		            out[3] = a[3];
		            out[4] = a[4] + v[0];
		            out[5] = a[5] + v[1];
		            return out;
		        },
		        /**
		         * 旋转变换
		         * @param {Float32Array|Array.<number>} out
		         * @param {Float32Array|Array.<number>} a
		         * @param {number} rad
		         */
		        rotate : function(out, a, rad) {
		            var aa = a[0];
		            var ac = a[2];
		            var atx = a[4];
		            var ab = a[1];
		            var ad = a[3];
		            var aty = a[5];
		            var st = Math.sin(rad);
		            var ct = Math.cos(rad);

		            out[0] = aa * ct + ab * st;
		            out[1] = -aa * st + ab * ct;
		            out[2] = ac * ct + ad * st;
		            out[3] = -ac * st + ct * ad;
		            out[4] = ct * atx + st * aty;
		            out[5] = ct * aty - st * atx;
		            return out;
		        },
		        /**
		         * 缩放变换
		         * @param {Float32Array|Array.<number>} out
		         * @param {Float32Array|Array.<number>} a
		         * @param {Float32Array|Array.<number>} v
		         */
		        scale : function(out, a, v) {
		            var vx = v[0];
		            var vy = v[1];
		            out[0] = a[0] * vx;
		            out[1] = a[1] * vy;
		            out[2] = a[2] * vx;
		            out[3] = a[3] * vy;
		            out[4] = a[4] * vx;
		            out[5] = a[5] * vy;
		            return out;
		        },
		        /**
		         * 求逆矩阵
		         * @param {Float32Array|Array.<number>} out
		         * @param {Float32Array|Array.<number>} a
		         */
		        invert : function(out, a) {

		            var aa = a[0];
		            var ac = a[2];
		            var atx = a[4];
		            var ab = a[1];
		            var ad = a[3];
		            var aty = a[5];

		            var det = aa * ad - ab * ac;
		            if (!det) {
		                return null;
		            }
		            det = 1.0 / det;

		            out[0] = ad * det;
		            out[1] = -ab * det;
		            out[2] = -ac * det;
		            out[3] = aa * det;
		            out[4] = (ac * aty - ad * atx) * det;
		            out[5] = (ab * atx - aa * aty) * det;
		            return out;
		        }
		    };

		    module.exports = matrix;



	/***/ },
	/* 12 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/model/Model
		 */


		    var zrUtil = __webpack_require__(4);
		    var clazzUtil = __webpack_require__(13);

		    /**
		     * @alias module:echarts/model/Model
		     * @constructor
		     * @param {Object} option
		     * @param {module:echarts/model/Model} [parentModel]
		     * @param {module:echarts/model/Global} [ecModel]
		     */
		    function Model(option, parentModel, ecModel) {
		        /**
		         * @type {module:echarts/model/Model}
		         * @readOnly
		         */
		        this.parentModel = parentModel;

		        /**
		         * @type {module:echarts/model/Global}
		         * @readOnly
		         */
		        this.ecModel = ecModel;

		        /**
		         * @type {Object}
		         * @protected
		         */
		        this.option = option;

		        // Simple optimization
		        // if (this.init) {
		        //     if (arguments.length <= 4) {
		        //         this.init(option, parentModel, ecModel, extraOpt);
		        //     }
		        //     else {
		        //         this.init.apply(this, arguments);
		        //     }
		        // }
		    }

		    Model.prototype = {

		        constructor: Model,

		        /**
		         * Model 的初始化函数
		         * @param {Object} option
		         */
		        init: null,

		        /**
		         * 从新的 Option merge
		         */
		        mergeOption: function (option) {
		            zrUtil.merge(this.option, option, true);
		        },

		        /**
		         * @param {string} path
		         * @param {boolean} [ignoreParent=false]
		         * @return {*}
		         */
		        get: function (path, ignoreParent) {
		            if (!path) {
		                return this.option;
		            }

		            if (typeof path === 'string') {
		                path = path.split('.');
		            }

		            var obj = this.option;
		            var parentModel = this.parentModel;
		            for (var i = 0; i < path.length; i++) {
		                // Ignore empty
		                if (!path[i]) {
		                    continue;
		                }
		                // obj could be number/string/... (like 0)
		                obj = (obj && typeof obj === 'object') ? obj[path[i]] : null;
		                if (obj == null) {
		                    break;
		                }
		            }
		            if (obj == null && parentModel && !ignoreParent) {
		                obj = parentModel.get(path);
		            }
		            return obj;
		        },

		        /**
		         * @param {string} key
		         * @param {boolean} [ignoreParent=false]
		         * @return {*}
		         */
		        getShallow: function (key, ignoreParent) {
		            var option = this.option;

		            var val = option == null ? option : option[key];
		            var parentModel = this.parentModel;
		            if (val == null && parentModel && !ignoreParent) {
		                val = parentModel.getShallow(key);
		            }
		            return val;
		        },

		        /**
		         * @param {string} path
		         * @param {module:echarts/model/Model} [parentModel]
		         * @return {module:echarts/model/Model}
		         */
		        getModel: function (path, parentModel) {
		            var obj = this.get(path, true);
		            var thisParentModel = this.parentModel;
		            var model = new Model(
		                obj, parentModel || (thisParentModel && thisParentModel.getModel(path)),
		                this.ecModel
		            );
		            return model;
		        },

		        /**
		         * If model has option
		         */
		        isEmpty: function () {
		            return this.option == null;
		        },

		        restoreData: function () {},

		        // Pending
		        clone: function () {
		            var Ctor = this.constructor;
		            return new Ctor(zrUtil.clone(this.option));
		        },

		        setReadOnly: function (properties) {
		            clazzUtil.setReadOnly(this, properties);
		        }
		    };

		    // Enable Model.extend.
		    clazzUtil.enableClassExtend(Model);

		    var mixin = zrUtil.mixin;
		    mixin(Model, __webpack_require__(14));
		    mixin(Model, __webpack_require__(16));
		    mixin(Model, __webpack_require__(17));
		    mixin(Model, __webpack_require__(18));

		    module.exports = Model;


	/***/ },
	/* 13 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    var clazz = {};

		    var TYPE_DELIMITER = '.';
		    var IS_CONTAINER = '___EC__COMPONENT__CONTAINER___';
		    /**
		     * @public
		     */
		    var parseClassType = clazz.parseClassType = function (componentType) {
		        var ret = {main: '', sub: ''};
		        if (componentType) {
		            componentType = componentType.split(TYPE_DELIMITER);
		            ret.main = componentType[0] || '';
		            ret.sub = componentType[1] || '';
		        }
		        return ret;
		    };
		    /**
		     * @public
		     */
		    clazz.enableClassExtend = function (RootClass, mandatoryMethods) {

		        RootClass.$constructor = RootClass;
		        RootClass.extend = function (proto) {

		            if (true) {
		                zrUtil.each(mandatoryMethods, function (method) {
		                    if (!proto[method]) {
		                        console.warn(
		                            'Method `' + method + '` should be implemented'
		                            + (proto.type ? ' in ' + proto.type : '') + '.'
		                        );
		                    }
		                });
		            }

		            var superClass = this;
		            var ExtendedClass = function () {
		                if (!proto.$constructor) {
		                    superClass.apply(this, arguments);
		                }
		                else {
		                    proto.$constructor.apply(this, arguments);
		                }
		            };

		            zrUtil.extend(ExtendedClass.prototype, proto);

		            ExtendedClass.extend = this.extend;
		            ExtendedClass.superCall = superCall;
		            ExtendedClass.superApply = superApply;
		            zrUtil.inherits(ExtendedClass, this);
		            ExtendedClass.superClass = superClass;

		            return ExtendedClass;
		        };
		    };

		    // superCall should have class info, which can not be fetch from 'this'.
		    // Consider this case:
		    // class A has method f,
		    // class B inherits class A, overrides method f, f call superApply('f'),
		    // class C inherits class B, do not overrides method f,
		    // then when method of class C is called, dead loop occured.
		    function superCall(context, methodName) {
		        var args = zrUtil.slice(arguments, 2);
		        return this.superClass.prototype[methodName].apply(context, args);
		    }

		    function superApply(context, methodName, args) {
		        return this.superClass.prototype[methodName].apply(context, args);
		    }

		    /**
		     * @param {Object} entity
		     * @param {Object} options
		     * @param {boolean} [options.registerWhenExtend]
		     * @public
		     */
		    clazz.enableClassManagement = function (entity, options) {
		        options = options || {};

		        /**
		         * Component model classes
		         * key: componentType,
		         * value:
		         *     componentClass, when componentType is 'xxx'
		         *     or Object.<subKey, componentClass>, when componentType is 'xxx.yy'
		         * @type {Object}
		         */
		        var storage = {};

		        entity.registerClass = function (Clazz, componentType) {
		            if (componentType) {
		                componentType = parseClassType(componentType);

		                if (!componentType.sub) {
		                    if (true) {
		                        if (storage[componentType.main]) {
		                            console.warn(componentType.main + ' exists.');
		                        }
		                    }
		                    storage[componentType.main] = Clazz;
		                }
		                else if (componentType.sub !== IS_CONTAINER) {
		                    var container = makeContainer(componentType);
		                    container[componentType.sub] = Clazz;
		                }
		            }
		            return Clazz;
		        };

		        entity.getClass = function (componentTypeMain, subType, throwWhenNotFound) {
		            var Clazz = storage[componentTypeMain];

		            if (Clazz && Clazz[IS_CONTAINER]) {
		                Clazz = subType ? Clazz[subType] : null;
		            }

		            if (throwWhenNotFound && !Clazz) {
		                throw new Error(
		                    'Component ' + componentTypeMain + '.' + (subType || '') + ' not exists. Load it first.'
		                );
		            }

		            return Clazz;
		        };

		        entity.getClassesByMainType = function (componentType) {
		            componentType = parseClassType(componentType);

		            var result = [];
		            var obj = storage[componentType.main];

		            if (obj && obj[IS_CONTAINER]) {
		                zrUtil.each(obj, function (o, type) {
		                    type !== IS_CONTAINER && result.push(o);
		                });
		            }
		            else {
		                result.push(obj);
		            }

		            return result;
		        };

		        entity.hasClass = function (componentType) {
		            // Just consider componentType.main.
		            componentType = parseClassType(componentType);
		            return !!storage[componentType.main];
		        };

		        /**
		         * @return {Array.<string>} Like ['aa', 'bb'], but can not be ['aa.xx']
		         */
		        entity.getAllClassMainTypes = function () {
		            var types = [];
		            zrUtil.each(storage, function (obj, type) {
		                types.push(type);
		            });
		            return types;
		        };

		        /**
		         * If a main type is container and has sub types
		         * @param  {string}  mainType
		         * @return {boolean}
		         */
		        entity.hasSubTypes = function (componentType) {
		            componentType = parseClassType(componentType);
		            var obj = storage[componentType.main];
		            return obj && obj[IS_CONTAINER];
		        };

		        entity.parseClassType = parseClassType;

		        function makeContainer(componentType) {
		            var container = storage[componentType.main];
		            if (!container || !container[IS_CONTAINER]) {
		                container = storage[componentType.main] = {};
		                container[IS_CONTAINER] = true;
		            }
		            return container;
		        }

		        if (options.registerWhenExtend) {
		            var originalExtend = entity.extend;
		            if (originalExtend) {
		                entity.extend = function (proto) {
		                    var ExtendedClass = originalExtend.call(this, proto);
		                    return entity.registerClass(ExtendedClass, proto.type);
		                };
		            }
		        }

		        return entity;
		    };

		    /**
		     * @param {string|Array.<string>} properties
		     */
		    clazz.setReadOnly = function (obj, properties) {
		        // FIXME It seems broken in IE8 simulation of IE11
		        // if (!zrUtil.isArray(properties)) {
		        //     properties = properties != null ? [properties] : [];
		        // }
		        // zrUtil.each(properties, function (prop) {
		        //     var value = obj[prop];

		        //     Object.defineProperty
		        //         && Object.defineProperty(obj, prop, {
		        //             value: value, writable: false
		        //         });
		        //     zrUtil.isArray(obj[prop])
		        //         && Object.freeze
		        //         && Object.freeze(obj[prop]);
		        // });
		    };

		    module.exports = clazz;


	/***/ },
	/* 14 */
	/***/ function(module, exports, __webpack_require__) {

		
		    var getLineStyle = __webpack_require__(15)(
		        [
		            ['lineWidth', 'width'],
		            ['stroke', 'color'],
		            ['opacity'],
		            ['shadowBlur'],
		            ['shadowOffsetX'],
		            ['shadowOffsetY'],
		            ['shadowColor']
		        ]
		    );
		    module.exports = {
		        getLineStyle: function (excludes) {
		            var style = getLineStyle.call(this, excludes);
		            var lineDash = this.getLineDash(style.lineWidth);
		            lineDash && (style.lineDash = lineDash);
		            return style;
		        },

		        getLineDash: function (lineWidth) {
		            if (lineWidth == null) {
		                lineWidth = 1;
		            }
		            var lineType = this.get('type');
		            var dotSize = Math.max(lineWidth, 2);
		            var dashSize = lineWidth * 4;
		            return (lineType === 'solid' || lineType == null) ? null
		                : (lineType === 'dashed' ? [dashSize, dashSize] : [dotSize, dotSize]);
		        }
		    };


	/***/ },
	/* 15 */
	/***/ function(module, exports, __webpack_require__) {

		// TODO Parse shadow style
		// TODO Only shallow path support

		    var zrUtil = __webpack_require__(4);

		    module.exports = function (properties) {
		        // Normalize
		        for (var i = 0; i < properties.length; i++) {
		            if (!properties[i][1]) {
		               properties[i][1] = properties[i][0];
		            }
		        }
		        return function (excludes) {
		            var style = {};
		            for (var i = 0; i < properties.length; i++) {
		                var propName = properties[i][1];
		                if (excludes && zrUtil.indexOf(excludes, propName) >= 0) {
		                    continue;
		                }
		                var val = this.getShallow(propName);
		                if (val != null) {
		                    style[properties[i][0]] = val;
		                }
		            }
		            return style;
		        };
		    };


	/***/ },
	/* 16 */
	/***/ function(module, exports, __webpack_require__) {

		
		    module.exports = {
		        getAreaStyle: __webpack_require__(15)(
		            [
		                ['fill', 'color'],
		                ['shadowBlur'],
		                ['shadowOffsetX'],
		                ['shadowOffsetY'],
		                ['opacity'],
		                ['shadowColor']
		            ]
		        )
		    };


	/***/ },
	/* 17 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var textContain = __webpack_require__(8);

		    function getShallow(model, path) {
		        return model && model.getShallow(path);
		    }

		    module.exports = {
		        /**
		         * Get color property or get color from option.textStyle.color
		         * @return {string}
		         */
		        getTextColor: function () {
		            var ecModel = this.ecModel;
		            return this.getShallow('color')
		                || (ecModel && ecModel.get('textStyle.color'));
		        },

		        /**
		         * Create font string from fontStyle, fontWeight, fontSize, fontFamily
		         * @return {string}
		         */
		        getFont: function () {
		            var ecModel = this.ecModel;
		            var gTextStyleModel = ecModel && ecModel.getModel('textStyle');
		            return [
		                // FIXME in node-canvas fontWeight is before fontStyle
		                this.getShallow('fontStyle') || getShallow(gTextStyleModel, 'fontStyle'),
		                this.getShallow('fontWeight') || getShallow(gTextStyleModel, 'fontWeight'),
		                (this.getShallow('fontSize') || getShallow(gTextStyleModel, 'fontSize') || 12) + 'px',
		                this.getShallow('fontFamily') || getShallow(gTextStyleModel, 'fontFamily') || 'sans-serif'
		            ].join(' ');
		        },

		        getTextRect: function (text) {
		            return textContain.getBoundingRect(
		                text,
		                this.getFont(),
		                this.getShallow('align'),
		                this.getShallow('baseline')
		            );
		        },

		        truncateText: function (text, containerWidth, ellipsis, options) {
		            return textContain.truncateText(
		                text, containerWidth, this.getFont(), ellipsis, options
		            );
		        }
		    };


	/***/ },
	/* 18 */
	/***/ function(module, exports, __webpack_require__) {

		
		    var getItemStyle = __webpack_require__(15)(
		        [
		            ['fill', 'color'],
		            ['stroke', 'borderColor'],
		            ['lineWidth', 'borderWidth'],
		            ['opacity'],
		            ['shadowBlur'],
		            ['shadowOffsetX'],
		            ['shadowOffsetY'],
		            ['shadowColor'],
		            ['textPosition'],
		            ['textAlign']
		        ]
		    );
		    module.exports = {
		        getItemStyle: function (excludes) {
		            var style = getItemStyle.call(this, excludes);
		            var lineDash = this.getBorderLineDash();
		            lineDash && (style.lineDash = lineDash);
		            return style;
		        },

		        getBorderLineDash: function () {
		            var lineType = this.get('borderType');
		            return (lineType === 'solid' || lineType == null) ? null
		                : (lineType === 'dashed' ? [5, 5] : [1, 1]);
		        }
		    };


	/***/ },
	/* 19 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Component model
		 *
		 * @module echarts/model/Component
		 */


		    var Model = __webpack_require__(12);
		    var zrUtil = __webpack_require__(4);
		    var arrayPush = Array.prototype.push;
		    var componentUtil = __webpack_require__(20);
		    var clazzUtil = __webpack_require__(13);
		    var layout = __webpack_require__(21);

		    /**
		     * @alias module:echarts/model/Component
		     * @constructor
		     * @param {Object} option
		     * @param {module:echarts/model/Model} parentModel
		     * @param {module:echarts/model/Model} ecModel
		     */
		    var ComponentModel = Model.extend({

		        type: 'component',

		        /**
		         * @readOnly
		         * @type {string}
		         */
		        id: '',

		        /**
		         * @readOnly
		         */
		        name: '',

		        /**
		         * @readOnly
		         * @type {string}
		         */
		        mainType: '',

		        /**
		         * @readOnly
		         * @type {string}
		         */
		        subType: '',

		        /**
		         * @readOnly
		         * @type {number}
		         */
		        componentIndex: 0,

		        /**
		         * @type {Object}
		         * @protected
		         */
		        defaultOption: null,

		        /**
		         * @type {module:echarts/model/Global}
		         * @readOnly
		         */
		        ecModel: null,

		        /**
		         * key: componentType
		         * value:  Component model list, can not be null.
		         * @type {Object.<string, Array.<module:echarts/model/Model>>}
		         * @readOnly
		         */
		        dependentModels: [],

		        /**
		         * @type {string}
		         * @readOnly
		         */
		        uid: null,

		        /**
		         * Support merge layout params.
		         * Only support 'box' now (left/right/top/bottom/width/height).
		         * @type {string|Object} Object can be {ignoreSize: true}
		         * @readOnly
		         */
		        layoutMode: null,

		        $constructor: function (option, parentModel, ecModel, extraOpt) {
		            Model.call(this, option, parentModel, ecModel, extraOpt);

		            this.uid = componentUtil.getUID('componentModel');
		        },


		        init: function (option, parentModel, ecModel, extraOpt) {
		            this.mergeDefaultAndTheme(option, ecModel);
		        },

		        mergeDefaultAndTheme: function (option, ecModel) {
		            var layoutMode = this.layoutMode;
		            var inputPositionParams = layoutMode
		                ? layout.getLayoutParams(option) : {};

		            var themeModel = ecModel.getTheme();
		            zrUtil.merge(option, themeModel.get(this.mainType));
		            zrUtil.merge(option, this.getDefaultOption());

		            if (layoutMode) {
		                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
		            }
		        },

		        mergeOption: function (option, extraOpt) {
		            zrUtil.merge(this.option, option, true);

		            var layoutMode = this.layoutMode;
		            if (layoutMode) {
		                layout.mergeLayoutParam(this.option, option, layoutMode);
		            }
		        },

		        // Hooker after init or mergeOption
		        optionUpdated: function (newCptOption, isInit) {},

		        getDefaultOption: function () {
		            if (!this.hasOwnProperty('__defaultOption')) {
		                var optList = [];
		                var Class = this.constructor;
		                while (Class) {
		                    var opt = Class.prototype.defaultOption;
		                    opt && optList.push(opt);
		                    Class = Class.superClass;
		                }

		                var defaultOption = {};
		                for (var i = optList.length - 1; i >= 0; i--) {
		                    defaultOption = zrUtil.merge(defaultOption, optList[i], true);
		                }
		                this.__defaultOption = defaultOption;
		            }
		            return this.__defaultOption;
		        },

		        getReferringComponents: function (mainType) {
		            return this.ecModel.queryComponents({
		                mainType: mainType,
		                index: this.get(mainType + 'Index', true),
		                id: this.get(mainType + 'Id', true)
		            });
		        }

		    });

		    // Reset ComponentModel.extend, add preConstruct.
		    // clazzUtil.enableClassExtend(
		    //     ComponentModel,
		    //     function (option, parentModel, ecModel, extraOpt) {
		    //         // Set dependentModels, componentIndex, name, id, mainType, subType.
		    //         zrUtil.extend(this, extraOpt);

		    //         this.uid = componentUtil.getUID('componentModel');

		    //         // this.setReadOnly([
		    //         //     'type', 'id', 'uid', 'name', 'mainType', 'subType',
		    //         //     'dependentModels', 'componentIndex'
		    //         // ]);
		    //     }
		    // );

		    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
		    clazzUtil.enableClassManagement(
		        ComponentModel, {registerWhenExtend: true}
		    );
		    componentUtil.enableSubTypeDefaulter(ComponentModel);

		    // Add capability of ComponentModel.topologicalTravel.
		    componentUtil.enableTopologicalTravel(ComponentModel, getDependencies);

		    function getDependencies(componentType) {
		        var deps = [];
		        zrUtil.each(ComponentModel.getClassesByMainType(componentType), function (Clazz) {
		            arrayPush.apply(deps, Clazz.prototype.dependencies || []);
		        });
		        // Ensure main type
		        return zrUtil.map(deps, function (type) {
		            return clazzUtil.parseClassType(type).main;
		        });
		    }

		    zrUtil.mixin(ComponentModel, __webpack_require__(22));

		    module.exports = ComponentModel;


	/***/ },
	/* 20 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var clazz = __webpack_require__(13);

		    var parseClassType = clazz.parseClassType;

		    var base = 0;

		    var componentUtil = {};

		    var DELIMITER = '_';

		    /**
		     * @public
		     * @param {string} type
		     * @return {string}
		     */
		    componentUtil.getUID = function (type) {
		        // Considering the case of crossing js context,
		        // use Math.random to make id as unique as possible.
		        return [(type || ''), base++, Math.random()].join(DELIMITER);
		    };

		    /**
		     * @inner
		     */
		    componentUtil.enableSubTypeDefaulter = function (entity) {

		        var subTypeDefaulters = {};

		        entity.registerSubTypeDefaulter = function (componentType, defaulter) {
		            componentType = parseClassType(componentType);
		            subTypeDefaulters[componentType.main] = defaulter;
		        };

		        entity.determineSubType = function (componentType, option) {
		            var type = option.type;
		            if (!type) {
		                var componentTypeMain = parseClassType(componentType).main;
		                if (entity.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
		                    type = subTypeDefaulters[componentTypeMain](option);
		                }
		            }
		            return type;
		        };

		        return entity;
		    };

		    /**
		     * Topological travel on Activity Network (Activity On Vertices).
		     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
		     *
		     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
		     *
		     * If there is circle dependencey, Error will be thrown.
		     *
		     */
		    componentUtil.enableTopologicalTravel = function (entity, dependencyGetter) {

		        /**
		         * @public
		         * @param {Array.<string>} targetNameList Target Component type list.
		         *                                           Can be ['aa', 'bb', 'aa.xx']
		         * @param {Array.<string>} fullNameList By which we can build dependency graph.
		         * @param {Function} callback Params: componentType, dependencies.
		         * @param {Object} context Scope of callback.
		         */
		        entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
		            if (!targetNameList.length) {
		                return;
		            }

		            var result = makeDepndencyGraph(fullNameList);
		            var graph = result.graph;
		            var stack = result.noEntryList;

		            var targetNameSet = {};
		            zrUtil.each(targetNameList, function (name) {
		                targetNameSet[name] = true;
		            });

		            while (stack.length) {
		                var currComponentType = stack.pop();
		                var currVertex = graph[currComponentType];
		                var isInTargetNameSet = !!targetNameSet[currComponentType];
		                if (isInTargetNameSet) {
		                    callback.call(context, currComponentType, currVertex.originalDeps.slice());
		                    delete targetNameSet[currComponentType];
		                }
		                zrUtil.each(
		                    currVertex.successor,
		                    isInTargetNameSet ? removeEdgeAndAdd : removeEdge
		                );
		            }

		            zrUtil.each(targetNameSet, function () {
		                throw new Error('Circle dependency may exists');
		            });

		            function removeEdge(succComponentType) {
		                graph[succComponentType].entryCount--;
		                if (graph[succComponentType].entryCount === 0) {
		                    stack.push(succComponentType);
		                }
		            }

		            // Consider this case: legend depends on series, and we call
		            // chart.setOption({series: [...]}), where only series is in option.
		            // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
		            // not be called, but only sereis.mergeOption is called. Thus legend
		            // have no chance to update its local record about series (like which
		            // name of series is available in legend).
		            function removeEdgeAndAdd(succComponentType) {
		                targetNameSet[succComponentType] = true;
		                removeEdge(succComponentType);
		            }
		        };

		        /**
		         * DepndencyGraph: {Object}
		         * key: conponentType,
		         * value: {
		         *     successor: [conponentTypes...],
		         *     originalDeps: [conponentTypes...],
		         *     entryCount: {number}
		         * }
		         */
		        function makeDepndencyGraph(fullNameList) {
		            var graph = {};
		            var noEntryList = [];

		            zrUtil.each(fullNameList, function (name) {

		                var thisItem = createDependencyGraphItem(graph, name);
		                var originalDeps = thisItem.originalDeps = dependencyGetter(name);

		                var availableDeps = getAvailableDependencies(originalDeps, fullNameList);
		                thisItem.entryCount = availableDeps.length;
		                if (thisItem.entryCount === 0) {
		                    noEntryList.push(name);
		                }

		                zrUtil.each(availableDeps, function (dependentName) {
		                    if (zrUtil.indexOf(thisItem.predecessor, dependentName) < 0) {
		                        thisItem.predecessor.push(dependentName);
		                    }
		                    var thatItem = createDependencyGraphItem(graph, dependentName);
		                    if (zrUtil.indexOf(thatItem.successor, dependentName) < 0) {
		                        thatItem.successor.push(name);
		                    }
		                });
		            });

		            return {graph: graph, noEntryList: noEntryList};
		        }

		        function createDependencyGraphItem(graph, name) {
		            if (!graph[name]) {
		                graph[name] = {predecessor: [], successor: []};
		            }
		            return graph[name];
		        }

		        function getAvailableDependencies(originalDeps, fullNameList) {
		            var availableDeps = [];
		            zrUtil.each(originalDeps, function (dep) {
		                zrUtil.indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep);
		            });
		            return availableDeps;
		        }
		    };

		    module.exports = componentUtil;


	/***/ },
	/* 21 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		// Layout helpers for each component positioning


		    var zrUtil = __webpack_require__(4);
		    var BoundingRect = __webpack_require__(9);
		    var numberUtil = __webpack_require__(7);
		    var formatUtil = __webpack_require__(6);
		    var parsePercent = numberUtil.parsePercent;
		    var each = zrUtil.each;

		    var layout = {};

		    var LOCATION_PARAMS = layout.LOCATION_PARAMS = [
		        'left', 'right', 'top', 'bottom', 'width', 'height'
		    ];

		    function boxLayout(orient, group, gap, maxWidth, maxHeight) {
		        var x = 0;
		        var y = 0;
		        if (maxWidth == null) {
		            maxWidth = Infinity;
		        }
		        if (maxHeight == null) {
		            maxHeight = Infinity;
		        }
		        var currentLineMaxSize = 0;
		        group.eachChild(function (child, idx) {
		            var position = child.position;
		            var rect = child.getBoundingRect();
		            var nextChild = group.childAt(idx + 1);
		            var nextChildRect = nextChild && nextChild.getBoundingRect();
		            var nextX;
		            var nextY;
		            if (orient === 'horizontal') {
		                var moveX = rect.width + (nextChildRect ? (-nextChildRect.x + rect.x) : 0);
		                nextX = x + moveX;
		                // Wrap when width exceeds maxWidth or meet a `newline` group
		                if (nextX > maxWidth || child.newline) {
		                    x = 0;
		                    nextX = moveX;
		                    y += currentLineMaxSize + gap;
		                    currentLineMaxSize = rect.height;
		                }
		                else {
		                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.height);
		                }
		            }
		            else {
		                var moveY = rect.height + (nextChildRect ? (-nextChildRect.y + rect.y) : 0);
		                nextY = y + moveY;
		                // Wrap when width exceeds maxHeight or meet a `newline` group
		                if (nextY > maxHeight || child.newline) {
		                    x += currentLineMaxSize + gap;
		                    y = 0;
		                    nextY = moveY;
		                    currentLineMaxSize = rect.width;
		                }
		                else {
		                    currentLineMaxSize = Math.max(currentLineMaxSize, rect.width);
		                }
		            }

		            if (child.newline) {
		                return;
		            }

		            position[0] = x;
		            position[1] = y;

		            orient === 'horizontal'
		                ? (x = nextX + gap)
		                : (y = nextY + gap);
		        });
		    }

		    /**
		     * VBox or HBox layouting
		     * @param {string} orient
		     * @param {module:zrender/container/Group} group
		     * @param {number} gap
		     * @param {number} [width=Infinity]
		     * @param {number} [height=Infinity]
		     */
		    layout.box = boxLayout;

		    /**
		     * VBox layouting
		     * @param {module:zrender/container/Group} group
		     * @param {number} gap
		     * @param {number} [width=Infinity]
		     * @param {number} [height=Infinity]
		     */
		    layout.vbox = zrUtil.curry(boxLayout, 'vertical');

		    /**
		     * HBox layouting
		     * @param {module:zrender/container/Group} group
		     * @param {number} gap
		     * @param {number} [width=Infinity]
		     * @param {number} [height=Infinity]
		     */
		    layout.hbox = zrUtil.curry(boxLayout, 'horizontal');

		    /**
		     * If x or x2 is not specified or 'center' 'left' 'right',
		     * the width would be as long as possible.
		     * If y or y2 is not specified or 'middle' 'top' 'bottom',
		     * the height would be as long as possible.
		     *
		     * @param {Object} positionInfo
		     * @param {number|string} [positionInfo.x]
		     * @param {number|string} [positionInfo.y]
		     * @param {number|string} [positionInfo.x2]
		     * @param {number|string} [positionInfo.y2]
		     * @param {Object} containerRect
		     * @param {string|number} margin
		     * @return {Object} {width, height}
		     */
		    layout.getAvailableSize = function (positionInfo, containerRect, margin) {
		        var containerWidth = containerRect.width;
		        var containerHeight = containerRect.height;

		        var x = parsePercent(positionInfo.x, containerWidth);
		        var y = parsePercent(positionInfo.y, containerHeight);
		        var x2 = parsePercent(positionInfo.x2, containerWidth);
		        var y2 = parsePercent(positionInfo.y2, containerHeight);

		        (isNaN(x) || isNaN(parseFloat(positionInfo.x))) && (x = 0);
		        (isNaN(x2) || isNaN(parseFloat(positionInfo.x2))) && (x2 = containerWidth);
		        (isNaN(y) || isNaN(parseFloat(positionInfo.y))) && (y = 0);
		        (isNaN(y2) || isNaN(parseFloat(positionInfo.y2))) && (y2 = containerHeight);

		        margin = formatUtil.normalizeCssArray(margin || 0);

		        return {
		            width: Math.max(x2 - x - margin[1] - margin[3], 0),
		            height: Math.max(y2 - y - margin[0] - margin[2], 0)
		        };
		    };

		    /**
		     * Parse position info.
		     *
		     * @param {Object} positionInfo
		     * @param {number|string} [positionInfo.left]
		     * @param {number|string} [positionInfo.top]
		     * @param {number|string} [positionInfo.right]
		     * @param {number|string} [positionInfo.bottom]
		     * @param {number|string} [positionInfo.width]
		     * @param {number|string} [positionInfo.height]
		     * @param {number|string} [positionInfo.aspect] Aspect is width / height
		     * @param {Object} containerRect
		     * @param {string|number} [margin]
		     *
		     * @return {module:zrender/core/BoundingRect}
		     */
		    layout.getLayoutRect = function (
		        positionInfo, containerRect, margin
		    ) {
		        margin = formatUtil.normalizeCssArray(margin || 0);

		        var containerWidth = containerRect.width;
		        var containerHeight = containerRect.height;

		        var left = parsePercent(positionInfo.left, containerWidth);
		        var top = parsePercent(positionInfo.top, containerHeight);
		        var right = parsePercent(positionInfo.right, containerWidth);
		        var bottom = parsePercent(positionInfo.bottom, containerHeight);
		        var width = parsePercent(positionInfo.width, containerWidth);
		        var height = parsePercent(positionInfo.height, containerHeight);

		        var verticalMargin = margin[2] + margin[0];
		        var horizontalMargin = margin[1] + margin[3];
		        var aspect = positionInfo.aspect;

		        // If width is not specified, calculate width from left and right
		        if (isNaN(width)) {
		            width = containerWidth - right - horizontalMargin - left;
		        }
		        if (isNaN(height)) {
		            height = containerHeight - bottom - verticalMargin - top;
		        }

		        // If width and height are not given
		        // 1. Graph should not exceeds the container
		        // 2. Aspect must be keeped
		        // 3. Graph should take the space as more as possible
		        if (isNaN(width) && isNaN(height)) {
		            if (aspect > containerWidth / containerHeight) {
		                width = containerWidth * 0.8;
		            }
		            else {
		                height = containerHeight * 0.8;
		            }
		        }

		        if (aspect != null) {
		            // Calculate width or height with given aspect
		            if (isNaN(width)) {
		                width = aspect * height;
		            }
		            if (isNaN(height)) {
		                height = width / aspect;
		            }
		        }

		        // If left is not specified, calculate left from right and width
		        if (isNaN(left)) {
		            left = containerWidth - right - width - horizontalMargin;
		        }
		        if (isNaN(top)) {
		            top = containerHeight - bottom - height - verticalMargin;
		        }

		        // Align left and top
		        switch (positionInfo.left || positionInfo.right) {
		            case 'center':
		                left = containerWidth / 2 - width / 2 - margin[3];
		                break;
		            case 'right':
		                left = containerWidth - width - horizontalMargin;
		                break;
		        }
		        switch (positionInfo.top || positionInfo.bottom) {
		            case 'middle':
		            case 'center':
		                top = containerHeight / 2 - height / 2 - margin[0];
		                break;
		            case 'bottom':
		                top = containerHeight - height - verticalMargin;
		                break;
		        }
		        // If something is wrong and left, top, width, height are calculated as NaN
		        left = left || 0;
		        top = top || 0;
		        if (isNaN(width)) {
		            // Width may be NaN if only one value is given except width
		            width = containerWidth - left - (right || 0);
		        }
		        if (isNaN(height)) {
		            // Height may be NaN if only one value is given except height
		            height = containerHeight - top - (bottom || 0);
		        }

		        var rect = new BoundingRect(left + margin[3], top + margin[0], width, height);
		        rect.margin = margin;
		        return rect;
		    };


		    /**
		     * Position a zr element in viewport
		     *  Group position is specified by either
		     *  {left, top}, {right, bottom}
		     *  If all properties exists, right and bottom will be igonred.
		     *
		     * Logic:
		     *     1. Scale (against origin point in parent coord)
		     *     2. Rotate (against origin point in parent coord)
		     *     3. Traslate (with el.position by this method)
		     * So this method only fixes the last step 'Traslate', which does not affect
		     * scaling and rotating.
		     *
		     * If be called repeatly with the same input el, the same result will be gotten.
		     *
		     * @param {module:zrender/Element} el Should have `getBoundingRect` method.
		     * @param {Object} positionInfo
		     * @param {number|string} [positionInfo.left]
		     * @param {number|string} [positionInfo.top]
		     * @param {number|string} [positionInfo.right]
		     * @param {number|string} [positionInfo.bottom]
		     * @param {Object} containerRect
		     * @param {string|number} margin
		     * @param {Object} [opt]
		     * @param {Array.<number>} [opt.hv=[1,1]] Only horizontal or only vertical.
		     * @param {Array.<number>} [opt.boundingMode='all']
		     *        Specify how to calculate boundingRect when locating.
		     *        'all': Position the boundingRect that is transformed and uioned
		     *               both itself and its descendants.
		     *               This mode simplies confine the elements in the bounding
		     *               of their container (e.g., using 'right: 0').
		     *        'raw': Position the boundingRect that is not transformed and only itself.
		     *               This mode is useful when you want a element can overflow its
		     *               container. (Consider a rotated circle needs to be located in a corner.)
		     *               In this mode positionInfo.width/height can only be number.
		     */
		    layout.positionElement = function (el, positionInfo, containerRect, margin, opt) {
		        var h = !opt || !opt.hv || opt.hv[0];
		        var v = !opt || !opt.hv || opt.hv[1];
		        var boundingMode = opt && opt.boundingMode || 'all';

		        if (!h && !v) {
		            return;
		        }

		        var rect;
		        if (boundingMode === 'raw') {
		            rect = el.type === 'group'
		                ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0)
		                : el.getBoundingRect();
		        }
		        else {
		            rect = el.getBoundingRect();
		            if (el.needLocalTransform()) {
		                var transform = el.getLocalTransform();
		                // Notice: raw rect may be inner object of el,
		                // which should not be modified.
		                rect = rect.clone();
		                rect.applyTransform(transform);
		            }
		        }

		        positionInfo = layout.getLayoutRect(
		            zrUtil.defaults(
		                {width: rect.width, height: rect.height},
		                positionInfo
		            ),
		            containerRect,
		            margin
		        );

		        // Because 'tranlate' is the last step in transform
		        // (see zrender/core/Transformable#getLocalTransfrom),
		        // we can just only modify el.position to get final result.
		        var elPos = el.position;
		        var dx = h ? positionInfo.x - rect.x : 0;
		        var dy = v ? positionInfo.y - rect.y : 0;

		        el.attr('position', boundingMode === 'raw' ? [dx, dy] : [elPos[0] + dx, elPos[1] + dy]);
		    };

		    /**
		     * Consider Case:
		     * When defulat option has {left: 0, width: 100}, and we set {right: 0}
		     * through setOption or media query, using normal zrUtil.merge will cause
		     * {right: 0} does not take effect.
		     *
		     * @example
		     * ComponentModel.extend({
		     *     init: function () {
		     *         ...
		     *         var inputPositionParams = layout.getLayoutParams(option);
		     *         this.mergeOption(inputPositionParams);
		     *     },
		     *     mergeOption: function (newOption) {
		     *         newOption && zrUtil.merge(thisOption, newOption, true);
		     *         layout.mergeLayoutParam(thisOption, newOption);
		     *     }
		     * });
		     *
		     * @param {Object} targetOption
		     * @param {Object} newOption
		     * @param {Object|string} [opt]
		     * @param {boolean} [opt.ignoreSize=false] Some component must has width and height.
		     */
		    layout.mergeLayoutParam = function (targetOption, newOption, opt) {
		        !zrUtil.isObject(opt) && (opt = {});
		        var hNames = ['width', 'left', 'right']; // Order by priority.
		        var vNames = ['height', 'top', 'bottom']; // Order by priority.
		        var hResult = merge(hNames);
		        var vResult = merge(vNames);

		        copy(hNames, targetOption, hResult);
		        copy(vNames, targetOption, vResult);

		        function merge(names) {
		            var newParams = {};
		            var newValueCount = 0;
		            var merged = {};
		            var mergedValueCount = 0;
		            var enoughParamNumber = opt.ignoreSize ? 1 : 2;

		            each(names, function (name) {
		                merged[name] = targetOption[name];
		            });
		            each(names, function (name) {
		                // Consider case: newOption.width is null, which is
		                // set by user for removing width setting.
		                hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name]);
		                hasValue(newParams, name) && newValueCount++;
		                hasValue(merged, name) && mergedValueCount++;
		            });

		            // Case: newOption: {width: ..., right: ...},
		            // or targetOption: {right: ...} and newOption: {width: ...},
		            // There is no conflict when merged only has params count
		            // little than enoughParamNumber.
		            if (mergedValueCount === enoughParamNumber || !newValueCount) {
		                return merged;
		            }
		            // Case: newOption: {width: ..., right: ...},
		            // Than we can make sure user only want those two, and ignore
		            // all origin params in targetOption.
		            else if (newValueCount >= enoughParamNumber) {
		                return newParams;
		            }
		            else {
		                // Chose another param from targetOption by priority.
		                // When 'ignoreSize', enoughParamNumber is 1 and those will not happen.
		                for (var i = 0; i < names.length; i++) {
		                    var name = names[i];
		                    if (!hasProp(newParams, name) && hasProp(targetOption, name)) {
		                        newParams[name] = targetOption[name];
		                        break;
		                    }
		                }
		                return newParams;
		            }
		        }

		        function hasProp(obj, name) {
		            return obj.hasOwnProperty(name);
		        }

		        function hasValue(obj, name) {
		            return obj[name] != null && obj[name] !== 'auto';
		        }

		        function copy(names, target, source) {
		            each(names, function (name) {
		                target[name] = source[name];
		            });
		        }
		    };

		    /**
		     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
		     * @param {Object} source
		     * @return {Object} Result contains those props.
		     */
		    layout.getLayoutParams = function (source) {
		        return layout.copyLayoutParams({}, source);
		    };

		    /**
		     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
		     * @param {Object} source
		     * @return {Object} Result contains those props.
		     */
		    layout.copyLayoutParams = function (target, source) {
		        source && target && each(LOCATION_PARAMS, function (name) {
		            source.hasOwnProperty(name) && (target[name] = source[name]);
		        });
		        return target;
		    };

		    module.exports = layout;


	/***/ },
	/* 22 */
	/***/ function(module, exports) {

		

		    module.exports = {
		        getBoxLayoutParams: function () {
		            return {
		                left: this.get('left'),
		                top: this.get('top'),
		                right: this.get('right'),
		                bottom: this.get('bottom'),
		                width: this.get('width'),
		                height: this.get('height')
		            };
		        }
		    };


	/***/ },
	/* 23 */
	/***/ function(module, exports) {

		
		    var platform = '';
		    // Navigator not exists in node
		    if (typeof navigator !== 'undefined') {
		        platform = navigator.platform || '';
		    }
		    module.exports = {
		        // 全图默认背景
		        // backgroundColor: 'rgba(0,0,0,0)',

		        // https://dribbble.com/shots/1065960-Infographic-Pie-chart-visualization
		        // color: ['#5793f3', '#d14a61', '#fd9c35', '#675bba', '#fec42c', '#dd4444', '#d4df5a', '#cd4870'],
		        // 浅色
		        // color: ['#bcd3bb', '#e88f70', '#edc1a5', '#9dc5c8', '#e1e8c8', '#7b7c68', '#e5b5b5', '#f0b489', '#928ea8', '#bda29a'],
		        // color: ['#cc5664', '#9bd6ec', '#ea946e', '#8acaaa', '#f1ec64', '#ee8686', '#a48dc1', '#5da6bc', '#b9dcae'],
		        // 深色
		        color: ['#c23531','#2f4554', '#61a0a8', '#d48265', '#91c7ae','#749f83',  '#ca8622', '#bda29a','#6e7074', '#546570', '#c4ccd3'],

		        // 默认需要 Grid 配置项
		        // grid: {},
		        // 主题，主题
		        textStyle: {
		            // color: '#000',
		            // decoration: 'none',
		            // PENDING
		            fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
		            // fontFamily: 'Arial, Verdana, sans-serif',
		            fontSize: 12,
		            fontStyle: 'normal',
		            fontWeight: 'normal'
		        },

		        // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
		        // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
		        // Default is source-over
		        blendMode: null,

		        animation: true,
		        animationDuration: 1000,
		        animationDurationUpdate: 300,
		        animationEasing: 'exponentialOut',
		        animationEasingUpdate: 'cubicOut',

		        animationThreshold: 2000,
		        // Configuration for progressive/incremental rendering
		        progressiveThreshold: 3000,
		        progressive: 400,

		        // Threshold of if use single hover layer to optimize.
		        // It is recommended that `hoverLayerThreshold` is equivalent to or less than
		        // `progressiveThreshold`, otherwise hover will cause restart of progressive,
		        // which is unexpected.
		        // see example <echarts/test/heatmap-large.html>.
		        hoverLayerThreshold: 3000
		    };


	/***/ },
	/* 24 */
	/***/ function(module, exports) {

		
		    module.exports = {
		        clearColorPalette: function () {
		            this._colorIdx = 0;
		            this._colorNameMap = {};
		        },

		        getColorFromPalette: function (name, scope) {
		            scope = scope || this;
		            var colorIdx = scope._colorIdx || 0;
		            var colorNameMap = scope._colorNameMap || (scope._colorNameMap = {});
		            if (colorNameMap[name]) {
		                return colorNameMap[name];
		            }
		            var colorPalette = this.get('color', true) || [];
		            if (!colorPalette.length) {
		                return;
		            }

		            var color = colorPalette[colorIdx];
		            if (name) {
		                colorNameMap[name] = color;
		            }
		            scope._colorIdx = (colorIdx + 1) % colorPalette.length;

		            return color;
		        }
		    };


	/***/ },
	/* 25 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);

		    var echartsAPIList = [
		        'getDom', 'getZr', 'getWidth', 'getHeight', 'dispatchAction', 'isDisposed',
		        'on', 'off', 'getDataURL', 'getConnectedDataURL', 'getModel', 'getOption'
		    ];

		    function ExtensionAPI(chartInstance) {
		        zrUtil.each(echartsAPIList, function (name) {
		            this[name] = zrUtil.bind(chartInstance[name], chartInstance);
		        }, this);
		    }

		    module.exports = ExtensionAPI;


	/***/ },
	/* 26 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);

		    /**
		     * Interface of Coordinate System Class
		     *
		     * create:
		     *     @param {module:echarts/model/Global} ecModel
		     *     @param {module:echarts/ExtensionAPI} api
		     *     @return {Object} coordinate system instance
		     *
		     * update:
		     *     @param {module:echarts/model/Global} ecModel
		     *     @param {module:echarts/ExtensionAPI} api
		     *
		     * convertToPixel:
		     * convertFromPixel:
		     *     These two methods is also responsible for determine whether this
		     *     coodinate system is applicable to the given `finder`.
		     *     Each coordinate system will be tried, util one returns none
		     *     null/undefined value.
		     *     @param {module:echarts/model/Global} ecModel
		     *     @param {Object} finder
		     *     @param {Array|number} value
		     *     @return {Array|number} convert result.
		     *
		     * containPoint:
		     *     @param {Array.<number>} point In pixel coordinate system.
		     *     @return {boolean}
		     */

		    var coordinateSystemCreators = {};

		    function CoordinateSystemManager() {

		        this._coordinateSystems = [];
		    }

		    CoordinateSystemManager.prototype = {

		        constructor: CoordinateSystemManager,

		        create: function (ecModel, api) {
		            var coordinateSystems = [];
		            zrUtil.each(coordinateSystemCreators, function (creater, type) {
		                var list = creater.create(ecModel, api);
		                coordinateSystems = coordinateSystems.concat(list || []);
		            });

		            this._coordinateSystems = coordinateSystems;
		        },

		        update: function (ecModel, api) {
		            zrUtil.each(this._coordinateSystems, function (coordSys) {
		                // FIXME MUST have
		                coordSys.update && coordSys.update(ecModel, api);
		            });
		        },

		        getCoordinateSystems: function () {
		            return this._coordinateSystems.slice();
		        }
		    };

		    CoordinateSystemManager.register = function (type, coordinateSystemCreator) {
		        coordinateSystemCreators[type] = coordinateSystemCreator;
		    };

		    CoordinateSystemManager.get = function (type) {
		        return coordinateSystemCreators[type];
		    };

		    module.exports = CoordinateSystemManager;


	/***/ },
	/* 27 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * ECharts option manager
		 *
		 * @module {echarts/model/OptionManager}
		 */



		    var zrUtil = __webpack_require__(4);
		    var modelUtil = __webpack_require__(5);
		    var ComponentModel = __webpack_require__(19);
		    var each = zrUtil.each;
		    var clone = zrUtil.clone;
		    var map = zrUtil.map;
		    var merge = zrUtil.merge;

		    var QUERY_REG = /^(min|max)?(.+)$/;

		    /**
		     * TERM EXPLANATIONS:
		     *
		     * [option]:
		     *
		     *     An object that contains definitions of components. For example:
		     *     var option = {
		     *         title: {...},
		     *         legend: {...},
		     *         visualMap: {...},
		     *         series: [
		     *             {data: [...]},
		     *             {data: [...]},
		     *             ...
		     *         ]
		     *     };
		     *
		     * [rawOption]:
		     *
		     *     An object input to echarts.setOption. 'rawOption' may be an
		     *     'option', or may be an object contains multi-options. For example:
		     *     var option = {
		     *         baseOption: {
		     *             title: {...},
		     *             legend: {...},
		     *             series: [
		     *                 {data: [...]},
		     *                 {data: [...]},
		     *                 ...
		     *             ]
		     *         },
		     *         timeline: {...},
		     *         options: [
		     *             {title: {...}, series: {data: [...]}},
		     *             {title: {...}, series: {data: [...]}},
		     *             ...
		     *         ],
		     *         media: [
		     *             {
		     *                 query: {maxWidth: 320},
		     *                 option: {series: {x: 20}, visualMap: {show: false}}
		     *             },
		     *             {
		     *                 query: {minWidth: 320, maxWidth: 720},
		     *                 option: {series: {x: 500}, visualMap: {show: true}}
		     *             },
		     *             {
		     *                 option: {series: {x: 1200}, visualMap: {show: true}}
		     *             }
		     *         ]
		     *     };
		     *
		     * @alias module:echarts/model/OptionManager
		     * @param {module:echarts/ExtensionAPI} api
		     */
		    function OptionManager(api) {

		        /**
		         * @private
		         * @type {module:echarts/ExtensionAPI}
		         */
		        this._api = api;

		        /**
		         * @private
		         * @type {Array.<number>}
		         */
		        this._timelineOptions = [];

		        /**
		         * @private
		         * @type {Array.<Object>}
		         */
		        this._mediaList = [];

		        /**
		         * @private
		         * @type {Object}
		         */
		        this._mediaDefault;

		        /**
		         * -1, means default.
		         * empty means no media.
		         * @private
		         * @type {Array.<number>}
		         */
		        this._currentMediaIndices = [];

		        /**
		         * @private
		         * @type {Object}
		         */
		        this._optionBackup;

		        /**
		         * @private
		         * @type {Object}
		         */
		        this._newBaseOption;
		    }

		    // timeline.notMerge is not supported in ec3. Firstly there is rearly
		    // case that notMerge is needed. Secondly supporting 'notMerge' requires
		    // rawOption cloned and backuped when timeline changed, which does no
		    // good to performance. What's more, that both timeline and setOption
		    // method supply 'notMerge' brings complex and some problems.
		    // Consider this case:
		    // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
		    // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);

		    OptionManager.prototype = {

		        constructor: OptionManager,

		        /**
		         * @public
		         * @param {Object} rawOption Raw option.
		         * @param {module:echarts/model/Global} ecModel
		         * @param {Array.<Function>} optionPreprocessorFuncs
		         * @return {Object} Init option
		         */
		        setOption: function (rawOption, optionPreprocessorFuncs) {
		            rawOption = clone(rawOption, true);

		            // FIXME
		            // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。

		            var oldOptionBackup = this._optionBackup;
		            var newParsedOption = parseRawOption.call(
		                this, rawOption, optionPreprocessorFuncs, !oldOptionBackup
		            );
		            this._newBaseOption = newParsedOption.baseOption;

		            // For setOption at second time (using merge mode);
		            if (oldOptionBackup) {
		                // Only baseOption can be merged.
		                mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption);

		                // For simplicity, timeline options and media options do not support merge,
		                // that is, if you `setOption` twice and both has timeline options, the latter
		                // timeline opitons will not be merged to the formers, but just substitude them.
		                if (newParsedOption.timelineOptions.length) {
		                    oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;
		                }
		                if (newParsedOption.mediaList.length) {
		                    oldOptionBackup.mediaList = newParsedOption.mediaList;
		                }
		                if (newParsedOption.mediaDefault) {
		                    oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;
		                }
		            }
		            else {
		                this._optionBackup = newParsedOption;
		            }
		        },

		        /**
		         * @param {boolean} isRecreate
		         * @return {Object}
		         */
		        mountOption: function (isRecreate) {
		            var optionBackup = this._optionBackup;

		            // TODO
		            // 如果没有reset功能则不clone。

		            this._timelineOptions = map(optionBackup.timelineOptions, clone);
		            this._mediaList = map(optionBackup.mediaList, clone);
		            this._mediaDefault = clone(optionBackup.mediaDefault);
		            this._currentMediaIndices = [];

		            return clone(isRecreate
		                // this._optionBackup.baseOption, which is created at the first `setOption`
		                // called, and is merged into every new option by inner method `mergeOption`
		                // each time `setOption` called, can be only used in `isRecreate`, because
		                // its reliability is under suspicion. In other cases option merge is
		                // performed by `model.mergeOption`.
		                ? optionBackup.baseOption : this._newBaseOption
		            );
		        },

		        /**
		         * @param {module:echarts/model/Global} ecModel
		         * @return {Object}
		         */
		        getTimelineOption: function (ecModel) {
		            var option;
		            var timelineOptions = this._timelineOptions;

		            if (timelineOptions.length) {
		                // getTimelineOption can only be called after ecModel inited,
		                // so we can get currentIndex from timelineModel.
		                var timelineModel = ecModel.getComponent('timeline');
		                if (timelineModel) {
		                    option = clone(
		                        timelineOptions[timelineModel.getCurrentIndex()],
		                        true
		                    );
		                }
		            }

		            return option;
		        },

		        /**
		         * @param {module:echarts/model/Global} ecModel
		         * @return {Array.<Object>}
		         */
		        getMediaOption: function (ecModel) {
		            var ecWidth = this._api.getWidth();
		            var ecHeight = this._api.getHeight();
		            var mediaList = this._mediaList;
		            var mediaDefault = this._mediaDefault;
		            var indices = [];
		            var result = [];

		            // No media defined.
		            if (!mediaList.length && !mediaDefault) {
		                return result;
		            }

		            // Multi media may be applied, the latter defined media has higher priority.
		            for (var i = 0, len = mediaList.length; i < len; i++) {
		                if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
		                    indices.push(i);
		                }
		            }

		            // FIXME
		            // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。
		            if (!indices.length && mediaDefault) {
		                indices = [-1];
		            }

		            if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
		                result = map(indices, function (index) {
		                    return clone(
		                        index === -1 ? mediaDefault.option : mediaList[index].option
		                    );
		                });
		            }
		            // Otherwise return nothing.

		            this._currentMediaIndices = indices;

		            return result;
		        }
		    };

		    function parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {
		        var timelineOptions = [];
		        var mediaList = [];
		        var mediaDefault;
		        var baseOption;

		        // Compatible with ec2.
		        var timelineOpt = rawOption.timeline;

		        if (rawOption.baseOption) {
		            baseOption = rawOption.baseOption;
		        }

		        // For timeline
		        if (timelineOpt || rawOption.options) {
		            baseOption = baseOption || {};
		            timelineOptions = (rawOption.options || []).slice();
		        }

		        // For media query
		        if (rawOption.media) {
		            baseOption = baseOption || {};
		            var media = rawOption.media;
		            each(media, function (singleMedia) {
		                if (singleMedia && singleMedia.option) {
		                    if (singleMedia.query) {
		                        mediaList.push(singleMedia);
		                    }
		                    else if (!mediaDefault) {
		                        // Use the first media default.
		                        mediaDefault = singleMedia;
		                    }
		                }
		            });
		        }

		        // For normal option
		        if (!baseOption) {
		            baseOption = rawOption;
		        }

		        // Set timelineOpt to baseOption in ec3,
		        // which is convenient for merge option.
		        if (!baseOption.timeline) {
		            baseOption.timeline = timelineOpt;
		        }

		        // Preprocess.
		        each([baseOption].concat(timelineOptions)
		            .concat(zrUtil.map(mediaList, function (media) {
		                return media.option;
		            })),
		            function (option) {
		                each(optionPreprocessorFuncs, function (preProcess) {
		                    preProcess(option, isNew);
		                });
		            }
		        );

		        return {
		            baseOption: baseOption,
		            timelineOptions: timelineOptions,
		            mediaDefault: mediaDefault,
		            mediaList: mediaList
		        };
		    }

		    /**
		     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
		     * Support: width, height, aspectRatio
		     * Can use max or min as prefix.
		     */
		    function applyMediaQuery(query, ecWidth, ecHeight) {
		        var realMap = {
		            width: ecWidth,
		            height: ecHeight,
		            aspectratio: ecWidth / ecHeight // lowser case for convenientce.
		        };

		        var applicatable = true;

		        zrUtil.each(query, function (value, attr) {
		            var matched = attr.match(QUERY_REG);

		            if (!matched || !matched[1] || !matched[2]) {
		                return;
		            }

		            var operator = matched[1];
		            var realAttr = matched[2].toLowerCase();

		            if (!compare(realMap[realAttr], value, operator)) {
		                applicatable = false;
		            }
		        });

		        return applicatable;
		    }

		    function compare(real, expect, operator) {
		        if (operator === 'min') {
		            return real >= expect;
		        }
		        else if (operator === 'max') {
		            return real <= expect;
		        }
		        else { // Equals
		            return real === expect;
		        }
		    }

		    function indicesEquals(indices1, indices2) {
		        // indices is always order by asc and has only finite number.
		        return indices1.join(',') === indices2.join(',');
		    }

		    /**
		     * Consider case:
		     * `chart.setOption(opt1);`
		     * Then user do some interaction like dataZoom, dataView changing.
		     * `chart.setOption(opt2);`
		     * Then user press 'reset button' in toolbox.
		     *
		     * After doing that all of the interaction effects should be reset, the
		     * chart should be the same as the result of invoke
		     * `chart.setOption(opt1); chart.setOption(opt2);`.
		     *
		     * Although it is not able ensure that
		     * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to
		     * `chart.setOption(merge(opt1, opt2));` exactly,
		     * this might be the only simple way to implement that feature.
		     *
		     * MEMO: We've considered some other approaches:
		     * 1. Each model handle its self restoration but not uniform treatment.
		     *     (Too complex in logic and error-prone)
		     * 2. Use a shadow ecModel. (Performace expensive)
		     */
		    function mergeOption(oldOption, newOption) {
		        newOption = newOption || {};

		        each(newOption, function (newCptOpt, mainType) {
		            if (newCptOpt == null) {
		                return;
		            }

		            var oldCptOpt = oldOption[mainType];

		            if (!ComponentModel.hasClass(mainType)) {
		                oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);
		            }
		            else {
		                newCptOpt = modelUtil.normalizeToArray(newCptOpt);
		                oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);

		                var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);

		                oldOption[mainType] = map(mapResult, function (item) {
		                    return (item.option && item.exist)
		                        ? merge(item.exist, item.option, true)
		                        : (item.exist || item.option);
		                });
		            }
		        });
		    }

		    module.exports = OptionManager;


	/***/ },
	/* 28 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);
		    var formatUtil = __webpack_require__(6);
		    var modelUtil = __webpack_require__(5);
		    var ComponentModel = __webpack_require__(19);
		    var colorPaletteMixin = __webpack_require__(24);
		    var env = __webpack_require__(2);
		    var layout = __webpack_require__(21);

		    var encodeHTML = formatUtil.encodeHTML;
		    var addCommas = formatUtil.addCommas;

		    var SeriesModel = ComponentModel.extend({

		        type: 'series.__base__',

		        /**
		         * @readOnly
		         */
		        seriesIndex: 0,

		        // coodinateSystem will be injected in the echarts/CoordinateSystem
		        coordinateSystem: null,

		        /**
		         * @type {Object}
		         * @protected
		         */
		        defaultOption: null,

		        /**
		         * Data provided for legend
		         * @type {Function}
		         */
		        // PENDING
		        legendDataProvider: null,

		        /**
		         * Access path of color for visual
		         */
		        visualColorAccessPath: 'itemStyle.normal.color',

		        /**
		         * Support merge layout params.
		         * Only support 'box' now (left/right/top/bottom/width/height).
		         * @type {string|Object} Object can be {ignoreSize: true}
		         * @readOnly
		         */
		        layoutMode: null,

		        init: function (option, parentModel, ecModel, extraOpt) {

		            /**
		             * @type {number}
		             * @readOnly
		             */
		            this.seriesIndex = this.componentIndex;

		            this.mergeDefaultAndTheme(option, ecModel);

		            /**
		             * @type {module:echarts/data/List|module:echarts/data/Tree|module:echarts/data/Graph}
		             * @private
		             */
		            this._dataBeforeProcessed = this.getInitialData(option, ecModel);

		            // If we reverse the order (make this._data firstly, and then make
		            // this._dataBeforeProcessed by cloneShallow), cloneShallow will
		            // cause this._data.graph.data !== this._data when using
		            // module:echarts/data/Graph or module:echarts/data/Tree.
		            // See module:echarts/data/helper/linkList
		            this._data = this._dataBeforeProcessed.cloneShallow();
		        },

		        /**
		         * Util for merge default and theme to option
		         * @param  {Object} option
		         * @param  {module:echarts/model/Global} ecModel
		         */
		        mergeDefaultAndTheme: function (option, ecModel) {
		            var layoutMode = this.layoutMode;
		            var inputPositionParams = layoutMode
		                ? layout.getLayoutParams(option) : {};

		            zrUtil.merge(
		                option,
		                ecModel.getTheme().get(this.subType)
		            );
		            zrUtil.merge(option, this.getDefaultOption());

		            // Default label emphasis `position` and `show`
		            // FIXME Set label in mergeOption
		            modelUtil.defaultEmphasis(option.label, modelUtil.LABEL_OPTIONS);

		            this.fillDataTextStyle(option.data);

		            if (layoutMode) {
		                layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
		            }
		        },

		        mergeOption: function (newSeriesOption, ecModel) {
		            newSeriesOption = zrUtil.merge(this.option, newSeriesOption, true);
		            this.fillDataTextStyle(newSeriesOption.data);

		            var layoutMode = this.layoutMode;
		            if (layoutMode) {
		                layout.mergeLayoutParam(this.option, newSeriesOption, layoutMode);
		            }

		            var data = this.getInitialData(newSeriesOption, ecModel);
		            // TODO Merge data?
		            if (data) {
		                this._data = data;
		                this._dataBeforeProcessed = data.cloneShallow();
		            }
		        },

		        fillDataTextStyle: function (data) {
		            // Default data label emphasis `position` and `show`
		            // FIXME Tree structure data ?
		            // FIXME Performance ?
		            if (data) {
		                for (var i = 0; i < data.length; i++) {
		                    if (data[i] && data[i].label) {
		                        modelUtil.defaultEmphasis(data[i].label, modelUtil.LABEL_OPTIONS);
		                    }
		                }
		            }
		        },

		        /**
		         * Init a data structure from data related option in series
		         * Must be overwritten
		         */
		        getInitialData: function () {},

		        /**
		         * @param {string} [dataType]
		         * @return {module:echarts/data/List}
		         */
		        getData: function (dataType) {
		            return dataType == null ? this._data : this._data.getLinkedData(dataType);
		        },

		        /**
		         * @param {module:echarts/data/List} data
		         */
		        setData: function (data) {
		            this._data = data;
		        },

		        /**
		         * Get data before processed
		         * @return {module:echarts/data/List}
		         */
		        getRawData: function () {
		            return this._dataBeforeProcessed;
		        },

		        /**
		         * Coord dimension to data dimension.
		         *
		         * By default the result is the same as dimensions of series data.
		         * But in some series data dimensions are different from coord dimensions (i.e.
		         * candlestick and boxplot). Override this method to handle those cases.
		         *
		         * Coord dimension to data dimension can be one-to-many
		         *
		         * @param {string} coordDim
		         * @return {Array.<string>} dimensions on the axis.
		         */
		        coordDimToDataDim: function (coordDim) {
		            return [coordDim];
		        },

		        /**
		         * Convert data dimension to coord dimension.
		         *
		         * @param {string|number} dataDim
		         * @return {string}
		         */
		        dataDimToCoordDim: function (dataDim) {
		            return dataDim;
		        },

		        /**
		         * Get base axis if has coordinate system and has axis.
		         * By default use coordSys.getBaseAxis();
		         * Can be overrided for some chart.
		         * @return {type} description
		         */
		        getBaseAxis: function () {
		            var coordSys = this.coordinateSystem;
		            return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis();
		        },

		        // FIXME
		        /**
		         * Default tooltip formatter
		         *
		         * @param {number} dataIndex
		         * @param {boolean} [multipleSeries=false]
		         * @param {number} [dataType]
		         */
		        formatTooltip: function (dataIndex, multipleSeries, dataType) {
		            function formatArrayValue(value) {
		                var result = [];

		                zrUtil.each(value, function (val, idx) {
		                    var dimInfo = data.getDimensionInfo(idx);
		                    var dimType = dimInfo && dimInfo.type;
		                    var valStr;

		                    if (dimType === 'ordinal') {
		                        valStr = val + '';
		                    }
		                    else if (dimType === 'time') {
		                        valStr = multipleSeries ? '' : formatUtil.formatTime('yyyy/MM/dd hh:mm:ss', val);
		                    }
		                    else {
		                        valStr = addCommas(val);
		                    }

		                    valStr && result.push(valStr);
		                });

		                return result.join(', ');
		            }

		            var data = this._data;

		            var value = this.getRawValue(dataIndex);
		            var formattedValue = zrUtil.isArray(value)
		                ? formatArrayValue(value) : addCommas(value);
		            var name = data.getName(dataIndex);

		            var color = data.getItemVisual(dataIndex, 'color');
		            if (zrUtil.isObject(color) && color.colorStops) {
		                color = (color.colorStops[0] || {}).color;
		            }
		            color = color || 'transparent';

		            var colorEl = '<span style="display:inline-block;margin-right:5px;'
		                + 'border-radius:10px;width:9px;height:9px;background-color:' + color + '"></span>';

		            var seriesName = this.name;
		            // FIXME
		            if (seriesName === '\0-') {
		                // Not show '-'
		                seriesName = '';
		            }
		            return !multipleSeries
		                ? ((seriesName && encodeHTML(seriesName) + '<br />') + colorEl
		                    + (name
		                        ? encodeHTML(name) + ' : ' + formattedValue
		                        : formattedValue)
		                  )
		                : (colorEl + encodeHTML(this.name) + ' : ' + formattedValue);
		        },

		        /**
		         * @return {boolean}
		         */
		        ifEnableAnimation: function () {
		            if (env.node) {
		                return false;
		            }

		            var animationEnabled = this.getShallow('animation');
		            if (animationEnabled) {
		                if (this.getData().count() > this.getShallow('animationThreshold')) {
		                    animationEnabled = false;
		                }
		            }
		            return animationEnabled;
		        },

		        restoreData: function () {
		            this._data = this._dataBeforeProcessed.cloneShallow();
		        },

		        getColorFromPalette: function (name, scope) {
		            var ecModel = this.ecModel;
		            // PENDING
		            var color = colorPaletteMixin.getColorFromPalette.call(this, name, scope);
		            if (!color) {
		                color = ecModel.getColorFromPalette(name, scope);
		            }
		            return color;
		        },

		        /**
		         * Get data indices for show tooltip content. See tooltip.
		         * @abstract
		         * @param {Array.<string>|string} dim
		         * @param {Array.<number>} value
		         * @param {module:echarts/coord/single/SingleAxis} baseAxis
		         * @return {Array.<number>} data indices.
		         */
		        getAxisTooltipDataIndex: null,

		        /**
		         * See tooltip.
		         * @abstract
		         * @param {number} dataIndex
		         * @return {Array.<number>} Point of tooltip. null/undefined can be returned.
		         */
		        getTooltipPosition: null
		    });

		    zrUtil.mixin(SeriesModel, modelUtil.dataFormatMixin);
		    zrUtil.mixin(SeriesModel, colorPaletteMixin);

		    module.exports = SeriesModel;


	/***/ },
	/* 29 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var Group = __webpack_require__(30);
		    var componentUtil = __webpack_require__(20);
		    var clazzUtil = __webpack_require__(13);

		    var Component = function () {
		        /**
		         * @type {module:zrender/container/Group}
		         * @readOnly
		         */
		        this.group = new Group();

		        /**
		         * @type {string}
		         * @readOnly
		         */
		        this.uid = componentUtil.getUID('viewComponent');
		    };

		    Component.prototype = {

		        constructor: Component,

		        init: function (ecModel, api) {},

		        render: function (componentModel, ecModel, api, payload) {},

		        dispose: function () {}

		    };

		    var componentProto = Component.prototype;
		    componentProto.updateView
		        = componentProto.updateLayout
		        = componentProto.updateVisual
		        = function (seriesModel, ecModel, api, payload) {
		            // Do nothing;
		        };
		    // Enable Component.extend.
		    clazzUtil.enableClassExtend(Component);

		    // Enable capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
		    clazzUtil.enableClassManagement(Component, {registerWhenExtend: true});

		    module.exports = Component;


	/***/ },
	/* 30 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Group是一个容器，可以插入子节点，Group的变换也会被应用到子节点上
		 * @module zrender/graphic/Group
		 * @example
		 *     var Group = require('zrender/lib/container/Group');
		 *     var Circle = require('zrender/lib/graphic/shape/Circle');
		 *     var g = new Group();
		 *     g.position[0] = 100;
		 *     g.position[1] = 100;
		 *     g.add(new Circle({
		 *         style: {
		 *             x: 100,
		 *             y: 100,
		 *             r: 20,
		 *         }
		 *     }));
		 *     zr.add(g);
		 */


		    var zrUtil = __webpack_require__(4);
		    var Element = __webpack_require__(31);
		    var BoundingRect = __webpack_require__(9);

		    /**
		     * @alias module:zrender/graphic/Group
		     * @constructor
		     * @extends module:zrender/mixin/Transformable
		     * @extends module:zrender/mixin/Eventful
		     */
		    var Group = function (opts) {

		        opts = opts || {};

		        Element.call(this, opts);

		        for (var key in opts) {
		            if (opts.hasOwnProperty(key)) {
		                this[key] = opts[key];
		            }
		        }

		        this._children = [];

		        this.__storage = null;

		        this.__dirty = true;
		    };

		    Group.prototype = {

		        constructor: Group,

		        isGroup: true,

		        /**
		         * @type {string}
		         */
		        type: 'group',

		        /**
		         * 所有子孙元素是否响应鼠标事件
		         * @name module:/zrender/container/Group#silent
		         * @type {boolean}
		         * @default false
		         */
		        silent: false,

		        /**
		         * @return {Array.<module:zrender/Element>}
		         */
		        children: function () {
		            return this._children.slice();
		        },

		        /**
		         * 获取指定 index 的儿子节点
		         * @param  {number} idx
		         * @return {module:zrender/Element}
		         */
		        childAt: function (idx) {
		            return this._children[idx];
		        },

		        /**
		         * 获取指定名字的儿子节点
		         * @param  {string} name
		         * @return {module:zrender/Element}
		         */
		        childOfName: function (name) {
		            var children = this._children;
		            for (var i = 0; i < children.length; i++) {
		                if (children[i].name === name) {
		                    return children[i];
		                }
		             }
		        },

		        /**
		         * @return {number}
		         */
		        childCount: function () {
		            return this._children.length;
		        },

		        /**
		         * 添加子节点到最后
		         * @param {module:zrender/Element} child
		         */
		        add: function (child) {
		            if (child && child !== this && child.parent !== this) {

		                this._children.push(child);

		                this._doAdd(child);
		            }

		            return this;
		        },

		        /**
		         * 添加子节点在 nextSibling 之前
		         * @param {module:zrender/Element} child
		         * @param {module:zrender/Element} nextSibling
		         */
		        addBefore: function (child, nextSibling) {
		            if (child && child !== this && child.parent !== this
		                && nextSibling && nextSibling.parent === this) {

		                var children = this._children;
		                var idx = children.indexOf(nextSibling);

		                if (idx >= 0) {
		                    children.splice(idx, 0, child);
		                    this._doAdd(child);
		                }
		            }

		            return this;
		        },

		        _doAdd: function (child) {
		            if (child.parent) {
		                child.parent.remove(child);
		            }

		            child.parent = this;

		            var storage = this.__storage;
		            var zr = this.__zr;
		            if (storage && storage !== child.__storage) {

		                storage.addToMap(child);

		                if (child instanceof Group) {
		                    child.addChildrenToStorage(storage);
		                }
		            }

		            zr && zr.refresh();
		        },

		        /**
		         * 移除子节点
		         * @param {module:zrender/Element} child
		         */
		        remove: function (child) {
		            var zr = this.__zr;
		            var storage = this.__storage;
		            var children = this._children;

		            var idx = zrUtil.indexOf(children, child);
		            if (idx < 0) {
		                return this;
		            }
		            children.splice(idx, 1);

		            child.parent = null;

		            if (storage) {

		                storage.delFromMap(child.id);

		                if (child instanceof Group) {
		                    child.delChildrenFromStorage(storage);
		                }
		            }

		            zr && zr.refresh();

		            return this;
		        },

		        /**
		         * 移除所有子节点
		         */
		        removeAll: function () {
		            var children = this._children;
		            var storage = this.__storage;
		            var child;
		            var i;
		            for (i = 0; i < children.length; i++) {
		                child = children[i];
		                if (storage) {
		                    storage.delFromMap(child.id);
		                    if (child instanceof Group) {
		                        child.delChildrenFromStorage(storage);
		                    }
		                }
		                child.parent = null;
		            }
		            children.length = 0;

		            return this;
		        },

		        /**
		         * 遍历所有子节点
		         * @param  {Function} cb
		         * @param  {}   context
		         */
		        eachChild: function (cb, context) {
		            var children = this._children;
		            for (var i = 0; i < children.length; i++) {
		                var child = children[i];
		                cb.call(context, child, i);
		            }
		            return this;
		        },

		        /**
		         * 深度优先遍历所有子孙节点
		         * @param  {Function} cb
		         * @param  {}   context
		         */
		        traverse: function (cb, context) {
		            for (var i = 0; i < this._children.length; i++) {
		                var child = this._children[i];
		                cb.call(context, child);

		                if (child.type === 'group') {
		                    child.traverse(cb, context);
		                }
		            }
		            return this;
		        },

		        addChildrenToStorage: function (storage) {
		            for (var i = 0; i < this._children.length; i++) {
		                var child = this._children[i];
		                storage.addToMap(child);
		                if (child instanceof Group) {
		                    child.addChildrenToStorage(storage);
		                }
		            }
		        },

		        delChildrenFromStorage: function (storage) {
		            for (var i = 0; i < this._children.length; i++) {
		                var child = this._children[i];
		                storage.delFromMap(child.id);
		                if (child instanceof Group) {
		                    child.delChildrenFromStorage(storage);
		                }
		            }
		        },

		        dirty: function () {
		            this.__dirty = true;
		            this.__zr && this.__zr.refresh();
		            return this;
		        },

		        /**
		         * @return {module:zrender/core/BoundingRect}
		         */
		        getBoundingRect: function (includeChildren) {
		            // TODO Caching
		            var rect = null;
		            var tmpRect = new BoundingRect(0, 0, 0, 0);
		            var children = includeChildren || this._children;
		            var tmpMat = [];

		            for (var i = 0; i < children.length; i++) {
		                var child = children[i];
		                if (child.ignore || child.invisible) {
		                    continue;
		                }

		                var childRect = child.getBoundingRect();
		                var transform = child.getLocalTransform(tmpMat);
		                // TODO
		                // The boundingRect cacluated by transforming original
		                // rect may be bigger than the actual bundingRect when rotation
		                // is used. (Consider a circle rotated aginst its center, where
		                // the actual boundingRect should be the same as that not be
		                // rotated.) But we can not find better approach to calculate
		                // actual boundingRect yet, considering performance.
		                if (transform) {
		                    tmpRect.copy(childRect);
		                    tmpRect.applyTransform(transform);
		                    rect = rect || tmpRect.clone();
		                    rect.union(tmpRect);
		                }
		                else {
		                    rect = rect || childRect.clone();
		                    rect.union(childRect);
		                }
		            }
		            return rect || tmpRect;
		        }
		    };

		    zrUtil.inherits(Group, Element);

		    module.exports = Group;


	/***/ },
	/* 31 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * @module zrender/Element
		 */


		    var guid = __webpack_require__(32);
		    var Eventful = __webpack_require__(33);
		    var Transformable = __webpack_require__(34);
		    var Animatable = __webpack_require__(35);
		    var zrUtil = __webpack_require__(4);

		    /**
		     * @alias module:zrender/Element
		     * @constructor
		     * @extends {module:zrender/mixin/Animatable}
		     * @extends {module:zrender/mixin/Transformable}
		     * @extends {module:zrender/mixin/Eventful}
		     */
		    var Element = function (opts) {

		        Transformable.call(this, opts);
		        Eventful.call(this, opts);
		        Animatable.call(this, opts);

		        /**
		         * 画布元素ID
		         * @type {string}
		         */
		        this.id = opts.id || guid();
		    };

		    Element.prototype = {

		        /**
		         * 元素类型
		         * Element type
		         * @type {string}
		         */
		        type: 'element',

		        /**
		         * 元素名字
		         * Element name
		         * @type {string}
		         */
		        name: '',

		        /**
		         * ZRender 实例对象，会在 element 添加到 zrender 实例中后自动赋值
		         * ZRender instance will be assigned when element is associated with zrender
		         * @name module:/zrender/Element#__zr
		         * @type {module:zrender/ZRender}
		         */
		        __zr: null,

		        /**
		         * 图形是否忽略，为true时忽略图形的绘制以及事件触发
		         * If ignore drawing and events of the element object
		         * @name module:/zrender/Element#ignore
		         * @type {boolean}
		         * @default false
		         */
		        ignore: false,

		        /**
		         * 用于裁剪的路径(shape)，所有 Group 内的路径在绘制时都会被这个路径裁剪
		         * 该路径会继承被裁减对象的变换
		         * @type {module:zrender/graphic/Path}
		         * @see http://www.w3.org/TR/2dcontext/#clipping-region
		         * @readOnly
		         */
		        clipPath: null,

		        /**
		         * Drift element
		         * @param  {number} dx dx on the global space
		         * @param  {number} dy dy on the global space
		         */
		        drift: function (dx, dy) {
		            switch (this.draggable) {
		                case 'horizontal':
		                    dy = 0;
		                    break;
		                case 'vertical':
		                    dx = 0;
		                    break;
		            }

		            var m = this.transform;
		            if (!m) {
		                m = this.transform = [1, 0, 0, 1, 0, 0];
		            }
		            m[4] += dx;
		            m[5] += dy;

		            this.decomposeTransform();
		            this.dirty(false);
		        },

		        /**
		         * Hook before update
		         */
		        beforeUpdate: function () {},
		        /**
		         * Hook after update
		         */
		        afterUpdate: function () {},
		        /**
		         * Update each frame
		         */
		        update: function () {
		            this.updateTransform();
		        },

		        /**
		         * @param  {Function} cb
		         * @param  {}   context
		         */
		        traverse: function (cb, context) {},

		        /**
		         * @protected
		         */
		        attrKV: function (key, value) {
		            if (key === 'position' || key === 'scale' || key === 'origin') {
		                // Copy the array
		                if (value) {
		                    var target = this[key];
		                    if (!target) {
		                        target = this[key] = [];
		                    }
		                    target[0] = value[0];
		                    target[1] = value[1];
		                }
		            }
		            else {
		                this[key] = value;
		            }
		        },

		        /**
		         * Hide the element
		         */
		        hide: function () {
		            this.ignore = true;
		            this.__zr && this.__zr.refresh();
		        },

		        /**
		         * Show the element
		         */
		        show: function () {
		            this.ignore = false;
		            this.__zr && this.__zr.refresh();
		        },

		        /**
		         * @param {string|Object} key
		         * @param {*} value
		         */
		        attr: function (key, value) {
		            if (typeof key === 'string') {
		                this.attrKV(key, value);
		            }
		            else if (zrUtil.isObject(key)) {
		                for (var name in key) {
		                    if (key.hasOwnProperty(name)) {
		                        this.attrKV(name, key[name]);
		                    }
		                }
		            }

		            this.dirty(false);

		            return this;
		        },

		        /**
		         * @param {module:zrender/graphic/Path} clipPath
		         */
		        setClipPath: function (clipPath) {
		            var zr = this.__zr;
		            if (zr) {
		                clipPath.addSelfToZr(zr);
		            }

		            // Remove previous clip path
		            if (this.clipPath && this.clipPath !== clipPath) {
		                this.removeClipPath();
		            }

		            this.clipPath = clipPath;
		            clipPath.__zr = zr;
		            clipPath.__clipTarget = this;

		            this.dirty(false);
		        },

		        /**
		         */
		        removeClipPath: function () {
		            var clipPath = this.clipPath;
		            if (clipPath) {
		                if (clipPath.__zr) {
		                    clipPath.removeSelfFromZr(clipPath.__zr);
		                }

		                clipPath.__zr = null;
		                clipPath.__clipTarget = null;
		                this.clipPath = null;

		                this.dirty(false);
		            }
		        },

		        /**
		         * Add self from zrender instance.
		         * Not recursively because it will be invoked when element added to storage.
		         * @param {module:zrender/ZRender} zr
		         */
		        addSelfToZr: function (zr) {
		            this.__zr = zr;
		            // 添加动画
		            var animators = this.animators;
		            if (animators) {
		                for (var i = 0; i < animators.length; i++) {
		                    zr.animation.addAnimator(animators[i]);
		                }
		            }

		            if (this.clipPath) {
		                this.clipPath.addSelfToZr(zr);
		            }
		        },

		        /**
		         * Remove self from zrender instance.
		         * Not recursively because it will be invoked when element added to storage.
		         * @param {module:zrender/ZRender} zr
		         */
		        removeSelfFromZr: function (zr) {
		            this.__zr = null;
		            // 移除动画
		            var animators = this.animators;
		            if (animators) {
		                for (var i = 0; i < animators.length; i++) {
		                    zr.animation.removeAnimator(animators[i]);
		                }
		            }

		            if (this.clipPath) {
		                this.clipPath.removeSelfFromZr(zr);
		            }
		        }
		    };

		    zrUtil.mixin(Element, Animatable);
		    zrUtil.mixin(Element, Transformable);
		    zrUtil.mixin(Element, Eventful);

		    module.exports = Element;


	/***/ },
	/* 32 */
	/***/ function(module, exports) {

		/**
		 * zrender: 生成唯一id
		 *
		 * @author errorrik (errorrik@gmail.com)
		 */


		    var idStart = 0x0907;

		    module.exports = function () {
		        return idStart++;
		    };



	/***/ },
	/* 33 */
	/***/ function(module, exports) {

		/**
		 * 事件扩展
		 * @module zrender/mixin/Eventful
		 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
		 *         pissang (https://www.github.com/pissang)
		 */


		    var arrySlice = Array.prototype.slice;

		    /**
		     * 事件分发器
		     * @alias module:zrender/mixin/Eventful
		     * @constructor
		     */
		    var Eventful = function () {
		        this._$handlers = {};
		    };

		    Eventful.prototype = {

		        constructor: Eventful,

		        /**
		         * 单次触发绑定，trigger后销毁
		         *
		         * @param {string} event 事件名
		         * @param {Function} handler 响应函数
		         * @param {Object} context
		         */
		        one: function (event, handler, context) {
		            var _h = this._$handlers;

		            if (!handler || !event) {
		                return this;
		            }

		            if (!_h[event]) {
		                _h[event] = [];
		            }

		            for (var i = 0; i < _h[event].length; i++) {
		                if (_h[event][i].h === handler) {
		                    return this;
		                }
		            }

		            _h[event].push({
		                h: handler,
		                one: true,
		                ctx: context || this
		            });

		            return this;
		        },

		        /**
		         * 绑定事件
		         * @param {string} event 事件名
		         * @param {Function} handler 事件处理函数
		         * @param {Object} [context]
		         */
		        on: function (event, handler, context) {
		            var _h = this._$handlers;

		            if (!handler || !event) {
		                return this;
		            }

		            if (!_h[event]) {
		                _h[event] = [];
		            }

		            for (var i = 0; i < _h[event].length; i++) {
		                if (_h[event][i].h === handler) {
		                    return this;
		                }
		            }

		            _h[event].push({
		                h: handler,
		                one: false,
		                ctx: context || this
		            });

		            return this;
		        },

		        /**
		         * 是否绑定了事件
		         * @param  {string}  event
		         * @return {boolean}
		         */
		        isSilent: function (event) {
		            var _h = this._$handlers;
		            return _h[event] && _h[event].length;
		        },

		        /**
		         * 解绑事件
		         * @param {string} event 事件名
		         * @param {Function} [handler] 事件处理函数
		         */
		        off: function (event, handler) {
		            var _h = this._$handlers;

		            if (!event) {
		                this._$handlers = {};
		                return this;
		            }

		            if (handler) {
		                if (_h[event]) {
		                    var newList = [];
		                    for (var i = 0, l = _h[event].length; i < l; i++) {
		                        if (_h[event][i]['h'] != handler) {
		                            newList.push(_h[event][i]);
		                        }
		                    }
		                    _h[event] = newList;
		                }

		                if (_h[event] && _h[event].length === 0) {
		                    delete _h[event];
		                }
		            }
		            else {
		                delete _h[event];
		            }

		            return this;
		        },

		        /**
		         * 事件分发
		         *
		         * @param {string} type 事件类型
		         */
		        trigger: function (type) {
		            if (this._$handlers[type]) {
		                var args = arguments;
		                var argLen = args.length;

		                if (argLen > 3) {
		                    args = arrySlice.call(args, 1);
		                }

		                var _h = this._$handlers[type];
		                var len = _h.length;
		                for (var i = 0; i < len;) {
		                    // Optimize advise from backbone
		                    switch (argLen) {
		                        case 1:
		                            _h[i]['h'].call(_h[i]['ctx']);
		                            break;
		                        case 2:
		                            _h[i]['h'].call(_h[i]['ctx'], args[1]);
		                            break;
		                        case 3:
		                            _h[i]['h'].call(_h[i]['ctx'], args[1], args[2]);
		                            break;
		                        default:
		                            // have more than 2 given arguments
		                            _h[i]['h'].apply(_h[i]['ctx'], args);
		                            break;
		                    }

		                    if (_h[i]['one']) {
		                        _h.splice(i, 1);
		                        len--;
		                    }
		                    else {
		                        i++;
		                    }
		                }
		            }

		            return this;
		        },

		        /**
		         * 带有context的事件分发, 最后一个参数是事件回调的context
		         * @param {string} type 事件类型
		         */
		        triggerWithContext: function (type) {
		            if (this._$handlers[type]) {
		                var args = arguments;
		                var argLen = args.length;

		                if (argLen > 4) {
		                    args = arrySlice.call(args, 1, args.length - 1);
		                }
		                var ctx = args[args.length - 1];

		                var _h = this._$handlers[type];
		                var len = _h.length;
		                for (var i = 0; i < len;) {
		                    // Optimize advise from backbone
		                    switch (argLen) {
		                        case 1:
		                            _h[i]['h'].call(ctx);
		                            break;
		                        case 2:
		                            _h[i]['h'].call(ctx, args[1]);
		                            break;
		                        case 3:
		                            _h[i]['h'].call(ctx, args[1], args[2]);
		                            break;
		                        default:
		                            // have more than 2 given arguments
		                            _h[i]['h'].apply(ctx, args);
		                            break;
		                    }

		                    if (_h[i]['one']) {
		                        _h.splice(i, 1);
		                        len--;
		                    }
		                    else {
		                        i++;
		                    }
		                }
		            }

		            return this;
		        }
		    };

		    // 对象可以通过 onxxxx 绑定事件
		    /**
		     * @event module:zrender/mixin/Eventful#onclick
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#onmouseover
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#onmouseout
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#onmousemove
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#onmousewheel
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#onmousedown
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#onmouseup
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#ondrag
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#ondragstart
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#ondragend
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#ondragenter
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#ondragleave
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#ondragover
		     * @type {Function}
		     * @default null
		     */
		    /**
		     * @event module:zrender/mixin/Eventful#ondrop
		     * @type {Function}
		     * @default null
		     */

		    module.exports = Eventful;



	/***/ },
	/* 34 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * 提供变换扩展
		 * @module zrender/mixin/Transformable
		 * @author pissang (https://www.github.com/pissang)
		 */


		    var matrix = __webpack_require__(11);
		    var vector = __webpack_require__(10);
		    var mIdentity = matrix.identity;

		    var EPSILON = 5e-5;

		    function isNotAroundZero(val) {
		        return val > EPSILON || val < -EPSILON;
		    }

		    /**
		     * @alias module:zrender/mixin/Transformable
		     * @constructor
		     */
		    var Transformable = function (opts) {
		        opts = opts || {};
		        // If there are no given position, rotation, scale
		        if (!opts.position) {
		            /**
		             * 平移
		             * @type {Array.<number>}
		             * @default [0, 0]
		             */
		            this.position = [0, 0];
		        }
		        if (opts.rotation == null) {
		            /**
		             * 旋转
		             * @type {Array.<number>}
		             * @default 0
		             */
		            this.rotation = 0;
		        }
		        if (!opts.scale) {
		            /**
		             * 缩放
		             * @type {Array.<number>}
		             * @default [1, 1]
		             */
		            this.scale = [1, 1];
		        }
		        /**
		         * 旋转和缩放的原点
		         * @type {Array.<number>}
		         * @default null
		         */
		        this.origin = this.origin || null;
		    };

		    var transformableProto = Transformable.prototype;
		    transformableProto.transform = null;

		    /**
		     * 判断是否需要有坐标变换
		     * 如果有坐标变换, 则从position, rotation, scale以及父节点的transform计算出自身的transform矩阵
		     */
		    transformableProto.needLocalTransform = function () {
		        return isNotAroundZero(this.rotation)
		            || isNotAroundZero(this.position[0])
		            || isNotAroundZero(this.position[1])
		            || isNotAroundZero(this.scale[0] - 1)
		            || isNotAroundZero(this.scale[1] - 1);
		    };

		    transformableProto.updateTransform = function () {
		        var parent = this.parent;
		        var parentHasTransform = parent && parent.transform;
		        var needLocalTransform = this.needLocalTransform();

		        var m = this.transform;
		        if (!(needLocalTransform || parentHasTransform)) {
		            m && mIdentity(m);
		            return;
		        }

		        m = m || matrix.create();

		        if (needLocalTransform) {
		            this.getLocalTransform(m);
		        }
		        else {
		            mIdentity(m);
		        }

		        // 应用父节点变换
		        if (parentHasTransform) {
		            if (needLocalTransform) {
		                matrix.mul(m, parent.transform, m);
		            }
		            else {
		                matrix.copy(m, parent.transform);
		            }
		        }
		        // 保存这个变换矩阵
		        this.transform = m;

		        this.invTransform = this.invTransform || matrix.create();
		        matrix.invert(this.invTransform, m);
		    };

		    transformableProto.getLocalTransform = function (m) {
		        m = m || [];
		        mIdentity(m);

		        var origin = this.origin;

		        var scale = this.scale;
		        var rotation = this.rotation;
		        var position = this.position;
		        if (origin) {
		            // Translate to origin
		            m[4] -= origin[0];
		            m[5] -= origin[1];
		        }
		        matrix.scale(m, m, scale);
		        if (rotation) {
		            matrix.rotate(m, m, rotation);
		        }
		        if (origin) {
		            // Translate back from origin
		            m[4] += origin[0];
		            m[5] += origin[1];
		        }

		        m[4] += position[0];
		        m[5] += position[1];

		        return m;
		    };
		    /**
		     * 将自己的transform应用到context上
		     * @param {Context2D} ctx
		     */
		    transformableProto.setTransform = function (ctx) {
		        var m = this.transform;
		        var dpr = ctx.dpr || 1;
		        if (m) {
		            ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5]);
		        }
		        else {
		            ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
		        }
		    };

		    transformableProto.restoreTransform = function (ctx) {
		        var m = this.transform;
		        var dpr = ctx.dpr || 1;
		        ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
		    }

		    var tmpTransform = [];

		    /**
		     * 分解`transform`矩阵到`position`, `rotation`, `scale`
		     */
		    transformableProto.decomposeTransform = function () {
		        if (!this.transform) {
		            return;
		        }
		        var parent = this.parent;
		        var m = this.transform;
		        if (parent && parent.transform) {
		            // Get local transform and decompose them to position, scale, rotation
		            matrix.mul(tmpTransform, parent.invTransform, m);
		            m = tmpTransform;
		        }
		        var sx = m[0] * m[0] + m[1] * m[1];
		        var sy = m[2] * m[2] + m[3] * m[3];
		        var position = this.position;
		        var scale = this.scale;
		        if (isNotAroundZero(sx - 1)) {
		            sx = Math.sqrt(sx);
		        }
		        if (isNotAroundZero(sy - 1)) {
		            sy = Math.sqrt(sy);
		        }
		        if (m[0] < 0) {
		            sx = -sx;
		        }
		        if (m[3] < 0) {
		            sy = -sy;
		        }
		        position[0] = m[4];
		        position[1] = m[5];
		        scale[0] = sx;
		        scale[1] = sy;
		        this.rotation = Math.atan2(-m[1] / sy, m[0] / sx);
		    };

		    /**
		     * Get global scale
		     * @return {Array.<number>}
		     */
		    transformableProto.getGlobalScale = function () {
		        var m = this.transform;
		        if (!m) {
		            return [1, 1];
		        }
		        var sx = Math.sqrt(m[0] * m[0] + m[1] * m[1]);
		        var sy = Math.sqrt(m[2] * m[2] + m[3] * m[3]);
		        if (m[0] < 0) {
		            sx = -sx;
		        }
		        if (m[3] < 0) {
		            sy = -sy;
		        }
		        return [sx, sy];
		    };
		    /**
		     * 变换坐标位置到 shape 的局部坐标空间
		     * @method
		     * @param {number} x
		     * @param {number} y
		     * @return {Array.<number>}
		     */
		    transformableProto.transformCoordToLocal = function (x, y) {
		        var v2 = [x, y];
		        var invTransform = this.invTransform;
		        if (invTransform) {
		            vector.applyTransform(v2, v2, invTransform);
		        }
		        return v2;
		    };

		    /**
		     * 变换局部坐标位置到全局坐标空间
		     * @method
		     * @param {number} x
		     * @param {number} y
		     * @return {Array.<number>}
		     */
		    transformableProto.transformCoordToGlobal = function (x, y) {
		        var v2 = [x, y];
		        var transform = this.transform;
		        if (transform) {
		            vector.applyTransform(v2, v2, transform);
		        }
		        return v2;
		    };

		    module.exports = Transformable;



	/***/ },
	/* 35 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * @module zrender/mixin/Animatable
		 */


		    var Animator = __webpack_require__(36);
		    var util = __webpack_require__(4);
		    var isString = util.isString;
		    var isFunction = util.isFunction;
		    var isObject = util.isObject;
		    var log = __webpack_require__(40);

		    /**
		     * @alias modue:zrender/mixin/Animatable
		     * @constructor
		     */
		    var Animatable = function () {

		        /**
		         * @type {Array.<module:zrender/animation/Animator>}
		         * @readOnly
		         */
		        this.animators = [];
		    };

		    Animatable.prototype = {

		        constructor: Animatable,

		        /**
		         * 动画
		         *
		         * @param {string} path 需要添加动画的属性获取路径，可以通过a.b.c来获取深层的属性
		         * @param {boolean} [loop] 动画是否循环
		         * @return {module:zrender/animation/Animator}
		         * @example:
		         *     el.animate('style', false)
		         *         .when(1000, {x: 10} )
		         *         .done(function(){ // Animation done })
		         *         .start()
		         */
		        animate: function (path, loop) {
		            var target;
		            var animatingShape = false;
		            var el = this;
		            var zr = this.__zr;
		            if (path) {
		                var pathSplitted = path.split('.');
		                var prop = el;
		                // If animating shape
		                animatingShape = pathSplitted[0] === 'shape';
		                for (var i = 0, l = pathSplitted.length; i < l; i++) {
		                    if (!prop) {
		                        continue;
		                    }
		                    prop = prop[pathSplitted[i]];
		                }
		                if (prop) {
		                    target = prop;
		                }
		            }
		            else {
		                target = el;
		            }

		            if (!target) {
		                log(
		                    'Property "'
		                    + path
		                    + '" is not existed in element '
		                    + el.id
		                );
		                return;
		            }

		            var animators = el.animators;

		            var animator = new Animator(target, loop);

		            animator.during(function (target) {
		                el.dirty(animatingShape);
		            })
		            .done(function () {
		                // FIXME Animator will not be removed if use `Animator#stop` to stop animation
		                animators.splice(util.indexOf(animators, animator), 1);
		            });

		            animators.push(animator);

		            // If animate after added to the zrender
		            if (zr) {
		                zr.animation.addAnimator(animator);
		            }

		            return animator;
		        },

		        /**
		         * 停止动画
		         * @param {boolean} forwardToLast If move to last frame before stop
		         */
		        stopAnimation: function (forwardToLast) {
		            var animators = this.animators;
		            var len = animators.length;
		            for (var i = 0; i < len; i++) {
		                animators[i].stop(forwardToLast);
		            }
		            animators.length = 0;

		            return this;
		        },

		        /**
		         * @param {Object} target
		         * @param {number} [time=500] Time in ms
		         * @param {string} [easing='linear']
		         * @param {number} [delay=0]
		         * @param {Function} [callback]
		         *
		         * @example
		         *  // Animate position
		         *  el.animateTo({
		         *      position: [10, 10]
		         *  }, function () { // done })
		         *
		         *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing
		         *  el.animateTo({
		         *      shape: {
		         *          width: 500
		         *      },
		         *      style: {
		         *          fill: 'red'
		         *      }
		         *      position: [10, 10]
		         *  }, 100, 100, 'cubicOut', function () { // done })
		         */
		         // TODO Return animation key
		        animateTo: function (target, time, delay, easing, callback) {
		            // animateTo(target, time, easing, callback);
		            if (isString(delay)) {
		                callback = easing;
		                easing = delay;
		                delay = 0;
		            }
		            // animateTo(target, time, delay, callback);
		            else if (isFunction(easing)) {
		                callback = easing;
		                easing = 'linear';
		                delay = 0;
		            }
		            // animateTo(target, time, callback);
		            else if (isFunction(delay)) {
		                callback = delay;
		                delay = 0;
		            }
		            // animateTo(target, callback)
		            else if (isFunction(time)) {
		                callback = time;
		                time = 500;
		            }
		            // animateTo(target)
		            else if (!time) {
		                time = 500;
		            }
		            // Stop all previous animations
		            this.stopAnimation();
		            this._animateToShallow('', this, target, time, delay, easing, callback);

		            // Animators may be removed immediately after start
		            // if there is nothing to animate
		            var animators = this.animators.slice();
		            var count = animators.length;
		            function done() {
		                count--;
		                if (!count) {
		                    callback && callback();
		                }
		            }

		            // No animators. This should be checked before animators[i].start(),
		            // because 'done' may be executed immediately if no need to animate.
		            if (!count) {
		                callback && callback();
		            }
		            // Start after all animators created
		            // Incase any animator is done immediately when all animation properties are not changed
		            for (var i = 0; i < animators.length; i++) {
		                animators[i]
		                    .done(done)
		                    .start(easing);
		            }
		        },

		        /**
		         * @private
		         * @param {string} path=''
		         * @param {Object} source=this
		         * @param {Object} target
		         * @param {number} [time=500]
		         * @param {number} [delay=0]
		         *
		         * @example
		         *  // Animate position
		         *  el._animateToShallow({
		         *      position: [10, 10]
		         *  })
		         *
		         *  // Animate shape, style and position in 100ms, delayed 100ms
		         *  el._animateToShallow({
		         *      shape: {
		         *          width: 500
		         *      },
		         *      style: {
		         *          fill: 'red'
		         *      }
		         *      position: [10, 10]
		         *  }, 100, 100)
		         */
		        _animateToShallow: function (path, source, target, time, delay) {
		            var objShallow = {};
		            var propertyCount = 0;
		            for (var name in target) {
		                if (!target.hasOwnProperty(name)) {
		                    continue;
		                }

		                if (source[name] != null) {
		                    if (isObject(target[name]) && !util.isArrayLike(target[name])) {
		                        this._animateToShallow(
		                            path ? path + '.' + name : name,
		                            source[name],
		                            target[name],
		                            time,
		                            delay
		                        );
		                    }
		                    else {
		                        objShallow[name] = target[name];
		                        propertyCount++;
		                    }
		                }
		                else if (target[name] != null) {
		                    // Attr directly if not has property
		                    // FIXME, if some property not needed for element ?
		                    if (!path) {
		                        this.attr(name, target[name]);
		                    }
		                    else {  // Shape or style
		                        var props = {};
		                        props[path] = {};
		                        props[path][name] = target[name];
		                        this.attr(props);
		                    }
		                }
		            }

		            if (propertyCount > 0) {
		                this.animate(path, false)
		                    .when(time == null ? 500 : time, objShallow)
		                    .delay(delay || 0);
		            }

		            return this;
		        }
		    };

		    module.exports = Animatable;


	/***/ },
	/* 36 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/animation/Animator
		 */


		    var Clip = __webpack_require__(37);
		    var color = __webpack_require__(39);
		    var util = __webpack_require__(4);
		    var isArrayLike = util.isArrayLike;

		    var arraySlice = Array.prototype.slice;

		    function defaultGetter(target, key) {
		        return target[key];
		    }

		    function defaultSetter(target, key, value) {
		        target[key] = value;
		    }

		    /**
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} percent
		     * @return {number}
		     */
		    function interpolateNumber(p0, p1, percent) {
		        return (p1 - p0) * percent + p0;
		    }

		    /**
		     * @param  {string} p0
		     * @param  {string} p1
		     * @param  {number} percent
		     * @return {string}
		     */
		    function interpolateString(p0, p1, percent) {
		        return percent > 0.5 ? p1 : p0;
		    }

		    /**
		     * @param  {Array} p0
		     * @param  {Array} p1
		     * @param  {number} percent
		     * @param  {Array} out
		     * @param  {number} arrDim
		     */
		    function interpolateArray(p0, p1, percent, out, arrDim) {
		        var len = p0.length;
		        if (arrDim == 1) {
		            for (var i = 0; i < len; i++) {
		                out[i] = interpolateNumber(p0[i], p1[i], percent);
		            }
		        }
		        else {
		            var len2 = p0[0].length;
		            for (var i = 0; i < len; i++) {
		                for (var j = 0; j < len2; j++) {
		                    out[i][j] = interpolateNumber(
		                        p0[i][j], p1[i][j], percent
		                    );
		                }
		            }
		        }
		    }

		    // arr0 is source array, arr1 is target array.
		    // Do some preprocess to avoid error happened when interpolating from arr0 to arr1
		    function fillArr(arr0, arr1, arrDim) {
		        var arr0Len = arr0.length;
		        var arr1Len = arr1.length;
		        if (arr0Len !== arr1Len) {
		            // FIXME Not work for TypedArray
		            var isPreviousLarger = arr0Len > arr1Len;
		            if (isPreviousLarger) {
		                // Cut the previous
		                arr0.length = arr1Len;
		            }
		            else {
		                // Fill the previous
		                for (var i = arr0Len; i < arr1Len; i++) {
		                    arr0.push(
		                        arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i])
		                    );
		                }
		            }
		        }
		        // Handling NaN value
		        var len2 = arr0[0] && arr0[0].length;
		        for (var i = 0; i < arr0.length; i++) {
		            if (arrDim === 1) {
		                if (isNaN(arr0[i])) {
		                    arr0[i] = arr1[i];
		                }
		            }
		            else {
		                for (var j = 0; j < len2; j++) {
		                    if (isNaN(arr0[i][j])) {
		                        arr0[i][j] = arr1[i][j];
		                    }
		                }
		            }
		        }
		    }

		    /**
		     * @param  {Array} arr0
		     * @param  {Array} arr1
		     * @param  {number} arrDim
		     * @return {boolean}
		     */
		    function isArraySame(arr0, arr1, arrDim) {
		        if (arr0 === arr1) {
		            return true;
		        }
		        var len = arr0.length;
		        if (len !== arr1.length) {
		            return false;
		        }
		        if (arrDim === 1) {
		            for (var i = 0; i < len; i++) {
		                if (arr0[i] !== arr1[i]) {
		                    return false;
		                }
		            }
		        }
		        else {
		            var len2 = arr0[0].length;
		            for (var i = 0; i < len; i++) {
		                for (var j = 0; j < len2; j++) {
		                    if (arr0[i][j] !== arr1[i][j]) {
		                        return false;
		                    }
		                }
		            }
		        }
		        return true;
		    }

		    /**
		     * Catmull Rom interpolate array
		     * @param  {Array} p0
		     * @param  {Array} p1
		     * @param  {Array} p2
		     * @param  {Array} p3
		     * @param  {number} t
		     * @param  {number} t2
		     * @param  {number} t3
		     * @param  {Array} out
		     * @param  {number} arrDim
		     */
		    function catmullRomInterpolateArray(
		        p0, p1, p2, p3, t, t2, t3, out, arrDim
		    ) {
		        var len = p0.length;
		        if (arrDim == 1) {
		            for (var i = 0; i < len; i++) {
		                out[i] = catmullRomInterpolate(
		                    p0[i], p1[i], p2[i], p3[i], t, t2, t3
		                );
		            }
		        }
		        else {
		            var len2 = p0[0].length;
		            for (var i = 0; i < len; i++) {
		                for (var j = 0; j < len2; j++) {
		                    out[i][j] = catmullRomInterpolate(
		                        p0[i][j], p1[i][j], p2[i][j], p3[i][j],
		                        t, t2, t3
		                    );
		                }
		            }
		        }
		    }

		    /**
		     * Catmull Rom interpolate number
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} p3
		     * @param  {number} t
		     * @param  {number} t2
		     * @param  {number} t3
		     * @return {number}
		     */
		    function catmullRomInterpolate(p0, p1, p2, p3, t, t2, t3) {
		        var v0 = (p2 - p0) * 0.5;
		        var v1 = (p3 - p1) * 0.5;
		        return (2 * (p1 - p2) + v0 + v1) * t3
		                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
		                + v0 * t + p1;
		    }

		    function cloneValue(value) {
		        if (isArrayLike(value)) {
		            var len = value.length;
		            if (isArrayLike(value[0])) {
		                var ret = [];
		                for (var i = 0; i < len; i++) {
		                    ret.push(arraySlice.call(value[i]));
		                }
		                return ret;
		            }

		            return arraySlice.call(value);
		        }

		        return value;
		    }

		    function rgba2String(rgba) {
		        rgba[0] = Math.floor(rgba[0]);
		        rgba[1] = Math.floor(rgba[1]);
		        rgba[2] = Math.floor(rgba[2]);

		        return 'rgba(' + rgba.join(',') + ')';
		    }

		    function createTrackClip (animator, easing, oneTrackDone, keyframes, propName) {
		        var getter = animator._getter;
		        var setter = animator._setter;
		        var useSpline = easing === 'spline';

		        var trackLen = keyframes.length;
		        if (!trackLen) {
		            return;
		        }
		        // Guess data type
		        var firstVal = keyframes[0].value;
		        var isValueArray = isArrayLike(firstVal);
		        var isValueColor = false;
		        var isValueString = false;

		        // For vertices morphing
		        var arrDim = (
		                isValueArray
		                && isArrayLike(firstVal[0])
		            )
		            ? 2 : 1;
		        var trackMaxTime;
		        // Sort keyframe as ascending
		        keyframes.sort(function(a, b) {
		            return a.time - b.time;
		        });

		        trackMaxTime = keyframes[trackLen - 1].time;
		        // Percents of each keyframe
		        var kfPercents = [];
		        // Value of each keyframe
		        var kfValues = [];
		        var prevValue = keyframes[0].value;
		        var isAllValueEqual = true;
		        for (var i = 0; i < trackLen; i++) {
		            kfPercents.push(keyframes[i].time / trackMaxTime);
		            // Assume value is a color when it is a string
		            var value = keyframes[i].value;

		            // Check if value is equal, deep check if value is array
		            if (!((isValueArray && isArraySame(value, prevValue, arrDim))
		                || (!isValueArray && value === prevValue))) {
		                isAllValueEqual = false;
		            }
		            prevValue = value;

		            // Try converting a string to a color array
		            if (typeof value == 'string') {
		                var colorArray = color.parse(value);
		                if (colorArray) {
		                    value = colorArray;
		                    isValueColor = true;
		                }
		                else {
		                    isValueString = true;
		                }
		            }
		            kfValues.push(value);
		        }
		        if (isAllValueEqual) {
		            return;
		        }

		        var lastValue = kfValues[trackLen - 1];
		        // Polyfill array and NaN value
		        for (var i = 0; i < trackLen - 1; i++) {
		            if (isValueArray) {
		                fillArr(kfValues[i], lastValue, arrDim);
		            }
		            else {
		                if (isNaN(kfValues[i]) && !isNaN(lastValue) && !isValueString && !isValueColor) {
		                    kfValues[i] = lastValue;
		                }
		            }
		        }
		        isValueArray && fillArr(getter(animator._target, propName), lastValue, arrDim);

		        // Cache the key of last frame to speed up when
		        // animation playback is sequency
		        var lastFrame = 0;
		        var lastFramePercent = 0;
		        var start;
		        var w;
		        var p0;
		        var p1;
		        var p2;
		        var p3;

		        if (isValueColor) {
		            var rgba = [0, 0, 0, 0];
		        }

		        var onframe = function (target, percent) {
		            // Find the range keyframes
		            // kf1-----kf2---------current--------kf3
		            // find kf2 and kf3 and do interpolation
		            var frame;
		            // In the easing function like elasticOut, percent may less than 0
		            if (percent < 0) {
		                frame = 0;
		            }
		            else if (percent < lastFramePercent) {
		                // Start from next key
		                // PENDING start from lastFrame ?
		                start = Math.min(lastFrame + 1, trackLen - 1);
		                for (frame = start; frame >= 0; frame--) {
		                    if (kfPercents[frame] <= percent) {
		                        break;
		                    }
		                }
		                // PENDING really need to do this ?
		                frame = Math.min(frame, trackLen - 2);
		            }
		            else {
		                for (frame = lastFrame; frame < trackLen; frame++) {
		                    if (kfPercents[frame] > percent) {
		                        break;
		                    }
		                }
		                frame = Math.min(frame - 1, trackLen - 2);
		            }
		            lastFrame = frame;
		            lastFramePercent = percent;

		            var range = (kfPercents[frame + 1] - kfPercents[frame]);
		            if (range === 0) {
		                return;
		            }
		            else {
		                w = (percent - kfPercents[frame]) / range;
		            }
		            if (useSpline) {
		                p1 = kfValues[frame];
		                p0 = kfValues[frame === 0 ? frame : frame - 1];
		                p2 = kfValues[frame > trackLen - 2 ? trackLen - 1 : frame + 1];
		                p3 = kfValues[frame > trackLen - 3 ? trackLen - 1 : frame + 2];
		                if (isValueArray) {
		                    catmullRomInterpolateArray(
		                        p0, p1, p2, p3, w, w * w, w * w * w,
		                        getter(target, propName),
		                        arrDim
		                    );
		                }
		                else {
		                    var value;
		                    if (isValueColor) {
		                        value = catmullRomInterpolateArray(
		                            p0, p1, p2, p3, w, w * w, w * w * w,
		                            rgba, 1
		                        );
		                        value = rgba2String(rgba);
		                    }
		                    else if (isValueString) {
		                        // String is step(0.5)
		                        return interpolateString(p1, p2, w);
		                    }
		                    else {
		                        value = catmullRomInterpolate(
		                            p0, p1, p2, p3, w, w * w, w * w * w
		                        );
		                    }
		                    setter(
		                        target,
		                        propName,
		                        value
		                    );
		                }
		            }
		            else {
		                if (isValueArray) {
		                    interpolateArray(
		                        kfValues[frame], kfValues[frame + 1], w,
		                        getter(target, propName),
		                        arrDim
		                    );
		                }
		                else {
		                    var value;
		                    if (isValueColor) {
		                        interpolateArray(
		                            kfValues[frame], kfValues[frame + 1], w,
		                            rgba, 1
		                        );
		                        value = rgba2String(rgba);
		                    }
		                    else if (isValueString) {
		                        // String is step(0.5)
		                        return interpolateString(kfValues[frame], kfValues[frame + 1], w);
		                    }
		                    else {
		                        value = interpolateNumber(kfValues[frame], kfValues[frame + 1], w);
		                    }
		                    setter(
		                        target,
		                        propName,
		                        value
		                    );
		                }
		            }
		        };

		        var clip = new Clip({
		            target: animator._target,
		            life: trackMaxTime,
		            loop: animator._loop,
		            delay: animator._delay,
		            onframe: onframe,
		            ondestroy: oneTrackDone
		        });

		        if (easing && easing !== 'spline') {
		            clip.easing = easing;
		        }

		        return clip;
		    }

		    /**
		     * @alias module:zrender/animation/Animator
		     * @constructor
		     * @param {Object} target
		     * @param {boolean} loop
		     * @param {Function} getter
		     * @param {Function} setter
		     */
		    var Animator = function(target, loop, getter, setter) {
		        this._tracks = {};
		        this._target = target;

		        this._loop = loop || false;

		        this._getter = getter || defaultGetter;
		        this._setter = setter || defaultSetter;

		        this._clipCount = 0;

		        this._delay = 0;

		        this._doneList = [];

		        this._onframeList = [];

		        this._clipList = [];
		    };

		    Animator.prototype = {
		        /**
		         * 设置动画关键帧
		         * @param  {number} time 关键帧时间，单位是ms
		         * @param  {Object} props 关键帧的属性值，key-value表示
		         * @return {module:zrender/animation/Animator}
		         */
		        when: function(time /* ms */, props) {
		            var tracks = this._tracks;
		            for (var propName in props) {
		                if (!props.hasOwnProperty(propName)) {
		                    continue;
		                }

		                if (!tracks[propName]) {
		                    tracks[propName] = [];
		                    // Invalid value
		                    var value = this._getter(this._target, propName);
		                    if (value == null) {
		                        // zrLog('Invalid property ' + propName);
		                        continue;
		                    }
		                    // If time is 0
		                    //  Then props is given initialize value
		                    // Else
		                    //  Initialize value from current prop value
		                    if (time !== 0) {
		                        tracks[propName].push({
		                            time: 0,
		                            value: cloneValue(value)
		                        });
		                    }
		                }
		                tracks[propName].push({
		                    time: time,
		                    value: props[propName]
		                });
		            }
		            return this;
		        },
		        /**
		         * 添加动画每一帧的回调函数
		         * @param  {Function} callback
		         * @return {module:zrender/animation/Animator}
		         */
		        during: function (callback) {
		            this._onframeList.push(callback);
		            return this;
		        },

		        _doneCallback: function () {
		            // Clear all tracks
		            this._tracks = {};
		            // Clear all clips
		            this._clipList.length = 0;

		            var doneList = this._doneList;
		            var len = doneList.length;
		            for (var i = 0; i < len; i++) {
		                doneList[i].call(this);
		            }
		        },
		        /**
		         * 开始执行动画
		         * @param  {string|Function} easing
		         *         动画缓动函数，详见{@link module:zrender/animation/easing}
		         * @return {module:zrender/animation/Animator}
		         */
		        start: function (easing) {

		            var self = this;
		            var clipCount = 0;

		            var oneTrackDone = function() {
		                clipCount--;
		                if (!clipCount) {
		                    self._doneCallback();
		                }
		            };

		            var lastClip;
		            for (var propName in this._tracks) {
		                if (!this._tracks.hasOwnProperty(propName)) {
		                    continue;
		                }
		                var clip = createTrackClip(
		                    this, easing, oneTrackDone,
		                    this._tracks[propName], propName
		                );
		                if (clip) {
		                    this._clipList.push(clip);
		                    clipCount++;

		                    // If start after added to animation
		                    if (this.animation) {
		                        this.animation.addClip(clip);
		                    }

		                    lastClip = clip;
		                }
		            }

		            // Add during callback on the last clip
		            if (lastClip) {
		                var oldOnFrame = lastClip.onframe;
		                lastClip.onframe = function (target, percent) {
		                    oldOnFrame(target, percent);

		                    for (var i = 0; i < self._onframeList.length; i++) {
		                        self._onframeList[i](target, percent);
		                    }
		                };
		            }

		            if (!clipCount) {
		                this._doneCallback();
		            }
		            return this;
		        },
		        /**
		         * 停止动画
		         * @param {boolean} forwardToLast If move to last frame before stop
		         */
		        stop: function (forwardToLast) {
		            var clipList = this._clipList;
		            var animation = this.animation;
		            for (var i = 0; i < clipList.length; i++) {
		                var clip = clipList[i];
		                if (forwardToLast) {
		                    // Move to last frame before stop
		                    clip.onframe(this._target, 1);
		                }
		                animation && animation.removeClip(clip);
		            }
		            clipList.length = 0;
		        },
		        /**
		         * 设置动画延迟开始的时间
		         * @param  {number} time 单位ms
		         * @return {module:zrender/animation/Animator}
		         */
		        delay: function (time) {
		            this._delay = time;
		            return this;
		        },
		        /**
		         * 添加动画结束的回调
		         * @param  {Function} cb
		         * @return {module:zrender/animation/Animator}
		         */
		        done: function(cb) {
		            if (cb) {
		                this._doneList.push(cb);
		            }
		            return this;
		        },

		        /**
		         * @return {Array.<module:zrender/animation/Clip>}
		         */
		        getClips: function () {
		            return this._clipList;
		        }
		    };

		    module.exports = Animator;


	/***/ },
	/* 37 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 动画主控制器
		 * @config target 动画对象，可以是数组，如果是数组的话会批量分发onframe等事件
		 * @config life(1000) 动画时长
		 * @config delay(0) 动画延迟时间
		 * @config loop(true)
		 * @config gap(0) 循环的间隔时间
		 * @config onframe
		 * @config easing(optional)
		 * @config ondestroy(optional)
		 * @config onrestart(optional)
		 *
		 * TODO pause
		 */


		    var easingFuncs = __webpack_require__(38);

		    function Clip(options) {

		        this._target = options.target;

		        // 生命周期
		        this._life = options.life || 1000;
		        // 延时
		        this._delay = options.delay || 0;
		        // 开始时间
		        // this._startTime = new Date().getTime() + this._delay;// 单位毫秒
		        this._initialized = false;

		        // 是否循环
		        this.loop = options.loop == null ? false : options.loop;

		        this.gap = options.gap || 0;

		        this.easing = options.easing || 'Linear';

		        this.onframe = options.onframe;
		        this.ondestroy = options.ondestroy;
		        this.onrestart = options.onrestart;
		    }

		    Clip.prototype = {

		        constructor: Clip,

		        step: function (globalTime) {
		            // Set startTime on first step, or _startTime may has milleseconds different between clips
		            // PENDING
		            if (!this._initialized) {
		                this._startTime = globalTime + this._delay;
		                this._initialized = true;
		            }

		            var percent = (globalTime - this._startTime) / this._life;

		            // 还没开始
		            if (percent < 0) {
		                return;
		            }

		            percent = Math.min(percent, 1);

		            var easing = this.easing;
		            var easingFunc = typeof easing == 'string' ? easingFuncs[easing] : easing;
		            var schedule = typeof easingFunc === 'function'
		                ? easingFunc(percent)
		                : percent;

		            this.fire('frame', schedule);

		            // 结束
		            if (percent == 1) {
		                if (this.loop) {
		                    this.restart (globalTime);
		                    // 重新开始周期
		                    // 抛出而不是直接调用事件直到 stage.update 后再统一调用这些事件
		                    return 'restart';
		                }

		                // 动画完成将这个控制器标识为待删除
		                // 在Animation.update中进行批量删除
		                this._needsRemove = true;
		                return 'destroy';
		            }

		            return null;
		        },

		        restart: function (globalTime) {
		            var remainder = (globalTime - this._startTime) % this._life;
		            this._startTime = globalTime - remainder + this.gap;

		            this._needsRemove = false;
		        },

		        fire: function(eventType, arg) {
		            eventType = 'on' + eventType;
		            if (this[eventType]) {
		                this[eventType](this._target, arg);
		            }
		        }
		    };

		    module.exports = Clip;



	/***/ },
	/* 38 */
	/***/ function(module, exports) {

		/**
		 * 缓动代码来自 https://github.com/sole/tween.js/blob/master/src/Tween.js
		 * @see http://sole.github.io/tween.js/examples/03_graphs.html
		 * @exports zrender/animation/easing
		 */

		    var easing = {
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        linear: function (k) {
		            return k;
		        },

		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        quadraticIn: function (k) {
		            return k * k;
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        quadraticOut: function (k) {
		            return k * (2 - k);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        quadraticInOut: function (k) {
		            if ((k *= 2) < 1) {
		                return 0.5 * k * k;
		            }
		            return -0.5 * (--k * (k - 2) - 1);
		        },

		        // 三次方的缓动（t^3）
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        cubicIn: function (k) {
		            return k * k * k;
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        cubicOut: function (k) {
		            return --k * k * k + 1;
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        cubicInOut: function (k) {
		            if ((k *= 2) < 1) {
		                return 0.5 * k * k * k;
		            }
		            return 0.5 * ((k -= 2) * k * k + 2);
		        },

		        // 四次方的缓动（t^4）
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        quarticIn: function (k) {
		            return k * k * k * k;
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        quarticOut: function (k) {
		            return 1 - (--k * k * k * k);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        quarticInOut: function (k) {
		            if ((k *= 2) < 1) {
		                return 0.5 * k * k * k * k;
		            }
		            return -0.5 * ((k -= 2) * k * k * k - 2);
		        },

		        // 五次方的缓动（t^5）
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        quinticIn: function (k) {
		            return k * k * k * k * k;
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        quinticOut: function (k) {
		            return --k * k * k * k * k + 1;
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        quinticInOut: function (k) {
		            if ((k *= 2) < 1) {
		                return 0.5 * k * k * k * k * k;
		            }
		            return 0.5 * ((k -= 2) * k * k * k * k + 2);
		        },

		        // 正弦曲线的缓动（sin(t)）
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        sinusoidalIn: function (k) {
		            return 1 - Math.cos(k * Math.PI / 2);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        sinusoidalOut: function (k) {
		            return Math.sin(k * Math.PI / 2);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        sinusoidalInOut: function (k) {
		            return 0.5 * (1 - Math.cos(Math.PI * k));
		        },

		        // 指数曲线的缓动（2^t）
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        exponentialIn: function (k) {
		            return k === 0 ? 0 : Math.pow(1024, k - 1);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        exponentialOut: function (k) {
		            return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        exponentialInOut: function (k) {
		            if (k === 0) {
		                return 0;
		            }
		            if (k === 1) {
		                return 1;
		            }
		            if ((k *= 2) < 1) {
		                return 0.5 * Math.pow(1024, k - 1);
		            }
		            return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);
		        },

		        // 圆形曲线的缓动（sqrt(1-t^2)）
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        circularIn: function (k) {
		            return 1 - Math.sqrt(1 - k * k);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        circularOut: function (k) {
		            return Math.sqrt(1 - (--k * k));
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        circularInOut: function (k) {
		            if ((k *= 2) < 1) {
		                return -0.5 * (Math.sqrt(1 - k * k) - 1);
		            }
		            return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1);
		        },

		        // 创建类似于弹簧在停止前来回振荡的动画
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        elasticIn: function (k) {
		            var s;
		            var a = 0.1;
		            var p = 0.4;
		            if (k === 0) {
		                return 0;
		            }
		            if (k === 1) {
		                return 1;
		            }
		            if (!a || a < 1) {
		                a = 1; s = p / 4;
		            }
		            else {
		                s = p * Math.asin(1 / a) / (2 * Math.PI);
		            }
		            return -(a * Math.pow(2, 10 * (k -= 1)) *
		                        Math.sin((k - s) * (2 * Math.PI) / p));
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        elasticOut: function (k) {
		            var s;
		            var a = 0.1;
		            var p = 0.4;
		            if (k === 0) {
		                return 0;
		            }
		            if (k === 1) {
		                return 1;
		            }
		            if (!a || a < 1) {
		                a = 1; s = p / 4;
		            }
		            else {
		                s = p * Math.asin(1 / a) / (2 * Math.PI);
		            }
		            return (a * Math.pow(2, -10 * k) *
		                    Math.sin((k - s) * (2 * Math.PI) / p) + 1);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        elasticInOut: function (k) {
		            var s;
		            var a = 0.1;
		            var p = 0.4;
		            if (k === 0) {
		                return 0;
		            }
		            if (k === 1) {
		                return 1;
		            }
		            if (!a || a < 1) {
		                a = 1; s = p / 4;
		            }
		            else {
		                s = p * Math.asin(1 / a) / (2 * Math.PI);
		            }
		            if ((k *= 2) < 1) {
		                return -0.5 * (a * Math.pow(2, 10 * (k -= 1))
		                    * Math.sin((k - s) * (2 * Math.PI) / p));
		            }
		            return a * Math.pow(2, -10 * (k -= 1))
		                    * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;

		        },

		        // 在某一动画开始沿指示的路径进行动画处理前稍稍收回该动画的移动
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        backIn: function (k) {
		            var s = 1.70158;
		            return k * k * ((s + 1) * k - s);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        backOut: function (k) {
		            var s = 1.70158;
		            return --k * k * ((s + 1) * k + s) + 1;
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        backInOut: function (k) {
		            var s = 1.70158 * 1.525;
		            if ((k *= 2) < 1) {
		                return 0.5 * (k * k * ((s + 1) * k - s));
		            }
		            return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2);
		        },

		        // 创建弹跳效果
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        bounceIn: function (k) {
		            return 1 - easing.bounceOut(1 - k);
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        bounceOut: function (k) {
		            if (k < (1 / 2.75)) {
		                return 7.5625 * k * k;
		            }
		            else if (k < (2 / 2.75)) {
		                return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75;
		            }
		            else if (k < (2.5 / 2.75)) {
		                return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375;
		            }
		            else {
		                return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375;
		            }
		        },
		        /**
		        * @param {number} k
		        * @return {number}
		        */
		        bounceInOut: function (k) {
		            if (k < 0.5) {
		                return easing.bounceIn(k * 2) * 0.5;
		            }
		            return easing.bounceOut(k * 2 - 1) * 0.5 + 0.5;
		        }
		    };

		    module.exports = easing;




	/***/ },
	/* 39 */
	/***/ function(module, exports) {

		/**
		 * @module zrender/tool/color
		 */


		    var kCSSColorTable = {
		        'transparent': [0,0,0,0], 'aliceblue': [240,248,255,1],
		        'antiquewhite': [250,235,215,1], 'aqua': [0,255,255,1],
		        'aquamarine': [127,255,212,1], 'azure': [240,255,255,1],
		        'beige': [245,245,220,1], 'bisque': [255,228,196,1],
		        'black': [0,0,0,1], 'blanchedalmond': [255,235,205,1],
		        'blue': [0,0,255,1], 'blueviolet': [138,43,226,1],
		        'brown': [165,42,42,1], 'burlywood': [222,184,135,1],
		        'cadetblue': [95,158,160,1], 'chartreuse': [127,255,0,1],
		        'chocolate': [210,105,30,1], 'coral': [255,127,80,1],
		        'cornflowerblue': [100,149,237,1], 'cornsilk': [255,248,220,1],
		        'crimson': [220,20,60,1], 'cyan': [0,255,255,1],
		        'darkblue': [0,0,139,1], 'darkcyan': [0,139,139,1],
		        'darkgoldenrod': [184,134,11,1], 'darkgray': [169,169,169,1],
		        'darkgreen': [0,100,0,1], 'darkgrey': [169,169,169,1],
		        'darkkhaki': [189,183,107,1], 'darkmagenta': [139,0,139,1],
		        'darkolivegreen': [85,107,47,1], 'darkorange': [255,140,0,1],
		        'darkorchid': [153,50,204,1], 'darkred': [139,0,0,1],
		        'darksalmon': [233,150,122,1], 'darkseagreen': [143,188,143,1],
		        'darkslateblue': [72,61,139,1], 'darkslategray': [47,79,79,1],
		        'darkslategrey': [47,79,79,1], 'darkturquoise': [0,206,209,1],
		        'darkviolet': [148,0,211,1], 'deeppink': [255,20,147,1],
		        'deepskyblue': [0,191,255,1], 'dimgray': [105,105,105,1],
		        'dimgrey': [105,105,105,1], 'dodgerblue': [30,144,255,1],
		        'firebrick': [178,34,34,1], 'floralwhite': [255,250,240,1],
		        'forestgreen': [34,139,34,1], 'fuchsia': [255,0,255,1],
		        'gainsboro': [220,220,220,1], 'ghostwhite': [248,248,255,1],
		        'gold': [255,215,0,1], 'goldenrod': [218,165,32,1],
		        'gray': [128,128,128,1], 'green': [0,128,0,1],
		        'greenyellow': [173,255,47,1], 'grey': [128,128,128,1],
		        'honeydew': [240,255,240,1], 'hotpink': [255,105,180,1],
		        'indianred': [205,92,92,1], 'indigo': [75,0,130,1],
		        'ivory': [255,255,240,1], 'khaki': [240,230,140,1],
		        'lavender': [230,230,250,1], 'lavenderblush': [255,240,245,1],
		        'lawngreen': [124,252,0,1], 'lemonchiffon': [255,250,205,1],
		        'lightblue': [173,216,230,1], 'lightcoral': [240,128,128,1],
		        'lightcyan': [224,255,255,1], 'lightgoldenrodyellow': [250,250,210,1],
		        'lightgray': [211,211,211,1], 'lightgreen': [144,238,144,1],
		        'lightgrey': [211,211,211,1], 'lightpink': [255,182,193,1],
		        'lightsalmon': [255,160,122,1], 'lightseagreen': [32,178,170,1],
		        'lightskyblue': [135,206,250,1], 'lightslategray': [119,136,153,1],
		        'lightslategrey': [119,136,153,1], 'lightsteelblue': [176,196,222,1],
		        'lightyellow': [255,255,224,1], 'lime': [0,255,0,1],
		        'limegreen': [50,205,50,1], 'linen': [250,240,230,1],
		        'magenta': [255,0,255,1], 'maroon': [128,0,0,1],
		        'mediumaquamarine': [102,205,170,1], 'mediumblue': [0,0,205,1],
		        'mediumorchid': [186,85,211,1], 'mediumpurple': [147,112,219,1],
		        'mediumseagreen': [60,179,113,1], 'mediumslateblue': [123,104,238,1],
		        'mediumspringgreen': [0,250,154,1], 'mediumturquoise': [72,209,204,1],
		        'mediumvioletred': [199,21,133,1], 'midnightblue': [25,25,112,1],
		        'mintcream': [245,255,250,1], 'mistyrose': [255,228,225,1],
		        'moccasin': [255,228,181,1], 'navajowhite': [255,222,173,1],
		        'navy': [0,0,128,1], 'oldlace': [253,245,230,1],
		        'olive': [128,128,0,1], 'olivedrab': [107,142,35,1],
		        'orange': [255,165,0,1], 'orangered': [255,69,0,1],
		        'orchid': [218,112,214,1], 'palegoldenrod': [238,232,170,1],
		        'palegreen': [152,251,152,1], 'paleturquoise': [175,238,238,1],
		        'palevioletred': [219,112,147,1], 'papayawhip': [255,239,213,1],
		        'peachpuff': [255,218,185,1], 'peru': [205,133,63,1],
		        'pink': [255,192,203,1], 'plum': [221,160,221,1],
		        'powderblue': [176,224,230,1], 'purple': [128,0,128,1],
		        'red': [255,0,0,1], 'rosybrown': [188,143,143,1],
		        'royalblue': [65,105,225,1], 'saddlebrown': [139,69,19,1],
		        'salmon': [250,128,114,1], 'sandybrown': [244,164,96,1],
		        'seagreen': [46,139,87,1], 'seashell': [255,245,238,1],
		        'sienna': [160,82,45,1], 'silver': [192,192,192,1],
		        'skyblue': [135,206,235,1], 'slateblue': [106,90,205,1],
		        'slategray': [112,128,144,1], 'slategrey': [112,128,144,1],
		        'snow': [255,250,250,1], 'springgreen': [0,255,127,1],
		        'steelblue': [70,130,180,1], 'tan': [210,180,140,1],
		        'teal': [0,128,128,1], 'thistle': [216,191,216,1],
		        'tomato': [255,99,71,1], 'turquoise': [64,224,208,1],
		        'violet': [238,130,238,1], 'wheat': [245,222,179,1],
		        'white': [255,255,255,1], 'whitesmoke': [245,245,245,1],
		        'yellow': [255,255,0,1], 'yellowgreen': [154,205,50,1]
		    };

		    function clampCssByte(i) {  // Clamp to integer 0 .. 255.
		        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
		        return i < 0 ? 0 : i > 255 ? 255 : i;
		    }

		    function clampCssAngle(i) {  // Clamp to integer 0 .. 360.
		        i = Math.round(i);  // Seems to be what Chrome does (vs truncation).
		        return i < 0 ? 0 : i > 360 ? 360 : i;
		    }

		    function clampCssFloat(f) {  // Clamp to float 0.0 .. 1.0.
		        return f < 0 ? 0 : f > 1 ? 1 : f;
		    }

		    function parseCssInt(str) {  // int or percentage.
		        if (str.length && str.charAt(str.length - 1) === '%') {
		            return clampCssByte(parseFloat(str) / 100 * 255);
		        }
		        return clampCssByte(parseInt(str, 10));
		    }

		    function parseCssFloat(str) {  // float or percentage.
		        if (str.length && str.charAt(str.length - 1) === '%') {
		            return clampCssFloat(parseFloat(str) / 100);
		        }
		        return clampCssFloat(parseFloat(str));
		    }

		    function cssHueToRgb(m1, m2, h) {
		        if (h < 0) {
		            h += 1;
		        }
		        else if (h > 1) {
		            h -= 1;
		        }

		        if (h * 6 < 1) {
		            return m1 + (m2 - m1) * h * 6;
		        }
		        if (h * 2 < 1) {
		            return m2;
		        }
		        if (h * 3 < 2) {
		            return m1 + (m2 - m1) * (2/3 - h) * 6;
		        }
		        return m1;
		    }

		    function lerp(a, b, p) {
		        return a + (b - a) * p;
		    }

		    /**
		     * @param {string} colorStr
		     * @return {Array.<number>}
		     * @memberOf module:zrender/util/color
		     */
		    function parse(colorStr) {
		        if (!colorStr) {
		            return;
		        }
		        // colorStr may be not string
		        colorStr = colorStr + '';
		        // Remove all whitespace, not compliant, but should just be more accepting.
		        var str = colorStr.replace(/ /g, '').toLowerCase();

		        // Color keywords (and transparent) lookup.
		        if (str in kCSSColorTable) {
		            return kCSSColorTable[str].slice();  // dup.
		        }

		        // #abc and #abc123 syntax.
		        if (str.charAt(0) === '#') {
		            if (str.length === 4) {
		                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
		                if (!(iv >= 0 && iv <= 0xfff)) {
		                    return;  // Covers NaN.
		                }
		                return [
		                    ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8),
		                    (iv & 0xf0) | ((iv & 0xf0) >> 4),
		                    (iv & 0xf) | ((iv & 0xf) << 4),
		                    1
		                ];
		            }
		            else if (str.length === 7) {
		                var iv = parseInt(str.substr(1), 16);  // TODO(deanm): Stricter parsing.
		                if (!(iv >= 0 && iv <= 0xffffff)) {
		                    return;  // Covers NaN.
		                }
		                return [
		                    (iv & 0xff0000) >> 16,
		                    (iv & 0xff00) >> 8,
		                    iv & 0xff,
		                    1
		                ];
		            }

		            return;
		        }
		        var op = str.indexOf('('), ep = str.indexOf(')');
		        if (op !== -1 && ep + 1 === str.length) {
		            var fname = str.substr(0, op);
		            var params = str.substr(op + 1, ep - (op + 1)).split(',');
		            var alpha = 1;  // To allow case fallthrough.
		            switch (fname) {
		                case 'rgba':
		                    if (params.length !== 4) {
		                        return;
		                    }
		                    alpha = parseCssFloat(params.pop()); // jshint ignore:line
		                // Fall through.
		                case 'rgb':
		                    if (params.length !== 3) {
		                        return;
		                    }
		                    return [
		                        parseCssInt(params[0]),
		                        parseCssInt(params[1]),
		                        parseCssInt(params[2]),
		                        alpha
		                    ];
		                case 'hsla':
		                    if (params.length !== 4) {
		                        return;
		                    }
		                    params[3] = parseCssFloat(params[3]);
		                    return hsla2rgba(params);
		                case 'hsl':
		                    if (params.length !== 3) {
		                        return;
		                    }
		                    return hsla2rgba(params);
		                default:
		                    return;
		            }
		        }

		        return;
		    }

		    /**
		     * @param {Array.<number>} hsla
		     * @return {Array.<number>} rgba
		     */
		    function hsla2rgba(hsla) {
		        var h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360;  // 0 .. 1
		        // NOTE(deanm): According to the CSS spec s/l should only be
		        // percentages, but we don't bother and let float or percentage.
		        var s = parseCssFloat(hsla[1]);
		        var l = parseCssFloat(hsla[2]);
		        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
		        var m1 = l * 2 - m2;

		        var rgba = [
		            clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255),
		            clampCssByte(cssHueToRgb(m1, m2, h) * 255),
		            clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255)
		        ];

		        if (hsla.length === 4) {
		            rgba[3] = hsla[3];
		        }

		        return rgba;
		    }

		    /**
		     * @param {Array.<number>} rgba
		     * @return {Array.<number>} hsla
		     */
		    function rgba2hsla(rgba) {
		        if (!rgba) {
		            return;
		        }

		        // RGB from 0 to 255
		        var R = rgba[0] / 255;
		        var G = rgba[1] / 255;
		        var B = rgba[2] / 255;

		        var vMin = Math.min(R, G, B); // Min. value of RGB
		        var vMax = Math.max(R, G, B); // Max. value of RGB
		        var delta = vMax - vMin; // Delta RGB value

		        var L = (vMax + vMin) / 2;
		        var H;
		        var S;
		        // HSL results from 0 to 1
		        if (delta === 0) {
		            H = 0;
		            S = 0;
		        }
		        else {
		            if (L < 0.5) {
		                S = delta / (vMax + vMin);
		            }
		            else {
		                S = delta / (2 - vMax - vMin);
		            }

		            var deltaR = (((vMax - R) / 6) + (delta / 2)) / delta;
		            var deltaG = (((vMax - G) / 6) + (delta / 2)) / delta;
		            var deltaB = (((vMax - B) / 6) + (delta / 2)) / delta;

		            if (R === vMax) {
		                H = deltaB - deltaG;
		            }
		            else if (G === vMax) {
		                H = (1 / 3) + deltaR - deltaB;
		            }
		            else if (B === vMax) {
		                H = (2 / 3) + deltaG - deltaR;
		            }

		            if (H < 0) {
		                H += 1;
		            }

		            if (H > 1) {
		                H -= 1;
		            }
		        }

		        var hsla = [H * 360, S, L];

		        if (rgba[3] != null) {
		            hsla.push(rgba[3]);
		        }

		        return hsla;
		    }

		    /**
		     * @param {string} color
		     * @param {number} level
		     * @return {string}
		     * @memberOf module:zrender/util/color
		     */
		    function lift(color, level) {
		        var colorArr = parse(color);
		        if (colorArr) {
		            for (var i = 0; i < 3; i++) {
		                if (level < 0) {
		                    colorArr[i] = colorArr[i] * (1 - level) | 0;
		                }
		                else {
		                    colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0;
		                }
		            }
		            return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb');
		        }
		    }

		    /**
		     * @param {string} color
		     * @return {string}
		     * @memberOf module:zrender/util/color
		     */
		    function toHex(color, level) {
		        var colorArr = parse(color);
		        if (colorArr) {
		            return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1);
		        }
		    }

		    /**
		     * Map value to color. Faster than mapToColor methods because color is represented by rgba array
		     * @param {number} normalizedValue A float between 0 and 1.
		     * @param {Array.<Array.<number>>} colors List of rgba color array
		     * @param {Array.<number>} [out] Mapped gba color array
		     * @return {Array.<number>}
		     */
		    function fastMapToColor(normalizedValue, colors, out) {
		        if (!(colors && colors.length)
		            || !(normalizedValue >= 0 && normalizedValue <= 1)
		        ) {
		            return;
		        }
		        out = out || [0, 0, 0, 0];
		        var value = normalizedValue * (colors.length - 1);
		        var leftIndex = Math.floor(value);
		        var rightIndex = Math.ceil(value);
		        var leftColor = colors[leftIndex];
		        var rightColor = colors[rightIndex];
		        var dv = value - leftIndex;
		        out[0] = clampCssByte(lerp(leftColor[0], rightColor[0], dv));
		        out[1] = clampCssByte(lerp(leftColor[1], rightColor[1], dv));
		        out[2] = clampCssByte(lerp(leftColor[2], rightColor[2], dv));
		        out[3] = clampCssByte(lerp(leftColor[3], rightColor[3], dv));
		        return out;
		    }
		    /**
		     * @param {number} normalizedValue A float between 0 and 1.
		     * @param {Array.<string>} colors Color list.
		     * @param {boolean=} fullOutput Default false.
		     * @return {(string|Object)} Result color. If fullOutput,
		     *                           return {color: ..., leftIndex: ..., rightIndex: ..., value: ...},
		     * @memberOf module:zrender/util/color
		     */
		    function mapToColor(normalizedValue, colors, fullOutput) {
		        if (!(colors && colors.length)
		            || !(normalizedValue >= 0 && normalizedValue <= 1)
		        ) {
		            return;
		        }

		        var value = normalizedValue * (colors.length - 1);
		        var leftIndex = Math.floor(value);
		        var rightIndex = Math.ceil(value);
		        var leftColor = parse(colors[leftIndex]);
		        var rightColor = parse(colors[rightIndex]);
		        var dv = value - leftIndex;

		        var color = stringify(
		            [
		                clampCssByte(lerp(leftColor[0], rightColor[0], dv)),
		                clampCssByte(lerp(leftColor[1], rightColor[1], dv)),
		                clampCssByte(lerp(leftColor[2], rightColor[2], dv)),
		                clampCssFloat(lerp(leftColor[3], rightColor[3], dv))
		            ],
		            'rgba'
		        );

		        return fullOutput
		            ? {
		                color: color,
		                leftIndex: leftIndex,
		                rightIndex: rightIndex,
		                value: value
		            }
		            : color;
		    }

		    /**
		     * @param {string} color
		     * @param {number=} h 0 ~ 360, ignore when null.
		     * @param {number=} s 0 ~ 1, ignore when null.
		     * @param {number=} l 0 ~ 1, ignore when null.
		     * @return {string} Color string in rgba format.
		     * @memberOf module:zrender/util/color
		     */
		    function modifyHSL(color, h, s, l) {
		        color = parse(color);

		        if (color) {
		            color = rgba2hsla(color);
		            h != null && (color[0] = clampCssAngle(h));
		            s != null && (color[1] = parseCssFloat(s));
		            l != null && (color[2] = parseCssFloat(l));

		            return stringify(hsla2rgba(color), 'rgba');
		        }
		    }

		    /**
		     * @param {string} color
		     * @param {number=} alpha 0 ~ 1
		     * @return {string} Color string in rgba format.
		     * @memberOf module:zrender/util/color
		     */
		    function modifyAlpha(color, alpha) {
		        color = parse(color);

		        if (color && alpha != null) {
		            color[3] = clampCssFloat(alpha);
		            return stringify(color, 'rgba');
		        }
		    }

		    /**
		     * @param {Array.<string>} colors Color list.
		     * @param {string} type 'rgba', 'hsva', ...
		     * @return {string} Result color.
		     */
		    function stringify(arrColor, type) {
		        var colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2];
		        if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
		            colorStr += ',' + arrColor[3];
		        }
		        return type + '(' + colorStr + ')';
		    }

		    module.exports = {
		        parse: parse,
		        lift: lift,
		        toHex: toHex,
		        fastMapToColor: fastMapToColor,
		        mapToColor: mapToColor,
		        modifyHSL: modifyHSL,
		        modifyAlpha: modifyAlpha,
		        stringify: stringify
		    };




	/***/ },
	/* 40 */
	/***/ function(module, exports, __webpack_require__) {

		
		        var config = __webpack_require__(41);

		        /**
		         * @exports zrender/tool/log
		         * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
		         */
		        module.exports = function() {
		            if (config.debugMode === 0) {
		                return;
		            }
		            else if (config.debugMode == 1) {
		                for (var k in arguments) {
		                    throw new Error(arguments[k]);
		                }
		            }
		            else if (config.debugMode > 1) {
		                for (var k in arguments) {
		                    console.log(arguments[k]);
		                }
		            }
		        };

		        /* for debug
		        return function(mes) {
		            document.getElementById('wrong-message').innerHTML =
		                mes + ' ' + (new Date() - 0)
		                + '<br/>'
		                + document.getElementById('wrong-message').innerHTML;
		        };
		        */
		    


	/***/ },
	/* 41 */
	/***/ function(module, exports) {

		
		    var dpr = 1;
		    // If in browser environment
		    if (typeof window !== 'undefined') {
		        dpr = Math.max(window.devicePixelRatio || 1, 1);
		    }
		    /**
		     * config默认配置项
		     * @exports zrender/config
		     * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
		     */
		    var config = {
		        /**
		         * debug日志选项：catchBrushException为true下有效
		         * 0 : 不生成debug数据，发布用
		         * 1 : 异常抛出，调试用
		         * 2 : 控制台输出，调试用
		         */
		        debugMode: 0,

		        // retina 屏幕优化
		        devicePixelRatio: dpr
		    };
		    module.exports = config;




	/***/ },
	/* 42 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var Group = __webpack_require__(30);
		    var componentUtil = __webpack_require__(20);
		    var clazzUtil = __webpack_require__(13);
		    var modelUtil = __webpack_require__(5);
		    var zrUtil = __webpack_require__(4);

		    function Chart() {

		        /**
		         * @type {module:zrender/container/Group}
		         * @readOnly
		         */
		        this.group = new Group();

		        /**
		         * @type {string}
		         * @readOnly
		         */
		        this.uid = componentUtil.getUID('viewChart');
		    }

		    Chart.prototype = {

		        type: 'chart',

		        /**
		         * Init the chart
		         * @param  {module:echarts/model/Global} ecModel
		         * @param  {module:echarts/ExtensionAPI} api
		         */
		        init: function (ecModel, api) {},

		        /**
		         * Render the chart
		         * @param  {module:echarts/model/Series} seriesModel
		         * @param  {module:echarts/model/Global} ecModel
		         * @param  {module:echarts/ExtensionAPI} api
		         * @param  {Object} payload
		         */
		        render: function (seriesModel, ecModel, api, payload) {},

		        /**
		         * Highlight series or specified data item
		         * @param  {module:echarts/model/Series} seriesModel
		         * @param  {module:echarts/model/Global} ecModel
		         * @param  {module:echarts/ExtensionAPI} api
		         * @param  {Object} payload
		         */
		        highlight: function (seriesModel, ecModel, api, payload) {
		            toggleHighlight(seriesModel.getData(), payload, 'emphasis');
		        },

		        /**
		         * Downplay series or specified data item
		         * @param  {module:echarts/model/Series} seriesModel
		         * @param  {module:echarts/model/Global} ecModel
		         * @param  {module:echarts/ExtensionAPI} api
		         * @param  {Object} payload
		         */
		        downplay: function (seriesModel, ecModel, api, payload) {
		            toggleHighlight(seriesModel.getData(), payload, 'normal');
		        },

		        /**
		         * Remove self
		         * @param  {module:echarts/model/Global} ecModel
		         * @param  {module:echarts/ExtensionAPI} api
		         */
		        remove: function (ecModel, api) {
		            this.group.removeAll();
		        },

		        /**
		         * Dispose self
		         * @param  {module:echarts/model/Global} ecModel
		         * @param  {module:echarts/ExtensionAPI} api
		         */
		        dispose: function () {}

		        /**
		         * The view contains the given point.
		         * @interface
		         * @param {Array.<number>} point
		         * @return {boolean}
		         */
		        // containPoint: function () {}

		    };

		    var chartProto = Chart.prototype;
		    chartProto.updateView
		        = chartProto.updateLayout
		        = chartProto.updateVisual
		        = function (seriesModel, ecModel, api, payload) {
		            this.render(seriesModel, ecModel, api, payload);
		        };

		    /**
		     * Set state of single element
		     * @param  {module:zrender/Element} el
		     * @param  {string} state
		     */
		    function elSetState(el, state) {
		        if (el) {
		            el.trigger(state);
		            if (el.type === 'group') {
		                for (var i = 0; i < el.childCount(); i++) {
		                    elSetState(el.childAt(i), state);
		                }
		            }
		        }
		    }
		    /**
		     * @param  {module:echarts/data/List} data
		     * @param  {Object} payload
		     * @param  {string} state 'normal'|'emphasis'
		     * @inner
		     */
		    function toggleHighlight(data, payload, state) {
		        var dataIndex = modelUtil.queryDataIndex(data, payload);

		        if (dataIndex != null) {
		            zrUtil.each(modelUtil.normalizeToArray(dataIndex), function (dataIdx) {
		                elSetState(data.getItemGraphicEl(dataIdx), state);
		            });
		        }
		        else {
		            data.eachItemGraphicEl(function (el) {
		                elSetState(el, state);
		            });
		        }
		    }

		    // Enable Chart.extend.
		    clazzUtil.enableClassExtend(Chart, ['dispose']);

		    // Add capability of registerClass, getClass, hasClass, registerSubTypeDefaulter and so on.
		    clazzUtil.enableClassManagement(Chart, {registerWhenExtend: true});

		    module.exports = Chart;


	/***/ },
	/* 43 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);

		    var pathTool = __webpack_require__(44);
		    var round = Math.round;
		    var Path = __webpack_require__(45);
		    var colorTool = __webpack_require__(39);
		    var matrix = __webpack_require__(11);
		    var vector = __webpack_require__(10);

		    var graphic = {};

		    graphic.Group = __webpack_require__(30);

		    graphic.Image = __webpack_require__(61);

		    graphic.Text = __webpack_require__(63);

		    graphic.Circle = __webpack_require__(64);

		    graphic.Sector = __webpack_require__(65);

		    graphic.Ring = __webpack_require__(66);

		    graphic.Polygon = __webpack_require__(67);

		    graphic.Polyline = __webpack_require__(71);

		    graphic.Rect = __webpack_require__(72);

		    graphic.Line = __webpack_require__(74);

		    graphic.BezierCurve = __webpack_require__(75);

		    graphic.Arc = __webpack_require__(76);

		    graphic.CompoundPath = __webpack_require__(77);

		    graphic.LinearGradient = __webpack_require__(78);

		    graphic.RadialGradient = __webpack_require__(80);

		    graphic.BoundingRect = __webpack_require__(9);

		    /**
		     * Extend shape with parameters
		     */
		    graphic.extendShape = function (opts) {
		        return Path.extend(opts);
		    };

		    /**
		     * Extend path
		     */
		    graphic.extendPath = function (pathData, opts) {
		        return pathTool.extendFromString(pathData, opts);
		    };

		    /**
		     * Create a path element from path data string
		     * @param {string} pathData
		     * @param {Object} opts
		     * @param {module:zrender/core/BoundingRect} rect
		     * @param {string} [layout=cover] 'center' or 'cover'
		     */
		    graphic.makePath = function (pathData, opts, rect, layout) {
		        var path = pathTool.createFromString(pathData, opts);
		        var boundingRect = path.getBoundingRect();
		        if (rect) {
		            var aspect = boundingRect.width / boundingRect.height;

		            if (layout === 'center') {
		                // Set rect to center, keep width / height ratio.
		                var width = rect.height * aspect;
		                var height;
		                if (width <= rect.width) {
		                    height = rect.height;
		                }
		                else {
		                    width = rect.width;
		                    height = width / aspect;
		                }
		                var cx = rect.x + rect.width / 2;
		                var cy = rect.y + rect.height / 2;

		                rect.x = cx - width / 2;
		                rect.y = cy - height / 2;
		                rect.width = width;
		                rect.height = height;
		            }

		            this.resizePath(path, rect);
		        }
		        return path;
		    };

		    graphic.mergePath = pathTool.mergePath,

		    /**
		     * Resize a path to fit the rect
		     * @param {module:zrender/graphic/Path} path
		     * @param {Object} rect
		     */
		    graphic.resizePath = function (path, rect) {
		        if (!path.applyTransform) {
		            return;
		        }

		        var pathRect = path.getBoundingRect();

		        var m = pathRect.calculateTransform(rect);

		        path.applyTransform(m);
		    };

		    /**
		     * Sub pixel optimize line for canvas
		     *
		     * @param {Object} param
		     * @param {Object} [param.shape]
		     * @param {number} [param.shape.x1]
		     * @param {number} [param.shape.y1]
		     * @param {number} [param.shape.x2]
		     * @param {number} [param.shape.y2]
		     * @param {Object} [param.style]
		     * @param {number} [param.style.lineWidth]
		     * @return {Object} Modified param
		     */
		    graphic.subPixelOptimizeLine = function (param) {
		        var subPixelOptimize = graphic.subPixelOptimize;
		        var shape = param.shape;
		        var lineWidth = param.style.lineWidth;

		        if (round(shape.x1 * 2) === round(shape.x2 * 2)) {
		            shape.x1 = shape.x2 = subPixelOptimize(shape.x1, lineWidth, true);
		        }
		        if (round(shape.y1 * 2) === round(shape.y2 * 2)) {
		            shape.y1 = shape.y2 = subPixelOptimize(shape.y1, lineWidth, true);
		        }
		        return param;
		    };

		    /**
		     * Sub pixel optimize rect for canvas
		     *
		     * @param {Object} param
		     * @param {Object} [param.shape]
		     * @param {number} [param.shape.x]
		     * @param {number} [param.shape.y]
		     * @param {number} [param.shape.width]
		     * @param {number} [param.shape.height]
		     * @param {Object} [param.style]
		     * @param {number} [param.style.lineWidth]
		     * @return {Object} Modified param
		     */
		    graphic.subPixelOptimizeRect = function (param) {
		        var subPixelOptimize = graphic.subPixelOptimize;
		        var shape = param.shape;
		        var lineWidth = param.style.lineWidth;
		        var originX = shape.x;
		        var originY = shape.y;
		        var originWidth = shape.width;
		        var originHeight = shape.height;
		        shape.x = subPixelOptimize(shape.x, lineWidth, true);
		        shape.y = subPixelOptimize(shape.y, lineWidth, true);
		        shape.width = Math.max(
		            subPixelOptimize(originX + originWidth, lineWidth, false) - shape.x,
		            originWidth === 0 ? 0 : 1
		        );
		        shape.height = Math.max(
		            subPixelOptimize(originY + originHeight, lineWidth, false) - shape.y,
		            originHeight === 0 ? 0 : 1
		        );
		        return param;
		    };

		    /**
		     * Sub pixel optimize for canvas
		     *
		     * @param {number} position Coordinate, such as x, y
		     * @param {number} lineWidth Should be nonnegative integer.
		     * @param {boolean=} positiveOrNegative Default false (negative).
		     * @return {number} Optimized position.
		     */
		    graphic.subPixelOptimize = function (position, lineWidth, positiveOrNegative) {
		        // Assure that (position + lineWidth / 2) is near integer edge,
		        // otherwise line will be fuzzy in canvas.
		        var doubledPosition = round(position * 2);
		        return (doubledPosition + round(lineWidth)) % 2 === 0
		            ? doubledPosition / 2
		            : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;
		    };

		    function hasFillOrStroke(fillOrStroke) {
		        return fillOrStroke != null && fillOrStroke != 'none';
		    }

		    function liftColor(color) {
		        return typeof color === 'string' ? colorTool.lift(color, -0.1) : color;
		    }

		    /**
		     * @private
		     */
		    function cacheElementStl(el) {
		        if (el.__hoverStlDirty) {
		            var stroke = el.style.stroke;
		            var fill = el.style.fill;

		            // Create hoverStyle on mouseover
		            var hoverStyle = el.__hoverStl;
		            hoverStyle.fill = hoverStyle.fill
		                || (hasFillOrStroke(fill) ? liftColor(fill) : null);
		            hoverStyle.stroke = hoverStyle.stroke
		                || (hasFillOrStroke(stroke) ? liftColor(stroke) : null);

		            var normalStyle = {};
		            for (var name in hoverStyle) {
		                if (hoverStyle.hasOwnProperty(name)) {
		                    normalStyle[name] = el.style[name];
		                }
		            }

		            el.__normalStl = normalStyle;

		            el.__hoverStlDirty = false;
		        }
		    }

		    /**
		     * @private
		     */
		    function doSingleEnterHover(el) {
		        if (el.__isHover) {
		            return;
		        }

		        cacheElementStl(el);

		        if (el.useHoverLayer) {
		            el.__zr && el.__zr.addHover(el, el.__hoverStl);
		        }
		        else {
		            el.setStyle(el.__hoverStl);
		            el.z2 += 1;
		        }

		        el.__isHover = true;
		    }

		    /**
		     * @inner
		     */
		    function doSingleLeaveHover(el) {
		        if (!el.__isHover) {
		            return;
		        }

		        var normalStl = el.__normalStl;
		        if (el.useHoverLayer) {
		            el.__zr && el.__zr.removeHover(el);
		        }
		        else {
		            normalStl && el.setStyle(normalStl);
		            el.z2 -= 1;
		        }

		        el.__isHover = false;
		    }

		    /**
		     * @inner
		     */
		    function doEnterHover(el) {
		        el.type === 'group'
		            ? el.traverse(function (child) {
		                if (child.type !== 'group') {
		                    doSingleEnterHover(child);
		                }
		            })
		            : doSingleEnterHover(el);
		    }

		    function doLeaveHover(el) {
		        el.type === 'group'
		            ? el.traverse(function (child) {
		                if (child.type !== 'group') {
		                    doSingleLeaveHover(child);
		                }
		            })
		            : doSingleLeaveHover(el);
		    }

		    /**
		     * @inner
		     */
		    function setElementHoverStl(el, hoverStl) {
		        // If element has sepcified hoverStyle, then use it instead of given hoverStyle
		        // Often used when item group has a label element and it's hoverStyle is different
		        el.__hoverStl = el.hoverStyle || hoverStl || {};
		        el.__hoverStlDirty = true;

		        if (el.__isHover) {
		            cacheElementStl(el);
		        }
		    }

		    /**
		     * @inner
		     */
		    function onElementMouseOver(e) {
		        if (this.__hoverSilentOnTouch && e.zrByTouch) {
		            return;
		        }

		        // Only if element is not in emphasis status
		        !this.__isEmphasis && doEnterHover(this);
		    }

		    /**
		     * @inner
		     */
		    function onElementMouseOut(e) {
		        if (this.__hoverSilentOnTouch && e.zrByTouch) {
		            return;
		        }

		        // Only if element is not in emphasis status
		        !this.__isEmphasis && doLeaveHover(this);
		    }

		    /**
		     * @inner
		     */
		    function enterEmphasis() {
		        this.__isEmphasis = true;
		        doEnterHover(this);
		    }

		    /**
		     * @inner
		     */
		    function leaveEmphasis() {
		        this.__isEmphasis = false;
		        doLeaveHover(this);
		    }

		    /**
		     * Set hover style of element
		     * @param {module:zrender/Element} el
		     * @param {Object} [hoverStyle]
		     * @param {Object} [opt]
		     * @param {boolean} [opt.hoverSilentOnTouch=false]
		     *        In touch device, mouseover event will be trigger on touchstart event
		     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
		     *        conviniently use hoverStyle when tap on touch screen without additional
		     *        code for compatibility.
		     *        But if the chart/component has select feature, which usually also use
		     *        hoverStyle, there might be conflict between 'select-highlight' and
		     *        'hover-highlight' especially when roam is enabled (see geo for example).
		     *        In this case, hoverSilentOnTouch should be used to disable hover-highlight
		     *        on touch device.
		     */
		    graphic.setHoverStyle = function (el, hoverStyle, opt) {
		        el.__hoverSilentOnTouch = opt && opt.hoverSilentOnTouch;

		        el.type === 'group'
		            ? el.traverse(function (child) {
		                if (child.type !== 'group') {
		                    setElementHoverStl(child, hoverStyle);
		                }
		            })
		            : setElementHoverStl(el, hoverStyle);

		        // Duplicated function will be auto-ignored, see Eventful.js.
		        el.on('mouseover', onElementMouseOver)
		          .on('mouseout', onElementMouseOut);

		        // Emphasis, normal can be triggered manually
		        el.on('emphasis', enterEmphasis)
		          .on('normal', leaveEmphasis);
		    };

		    /**
		     * Set text option in the style
		     * @param {Object} textStyle
		     * @param {module:echarts/model/Model} labelModel
		     * @param {string} color
		     */
		    graphic.setText = function (textStyle, labelModel, color) {
		        var labelPosition = labelModel.getShallow('position') || 'inside';
		        var labelColor = labelPosition.indexOf('inside') >= 0 ? 'white' : color;
		        var textStyleModel = labelModel.getModel('textStyle');
		        zrUtil.extend(textStyle, {
		            textDistance: labelModel.getShallow('distance') || 5,
		            textFont: textStyleModel.getFont(),
		            textPosition: labelPosition,
		            textFill: textStyleModel.getTextColor() || labelColor
		        });
		    };

		    function animateOrSetProps(isUpdate, el, props, animatableModel, dataIndex, cb) {
		        if (typeof dataIndex === 'function') {
		            cb = dataIndex;
		            dataIndex = null;
		        }
		        var animationEnabled = animatableModel
		            && (
		                animatableModel.ifEnableAnimation
		                ? animatableModel.ifEnableAnimation()
		                // Directly use animation property
		                : animatableModel.getShallow('animation')
		            );

		        if (animationEnabled) {
		            var postfix = isUpdate ? 'Update' : '';
		            var duration = animatableModel
		                && animatableModel.getShallow('animationDuration' + postfix);
		            var animationEasing = animatableModel
		                && animatableModel.getShallow('animationEasing' + postfix);
		            var animationDelay = animatableModel
		                && animatableModel.getShallow('animationDelay' + postfix);
		            if (typeof animationDelay === 'function') {
		                animationDelay = animationDelay(dataIndex);
		            }
		            duration > 0
		                ? el.animateTo(props, duration, animationDelay || 0, animationEasing, cb)
		                : (el.attr(props), cb && cb());
		        }
		        else {
		            el.attr(props);
		            cb && cb();
		        }
		    }
		    /**
		     * Update graphic element properties with or without animation according to the configuration in series
		     * @param {module:zrender/Element} el
		     * @param {Object} props
		     * @param {module:echarts/model/Model} [animatableModel]
		     * @param {number} [dataIndex]
		     * @param {Function} [cb]
		     * @example
		     *     graphic.updateProps(el, {
		     *         position: [100, 100]
		     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
		     *     // Or
		     *     graphic.updateProps(el, {
		     *         position: [100, 100]
		     *     }, seriesModel, function () { console.log('Animation done!'); });
		     */
		    graphic.updateProps = function (el, props, animatableModel, dataIndex, cb) {
		        animateOrSetProps(true, el, props, animatableModel, dataIndex, cb);
		    };

		    /**
		     * Init graphic element properties with or without animation according to the configuration in series
		     * @param {module:zrender/Element} el
		     * @param {Object} props
		     * @param {module:echarts/model/Model} [animatableModel]
		     * @param {number} [dataIndex]
		     * @param {Function} cb
		     */
		    graphic.initProps = function (el, props, animatableModel, dataIndex, cb) {
		        animateOrSetProps(false, el, props, animatableModel, dataIndex, cb);
		    };

		    /**
		     * Get transform matrix of target (param target),
		     * in coordinate of its ancestor (param ancestor)
		     *
		     * @param {module:zrender/mixin/Transformable} target
		     * @param {module:zrender/mixin/Transformable} [ancestor]
		     */
		    graphic.getTransform = function (target, ancestor) {
		        var mat = matrix.identity([]);

		        while (target && target !== ancestor) {
		            matrix.mul(mat, target.getLocalTransform(), mat);
		            target = target.parent;
		        }

		        return mat;
		    };

		    /**
		     * Apply transform to an vertex.
		     * @param {Array.<number>} vertex [x, y]
		     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
		     * @param {boolean=} invert Whether use invert matrix.
		     * @return {Array.<number>} [x, y]
		     */
		    graphic.applyTransform = function (vertex, transform, invert) {
		        if (invert) {
		            transform = matrix.invert([], transform);
		        }
		        return vector.applyTransform([], vertex, transform);
		    };

		    /**
		     * @param {string} direction 'left' 'right' 'top' 'bottom'
		     * @param {Array.<number>} transform Transform matrix: like [1, 0, 0, 1, 0, 0]
		     * @param {boolean=} invert Whether use invert matrix.
		     * @return {string} Transformed direction. 'left' 'right' 'top' 'bottom'
		     */
		    graphic.transformDirection = function (direction, transform, invert) {

		        // Pick a base, ensure that transform result will not be (0, 0).
		        var hBase = (transform[4] === 0 || transform[5] === 0 || transform[0] === 0)
		            ? 1 : Math.abs(2 * transform[4] / transform[0]);
		        var vBase = (transform[4] === 0 || transform[5] === 0 || transform[2] === 0)
		            ? 1 : Math.abs(2 * transform[4] / transform[2]);

		        var vertex = [
		            direction === 'left' ? -hBase : direction === 'right' ? hBase : 0,
		            direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0
		        ];

		        vertex = graphic.applyTransform(vertex, transform, invert);

		        return Math.abs(vertex[0]) > Math.abs(vertex[1])
		            ? (vertex[0] > 0 ? 'right' : 'left')
		            : (vertex[1] > 0 ? 'bottom' : 'top');
		    };

		    /**
		     * Apply group transition animation from g1 to g2
		     */
		    graphic.groupTransition = function (g1, g2, animatableModel, cb) {
		        if (!g1 || !g2) {
		            return;
		        }

		        function getElMap(g) {
		            var elMap = {};
		            g.traverse(function (el) {
		                if (!el.isGroup && el.anid) {
		                    elMap[el.anid] = el;
		                }
		            });
		            return elMap;
		        }
		        function getAnimatableProps(el) {
		            var obj = {
		                position: vector.clone(el.position),
		                rotation: el.rotation
		            };
		            if (el.shape) {
		                obj.shape = zrUtil.extend({}, el.shape);
		            }
		            return obj;
		        }
		        var elMap1 = getElMap(g1);

		        g2.traverse(function (el) {
		            if (!el.isGroup && el.anid) {
		                var oldEl = elMap1[el.anid];
		                if (oldEl) {
		                    var newProp = getAnimatableProps(el);
		                    el.attr(getAnimatableProps(oldEl));
		                    graphic.updateProps(el, newProp, animatableModel, el.dataIndex);
		                }
		                // else {
		                //     if (el.previousProps) {
		                //         graphic.updateProps
		                //     }
		                // }
		            }
		        });
		    };

		    module.exports = graphic;


	/***/ },
	/* 44 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var Path = __webpack_require__(45);
		    var PathProxy = __webpack_require__(49);
		    var transformPath = __webpack_require__(60);
		    var matrix = __webpack_require__(11);

		    // command chars
		    var cc = [
		        'm', 'M', 'l', 'L', 'v', 'V', 'h', 'H', 'z', 'Z',
		        'c', 'C', 'q', 'Q', 't', 'T', 's', 'S', 'a', 'A'
		    ];

		    var mathSqrt = Math.sqrt;
		    var mathSin = Math.sin;
		    var mathCos = Math.cos;
		    var PI = Math.PI;

		    var vMag = function(v) {
		        return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
		    };
		    var vRatio = function(u, v) {
		        return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v));
		    };
		    var vAngle = function(u, v) {
		        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1)
		                * Math.acos(vRatio(u, v));
		    };

		    function processArc(x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
		        var psi = psiDeg * (PI / 180.0);
		        var xp = mathCos(psi) * (x1 - x2) / 2.0
		                 + mathSin(psi) * (y1 - y2) / 2.0;
		        var yp = -1 * mathSin(psi) * (x1 - x2) / 2.0
		                 + mathCos(psi) * (y1 - y2) / 2.0;

		        var lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry);

		        if (lambda > 1) {
		            rx *= mathSqrt(lambda);
		            ry *= mathSqrt(lambda);
		        }

		        var f = (fa === fs ? -1 : 1)
		            * mathSqrt((((rx * rx) * (ry * ry))
		                    - ((rx * rx) * (yp * yp))
		                    - ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp)
		                    + (ry * ry) * (xp * xp))
		                ) || 0;

		        var cxp = f * rx * yp / ry;
		        var cyp = f * -ry * xp / rx;

		        var cx = (x1 + x2) / 2.0
		                 + mathCos(psi) * cxp
		                 - mathSin(psi) * cyp;
		        var cy = (y1 + y2) / 2.0
		                + mathSin(psi) * cxp
		                + mathCos(psi) * cyp;

		        var theta = vAngle([ 1, 0 ], [ (xp - cxp) / rx, (yp - cyp) / ry ]);
		        var u = [ (xp - cxp) / rx, (yp - cyp) / ry ];
		        var v = [ (-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry ];
		        var dTheta = vAngle(u, v);

		        if (vRatio(u, v) <= -1) {
		            dTheta = PI;
		        }
		        if (vRatio(u, v) >= 1) {
		            dTheta = 0;
		        }
		        if (fs === 0 && dTheta > 0) {
		            dTheta = dTheta - 2 * PI;
		        }
		        if (fs === 1 && dTheta < 0) {
		            dTheta = dTheta + 2 * PI;
		        }

		        path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs);
		    }

		    function createPathProxyFromString(data) {
		        if (!data) {
		            return [];
		        }

		        // command string
		        var cs = data.replace(/-/g, ' -')
		            .replace(/  /g, ' ')
		            .replace(/ /g, ',')
		            .replace(/,,/g, ',');

		        var n;
		        // create pipes so that we can split the data
		        for (n = 0; n < cc.length; n++) {
		            cs = cs.replace(new RegExp(cc[n], 'g'), '|' + cc[n]);
		        }

		        // create array
		        var arr = cs.split('|');
		        // init context point
		        var cpx = 0;
		        var cpy = 0;

		        var path = new PathProxy();
		        var CMD = PathProxy.CMD;

		        var prevCmd;
		        for (n = 1; n < arr.length; n++) {
		            var str = arr[n];
		            var c = str.charAt(0);
		            var off = 0;
		            var p = str.slice(1).replace(/e,-/g, 'e-').split(',');
		            var cmd;

		            if (p.length > 0 && p[0] === '') {
		                p.shift();
		            }

		            for (var i = 0; i < p.length; i++) {
		                p[i] = parseFloat(p[i]);
		            }
		            while (off < p.length && !isNaN(p[off])) {
		                if (isNaN(p[0])) {
		                    break;
		                }
		                var ctlPtx;
		                var ctlPty;

		                var rx;
		                var ry;
		                var psi;
		                var fa;
		                var fs;

		                var x1 = cpx;
		                var y1 = cpy;

		                // convert l, H, h, V, and v to L
		                switch (c) {
		                    case 'l':
		                        cpx += p[off++];
		                        cpy += p[off++];
		                        cmd = CMD.L;
		                        path.addData(cmd, cpx, cpy);
		                        break;
		                    case 'L':
		                        cpx = p[off++];
		                        cpy = p[off++];
		                        cmd = CMD.L;
		                        path.addData(cmd, cpx, cpy);
		                        break;
		                    case 'm':
		                        cpx += p[off++];
		                        cpy += p[off++];
		                        cmd = CMD.M;
		                        path.addData(cmd, cpx, cpy);
		                        c = 'l';
		                        break;
		                    case 'M':
		                        cpx = p[off++];
		                        cpy = p[off++];
		                        cmd = CMD.M;
		                        path.addData(cmd, cpx, cpy);
		                        c = 'L';
		                        break;
		                    case 'h':
		                        cpx += p[off++];
		                        cmd = CMD.L;
		                        path.addData(cmd, cpx, cpy);
		                        break;
		                    case 'H':
		                        cpx = p[off++];
		                        cmd = CMD.L;
		                        path.addData(cmd, cpx, cpy);
		                        break;
		                    case 'v':
		                        cpy += p[off++];
		                        cmd = CMD.L;
		                        path.addData(cmd, cpx, cpy);
		                        break;
		                    case 'V':
		                        cpy = p[off++];
		                        cmd = CMD.L;
		                        path.addData(cmd, cpx, cpy);
		                        break;
		                    case 'C':
		                        cmd = CMD.C;
		                        path.addData(
		                            cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++]
		                        );
		                        cpx = p[off - 2];
		                        cpy = p[off - 1];
		                        break;
		                    case 'c':
		                        cmd = CMD.C;
		                        path.addData(
		                            cmd,
		                            p[off++] + cpx, p[off++] + cpy,
		                            p[off++] + cpx, p[off++] + cpy,
		                            p[off++] + cpx, p[off++] + cpy
		                        );
		                        cpx += p[off - 2];
		                        cpy += p[off - 1];
		                        break;
		                    case 'S':
		                        ctlPtx = cpx;
		                        ctlPty = cpy;
		                        var len = path.len();
		                        var pathData = path.data;
		                        if (prevCmd === CMD.C) {
		                            ctlPtx += cpx - pathData[len - 4];
		                            ctlPty += cpy - pathData[len - 3];
		                        }
		                        cmd = CMD.C;
		                        x1 = p[off++];
		                        y1 = p[off++];
		                        cpx = p[off++];
		                        cpy = p[off++];
		                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
		                        break;
		                    case 's':
		                        ctlPtx = cpx;
		                        ctlPty = cpy;
		                        var len = path.len();
		                        var pathData = path.data;
		                        if (prevCmd === CMD.C) {
		                            ctlPtx += cpx - pathData[len - 4];
		                            ctlPty += cpy - pathData[len - 3];
		                        }
		                        cmd = CMD.C;
		                        x1 = cpx + p[off++];
		                        y1 = cpy + p[off++];
		                        cpx += p[off++];
		                        cpy += p[off++];
		                        path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy);
		                        break;
		                    case 'Q':
		                        x1 = p[off++];
		                        y1 = p[off++];
		                        cpx = p[off++];
		                        cpy = p[off++];
		                        cmd = CMD.Q;
		                        path.addData(cmd, x1, y1, cpx, cpy);
		                        break;
		                    case 'q':
		                        x1 = p[off++] + cpx;
		                        y1 = p[off++] + cpy;
		                        cpx += p[off++];
		                        cpy += p[off++];
		                        cmd = CMD.Q;
		                        path.addData(cmd, x1, y1, cpx, cpy);
		                        break;
		                    case 'T':
		                        ctlPtx = cpx;
		                        ctlPty = cpy;
		                        var len = path.len();
		                        var pathData = path.data;
		                        if (prevCmd === CMD.Q) {
		                            ctlPtx += cpx - pathData[len - 4];
		                            ctlPty += cpy - pathData[len - 3];
		                        }
		                        cpx = p[off++];
		                        cpy = p[off++];
		                        cmd = CMD.Q;
		                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
		                        break;
		                    case 't':
		                        ctlPtx = cpx;
		                        ctlPty = cpy;
		                        var len = path.len();
		                        var pathData = path.data;
		                        if (prevCmd === CMD.Q) {
		                            ctlPtx += cpx - pathData[len - 4];
		                            ctlPty += cpy - pathData[len - 3];
		                        }
		                        cpx += p[off++];
		                        cpy += p[off++];
		                        cmd = CMD.Q;
		                        path.addData(cmd, ctlPtx, ctlPty, cpx, cpy);
		                        break;
		                    case 'A':
		                        rx = p[off++];
		                        ry = p[off++];
		                        psi = p[off++];
		                        fa = p[off++];
		                        fs = p[off++];

		                        x1 = cpx, y1 = cpy;
		                        cpx = p[off++];
		                        cpy = p[off++];
		                        cmd = CMD.A;
		                        processArc(
		                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
		                        );
		                        break;
		                    case 'a':
		                        rx = p[off++];
		                        ry = p[off++];
		                        psi = p[off++];
		                        fa = p[off++];
		                        fs = p[off++];

		                        x1 = cpx, y1 = cpy;
		                        cpx += p[off++];
		                        cpy += p[off++];
		                        cmd = CMD.A;
		                        processArc(
		                            x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path
		                        );
		                        break;
		                }
		            }

		            if (c === 'z' || c === 'Z') {
		                cmd = CMD.Z;
		                path.addData(cmd);
		            }

		            prevCmd = cmd;
		        }

		        path.toStatic();

		        return path;
		    }

		    // TODO Optimize double memory cost problem
		    function createPathOptions(str, opts) {
		        var pathProxy = createPathProxyFromString(str);
		        var transform;
		        opts = opts || {};
		        opts.buildPath = function (path) {
		            path.setData(pathProxy.data);
		            transform && transformPath(path, transform);
		            // Svg and vml renderer don't have context
		            var ctx = path.getContext();
		            if (ctx) {
		                path.rebuildPath(ctx);
		            }
		        };

		        opts.applyTransform = function (m) {
		            if (!transform) {
		                transform = matrix.create();
		            }
		            matrix.mul(transform, m, transform);
		            this.dirty(true);
		        };

		        return opts;
		    }

		    module.exports = {
		        /**
		         * Create a Path object from path string data
		         * http://www.w3.org/TR/SVG/paths.html#PathData
		         * @param  {Object} opts Other options
		         */
		        createFromString: function (str, opts) {
		            return new Path(createPathOptions(str, opts));
		        },

		        /**
		         * Create a Path class from path string data
		         * @param  {string} str
		         * @param  {Object} opts Other options
		         */
		        extendFromString: function (str, opts) {
		            return Path.extend(createPathOptions(str, opts));
		        },

		        /**
		         * Merge multiple paths
		         */
		        // TODO Apply transform
		        // TODO stroke dash
		        // TODO Optimize double memory cost problem
		        mergePath: function (pathEls, opts) {
		            var pathList = [];
		            var len = pathEls.length;
		            for (var i = 0; i < len; i++) {
		                var pathEl = pathEls[i];
		                if (pathEl.__dirty) {
		                    pathEl.buildPath(pathEl.path, pathEl.shape, true);
		                }
		                pathList.push(pathEl.path);
		            }

		            var pathBundle = new Path(opts);
		            pathBundle.buildPath = function (path) {
		                path.appendPath(pathList);
		                // Svg and vml renderer don't have context
		                var ctx = path.getContext();
		                if (ctx) {
		                    path.rebuildPath(ctx);
		                }
		            };

		            return pathBundle;
		        }
		    };


	/***/ },
	/* 45 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Path element
		 * @module zrender/graphic/Path
		 */



		    var Displayable = __webpack_require__(46);
		    var zrUtil = __webpack_require__(4);
		    var PathProxy = __webpack_require__(49);
		    var pathContain = __webpack_require__(52);

		    var Pattern = __webpack_require__(59);
		    var getCanvasPattern = Pattern.prototype.getCanvasPattern;

		    var abs = Math.abs;

		    /**
		     * @alias module:zrender/graphic/Path
		     * @extends module:zrender/graphic/Displayable
		     * @constructor
		     * @param {Object} opts
		     */
		    function Path(opts) {
		        Displayable.call(this, opts);

		        /**
		         * @type {module:zrender/core/PathProxy}
		         * @readOnly
		         */
		        this.path = new PathProxy();
		    }

		    Path.prototype = {

		        constructor: Path,

		        type: 'path',

		        __dirtyPath: true,

		        strokeContainThreshold: 5,

		        brush: function (ctx, prevEl) {
		            var style = this.style;
		            var path = this.path;
		            var hasStroke = style.hasStroke();
		            var hasFill = style.hasFill();
		            var fill = style.fill;
		            var stroke = style.stroke;
		            var hasFillGradient = hasFill && !!(fill.colorStops);
		            var hasStrokeGradient = hasStroke && !!(stroke.colorStops);
		            var hasFillPattern = hasFill && !!(fill.image);
		            var hasStrokePattern = hasStroke && !!(stroke.image);

		            style.bind(ctx, this, prevEl);
		            this.setTransform(ctx);

		            if (this.__dirty) {
		                var rect = this.getBoundingRect();
		                // Update gradient because bounding rect may changed
		                if (hasFillGradient) {
		                    this._fillGradient = style.getGradient(ctx, fill, rect);
		                }
		                if (hasStrokeGradient) {
		                    this._strokeGradient = style.getGradient(ctx, stroke, rect);
		                }
		            }
		            // Use the gradient or pattern
		            if (hasFillGradient) {
		                // PENDING If may have affect the state
		                ctx.fillStyle = this._fillGradient;
		            }
		            else if (hasFillPattern) {
		                ctx.fillStyle = getCanvasPattern.call(fill, ctx);
		            }
		            if (hasStrokeGradient) {
		                ctx.strokeStyle = this._strokeGradient;
		            }
		            else if (hasStrokePattern) {
		                ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);
		            }

		            var lineDash = style.lineDash;
		            var lineDashOffset = style.lineDashOffset;

		            var ctxLineDash = !!ctx.setLineDash;

		            // Update path sx, sy
		            var scale = this.getGlobalScale();
		            path.setScale(scale[0], scale[1]);

		            // Proxy context
		            // Rebuild path in following 2 cases
		            // 1. Path is dirty
		            // 2. Path needs javascript implemented lineDash stroking.
		            //    In this case, lineDash information will not be saved in PathProxy
		            if (this.__dirtyPath || (
		                lineDash && !ctxLineDash && hasStroke
		            )) {
		                path = this.path.beginPath(ctx);

		                // Setting line dash before build path
		                if (lineDash && !ctxLineDash) {
		                    path.setLineDash(lineDash);
		                    path.setLineDashOffset(lineDashOffset);
		                }

		                this.buildPath(path, this.shape, false);

		                // Clear path dirty flag
		                this.__dirtyPath = false;
		            }
		            else {
		                // Replay path building
		                ctx.beginPath();
		                this.path.rebuildPath(ctx);
		            }

		            hasFill && path.fill(ctx);

		            if (lineDash && ctxLineDash) {
		                ctx.setLineDash(lineDash);
		                ctx.lineDashOffset = lineDashOffset;
		            }

		            hasStroke && path.stroke(ctx);

		            if (lineDash && ctxLineDash) {
		                // PENDING
		                // Remove lineDash
		                ctx.setLineDash([]);
		            }


		            this.restoreTransform(ctx);

		            // Draw rect text
		            if (style.text != null) {
		                // var rect = this.getBoundingRect();
		                this.drawRectText(ctx, this.getBoundingRect());
		            }
		        },

		        // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath
		        // Like in circle
		        buildPath: function (ctx, shapeCfg, inBundle) {},

		        getBoundingRect: function () {
		            var rect = this._rect;
		            var style = this.style;
		            var needsUpdateRect = !rect;
		            if (needsUpdateRect) {
		                var path = this.path;
		                if (this.__dirtyPath) {
		                    path.beginPath();
		                    this.buildPath(path, this.shape, false);
		                }
		                rect = path.getBoundingRect();
		            }
		            this._rect = rect;

		            if (style.hasStroke()) {
		                // Needs update rect with stroke lineWidth when
		                // 1. Element changes scale or lineWidth
		                // 2. Shape is changed
		                var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());
		                if (this.__dirty || needsUpdateRect) {
		                    rectWithStroke.copy(rect);
		                    // FIXME Must after updateTransform
		                    var w = style.lineWidth;
		                    // PENDING, Min line width is needed when line is horizontal or vertical
		                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;

		                    // Only add extra hover lineWidth when there are no fill
		                    if (!style.hasFill()) {
		                        w = Math.max(w, this.strokeContainThreshold || 4);
		                    }
		                    // Consider line width
		                    // Line scale can't be 0;
		                    if (lineScale > 1e-10) {
		                        rectWithStroke.width += w / lineScale;
		                        rectWithStroke.height += w / lineScale;
		                        rectWithStroke.x -= w / lineScale / 2;
		                        rectWithStroke.y -= w / lineScale / 2;
		                    }
		                }

		                // Return rect with stroke
		                return rectWithStroke;
		            }

		            return rect;
		        },

		        contain: function (x, y) {
		            var localPos = this.transformCoordToLocal(x, y);
		            var rect = this.getBoundingRect();
		            var style = this.style;
		            x = localPos[0];
		            y = localPos[1];

		            if (rect.contain(x, y)) {
		                var pathData = this.path.data;
		                if (style.hasStroke()) {
		                    var lineWidth = style.lineWidth;
		                    var lineScale = style.strokeNoScale ? this.getLineScale() : 1;
		                    // Line scale can't be 0;
		                    if (lineScale > 1e-10) {
		                        // Only add extra hover lineWidth when there are no fill
		                        if (!style.hasFill()) {
		                            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);
		                        }
		                        if (pathContain.containStroke(
		                            pathData, lineWidth / lineScale, x, y
		                        )) {
		                            return true;
		                        }
		                    }
		                }
		                if (style.hasFill()) {
		                    return pathContain.contain(pathData, x, y);
		                }
		            }
		            return false;
		        },

		        /**
		         * @param  {boolean} dirtyPath
		         */
		        dirty: function (dirtyPath) {
		            if (dirtyPath == null) {
		                dirtyPath = true;
		            }
		            // Only mark dirty, not mark clean
		            if (dirtyPath) {
		                this.__dirtyPath = dirtyPath;
		                this._rect = null;
		            }

		            this.__dirty = true;

		            this.__zr && this.__zr.refresh();

		            // Used as a clipping path
		            if (this.__clipTarget) {
		                this.__clipTarget.dirty();
		            }
		        },

		        /**
		         * Alias for animate('shape')
		         * @param {boolean} loop
		         */
		        animateShape: function (loop) {
		            return this.animate('shape', loop);
		        },

		        // Overwrite attrKV
		        attrKV: function (key, value) {
		            // FIXME
		            if (key === 'shape') {
		                this.setShape(value);
		                this.__dirtyPath = true;
		                this._rect = null;
		            }
		            else {
		                Displayable.prototype.attrKV.call(this, key, value);
		            }
		        },

		        /**
		         * @param {Object|string} key
		         * @param {*} value
		         */
		        setShape: function (key, value) {
		            var shape = this.shape;
		            // Path from string may not have shape
		            if (shape) {
		                if (zrUtil.isObject(key)) {
		                    for (var name in key) {
		                        if (key.hasOwnProperty(name)) {
		                            shape[name] = key[name];
		                        }
		                    }
		                }
		                else {
		                    shape[key] = value;
		                }
		                this.dirty(true);
		            }
		            return this;
		        },

		        getLineScale: function () {
		            var m = this.transform;
		            // Get the line scale.
		            // Determinant of `m` means how much the area is enlarged by the
		            // transformation. So its square root can be used as a scale factor
		            // for width.
		            return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
		                ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
		                : 1;
		        }
		    };

		    /**
		     * 扩展一个 Path element, 比如星形，圆等。
		     * Extend a path element
		     * @param {Object} props
		     * @param {string} props.type Path type
		     * @param {Function} props.init Initialize
		     * @param {Function} props.buildPath Overwrite buildPath method
		     * @param {Object} [props.style] Extended default style config
		     * @param {Object} [props.shape] Extended default shape config
		     */
		    Path.extend = function (defaults) {
		        var Sub = function (opts) {
		            Path.call(this, opts);

		            if (defaults.style) {
		                // Extend default style
		                this.style.extendFrom(defaults.style, false);
		            }

		            // Extend default shape
		            var defaultShape = defaults.shape;
		            if (defaultShape) {
		                this.shape = this.shape || {};
		                var thisShape = this.shape;
		                for (var name in defaultShape) {
		                    if (
		                        ! thisShape.hasOwnProperty(name)
		                        && defaultShape.hasOwnProperty(name)
		                    ) {
		                        thisShape[name] = defaultShape[name];
		                    }
		                }
		            }

		            defaults.init && defaults.init.call(this, opts);
		        };

		        zrUtil.inherits(Sub, Path);

		        // FIXME 不能 extend position, rotation 等引用对象
		        for (var name in defaults) {
		            // Extending prototype values and methods
		            if (name !== 'style' && name !== 'shape') {
		                Sub.prototype[name] = defaults[name];
		            }
		        }

		        return Sub;
		    };

		    zrUtil.inherits(Path, Displayable);

		    module.exports = Path;


	/***/ },
	/* 46 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 可绘制的图形基类
		 * Base class of all displayable graphic objects
		 * @module zrender/graphic/Displayable
		 */



		    var zrUtil = __webpack_require__(4);

		    var Style = __webpack_require__(47);

		    var Element = __webpack_require__(31);
		    var RectText = __webpack_require__(48);
		    // var Stateful = require('./mixin/Stateful');

		    /**
		     * @alias module:zrender/graphic/Displayable
		     * @extends module:zrender/Element
		     * @extends module:zrender/graphic/mixin/RectText
		     */
		    function Displayable(opts) {

		        opts = opts || {};

		        Element.call(this, opts);

		        // Extend properties
		        for (var name in opts) {
		            if (
		                opts.hasOwnProperty(name) &&
		                name !== 'style'
		            ) {
		                this[name] = opts[name];
		            }
		        }

		        /**
		         * @type {module:zrender/graphic/Style}
		         */
		        this.style = new Style(opts.style);

		        this._rect = null;
		        // Shapes for cascade clipping.
		        this.__clipPaths = [];

		        // FIXME Stateful must be mixined after style is setted
		        // Stateful.call(this, opts);
		    }

		    Displayable.prototype = {

		        constructor: Displayable,

		        type: 'displayable',

		        /**
		         * Displayable 是否为脏，Painter 中会根据该标记判断是否需要是否需要重新绘制
		         * Dirty flag. From which painter will determine if this displayable object needs brush
		         * @name module:zrender/graphic/Displayable#__dirty
		         * @type {boolean}
		         */
		        __dirty: true,

		        /**
		         * 图形是否可见，为true时不绘制图形，但是仍能触发鼠标事件
		         * If ignore drawing of the displayable object. Mouse event will still be triggered
		         * @name module:/zrender/graphic/Displayable#invisible
		         * @type {boolean}
		         * @default false
		         */
		        invisible: false,

		        /**
		         * @name module:/zrender/graphic/Displayable#z
		         * @type {number}
		         * @default 0
		         */
		        z: 0,

		        /**
		         * @name module:/zrender/graphic/Displayable#z
		         * @type {number}
		         * @default 0
		         */
		        z2: 0,

		        /**
		         * z层level，决定绘画在哪层canvas中
		         * @name module:/zrender/graphic/Displayable#zlevel
		         * @type {number}
		         * @default 0
		         */
		        zlevel: 0,

		        /**
		         * 是否可拖拽
		         * @name module:/zrender/graphic/Displayable#draggable
		         * @type {boolean}
		         * @default false
		         */
		        draggable: false,

		        /**
		         * 是否正在拖拽
		         * @name module:/zrender/graphic/Displayable#draggable
		         * @type {boolean}
		         * @default false
		         */
		        dragging: false,

		        /**
		         * 是否相应鼠标事件
		         * @name module:/zrender/graphic/Displayable#silent
		         * @type {boolean}
		         * @default false
		         */
		        silent: false,

		        /**
		         * If enable culling
		         * @type {boolean}
		         * @default false
		         */
		        culling: false,

		        /**
		         * Mouse cursor when hovered
		         * @name module:/zrender/graphic/Displayable#cursor
		         * @type {string}
		         */
		        cursor: 'pointer',

		        /**
		         * If hover area is bounding rect
		         * @name module:/zrender/graphic/Displayable#rectHover
		         * @type {string}
		         */
		        rectHover: false,

		        /**
		         * Render the element progressively when the value >= 0,
		         * usefull for large data.
		         * @type {number}
		         */
		        progressive: -1,

		        beforeBrush: function (ctx) {},

		        afterBrush: function (ctx) {},

		        /**
		         * 图形绘制方法
		         * @param {Canvas2DRenderingContext} ctx
		         */
		        // Interface
		        brush: function (ctx, prevEl) {},

		        /**
		         * 获取最小包围盒
		         * @return {module:zrender/core/BoundingRect}
		         */
		        // Interface
		        getBoundingRect: function () {},

		        /**
		         * 判断坐标 x, y 是否在图形上
		         * If displayable element contain coord x, y
		         * @param  {number} x
		         * @param  {number} y
		         * @return {boolean}
		         */
		        contain: function (x, y) {
		            return this.rectContain(x, y);
		        },

		        /**
		         * @param  {Function} cb
		         * @param  {}   context
		         */
		        traverse: function (cb, context) {
		            cb.call(context, this);
		        },

		        /**
		         * 判断坐标 x, y 是否在图形的包围盒上
		         * If bounding rect of element contain coord x, y
		         * @param  {number} x
		         * @param  {number} y
		         * @return {boolean}
		         */
		        rectContain: function (x, y) {
		            var coord = this.transformCoordToLocal(x, y);
		            var rect = this.getBoundingRect();
		            return rect.contain(coord[0], coord[1]);
		        },

		        /**
		         * 标记图形元素为脏，并且在下一帧重绘
		         * Mark displayable element dirty and refresh next frame
		         */
		        dirty: function () {
		            this.__dirty = true;

		            this._rect = null;

		            this.__zr && this.__zr.refresh();
		        },

		        /**
		         * 图形是否会触发事件
		         * If displayable object binded any event
		         * @return {boolean}
		         */
		        // TODO, 通过 bind 绑定的事件
		        // isSilent: function () {
		        //     return !(
		        //         this.hoverable || this.draggable
		        //         || this.onmousemove || this.onmouseover || this.onmouseout
		        //         || this.onmousedown || this.onmouseup || this.onclick
		        //         || this.ondragenter || this.ondragover || this.ondragleave
		        //         || this.ondrop
		        //     );
		        // },
		        /**
		         * Alias for animate('style')
		         * @param {boolean} loop
		         */
		        animateStyle: function (loop) {
		            return this.animate('style', loop);
		        },

		        attrKV: function (key, value) {
		            if (key !== 'style') {
		                Element.prototype.attrKV.call(this, key, value);
		            }
		            else {
		                this.style.set(value);
		            }
		        },

		        /**
		         * @param {Object|string} key
		         * @param {*} value
		         */
		        setStyle: function (key, value) {
		            this.style.set(key, value);
		            this.dirty(false);
		            return this;
		        },

		        /**
		         * Use given style object
		         * @param  {Object} obj
		         */
		        useStyle: function (obj) {
		            this.style = new Style(obj);
		            this.dirty(false);
		            return this;
		        }
		    };

		    zrUtil.inherits(Displayable, Element);

		    zrUtil.mixin(Displayable, RectText);
		    // zrUtil.mixin(Displayable, Stateful);

		    module.exports = Displayable;


	/***/ },
	/* 47 */
	/***/ function(module, exports) {

		/**
		 * @module zrender/graphic/Style
		 */


		    var STYLE_COMMON_PROPS = [
		        ['shadowBlur', 0], ['shadowOffsetX', 0], ['shadowOffsetY', 0], ['shadowColor', '#000'],
		        ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
		    ];

		    // var SHADOW_PROPS = STYLE_COMMON_PROPS.slice(0, 4);
		    // var LINE_PROPS = STYLE_COMMON_PROPS.slice(4);

		    var Style = function (opts) {
		        this.extendFrom(opts);
		    };

		    function createLinearGradient(ctx, obj, rect) {
		        // var size =
		        var x = obj.x;
		        var x2 = obj.x2;
		        var y = obj.y;
		        var y2 = obj.y2;

		        if (!obj.global) {
		            x = x * rect.width + rect.x;
		            x2 = x2 * rect.width + rect.x;
		            y = y * rect.height + rect.y;
		            y2 = y2 * rect.height + rect.y;
		        }

		        var canvasGradient = ctx.createLinearGradient(x, y, x2, y2);

		        return canvasGradient;
		    }

		    function createRadialGradient(ctx, obj, rect) {
		        var width = rect.width;
		        var height = rect.height;
		        var min = Math.min(width, height);

		        var x = obj.x;
		        var y = obj.y;
		        var r = obj.r;
		        if (!obj.global) {
		            x = x * width + rect.x;
		            y = y * height + rect.y;
		            r = r * min;
		        }

		        var canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r);

		        return canvasGradient;
		    }


		    Style.prototype = {

		        constructor: Style,

		        /**
		         * @type {string}
		         */
		        fill: '#000000',

		        /**
		         * @type {string}
		         */
		        stroke: null,

		        /**
		         * @type {number}
		         */
		        opacity: 1,

		        /**
		         * @type {Array.<number>}
		         */
		        lineDash: null,

		        /**
		         * @type {number}
		         */
		        lineDashOffset: 0,

		        /**
		         * @type {number}
		         */
		        shadowBlur: 0,

		        /**
		         * @type {number}
		         */
		        shadowOffsetX: 0,

		        /**
		         * @type {number}
		         */
		        shadowOffsetY: 0,

		        /**
		         * @type {number}
		         */
		        lineWidth: 1,

		        /**
		         * If stroke ignore scale
		         * @type {Boolean}
		         */
		        strokeNoScale: false,

		        // Bounding rect text configuration
		        // Not affected by element transform
		        /**
		         * @type {string}
		         */
		        text: null,

		        /**
		         * @type {string}
		         */
		        textFill: '#000',

		        /**
		         * @type {string}
		         */
		        textStroke: null,

		        /**
		         * 'inside', 'left', 'right', 'top', 'bottom'
		         * [x, y]
		         * @type {string|Array.<number>}
		         * @default 'inside'
		         */
		        textPosition: 'inside',

		        /**
		         * @type {string}
		         */
		        textBaseline: null,

		        /**
		         * @type {string}
		         */
		        textAlign: null,

		        /**
		         * @type {string}
		         */
		        textVerticalAlign: null,

		        /**
		         * Only useful in Path and Image element
		         * @type {number}
		         */
		        textDistance: 5,

		        /**
		         * Only useful in Path and Image element
		         * @type {number}
		         */
		        textShadowBlur: 0,

		        /**
		         * Only useful in Path and Image element
		         * @type {number}
		         */
		        textShadowOffsetX: 0,

		        /**
		         * Only useful in Path and Image element
		         * @type {number}
		         */
		        textShadowOffsetY: 0,

		        /**
		         * If transform text
		         * Only useful in Path and Image element
		         * @type {boolean}
		         */
		        textTransform: false,

		        /**
		         * Text rotate around position of Path or Image
		         * Only useful in Path and Image element and textTransform is false.
		         */
		        textRotation: 0,

		        /**
		         * @type {string}
		         * https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
		         */
		        blend: null,

		        /**
		         * @param {CanvasRenderingContext2D} ctx
		         */
		        bind: function (ctx, el, prevEl) {
		            var style = this;
		            var prevStyle = prevEl && prevEl.style;
		            var firstDraw = !prevStyle;

		            for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
		                var prop = STYLE_COMMON_PROPS[i];
		                var styleName = prop[0];

		                if (firstDraw || style[styleName] !== prevStyle[styleName]) {
		                    // FIXME Invalid property value will cause style leak from previous element.
		                    ctx[styleName] = style[styleName] || prop[1];
		                }
		            }

		            if ((firstDraw || style.fill !== prevStyle.fill)) {
		                ctx.fillStyle = style.fill;
		            }
		            if ((firstDraw || style.stroke !== prevStyle.stroke)) {
		                ctx.strokeStyle = style.stroke;
		            }
		            if ((firstDraw || style.opacity !== prevStyle.opacity)) {
		                ctx.globalAlpha = style.opacity == null ? 1 : style.opacity;
		            }

		            if ((firstDraw || style.blend !== prevStyle.blend)) {
		                ctx.globalCompositeOperation = style.blend || 'source-over';
		            }
		            if (this.hasStroke()) {
		                var lineWidth = style.lineWidth;
		                ctx.lineWidth = lineWidth / (
		                    (this.strokeNoScale && el && el.getLineScale) ? el.getLineScale() : 1
		                );
		            }
		        },

		        hasFill: function () {
		            var fill = this.fill;
		            return fill != null && fill !== 'none';
		        },

		        hasStroke: function () {
		            var stroke = this.stroke;
		            return stroke != null && stroke !== 'none' && this.lineWidth > 0;
		        },

		        /**
		         * Extend from other style
		         * @param {zrender/graphic/Style} otherStyle
		         * @param {boolean} overwrite
		         */
		        extendFrom: function (otherStyle, overwrite) {
		            if (otherStyle) {
		                var target = this;
		                for (var name in otherStyle) {
		                    if (otherStyle.hasOwnProperty(name)
		                        && (overwrite || ! target.hasOwnProperty(name))
		                    ) {
		                        target[name] = otherStyle[name];
		                    }
		                }
		            }
		        },

		        /**
		         * Batch setting style with a given object
		         * @param {Object|string} obj
		         * @param {*} [obj]
		         */
		        set: function (obj, value) {
		            if (typeof obj === 'string') {
		                this[obj] = value;
		            }
		            else {
		                this.extendFrom(obj, true);
		            }
		        },

		        /**
		         * Clone
		         * @return {zrender/graphic/Style} [description]
		         */
		        clone: function () {
		            var newStyle = new this.constructor();
		            newStyle.extendFrom(this, true);
		            return newStyle;
		        },

		        getGradient: function (ctx, obj, rect) {
		            var method = obj.type === 'radial' ? createRadialGradient : createLinearGradient;
		            var canvasGradient = method(ctx, obj, rect);
		            var colorStops = obj.colorStops;
		            for (var i = 0; i < colorStops.length; i++) {
		                canvasGradient.addColorStop(
		                    colorStops[i].offset, colorStops[i].color
		                );
		            }
		            return canvasGradient;
		        }
		    };

		    var styleProto = Style.prototype;
		    for (var i = 0; i < STYLE_COMMON_PROPS.length; i++) {
		        var prop = STYLE_COMMON_PROPS[i];
		        if (!(prop[0] in styleProto)) {
		            styleProto[prop[0]] = prop[1];
		        }
		    }

		    // Provide for others
		    Style.getGradient = styleProto.getGradient;

		    module.exports = Style;


	/***/ },
	/* 48 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Mixin for drawing text in a element bounding rect
		 * @module zrender/mixin/RectText
		 */



		    var textContain = __webpack_require__(8);
		    var BoundingRect = __webpack_require__(9);

		    var tmpRect = new BoundingRect();

		    var RectText = function () {};

		    function parsePercent(value, maxValue) {
		        if (typeof value === 'string') {
		            if (value.lastIndexOf('%') >= 0) {
		                return parseFloat(value) / 100 * maxValue;
		            }
		            return parseFloat(value);
		        }
		        return value;
		    }

		    RectText.prototype = {

		        constructor: RectText,

		        /**
		         * Draw text in a rect with specified position.
		         * @param  {CanvasRenderingContext} ctx
		         * @param  {Object} rect Displayable rect
		         * @return {Object} textRect Alternative precalculated text bounding rect
		         */
		        drawRectText: function (ctx, rect, textRect) {
		            var style = this.style;
		            var text = style.text;
		            // Convert to string
		            text != null && (text += '');
		            if (!text) {
		                return;
		            }

		            // FIXME
		            ctx.save();

		            var x;
		            var y;
		            var textPosition = style.textPosition;
		            var distance = style.textDistance;
		            var align = style.textAlign;
		            var font = style.textFont || style.font;
		            var baseline = style.textBaseline;
		            var verticalAlign = style.textVerticalAlign;

		            textRect = textRect || textContain.getBoundingRect(text, font, align, baseline);

		            // Transform rect to view space
		            var transform = this.transform;
		            if (!style.textTransform) {
		                if (transform) {
		                    tmpRect.copy(rect);
		                    tmpRect.applyTransform(transform);
		                    rect = tmpRect;
		                }
		            }
		            else {
		                this.setTransform(ctx);
		            }

		            // Text position represented by coord
		            if (textPosition instanceof Array) {
		                // Percent
		                x = rect.x + parsePercent(textPosition[0], rect.width);
		                y = rect.y + parsePercent(textPosition[1], rect.height);
		                align = align || 'left';
		                baseline = baseline || 'top';

		                if (verticalAlign) {
		                    switch (verticalAlign) {
		                        case 'middle':
		                            y -= textRect.height / 2 - textRect.lineHeight / 2;
		                            break;
		                        case 'bottom':
		                            y -= textRect.height - textRect.lineHeight / 2;
		                            break;
		                        default:
		                            y += textRect.lineHeight / 2;
		                    }
		                    // Force bseline to be middle
		                    baseline = 'middle';
		                }
		            }
		            else {
		                var res = textContain.adjustTextPositionOnRect(
		                    textPosition, rect, textRect, distance
		                );
		                x = res.x;
		                y = res.y;
		                // Default align and baseline when has textPosition
		                align = align || res.textAlign;
		                baseline = baseline || res.textBaseline;
		            }

		            // Use canvas default left textAlign. Giving invalid value will cause state not change
		            ctx.textAlign = align || 'left';
		            // Use canvas default alphabetic baseline
		            ctx.textBaseline = baseline || 'alphabetic';

		            var textFill = style.textFill;
		            var textStroke = style.textStroke;
		            textFill && (ctx.fillStyle = textFill);
		            textStroke && (ctx.strokeStyle = textStroke);

		            // TODO Invalid font
		            ctx.font = font || '12px sans-serif';

		            // Text shadow
		            // Always set shadowBlur and shadowOffset to avoid leak from displayable
		            ctx.shadowBlur = style.textShadowBlur;
		            ctx.shadowColor = style.textShadowColor || 'transparent';
		            ctx.shadowOffsetX = style.textShadowOffsetX;
		            ctx.shadowOffsetY = style.textShadowOffsetY;

		            var textLines = text.split('\n');

		            if (style.textRotation) {
		                transform && ctx.translate(transform[4], transform[5]);
		                ctx.rotate(style.textRotation);
		                transform && ctx.translate(-transform[4], -transform[5]);
		            }

		            for (var i = 0; i < textLines.length; i++) {
		                textFill && ctx.fillText(textLines[i], x, y);
		                textStroke && ctx.strokeText(textLines[i], x, y);
		                y += textRect.lineHeight;
		            }

		            ctx.restore();
		        }
		    };

		    module.exports = RectText;


	/***/ },
	/* 49 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * Path 代理，可以在`buildPath`中用于替代`ctx`, 会保存每个path操作的命令到pathCommands属性中
		 * 可以用于 isInsidePath 判断以及获取boundingRect
		 *
		 * @module zrender/core/PathProxy
		 * @author Yi Shen (http://www.github.com/pissang)
		 */

		 // TODO getTotalLength, getPointAtLength


		    var curve = __webpack_require__(50);
		    var vec2 = __webpack_require__(10);
		    var bbox = __webpack_require__(51);
		    var BoundingRect = __webpack_require__(9);
		    var dpr = __webpack_require__(41).devicePixelRatio;

		    var CMD = {
		        M: 1,
		        L: 2,
		        C: 3,
		        Q: 4,
		        A: 5,
		        Z: 6,
		        // Rect
		        R: 7
		    };

		    var min = [];
		    var max = [];
		    var min2 = [];
		    var max2 = [];
		    var mathMin = Math.min;
		    var mathMax = Math.max;
		    var mathCos = Math.cos;
		    var mathSin = Math.sin;
		    var mathSqrt = Math.sqrt;
		    var mathAbs = Math.abs;

		    var hasTypedArray = typeof Float32Array != 'undefined';

		    /**
		     * @alias module:zrender/core/PathProxy
		     * @constructor
		     */
		    var PathProxy = function () {

		        /**
		         * Path data. Stored as flat array
		         * @type {Array.<Object>}
		         */
		        this.data = [];

		        this._len = 0;

		        this._ctx = null;

		        this._xi = 0;
		        this._yi = 0;

		        this._x0 = 0;
		        this._y0 = 0;

		        // Unit x, Unit y. Provide for avoiding drawing that too short line segment
		        this._ux = 0;
		        this._uy = 0;
		    };

		    /**
		     * 快速计算Path包围盒（并不是最小包围盒）
		     * @return {Object}
		     */
		    PathProxy.prototype = {

		        constructor: PathProxy,

		        _lineDash: null,

		        _dashOffset: 0,

		        _dashIdx: 0,

		        _dashSum: 0,

		        /**
		         * @readOnly
		         */
		        setScale: function (sx, sy) {
		            this._ux = mathAbs(1 / dpr / sx) || 0;
		            this._uy = mathAbs(1 / dpr / sy) || 0;
		        },

		        getContext: function () {
		            return this._ctx;
		        },

		        /**
		         * @param  {CanvasRenderingContext2D} ctx
		         * @return {module:zrender/core/PathProxy}
		         */
		        beginPath: function (ctx) {

		            this._ctx = ctx;

		            ctx && ctx.beginPath();

		            ctx && (this.dpr = ctx.dpr);

		            // Reset
		            this._len = 0;

		            if (this._lineDash) {
		                this._lineDash = null;

		                this._dashOffset = 0;
		            }

		            return this;
		        },

		        /**
		         * @param  {number} x
		         * @param  {number} y
		         * @return {module:zrender/core/PathProxy}
		         */
		        moveTo: function (x, y) {
		            this.addData(CMD.M, x, y);
		            this._ctx && this._ctx.moveTo(x, y);

		            // x0, y0, xi, yi 是记录在 _dashedXXXXTo 方法中使用
		            // xi, yi 记录当前点, x0, y0 在 closePath 的时候回到起始点。
		            // 有可能在 beginPath 之后直接调用 lineTo，这时候 x0, y0 需要
		            // 在 lineTo 方法中记录，这里先不考虑这种情况，dashed line 也只在 IE10- 中不支持
		            this._x0 = x;
		            this._y0 = y;

		            this._xi = x;
		            this._yi = y;

		            return this;
		        },

		        /**
		         * @param  {number} x
		         * @param  {number} y
		         * @return {module:zrender/core/PathProxy}
		         */
		        lineTo: function (x, y) {
		            var exceedUnit = mathAbs(x - this._xi) > this._ux
		                || mathAbs(y - this._yi) > this._uy
		                // Force draw the first segment
		                || this._len < 5;

		            this.addData(CMD.L, x, y);

		            if (this._ctx && exceedUnit) {
		                this._needsDash() ? this._dashedLineTo(x, y)
		                    : this._ctx.lineTo(x, y);
		            }
		            if (exceedUnit) {
		                this._xi = x;
		                this._yi = y;
		            }

		            return this;
		        },

		        /**
		         * @param  {number} x1
		         * @param  {number} y1
		         * @param  {number} x2
		         * @param  {number} y2
		         * @param  {number} x3
		         * @param  {number} y3
		         * @return {module:zrender/core/PathProxy}
		         */
		        bezierCurveTo: function (x1, y1, x2, y2, x3, y3) {
		            this.addData(CMD.C, x1, y1, x2, y2, x3, y3);
		            if (this._ctx) {
		                this._needsDash() ? this._dashedBezierTo(x1, y1, x2, y2, x3, y3)
		                    : this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3);
		            }
		            this._xi = x3;
		            this._yi = y3;
		            return this;
		        },

		        /**
		         * @param  {number} x1
		         * @param  {number} y1
		         * @param  {number} x2
		         * @param  {number} y2
		         * @return {module:zrender/core/PathProxy}
		         */
		        quadraticCurveTo: function (x1, y1, x2, y2) {
		            this.addData(CMD.Q, x1, y1, x2, y2);
		            if (this._ctx) {
		                this._needsDash() ? this._dashedQuadraticTo(x1, y1, x2, y2)
		                    : this._ctx.quadraticCurveTo(x1, y1, x2, y2);
		            }
		            this._xi = x2;
		            this._yi = y2;
		            return this;
		        },

		        /**
		         * @param  {number} cx
		         * @param  {number} cy
		         * @param  {number} r
		         * @param  {number} startAngle
		         * @param  {number} endAngle
		         * @param  {boolean} anticlockwise
		         * @return {module:zrender/core/PathProxy}
		         */
		        arc: function (cx, cy, r, startAngle, endAngle, anticlockwise) {
		            this.addData(
		                CMD.A, cx, cy, r, r, startAngle, endAngle - startAngle, 0, anticlockwise ? 0 : 1
		            );
		            this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise);

		            this._xi = mathCos(endAngle) * r + cx;
		            this._xi = mathSin(endAngle) * r + cx;
		            return this;
		        },

		        // TODO
		        arcTo: function (x1, y1, x2, y2, radius) {
		            if (this._ctx) {
		                this._ctx.arcTo(x1, y1, x2, y2, radius);
		            }
		            return this;
		        },

		        // TODO
		        rect: function (x, y, w, h) {
		            this._ctx && this._ctx.rect(x, y, w, h);
		            this.addData(CMD.R, x, y, w, h);
		            return this;
		        },

		        /**
		         * @return {module:zrender/core/PathProxy}
		         */
		        closePath: function () {
		            this.addData(CMD.Z);

		            var ctx = this._ctx;
		            var x0 = this._x0;
		            var y0 = this._y0;
		            if (ctx) {
		                this._needsDash() && this._dashedLineTo(x0, y0);
		                ctx.closePath();
		            }

		            this._xi = x0;
		            this._yi = y0;
		            return this;
		        },

		        /**
		         * Context 从外部传入，因为有可能是 rebuildPath 完之后再 fill。
		         * stroke 同样
		         * @param {CanvasRenderingContext2D} ctx
		         * @return {module:zrender/core/PathProxy}
		         */
		        fill: function (ctx) {
		            ctx && ctx.fill();
		            this.toStatic();
		        },

		        /**
		         * @param {CanvasRenderingContext2D} ctx
		         * @return {module:zrender/core/PathProxy}
		         */
		        stroke: function (ctx) {
		            ctx && ctx.stroke();
		            this.toStatic();
		        },

		        /**
		         * 必须在其它绘制命令前调用
		         * Must be invoked before all other path drawing methods
		         * @return {module:zrender/core/PathProxy}
		         */
		        setLineDash: function (lineDash) {
		            if (lineDash instanceof Array) {
		                this._lineDash = lineDash;

		                this._dashIdx = 0;

		                var lineDashSum = 0;
		                for (var i = 0; i < lineDash.length; i++) {
		                    lineDashSum += lineDash[i];
		                }
		                this._dashSum = lineDashSum;
		            }
		            return this;
		        },

		        /**
		         * 必须在其它绘制命令前调用
		         * Must be invoked before all other path drawing methods
		         * @return {module:zrender/core/PathProxy}
		         */
		        setLineDashOffset: function (offset) {
		            this._dashOffset = offset;
		            return this;
		        },

		        /**
		         *
		         * @return {boolean}
		         */
		        len: function () {
		            return this._len;
		        },

		        /**
		         * 直接设置 Path 数据
		         */
		        setData: function (data) {

		            var len = data.length;

		            if (! (this.data && this.data.length == len) && hasTypedArray) {
		                this.data = new Float32Array(len);
		            }

		            for (var i = 0; i < len; i++) {
		                this.data[i] = data[i];
		            }

		            this._len = len;
		        },

		        /**
		         * 添加子路径
		         * @param {module:zrender/core/PathProxy|Array.<module:zrender/core/PathProxy>} path
		         */
		        appendPath: function (path) {
		            if (!(path instanceof Array)) {
		                path = [path];
		            }
		            var len = path.length;
		            var appendSize = 0;
		            var offset = this._len;
		            for (var i = 0; i < len; i++) {
		                appendSize += path[i].len();
		            }
		            if (hasTypedArray && (this.data instanceof Float32Array)) {
		                this.data = new Float32Array(offset + appendSize);
		            }
		            for (var i = 0; i < len; i++) {
		                var appendPathData = path[i].data;
		                for (var k = 0; k < appendPathData.length; k++) {
		                    this.data[offset++] = appendPathData[k];
		                }
		            }
		            this._len = offset;
		        },

		        /**
		         * 填充 Path 数据。
		         * 尽量复用而不申明新的数组。大部分图形重绘的指令数据长度都是不变的。
		         */
		        addData: function (cmd) {
		            var data = this.data;
		            if (this._len + arguments.length > data.length) {
		                // 因为之前的数组已经转换成静态的 Float32Array
		                // 所以不够用时需要扩展一个新的动态数组
		                this._expandData();
		                data = this.data;
		            }
		            for (var i = 0; i < arguments.length; i++) {
		                data[this._len++] = arguments[i];
		            }

		            this._prevCmd = cmd;
		        },

		        _expandData: function () {
		            // Only if data is Float32Array
		            if (!(this.data instanceof Array)) {
		                var newData = [];
		                for (var i = 0; i < this._len; i++) {
		                    newData[i] = this.data[i];
		                }
		                this.data = newData;
		            }
		        },

		        /**
		         * If needs js implemented dashed line
		         * @return {boolean}
		         * @private
		         */
		        _needsDash: function () {
		            return this._lineDash;
		        },

		        _dashedLineTo: function (x1, y1) {
		            var dashSum = this._dashSum;
		            var offset = this._dashOffset;
		            var lineDash = this._lineDash;
		            var ctx = this._ctx;

		            var x0 = this._xi;
		            var y0 = this._yi;
		            var dx = x1 - x0;
		            var dy = y1 - y0;
		            var dist = mathSqrt(dx * dx + dy * dy);
		            var x = x0;
		            var y = y0;
		            var dash;
		            var nDash = lineDash.length;
		            var idx;
		            dx /= dist;
		            dy /= dist;

		            if (offset < 0) {
		                // Convert to positive offset
		                offset = dashSum + offset;
		            }
		            offset %= dashSum;
		            x -= offset * dx;
		            y -= offset * dy;

		            while ((dx > 0 && x <= x1) || (dx < 0 && x >= x1)
		            || (dx == 0 && ((dy > 0 && y <= y1) || (dy < 0 && y >= y1)))) {
		                idx = this._dashIdx;
		                dash = lineDash[idx];
		                x += dx * dash;
		                y += dy * dash;
		                this._dashIdx = (idx + 1) % nDash;
		                // Skip positive offset
		                if ((dx > 0 && x < x0) || (dx < 0 && x > x0) || (dy > 0 && y < y0) || (dy < 0 && y > y0)) {
		                    continue;
		                }
		                ctx[idx % 2 ? 'moveTo' : 'lineTo'](
		                    dx >= 0 ? mathMin(x, x1) : mathMax(x, x1),
		                    dy >= 0 ? mathMin(y, y1) : mathMax(y, y1)
		                );
		            }
		            // Offset for next lineTo
		            dx = x - x1;
		            dy = y - y1;
		            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
		        },

		        // Not accurate dashed line to
		        _dashedBezierTo: function (x1, y1, x2, y2, x3, y3) {
		            var dashSum = this._dashSum;
		            var offset = this._dashOffset;
		            var lineDash = this._lineDash;
		            var ctx = this._ctx;

		            var x0 = this._xi;
		            var y0 = this._yi;
		            var t;
		            var dx;
		            var dy;
		            var cubicAt = curve.cubicAt;
		            var bezierLen = 0;
		            var idx = this._dashIdx;
		            var nDash = lineDash.length;

		            var x;
		            var y;

		            var tmpLen = 0;

		            if (offset < 0) {
		                // Convert to positive offset
		                offset = dashSum + offset;
		            }
		            offset %= dashSum;
		            // Bezier approx length
		            for (t = 0; t < 1; t += 0.1) {
		                dx = cubicAt(x0, x1, x2, x3, t + 0.1)
		                    - cubicAt(x0, x1, x2, x3, t);
		                dy = cubicAt(y0, y1, y2, y3, t + 0.1)
		                    - cubicAt(y0, y1, y2, y3, t);
		                bezierLen += mathSqrt(dx * dx + dy * dy);
		            }

		            // Find idx after add offset
		            for (; idx < nDash; idx++) {
		                tmpLen += lineDash[idx];
		                if (tmpLen > offset) {
		                    break;
		                }
		            }
		            t = (tmpLen - offset) / bezierLen;

		            while (t <= 1) {

		                x = cubicAt(x0, x1, x2, x3, t);
		                y = cubicAt(y0, y1, y2, y3, t);

		                // Use line to approximate dashed bezier
		                // Bad result if dash is long
		                idx % 2 ? ctx.moveTo(x, y)
		                    : ctx.lineTo(x, y);

		                t += lineDash[idx] / bezierLen;

		                idx = (idx + 1) % nDash;
		            }

		            // Finish the last segment and calculate the new offset
		            (idx % 2 !== 0) && ctx.lineTo(x3, y3);
		            dx = x3 - x;
		            dy = y3 - y;
		            this._dashOffset = -mathSqrt(dx * dx + dy * dy);
		        },

		        _dashedQuadraticTo: function (x1, y1, x2, y2) {
		            // Convert quadratic to cubic using degree elevation
		            var x3 = x2;
		            var y3 = y2;
		            x2 = (x2 + 2 * x1) / 3;
		            y2 = (y2 + 2 * y1) / 3;
		            x1 = (this._xi + 2 * x1) / 3;
		            y1 = (this._yi + 2 * y1) / 3;

		            this._dashedBezierTo(x1, y1, x2, y2, x3, y3);
		        },

		        /**
		         * 转成静态的 Float32Array 减少堆内存占用
		         * Convert dynamic array to static Float32Array
		         */
		        toStatic: function () {
		            var data = this.data;
		            if (data instanceof Array) {
		                data.length = this._len;
		                if (hasTypedArray) {
		                    this.data = new Float32Array(data);
		                }
		            }
		        },

		        /**
		         * @return {module:zrender/core/BoundingRect}
		         */
		        getBoundingRect: function () {
		            min[0] = min[1] = min2[0] = min2[1] = Number.MAX_VALUE;
		            max[0] = max[1] = max2[0] = max2[1] = -Number.MAX_VALUE;

		            var data = this.data;
		            var xi = 0;
		            var yi = 0;
		            var x0 = 0;
		            var y0 = 0;

		            for (var i = 0; i < data.length;) {
		                var cmd = data[i++];

		                if (i == 1) {
		                    // 如果第一个命令是 L, C, Q
		                    // 则 previous point 同绘制命令的第一个 point
		                    //
		                    // 第一个命令为 Arc 的情况下会在后面特殊处理
		                    xi = data[i];
		                    yi = data[i + 1];

		                    x0 = xi;
		                    y0 = yi;
		                }

		                switch (cmd) {
		                    case CMD.M:
		                        // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
		                        // 在 closePath 的时候使用
		                        x0 = data[i++];
		                        y0 = data[i++];
		                        xi = x0;
		                        yi = y0;
		                        min2[0] = x0;
		                        min2[1] = y0;
		                        max2[0] = x0;
		                        max2[1] = y0;
		                        break;
		                    case CMD.L:
		                        bbox.fromLine(xi, yi, data[i], data[i + 1], min2, max2);
		                        xi = data[i++];
		                        yi = data[i++];
		                        break;
		                    case CMD.C:
		                        bbox.fromCubic(
		                            xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
		                            min2, max2
		                        );
		                        xi = data[i++];
		                        yi = data[i++];
		                        break;
		                    case CMD.Q:
		                        bbox.fromQuadratic(
		                            xi, yi, data[i++], data[i++], data[i], data[i + 1],
		                            min2, max2
		                        );
		                        xi = data[i++];
		                        yi = data[i++];
		                        break;
		                    case CMD.A:
		                        // TODO Arc 判断的开销比较大
		                        var cx = data[i++];
		                        var cy = data[i++];
		                        var rx = data[i++];
		                        var ry = data[i++];
		                        var startAngle = data[i++];
		                        var endAngle = data[i++] + startAngle;
		                        // TODO Arc 旋转
		                        var psi = data[i++];
		                        var anticlockwise = 1 - data[i++];

		                        if (i == 1) {
		                            // 直接使用 arc 命令
		                            // 第一个命令起点还未定义
		                            x0 = mathCos(startAngle) * rx + cx;
		                            y0 = mathSin(startAngle) * ry + cy;
		                        }

		                        bbox.fromArc(
		                            cx, cy, rx, ry, startAngle, endAngle,
		                            anticlockwise, min2, max2
		                        );

		                        xi = mathCos(endAngle) * rx + cx;
		                        yi = mathSin(endAngle) * ry + cy;
		                        break;
		                    case CMD.R:
		                        x0 = xi = data[i++];
		                        y0 = yi = data[i++];
		                        var width = data[i++];
		                        var height = data[i++];
		                        // Use fromLine
		                        bbox.fromLine(x0, y0, x0 + width, y0 + height, min2, max2);
		                        break;
		                    case CMD.Z:
		                        xi = x0;
		                        yi = y0;
		                        break;
		                }

		                // Union
		                vec2.min(min, min, min2);
		                vec2.max(max, max, max2);
		            }

		            // No data
		            if (i === 0) {
		                min[0] = min[1] = max[0] = max[1] = 0;
		            }

		            return new BoundingRect(
		                min[0], min[1], max[0] - min[0], max[1] - min[1]
		            );
		        },

		        /**
		         * Rebuild path from current data
		         * Rebuild path will not consider javascript implemented line dash.
		         * @param {CanvasRenderingContext} ctx
		         */
		        rebuildPath: function (ctx) {
		            var d = this.data;
		            var x0, y0;
		            var xi, yi;
		            var x, y;
		            var ux = this._ux;
		            var uy = this._uy;
		            var len = this._len;
		            for (var i = 0; i < len;) {
		                var cmd = d[i++];

		                if (i == 1) {
		                    // 如果第一个命令是 L, C, Q
		                    // 则 previous point 同绘制命令的第一个 point
		                    //
		                    // 第一个命令为 Arc 的情况下会在后面特殊处理
		                    xi = d[i];
		                    yi = d[i + 1];

		                    x0 = xi;
		                    y0 = yi;
		                }
		                switch (cmd) {
		                    case CMD.M:
		                        x0 = xi = d[i++];
		                        y0 = yi = d[i++];
		                        ctx.moveTo(xi, yi);
		                        break;
		                    case CMD.L:
		                        x = d[i++];
		                        y = d[i++];
		                        // Not draw too small seg between
		                        if (mathAbs(x - xi) > ux || mathAbs(y - yi) > uy || i === len - 1) {
		                            ctx.lineTo(x, y);
		                            xi = x;
		                            yi = y;
		                        }
		                        break;
		                    case CMD.C:
		                        ctx.bezierCurveTo(
		                            d[i++], d[i++], d[i++], d[i++], d[i++], d[i++]
		                        );
		                        xi = d[i - 2];
		                        yi = d[i - 1];
		                        break;
		                    case CMD.Q:
		                        ctx.quadraticCurveTo(d[i++], d[i++], d[i++], d[i++]);
		                        xi = d[i - 2];
		                        yi = d[i - 1];
		                        break;
		                    case CMD.A:
		                        var cx = d[i++];
		                        var cy = d[i++];
		                        var rx = d[i++];
		                        var ry = d[i++];
		                        var theta = d[i++];
		                        var dTheta = d[i++];
		                        var psi = d[i++];
		                        var fs = d[i++];
		                        var r = (rx > ry) ? rx : ry;
		                        var scaleX = (rx > ry) ? 1 : rx / ry;
		                        var scaleY = (rx > ry) ? ry / rx : 1;
		                        var isEllipse = Math.abs(rx - ry) > 1e-3;
		                        var endAngle = theta + dTheta;
		                        if (isEllipse) {
		                            ctx.translate(cx, cy);
		                            ctx.rotate(psi);
		                            ctx.scale(scaleX, scaleY);
		                            ctx.arc(0, 0, r, theta, endAngle, 1 - fs);
		                            ctx.scale(1 / scaleX, 1 / scaleY);
		                            ctx.rotate(-psi);
		                            ctx.translate(-cx, -cy);
		                        }
		                        else {
		                            ctx.arc(cx, cy, r, theta, endAngle, 1 - fs);
		                        }

		                        if (i == 1) {
		                            // 直接使用 arc 命令
		                            // 第一个命令起点还未定义
		                            x0 = mathCos(theta) * rx + cx;
		                            y0 = mathSin(theta) * ry + cy;
		                        }
		                        xi = mathCos(endAngle) * rx + cx;
		                        yi = mathSin(endAngle) * ry + cy;
		                        break;
		                    case CMD.R:
		                        x0 = xi = d[i];
		                        y0 = yi = d[i + 1];
		                        ctx.rect(d[i++], d[i++], d[i++], d[i++]);
		                        break;
		                    case CMD.Z:
		                        ctx.closePath();
		                        xi = x0;
		                        yi = y0;
		                }
		            }
		        }
		    };

		    PathProxy.CMD = CMD;

		    module.exports = PathProxy;


	/***/ },
	/* 50 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * 曲线辅助模块
		 * @module zrender/core/curve
		 * @author pissang(https://www.github.com/pissang)
		 */


		    var vec2 = __webpack_require__(10);
		    var v2Create = vec2.create;
		    var v2DistSquare = vec2.distSquare;
		    var mathPow = Math.pow;
		    var mathSqrt = Math.sqrt;

		    var EPSILON = 1e-8;
		    var EPSILON_NUMERIC = 1e-4;

		    var THREE_SQRT = mathSqrt(3);
		    var ONE_THIRD = 1 / 3;

		    // 临时变量
		    var _v0 = v2Create();
		    var _v1 = v2Create();
		    var _v2 = v2Create();
		    // var _v3 = vec2.create();

		    function isAroundZero(val) {
		        return val > -EPSILON && val < EPSILON;
		    }
		    function isNotAroundZero(val) {
		        return val > EPSILON || val < -EPSILON;
		    }
		    /**
		     * 计算三次贝塞尔值
		     * @memberOf module:zrender/core/curve
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} p3
		     * @param  {number} t
		     * @return {number}
		     */
		    function cubicAt(p0, p1, p2, p3, t) {
		        var onet = 1 - t;
		        return onet * onet * (onet * p0 + 3 * t * p1)
		             + t * t * (t * p3 + 3 * onet * p2);
		    }

		    /**
		     * 计算三次贝塞尔导数值
		     * @memberOf module:zrender/core/curve
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} p3
		     * @param  {number} t
		     * @return {number}
		     */
		    function cubicDerivativeAt(p0, p1, p2, p3, t) {
		        var onet = 1 - t;
		        return 3 * (
		            ((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet
		            + (p3 - p2) * t * t
		        );
		    }

		    /**
		     * 计算三次贝塞尔方程根，使用盛金公式
		     * @memberOf module:zrender/core/curve
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} p3
		     * @param  {number} val
		     * @param  {Array.<number>} roots
		     * @return {number} 有效根数目
		     */
		    function cubicRootAt(p0, p1, p2, p3, val, roots) {
		        // Evaluate roots of cubic functions
		        var a = p3 + 3 * (p1 - p2) - p0;
		        var b = 3 * (p2 - p1 * 2 + p0);
		        var c = 3 * (p1  - p0);
		        var d = p0 - val;

		        var A = b * b - 3 * a * c;
		        var B = b * c - 9 * a * d;
		        var C = c * c - 3 * b * d;

		        var n = 0;

		        if (isAroundZero(A) && isAroundZero(B)) {
		            if (isAroundZero(b)) {
		                roots[0] = 0;
		            }
		            else {
		                var t1 = -c / b;  //t1, t2, t3, b is not zero
		                if (t1 >= 0 && t1 <= 1) {
		                    roots[n++] = t1;
		                }
		            }
		        }
		        else {
		            var disc = B * B - 4 * A * C;

		            if (isAroundZero(disc)) {
		                var K = B / A;
		                var t1 = -b / a + K;  // t1, a is not zero
		                var t2 = -K / 2;  // t2, t3
		                if (t1 >= 0 && t1 <= 1) {
		                    roots[n++] = t1;
		                }
		                if (t2 >= 0 && t2 <= 1) {
		                    roots[n++] = t2;
		                }
		            }
		            else if (disc > 0) {
		                var discSqrt = mathSqrt(disc);
		                var Y1 = A * b + 1.5 * a * (-B + discSqrt);
		                var Y2 = A * b + 1.5 * a * (-B - discSqrt);
		                if (Y1 < 0) {
		                    Y1 = -mathPow(-Y1, ONE_THIRD);
		                }
		                else {
		                    Y1 = mathPow(Y1, ONE_THIRD);
		                }
		                if (Y2 < 0) {
		                    Y2 = -mathPow(-Y2, ONE_THIRD);
		                }
		                else {
		                    Y2 = mathPow(Y2, ONE_THIRD);
		                }
		                var t1 = (-b - (Y1 + Y2)) / (3 * a);
		                if (t1 >= 0 && t1 <= 1) {
		                    roots[n++] = t1;
		                }
		            }
		            else {
		                var T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A));
		                var theta = Math.acos(T) / 3;
		                var ASqrt = mathSqrt(A);
		                var tmp = Math.cos(theta);

		                var t1 = (-b - 2 * ASqrt * tmp) / (3 * a);
		                var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a);
		                var t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a);
		                if (t1 >= 0 && t1 <= 1) {
		                    roots[n++] = t1;
		                }
		                if (t2 >= 0 && t2 <= 1) {
		                    roots[n++] = t2;
		                }
		                if (t3 >= 0 && t3 <= 1) {
		                    roots[n++] = t3;
		                }
		            }
		        }
		        return n;
		    }

		    /**
		     * 计算三次贝塞尔方程极限值的位置
		     * @memberOf module:zrender/core/curve
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} p3
		     * @param  {Array.<number>} extrema
		     * @return {number} 有效数目
		     */
		    function cubicExtrema(p0, p1, p2, p3, extrema) {
		        var b = 6 * p2 - 12 * p1 + 6 * p0;
		        var a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2;
		        var c = 3 * p1 - 3 * p0;

		        var n = 0;
		        if (isAroundZero(a)) {
		            if (isNotAroundZero(b)) {
		                var t1 = -c / b;
		                if (t1 >= 0 && t1 <=1) {
		                    extrema[n++] = t1;
		                }
		            }
		        }
		        else {
		            var disc = b * b - 4 * a * c;
		            if (isAroundZero(disc)) {
		                extrema[0] = -b / (2 * a);
		            }
		            else if (disc > 0) {
		                var discSqrt = mathSqrt(disc);
		                var t1 = (-b + discSqrt) / (2 * a);
		                var t2 = (-b - discSqrt) / (2 * a);
		                if (t1 >= 0 && t1 <= 1) {
		                    extrema[n++] = t1;
		                }
		                if (t2 >= 0 && t2 <= 1) {
		                    extrema[n++] = t2;
		                }
		            }
		        }
		        return n;
		    }

		    /**
		     * 细分三次贝塞尔曲线
		     * @memberOf module:zrender/core/curve
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} p3
		     * @param  {number} t
		     * @param  {Array.<number>} out
		     */
		    function cubicSubdivide(p0, p1, p2, p3, t, out) {
		        var p01 = (p1 - p0) * t + p0;
		        var p12 = (p2 - p1) * t + p1;
		        var p23 = (p3 - p2) * t + p2;

		        var p012 = (p12 - p01) * t + p01;
		        var p123 = (p23 - p12) * t + p12;

		        var p0123 = (p123 - p012) * t + p012;
		        // Seg0
		        out[0] = p0;
		        out[1] = p01;
		        out[2] = p012;
		        out[3] = p0123;
		        // Seg1
		        out[4] = p0123;
		        out[5] = p123;
		        out[6] = p23;
		        out[7] = p3;
		    }

		    /**
		     * 投射点到三次贝塞尔曲线上，返回投射距离。
		     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
		     * @param {number} x0
		     * @param {number} y0
		     * @param {number} x1
		     * @param {number} y1
		     * @param {number} x2
		     * @param {number} y2
		     * @param {number} x3
		     * @param {number} y3
		     * @param {number} x
		     * @param {number} y
		     * @param {Array.<number>} [out] 投射点
		     * @return {number}
		     */
		    function cubicProjectPoint(
		        x0, y0, x1, y1, x2, y2, x3, y3,
		        x, y, out
		    ) {
		        // http://pomax.github.io/bezierinfo/#projections
		        var t;
		        var interval = 0.005;
		        var d = Infinity;
		        var prev;
		        var next;
		        var d1;
		        var d2;

		        _v0[0] = x;
		        _v0[1] = y;

		        // 先粗略估计一下可能的最小距离的 t 值
		        // PENDING
		        for (var _t = 0; _t < 1; _t += 0.05) {
		            _v1[0] = cubicAt(x0, x1, x2, x3, _t);
		            _v1[1] = cubicAt(y0, y1, y2, y3, _t);
		            d1 = v2DistSquare(_v0, _v1);
		            if (d1 < d) {
		                t = _t;
		                d = d1;
		            }
		        }
		        d = Infinity;

		        // At most 32 iteration
		        for (var i = 0; i < 32; i++) {
		            if (interval < EPSILON_NUMERIC) {
		                break;
		            }
		            prev = t - interval;
		            next = t + interval;
		            // t - interval
		            _v1[0] = cubicAt(x0, x1, x2, x3, prev);
		            _v1[1] = cubicAt(y0, y1, y2, y3, prev);

		            d1 = v2DistSquare(_v1, _v0);

		            if (prev >= 0 && d1 < d) {
		                t = prev;
		                d = d1;
		            }
		            else {
		                // t + interval
		                _v2[0] = cubicAt(x0, x1, x2, x3, next);
		                _v2[1] = cubicAt(y0, y1, y2, y3, next);
		                d2 = v2DistSquare(_v2, _v0);

		                if (next <= 1 && d2 < d) {
		                    t = next;
		                    d = d2;
		                }
		                else {
		                    interval *= 0.5;
		                }
		            }
		        }
		        // t
		        if (out) {
		            out[0] = cubicAt(x0, x1, x2, x3, t);
		            out[1] = cubicAt(y0, y1, y2, y3, t);
		        }
		        // console.log(interval, i);
		        return mathSqrt(d);
		    }

		    /**
		     * 计算二次方贝塞尔值
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} t
		     * @return {number}
		     */
		    function quadraticAt(p0, p1, p2, t) {
		        var onet = 1 - t;
		        return onet * (onet * p0 + 2 * t * p1) + t * t * p2;
		    }

		    /**
		     * 计算二次方贝塞尔导数值
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} t
		     * @return {number}
		     */
		    function quadraticDerivativeAt(p0, p1, p2, t) {
		        return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1));
		    }

		    /**
		     * 计算二次方贝塞尔方程根
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} t
		     * @param  {Array.<number>} roots
		     * @return {number} 有效根数目
		     */
		    function quadraticRootAt(p0, p1, p2, val, roots) {
		        var a = p0 - 2 * p1 + p2;
		        var b = 2 * (p1 - p0);
		        var c = p0 - val;

		        var n = 0;
		        if (isAroundZero(a)) {
		            if (isNotAroundZero(b)) {
		                var t1 = -c / b;
		                if (t1 >= 0 && t1 <= 1) {
		                    roots[n++] = t1;
		                }
		            }
		        }
		        else {
		            var disc = b * b - 4 * a * c;
		            if (isAroundZero(disc)) {
		                var t1 = -b / (2 * a);
		                if (t1 >= 0 && t1 <= 1) {
		                    roots[n++] = t1;
		                }
		            }
		            else if (disc > 0) {
		                var discSqrt = mathSqrt(disc);
		                var t1 = (-b + discSqrt) / (2 * a);
		                var t2 = (-b - discSqrt) / (2 * a);
		                if (t1 >= 0 && t1 <= 1) {
		                    roots[n++] = t1;
		                }
		                if (t2 >= 0 && t2 <= 1) {
		                    roots[n++] = t2;
		                }
		            }
		        }
		        return n;
		    }

		    /**
		     * 计算二次贝塞尔方程极限值
		     * @memberOf module:zrender/core/curve
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @return {number}
		     */
		    function quadraticExtremum(p0, p1, p2) {
		        var divider = p0 + p2 - 2 * p1;
		        if (divider === 0) {
		            // p1 is center of p0 and p2
		            return 0.5;
		        }
		        else {
		            return (p0 - p1) / divider;
		        }
		    }

		    /**
		     * 细分二次贝塞尔曲线
		     * @memberOf module:zrender/core/curve
		     * @param  {number} p0
		     * @param  {number} p1
		     * @param  {number} p2
		     * @param  {number} t
		     * @param  {Array.<number>} out
		     */
		    function quadraticSubdivide(p0, p1, p2, t, out) {
		        var p01 = (p1 - p0) * t + p0;
		        var p12 = (p2 - p1) * t + p1;
		        var p012 = (p12 - p01) * t + p01;

		        // Seg0
		        out[0] = p0;
		        out[1] = p01;
		        out[2] = p012;

		        // Seg1
		        out[3] = p012;
		        out[4] = p12;
		        out[5] = p2;
		    }

		    /**
		     * 投射点到二次贝塞尔曲线上，返回投射距离。
		     * 投射点有可能会有一个或者多个，这里只返回其中距离最短的一个。
		     * @param {number} x0
		     * @param {number} y0
		     * @param {number} x1
		     * @param {number} y1
		     * @param {number} x2
		     * @param {number} y2
		     * @param {number} x
		     * @param {number} y
		     * @param {Array.<number>} out 投射点
		     * @return {number}
		     */
		    function quadraticProjectPoint(
		        x0, y0, x1, y1, x2, y2,
		        x, y, out
		    ) {
		        // http://pomax.github.io/bezierinfo/#projections
		        var t;
		        var interval = 0.005;
		        var d = Infinity;

		        _v0[0] = x;
		        _v0[1] = y;

		        // 先粗略估计一下可能的最小距离的 t 值
		        // PENDING
		        for (var _t = 0; _t < 1; _t += 0.05) {
		            _v1[0] = quadraticAt(x0, x1, x2, _t);
		            _v1[1] = quadraticAt(y0, y1, y2, _t);
		            var d1 = v2DistSquare(_v0, _v1);
		            if (d1 < d) {
		                t = _t;
		                d = d1;
		            }
		        }
		        d = Infinity;

		        // At most 32 iteration
		        for (var i = 0; i < 32; i++) {
		            if (interval < EPSILON_NUMERIC) {
		                break;
		            }
		            var prev = t - interval;
		            var next = t + interval;
		            // t - interval
		            _v1[0] = quadraticAt(x0, x1, x2, prev);
		            _v1[1] = quadraticAt(y0, y1, y2, prev);

		            var d1 = v2DistSquare(_v1, _v0);

		            if (prev >= 0 && d1 < d) {
		                t = prev;
		                d = d1;
		            }
		            else {
		                // t + interval
		                _v2[0] = quadraticAt(x0, x1, x2, next);
		                _v2[1] = quadraticAt(y0, y1, y2, next);
		                var d2 = v2DistSquare(_v2, _v0);
		                if (next <= 1 && d2 < d) {
		                    t = next;
		                    d = d2;
		                }
		                else {
		                    interval *= 0.5;
		                }
		            }
		        }
		        // t
		        if (out) {
		            out[0] = quadraticAt(x0, x1, x2, t);
		            out[1] = quadraticAt(y0, y1, y2, t);
		        }
		        // console.log(interval, i);
		        return mathSqrt(d);
		    }

		    module.exports = {

		        cubicAt: cubicAt,

		        cubicDerivativeAt: cubicDerivativeAt,

		        cubicRootAt: cubicRootAt,

		        cubicExtrema: cubicExtrema,

		        cubicSubdivide: cubicSubdivide,

		        cubicProjectPoint: cubicProjectPoint,

		        quadraticAt: quadraticAt,

		        quadraticDerivativeAt: quadraticDerivativeAt,

		        quadraticRootAt: quadraticRootAt,

		        quadraticExtremum: quadraticExtremum,

		        quadraticSubdivide: quadraticSubdivide,

		        quadraticProjectPoint: quadraticProjectPoint
		    };


	/***/ },
	/* 51 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @author Yi Shen(https://github.com/pissang)
		 */


		    var vec2 = __webpack_require__(10);
		    var curve = __webpack_require__(50);

		    var bbox = {};
		    var mathMin = Math.min;
		    var mathMax = Math.max;
		    var mathSin = Math.sin;
		    var mathCos = Math.cos;

		    var start = vec2.create();
		    var end = vec2.create();
		    var extremity = vec2.create();

		    var PI2 = Math.PI * 2;
		    /**
		     * 从顶点数组中计算出最小包围盒，写入`min`和`max`中
		     * @module zrender/core/bbox
		     * @param {Array<Object>} points 顶点数组
		     * @param {number} min
		     * @param {number} max
		     */
		    bbox.fromPoints = function(points, min, max) {
		        if (points.length === 0) {
		            return;
		        }
		        var p = points[0];
		        var left = p[0];
		        var right = p[0];
		        var top = p[1];
		        var bottom = p[1];
		        var i;

		        for (i = 1; i < points.length; i++) {
		            p = points[i];
		            left = mathMin(left, p[0]);
		            right = mathMax(right, p[0]);
		            top = mathMin(top, p[1]);
		            bottom = mathMax(bottom, p[1]);
		        }

		        min[0] = left;
		        min[1] = top;
		        max[0] = right;
		        max[1] = bottom;
		    };

		    /**
		     * @memberOf module:zrender/core/bbox
		     * @param {number} x0
		     * @param {number} y0
		     * @param {number} x1
		     * @param {number} y1
		     * @param {Array.<number>} min
		     * @param {Array.<number>} max
		     */
		    bbox.fromLine = function (x0, y0, x1, y1, min, max) {
		        min[0] = mathMin(x0, x1);
		        min[1] = mathMin(y0, y1);
		        max[0] = mathMax(x0, x1);
		        max[1] = mathMax(y0, y1);
		    };

		    var xDim = [];
		    var yDim = [];
		    /**
		     * 从三阶贝塞尔曲线(p0, p1, p2, p3)中计算出最小包围盒，写入`min`和`max`中
		     * @memberOf module:zrender/core/bbox
		     * @param {number} x0
		     * @param {number} y0
		     * @param {number} x1
		     * @param {number} y1
		     * @param {number} x2
		     * @param {number} y2
		     * @param {number} x3
		     * @param {number} y3
		     * @param {Array.<number>} min
		     * @param {Array.<number>} max
		     */
		    bbox.fromCubic = function(
		        x0, y0, x1, y1, x2, y2, x3, y3, min, max
		    ) {
		        var cubicExtrema = curve.cubicExtrema;
		        var cubicAt = curve.cubicAt;
		        var i;
		        var n = cubicExtrema(x0, x1, x2, x3, xDim);
		        min[0] = Infinity;
		        min[1] = Infinity;
		        max[0] = -Infinity;
		        max[1] = -Infinity;

		        for (i = 0; i < n; i++) {
		            var x = cubicAt(x0, x1, x2, x3, xDim[i]);
		            min[0] = mathMin(x, min[0]);
		            max[0] = mathMax(x, max[0]);
		        }
		        n = cubicExtrema(y0, y1, y2, y3, yDim);
		        for (i = 0; i < n; i++) {
		            var y = cubicAt(y0, y1, y2, y3, yDim[i]);
		            min[1] = mathMin(y, min[1]);
		            max[1] = mathMax(y, max[1]);
		        }

		        min[0] = mathMin(x0, min[0]);
		        max[0] = mathMax(x0, max[0]);
		        min[0] = mathMin(x3, min[0]);
		        max[0] = mathMax(x3, max[0]);

		        min[1] = mathMin(y0, min[1]);
		        max[1] = mathMax(y0, max[1]);
		        min[1] = mathMin(y3, min[1]);
		        max[1] = mathMax(y3, max[1]);
		    };

		    /**
		     * 从二阶贝塞尔曲线(p0, p1, p2)中计算出最小包围盒，写入`min`和`max`中
		     * @memberOf module:zrender/core/bbox
		     * @param {number} x0
		     * @param {number} y0
		     * @param {number} x1
		     * @param {number} y1
		     * @param {number} x2
		     * @param {number} y2
		     * @param {Array.<number>} min
		     * @param {Array.<number>} max
		     */
		    bbox.fromQuadratic = function(x0, y0, x1, y1, x2, y2, min, max) {
		        var quadraticExtremum = curve.quadraticExtremum;
		        var quadraticAt = curve.quadraticAt;
		        // Find extremities, where derivative in x dim or y dim is zero
		        var tx =
		            mathMax(
		                mathMin(quadraticExtremum(x0, x1, x2), 1), 0
		            );
		        var ty =
		            mathMax(
		                mathMin(quadraticExtremum(y0, y1, y2), 1), 0
		            );

		        var x = quadraticAt(x0, x1, x2, tx);
		        var y = quadraticAt(y0, y1, y2, ty);

		        min[0] = mathMin(x0, x2, x);
		        min[1] = mathMin(y0, y2, y);
		        max[0] = mathMax(x0, x2, x);
		        max[1] = mathMax(y0, y2, y);
		    };

		    /**
		     * 从圆弧中计算出最小包围盒，写入`min`和`max`中
		     * @method
		     * @memberOf module:zrender/core/bbox
		     * @param {number} x
		     * @param {number} y
		     * @param {number} rx
		     * @param {number} ry
		     * @param {number} startAngle
		     * @param {number} endAngle
		     * @param {number} anticlockwise
		     * @param {Array.<number>} min
		     * @param {Array.<number>} max
		     */
		    bbox.fromArc = function (
		        x, y, rx, ry, startAngle, endAngle, anticlockwise, min, max
		    ) {
		        var vec2Min = vec2.min;
		        var vec2Max = vec2.max;

		        var diff = Math.abs(startAngle - endAngle);


		        if (diff % PI2 < 1e-4 && diff > 1e-4) {
		            // Is a circle
		            min[0] = x - rx;
		            min[1] = y - ry;
		            max[0] = x + rx;
		            max[1] = y + ry;
		            return;
		        }

		        start[0] = mathCos(startAngle) * rx + x;
		        start[1] = mathSin(startAngle) * ry + y;

		        end[0] = mathCos(endAngle) * rx + x;
		        end[1] = mathSin(endAngle) * ry + y;

		        vec2Min(min, start, end);
		        vec2Max(max, start, end);

		        // Thresh to [0, Math.PI * 2]
		        startAngle = startAngle % (PI2);
		        if (startAngle < 0) {
		            startAngle = startAngle + PI2;
		        }
		        endAngle = endAngle % (PI2);
		        if (endAngle < 0) {
		            endAngle = endAngle + PI2;
		        }

		        if (startAngle > endAngle && !anticlockwise) {
		            endAngle += PI2;
		        }
		        else if (startAngle < endAngle && anticlockwise) {
		            startAngle += PI2;
		        }
		        if (anticlockwise) {
		            var tmp = endAngle;
		            endAngle = startAngle;
		            startAngle = tmp;
		        }

		        // var number = 0;
		        // var step = (anticlockwise ? -Math.PI : Math.PI) / 2;
		        for (var angle = 0; angle < endAngle; angle += Math.PI / 2) {
		            if (angle > startAngle) {
		                extremity[0] = mathCos(angle) * rx + x;
		                extremity[1] = mathSin(angle) * ry + y;

		                vec2Min(min, extremity, min);
		                vec2Max(max, extremity, max);
		            }
		        }
		    };

		    module.exports = bbox;



	/***/ },
	/* 52 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var CMD = __webpack_require__(49).CMD;
		    var line = __webpack_require__(53);
		    var cubic = __webpack_require__(54);
		    var quadratic = __webpack_require__(55);
		    var arc = __webpack_require__(56);
		    var normalizeRadian = __webpack_require__(57).normalizeRadian;
		    var curve = __webpack_require__(50);

		    var windingLine = __webpack_require__(58);

		    var containStroke = line.containStroke;

		    var PI2 = Math.PI * 2;

		    var EPSILON = 1e-4;

		    function isAroundEqual(a, b) {
		        return Math.abs(a - b) < EPSILON;
		    }

		    // 临时数组
		    var roots = [-1, -1, -1];
		    var extrema = [-1, -1];

		    function swapExtrema() {
		        var tmp = extrema[0];
		        extrema[0] = extrema[1];
		        extrema[1] = tmp;
		    }

		    function windingCubic(x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
		        // Quick reject
		        if (
		            (y > y0 && y > y1 && y > y2 && y > y3)
		            || (y < y0 && y < y1 && y < y2 && y < y3)
		        ) {
		            return 0;
		        }
		        var nRoots = curve.cubicRootAt(y0, y1, y2, y3, y, roots);
		        if (nRoots === 0) {
		            return 0;
		        }
		        else {
		            var w = 0;
		            var nExtrema = -1;
		            var y0_, y1_;
		            for (var i = 0; i < nRoots; i++) {
		                var t = roots[i];

		                // Avoid winding error when intersection point is the connect point of two line of polygon
		                var unit = (t === 0 || t === 1) ? 0.5 : 1;

		                var x_ = curve.cubicAt(x0, x1, x2, x3, t);
		                if (x_ < x) { // Quick reject
		                    continue;
		                }
		                if (nExtrema < 0) {
		                    nExtrema = curve.cubicExtrema(y0, y1, y2, y3, extrema);
		                    if (extrema[1] < extrema[0] && nExtrema > 1) {
		                        swapExtrema();
		                    }
		                    y0_ = curve.cubicAt(y0, y1, y2, y3, extrema[0]);
		                    if (nExtrema > 1) {
		                        y1_ = curve.cubicAt(y0, y1, y2, y3, extrema[1]);
		                    }
		                }
		                if (nExtrema == 2) {
		                    // 分成三段单调函数
		                    if (t < extrema[0]) {
		                        w += y0_ < y0 ? unit : -unit;
		                    }
		                    else if (t < extrema[1]) {
		                        w += y1_ < y0_ ? unit : -unit;
		                    }
		                    else {
		                        w += y3 < y1_ ? unit : -unit;
		                    }
		                }
		                else {
		                    // 分成两段单调函数
		                    if (t < extrema[0]) {
		                        w += y0_ < y0 ? unit : -unit;
		                    }
		                    else {
		                        w += y3 < y0_ ? unit : -unit;
		                    }
		                }
		            }
		            return w;
		        }
		    }

		    function windingQuadratic(x0, y0, x1, y1, x2, y2, x, y) {
		        // Quick reject
		        if (
		            (y > y0 && y > y1 && y > y2)
		            || (y < y0 && y < y1 && y < y2)
		        ) {
		            return 0;
		        }
		        var nRoots = curve.quadraticRootAt(y0, y1, y2, y, roots);
		        if (nRoots === 0) {
		            return 0;
		        }
		        else {
		            var t = curve.quadraticExtremum(y0, y1, y2);
		            if (t >= 0 && t <= 1) {
		                var w = 0;
		                var y_ = curve.quadraticAt(y0, y1, y2, t);
		                for (var i = 0; i < nRoots; i++) {
		                    // Remove one endpoint.
		                    var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1;

		                    var x_ = curve.quadraticAt(x0, x1, x2, roots[i]);
		                    if (x_ < x) {   // Quick reject
		                        continue;
		                    }
		                    if (roots[i] < t) {
		                        w += y_ < y0 ? unit : -unit;
		                    }
		                    else {
		                        w += y2 < y_ ? unit : -unit;
		                    }
		                }
		                return w;
		            }
		            else {
		                // Remove one endpoint.
		                var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1;

		                var x_ = curve.quadraticAt(x0, x1, x2, roots[0]);
		                if (x_ < x) {   // Quick reject
		                    return 0;
		                }
		                return y2 < y0 ? unit : -unit;
		            }
		        }
		    }

		    // TODO
		    // Arc 旋转
		    function windingArc(
		        cx, cy, r, startAngle, endAngle, anticlockwise, x, y
		    ) {
		        y -= cy;
		        if (y > r || y < -r) {
		            return 0;
		        }
		        var tmp = Math.sqrt(r * r - y * y);
		        roots[0] = -tmp;
		        roots[1] = tmp;

		        var diff = Math.abs(startAngle - endAngle);
		        if (diff < 1e-4) {
		            return 0;
		        }
		        if (diff % PI2 < 1e-4) {
		            // Is a circle
		            startAngle = 0;
		            endAngle = PI2;
		            var dir = anticlockwise ? 1 : -1;
		            if (x >= roots[0] + cx && x <= roots[1] + cx) {
		                return dir;
		            } else {
		                return 0;
		            }
		        }

		        if (anticlockwise) {
		            var tmp = startAngle;
		            startAngle = normalizeRadian(endAngle);
		            endAngle = normalizeRadian(tmp);
		        }
		        else {
		            startAngle = normalizeRadian(startAngle);
		            endAngle = normalizeRadian(endAngle);
		        }
		        if (startAngle > endAngle) {
		            endAngle += PI2;
		        }

		        var w = 0;
		        for (var i = 0; i < 2; i++) {
		            var x_ = roots[i];
		            if (x_ + cx > x) {
		                var angle = Math.atan2(y, x_);
		                var dir = anticlockwise ? 1 : -1;
		                if (angle < 0) {
		                    angle = PI2 + angle;
		                }
		                if (
		                    (angle >= startAngle && angle <= endAngle)
		                    || (angle + PI2 >= startAngle && angle + PI2 <= endAngle)
		                ) {
		                    if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
		                        dir = -dir;
		                    }
		                    w += dir;
		                }
		            }
		        }
		        return w;
		    }

		    function containPath(data, lineWidth, isStroke, x, y) {
		        var w = 0;
		        var xi = 0;
		        var yi = 0;
		        var x0 = 0;
		        var y0 = 0;

		        for (var i = 0; i < data.length;) {
		            var cmd = data[i++];
		            // Begin a new subpath
		            if (cmd === CMD.M && i > 1) {
		                // Close previous subpath
		                if (!isStroke) {
		                    w += windingLine(xi, yi, x0, y0, x, y);
		                }
		                // 如果被任何一个 subpath 包含
		                // if (w !== 0) {
		                //     return true;
		                // }
		            }

		            if (i == 1) {
		                // 如果第一个命令是 L, C, Q
		                // 则 previous point 同绘制命令的第一个 point
		                //
		                // 第一个命令为 Arc 的情况下会在后面特殊处理
		                xi = data[i];
		                yi = data[i + 1];

		                x0 = xi;
		                y0 = yi;
		            }

		            switch (cmd) {
		                case CMD.M:
		                    // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
		                    // 在 closePath 的时候使用
		                    x0 = data[i++];
		                    y0 = data[i++];
		                    xi = x0;
		                    yi = y0;
		                    break;
		                case CMD.L:
		                    if (isStroke) {
		                        if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
		                            return true;
		                        }
		                    }
		                    else {
		                        // NOTE 在第一个命令为 L, C, Q 的时候会计算出 NaN
		                        w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0;
		                    }
		                    xi = data[i++];
		                    yi = data[i++];
		                    break;
		                case CMD.C:
		                    if (isStroke) {
		                        if (cubic.containStroke(xi, yi,
		                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
		                            lineWidth, x, y
		                        )) {
		                            return true;
		                        }
		                    }
		                    else {
		                        w += windingCubic(
		                            xi, yi,
		                            data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1],
		                            x, y
		                        ) || 0;
		                    }
		                    xi = data[i++];
		                    yi = data[i++];
		                    break;
		                case CMD.Q:
		                    if (isStroke) {
		                        if (quadratic.containStroke(xi, yi,
		                            data[i++], data[i++], data[i], data[i + 1],
		                            lineWidth, x, y
		                        )) {
		                            return true;
		                        }
		                    }
		                    else {
		                        w += windingQuadratic(
		                            xi, yi,
		                            data[i++], data[i++], data[i], data[i + 1],
		                            x, y
		                        ) || 0;
		                    }
		                    xi = data[i++];
		                    yi = data[i++];
		                    break;
		                case CMD.A:
		                    // TODO Arc 判断的开销比较大
		                    var cx = data[i++];
		                    var cy = data[i++];
		                    var rx = data[i++];
		                    var ry = data[i++];
		                    var theta = data[i++];
		                    var dTheta = data[i++];
		                    // TODO Arc 旋转
		                    var psi = data[i++];
		                    var anticlockwise = 1 - data[i++];
		                    var x1 = Math.cos(theta) * rx + cx;
		                    var y1 = Math.sin(theta) * ry + cy;
		                    // 不是直接使用 arc 命令
		                    if (i > 1) {
		                        w += windingLine(xi, yi, x1, y1, x, y);
		                    }
		                    else {
		                        // 第一个命令起点还未定义
		                        x0 = x1;
		                        y0 = y1;
		                    }
		                    // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放
		                    var _x = (x - cx) * ry / rx + cx;
		                    if (isStroke) {
		                        if (arc.containStroke(
		                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
		                            lineWidth, _x, y
		                        )) {
		                            return true;
		                        }
		                    }
		                    else {
		                        w += windingArc(
		                            cx, cy, ry, theta, theta + dTheta, anticlockwise,
		                            _x, y
		                        );
		                    }
		                    xi = Math.cos(theta + dTheta) * rx + cx;
		                    yi = Math.sin(theta + dTheta) * ry + cy;
		                    break;
		                case CMD.R:
		                    x0 = xi = data[i++];
		                    y0 = yi = data[i++];
		                    var width = data[i++];
		                    var height = data[i++];
		                    var x1 = x0 + width;
		                    var y1 = y0 + height;
		                    if (isStroke) {
		                        if (containStroke(x0, y0, x1, y0, lineWidth, x, y)
		                          || containStroke(x1, y0, x1, y1, lineWidth, x, y)
		                          || containStroke(x1, y1, x0, y1, lineWidth, x, y)
		                          || containStroke(x0, y1, x0, y0, lineWidth, x, y)
		                        ) {
		                            return true;
		                        }
		                    }
		                    else {
		                        // FIXME Clockwise ?
		                        w += windingLine(x1, y0, x1, y1, x, y);
		                        w += windingLine(x0, y1, x0, y0, x, y);
		                    }
		                    break;
		                case CMD.Z:
		                    if (isStroke) {
		                        if (containStroke(
		                            xi, yi, x0, y0, lineWidth, x, y
		                        )) {
		                            return true;
		                        }
		                    }
		                    else {
		                        // Close a subpath
		                        w += windingLine(xi, yi, x0, y0, x, y);
		                        // 如果被任何一个 subpath 包含
		                        // FIXME subpaths may overlap
		                        // if (w !== 0) {
		                        //     return true;
		                        // }
		                    }
		                    xi = x0;
		                    yi = y0;
		                    break;
		            }
		        }
		        if (!isStroke && !isAroundEqual(yi, y0)) {
		            w += windingLine(xi, yi, x0, y0, x, y) || 0;
		        }
		        return w !== 0;
		    }

		    module.exports = {
		        contain: function (pathData, x, y) {
		            return containPath(pathData, 0, false, x, y);
		        },

		        containStroke: function (pathData, lineWidth, x, y) {
		            return containPath(pathData, lineWidth, true, x, y);
		        }
		    };


	/***/ },
	/* 53 */
	/***/ function(module, exports) {

		
		    module.exports = {
		        /**
		         * 线段包含判断
		         * @param  {number}  x0
		         * @param  {number}  y0
		         * @param  {number}  x1
		         * @param  {number}  y1
		         * @param  {number}  lineWidth
		         * @param  {number}  x
		         * @param  {number}  y
		         * @return {boolean}
		         */
		        containStroke: function (x0, y0, x1, y1, lineWidth, x, y) {
		            if (lineWidth === 0) {
		                return false;
		            }
		            var _l = lineWidth;
		            var _a = 0;
		            var _b = x0;
		            // Quick reject
		            if (
		                (y > y0 + _l && y > y1 + _l)
		                || (y < y0 - _l && y < y1 - _l)
		                || (x > x0 + _l && x > x1 + _l)
		                || (x < x0 - _l && x < x1 - _l)
		            ) {
		                return false;
		            }

		            if (x0 !== x1) {
		                _a = (y0 - y1) / (x0 - x1);
		                _b = (x0 * y1 - x1 * y0) / (x0 - x1) ;
		            }
		            else {
		                return Math.abs(x - x0) <= _l / 2;
		            }
		            var tmp = _a * x - y + _b;
		            var _s = tmp * tmp / (_a * _a + 1);
		            return _s <= _l / 2 * _l / 2;
		        }
		    };


	/***/ },
	/* 54 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var curve = __webpack_require__(50);

		    module.exports = {
		        /**
		         * 三次贝塞尔曲线描边包含判断
		         * @param  {number}  x0
		         * @param  {number}  y0
		         * @param  {number}  x1
		         * @param  {number}  y1
		         * @param  {number}  x2
		         * @param  {number}  y2
		         * @param  {number}  x3
		         * @param  {number}  y3
		         * @param  {number}  lineWidth
		         * @param  {number}  x
		         * @param  {number}  y
		         * @return {boolean}
		         */
		        containStroke: function(x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
		            if (lineWidth === 0) {
		                return false;
		            }
		            var _l = lineWidth;
		            // Quick reject
		            if (
		                (y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l)
		                || (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l)
		                || (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l)
		                || (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)
		            ) {
		                return false;
		            }
		            var d = curve.cubicProjectPoint(
		                x0, y0, x1, y1, x2, y2, x3, y3,
		                x, y, null
		            );
		            return d <= _l / 2;
		        }
		    };


	/***/ },
	/* 55 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var curve = __webpack_require__(50);

		    module.exports = {
		        /**
		         * 二次贝塞尔曲线描边包含判断
		         * @param  {number}  x0
		         * @param  {number}  y0
		         * @param  {number}  x1
		         * @param  {number}  y1
		         * @param  {number}  x2
		         * @param  {number}  y2
		         * @param  {number}  lineWidth
		         * @param  {number}  x
		         * @param  {number}  y
		         * @return {boolean}
		         */
		        containStroke: function (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
		            if (lineWidth === 0) {
		                return false;
		            }
		            var _l = lineWidth;
		            // Quick reject
		            if (
		                (y > y0 + _l && y > y1 + _l && y > y2 + _l)
		                || (y < y0 - _l && y < y1 - _l && y < y2 - _l)
		                || (x > x0 + _l && x > x1 + _l && x > x2 + _l)
		                || (x < x0 - _l && x < x1 - _l && x < x2 - _l)
		            ) {
		                return false;
		            }
		            var d = curve.quadraticProjectPoint(
		                x0, y0, x1, y1, x2, y2,
		                x, y, null
		            );
		            return d <= _l / 2;
		        }
		    };


	/***/ },
	/* 56 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var normalizeRadian = __webpack_require__(57).normalizeRadian;
		    var PI2 = Math.PI * 2;

		    module.exports = {
		        /**
		         * 圆弧描边包含判断
		         * @param  {number}  cx
		         * @param  {number}  cy
		         * @param  {number}  r
		         * @param  {number}  startAngle
		         * @param  {number}  endAngle
		         * @param  {boolean}  anticlockwise
		         * @param  {number} lineWidth
		         * @param  {number}  x
		         * @param  {number}  y
		         * @return {Boolean}
		         */
		        containStroke: function (
		            cx, cy, r, startAngle, endAngle, anticlockwise,
		            lineWidth, x, y
		        ) {

		            if (lineWidth === 0) {
		                return false;
		            }
		            var _l = lineWidth;

		            x -= cx;
		            y -= cy;
		            var d = Math.sqrt(x * x + y * y);

		            if ((d - _l > r) || (d + _l < r)) {
		                return false;
		            }
		            if (Math.abs(startAngle - endAngle) % PI2 < 1e-4) {
		                // Is a circle
		                return true;
		            }
		            if (anticlockwise) {
		                var tmp = startAngle;
		                startAngle = normalizeRadian(endAngle);
		                endAngle = normalizeRadian(tmp);
		            } else {
		                startAngle = normalizeRadian(startAngle);
		                endAngle = normalizeRadian(endAngle);
		            }
		            if (startAngle > endAngle) {
		                endAngle += PI2;
		            }

		            var angle = Math.atan2(y, x);
		            if (angle < 0) {
		                angle += PI2;
		            }
		            return (angle >= startAngle && angle <= endAngle)
		                || (angle + PI2 >= startAngle && angle + PI2 <= endAngle);
		        }
		    };


	/***/ },
	/* 57 */
	/***/ function(module, exports) {

		

		    var PI2 = Math.PI * 2;
		    module.exports = {
		        normalizeRadian: function(angle) {
		            angle %= PI2;
		            if (angle < 0) {
		                angle += PI2;
		            }
		            return angle;
		        }
		    };


	/***/ },
	/* 58 */
	/***/ function(module, exports) {

		
		    module.exports = function windingLine(x0, y0, x1, y1, x, y) {
		        if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
		            return 0;
		        }
		        // Ignore horizontal line
		        if (y1 === y0) {
		            return 0;
		        }
		        var dir = y1 < y0 ? 1 : -1;
		        var t = (y - y0) / (y1 - y0);

		        // Avoid winding error when intersection point is the connect point of two line of polygon
		        if (t === 1 || t === 0) {
		            dir = y1 < y0 ? 0.5 : -0.5;
		        }

		        var x_ = t * (x1 - x0) + x0;

		        return x_ > x ? dir : 0;
		    };


	/***/ },
	/* 59 */
	/***/ function(module, exports) {

		

		    var Pattern = function (image, repeat) {
		        this.image = image;
		        this.repeat = repeat;

		        // Can be cloned
		        this.type = 'pattern';
		    };

		    Pattern.prototype.getCanvasPattern = function (ctx) {

		        return this._canvasPattern
		            || (this._canvasPattern = ctx.createPattern(this.image, this.repeat));
		    };

		    module.exports = Pattern;


	/***/ },
	/* 60 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var CMD = __webpack_require__(49).CMD;
		    var vec2 = __webpack_require__(10);
		    var v2ApplyTransform = vec2.applyTransform;

		    var points = [[], [], []];
		    var mathSqrt = Math.sqrt;
		    var mathAtan2 = Math.atan2;
		    function transformPath(path, m) {
		        var data = path.data;
		        var cmd;
		        var nPoint;
		        var i;
		        var j;
		        var k;
		        var p;

		        var M = CMD.M;
		        var C = CMD.C;
		        var L = CMD.L;
		        var R = CMD.R;
		        var A = CMD.A;
		        var Q = CMD.Q;

		        for (i = 0, j = 0; i < data.length;) {
		            cmd = data[i++];
		            j = i;
		            nPoint = 0;

		            switch (cmd) {
		                case M:
		                    nPoint = 1;
		                    break;
		                case L:
		                    nPoint = 1;
		                    break;
		                case C:
		                    nPoint = 3;
		                    break;
		                case Q:
		                    nPoint = 2;
		                    break;
		                case A:
		                    var x = m[4];
		                    var y = m[5];
		                    var sx = mathSqrt(m[0] * m[0] + m[1] * m[1]);
		                    var sy = mathSqrt(m[2] * m[2] + m[3] * m[3]);
		                    var angle = mathAtan2(-m[1] / sy, m[0] / sx);
		                    // cx
		                    data[i++] += x;
		                    // cy
		                    data[i++] += y;
		                    // Scale rx and ry
		                    // FIXME Assume psi is 0 here
		                    data[i++] *= sx;
		                    data[i++] *= sy;

		                    // Start angle
		                    data[i++] += angle;
		                    // end angle
		                    data[i++] += angle;
		                    // FIXME psi
		                    i += 2;
		                    j = i;
		                    break;
		                case R:
		                    // x0, y0
		                    p[0] = data[i++];
		                    p[1] = data[i++];
		                    v2ApplyTransform(p, p, m);
		                    data[j++] = p[0];
		                    data[j++] = p[1];
		                    // x1, y1
		                    p[0] += data[i++];
		                    p[1] += data[i++];
		                    v2ApplyTransform(p, p, m);
		                    data[j++] = p[0];
		                    data[j++] = p[1];
		            }

		            for (k = 0; k < nPoint; k++) {
		                var p = points[k];
		                p[0] = data[i++];
		                p[1] = data[i++];

		                v2ApplyTransform(p, p, m);
		                // Write back
		                data[j++] = p[0];
		                data[j++] = p[1];
		            }
		        }
		    }

		    module.exports = transformPath;


	/***/ },
	/* 61 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Image element
		 * @module zrender/graphic/Image
		 */



		    var Displayable = __webpack_require__(46);
		    var BoundingRect = __webpack_require__(9);
		    var zrUtil = __webpack_require__(4);

		    var LRU = __webpack_require__(62);
		    var globalImageCache = new LRU(50);
		    /**
		     * @alias zrender/graphic/Image
		     * @extends module:zrender/graphic/Displayable
		     * @constructor
		     * @param {Object} opts
		     */
		    function ZImage(opts) {
		        Displayable.call(this, opts);
		    }

		    ZImage.prototype = {

		        constructor: ZImage,

		        type: 'image',

		        brush: function (ctx, prevEl) {
		            var style = this.style;
		            var src = style.image;
		            var image;

		            // Must bind each time
		            style.bind(ctx, this, prevEl);
		            // style.image is a url string
		            if (typeof src === 'string') {
		                image = this._image;
		            }
		            // style.image is an HTMLImageElement or HTMLCanvasElement or Canvas
		            else {
		                image = src;
		            }
		            // FIXME Case create many images with src
		            if (!image && src) {
		                // Try get from global image cache
		                var cachedImgObj = globalImageCache.get(src);
		                if (!cachedImgObj) {
		                    // Create a new image
		                    image = new Image();
		                    image.onload = function () {
		                        image.onload = null;
		                        for (var i = 0; i < cachedImgObj.pending.length; i++) {
		                            cachedImgObj.pending[i].dirty();
		                        }
		                    };
		                    cachedImgObj = {
		                        image: image,
		                        pending: [this]
		                    };
		                    image.src = src;
		                    globalImageCache.put(src, cachedImgObj);
		                    this._image = image;
		                    return;
		                }
		                else {
		                    image = cachedImgObj.image;
		                    this._image = image;
		                    // Image is not complete finish, add to pending list
		                    if (!image.width || !image.height) {
		                        cachedImgObj.pending.push(this);
		                        return;
		                    }
		                }
		            }

		            if (image) {
		                // 图片已经加载完成
		                // if (image.nodeName.toUpperCase() == 'IMG') {
		                //     if (!image.complete) {
		                //         return;
		                //     }
		                // }
		                // Else is canvas

		                var width = style.width || image.width;
		                var height = style.height || image.height;
		                var x = style.x || 0;
		                var y = style.y || 0;
		                // 图片加载失败
		                if (!image.width || !image.height) {
		                    return;
		                }

		                // 设置transform
		                this.setTransform(ctx);


		                if (style.sWidth && style.sHeight) {
		                    var sx = style.sx || 0;
		                    var sy = style.sy || 0;
		                    ctx.drawImage(
		                        image,
		                        sx, sy, style.sWidth, style.sHeight,
		                        x, y, width, height
		                    );
		                }
		                else if (style.sx && style.sy) {
		                    var sx = style.sx;
		                    var sy = style.sy;
		                    var sWidth = width - sx;
		                    var sHeight = height - sy;
		                    ctx.drawImage(
		                        image,
		                        sx, sy, sWidth, sHeight,
		                        x, y, width, height
		                    );
		                }
		                else {
		                    ctx.drawImage(image, x, y, width, height);
		                }

		                // 如果没设置宽和高的话自动根据图片宽高设置
		                if (style.width == null) {
		                    style.width = width;
		                }
		                if (style.height == null) {
		                    style.height = height;
		                }

		                this.restoreTransform(ctx);

		                // Draw rect text
		                if (style.text != null) {
		                    this.drawRectText(ctx, this.getBoundingRect());
		                }

		            }
		        },

		        getBoundingRect: function () {
		            var style = this.style;
		            if (! this._rect) {
		                this._rect = new BoundingRect(
		                    style.x || 0, style.y || 0, style.width || 0, style.height || 0
		                );
		            }
		            return this._rect;
		        }
		    };

		    zrUtil.inherits(ZImage, Displayable);

		    module.exports = ZImage;


	/***/ },
	/* 62 */
	/***/ function(module, exports) {

		// Simple LRU cache use doubly linked list
		// @module zrender/core/LRU


		    /**
		     * Simple double linked list. Compared with array, it has O(1) remove operation.
		     * @constructor
		     */
		    var LinkedList = function() {

		        /**
		         * @type {module:zrender/core/LRU~Entry}
		         */
		        this.head = null;

		        /**
		         * @type {module:zrender/core/LRU~Entry}
		         */
		        this.tail = null;

		        this._len = 0;
		    };

		    var linkedListProto = LinkedList.prototype;
		    /**
		     * Insert a new value at the tail
		     * @param  {} val
		     * @return {module:zrender/core/LRU~Entry}
		     */
		    linkedListProto.insert = function(val) {
		        var entry = new Entry(val);
		        this.insertEntry(entry);
		        return entry;
		    };

		    /**
		     * Insert an entry at the tail
		     * @param  {module:zrender/core/LRU~Entry} entry
		     */
		    linkedListProto.insertEntry = function(entry) {
		        if (!this.head) {
		            this.head = this.tail = entry;
		        }
		        else {
		            this.tail.next = entry;
		            entry.prev = this.tail;
		            this.tail = entry;
		        }
		        this._len++;
		    };

		    /**
		     * Remove entry.
		     * @param  {module:zrender/core/LRU~Entry} entry
		     */
		    linkedListProto.remove = function(entry) {
		        var prev = entry.prev;
		        var next = entry.next;
		        if (prev) {
		            prev.next = next;
		        }
		        else {
		            // Is head
		            this.head = next;
		        }
		        if (next) {
		            next.prev = prev;
		        }
		        else {
		            // Is tail
		            this.tail = prev;
		        }
		        entry.next = entry.prev = null;
		        this._len--;
		    };

		    /**
		     * @return {number}
		     */
		    linkedListProto.len = function() {
		        return this._len;
		    };

		    /**
		     * @constructor
		     * @param {} val
		     */
		    var Entry = function(val) {
		        /**
		         * @type {}
		         */
		        this.value = val;

		        /**
		         * @type {module:zrender/core/LRU~Entry}
		         */
		        this.next;

		        /**
		         * @type {module:zrender/core/LRU~Entry}
		         */
		        this.prev;
		    };

		    /**
		     * LRU Cache
		     * @constructor
		     * @alias module:zrender/core/LRU
		     */
		    var LRU = function(maxSize) {

		        this._list = new LinkedList();

		        this._map = {};

		        this._maxSize = maxSize || 10;
		    };

		    var LRUProto = LRU.prototype;

		    /**
		     * @param  {string} key
		     * @param  {} value
		     */
		    LRUProto.put = function(key, value) {
		        var list = this._list;
		        var map = this._map;
		        if (map[key] == null) {
		            var len = list.len();
		            if (len >= this._maxSize && len > 0) {
		                // Remove the least recently used
		                var leastUsedEntry = list.head;
		                list.remove(leastUsedEntry);
		                delete map[leastUsedEntry.key];
		            }

		            var entry = list.insert(value);
		            entry.key = key;
		            map[key] = entry;
		        }
		    };

		    /**
		     * @param  {string} key
		     * @return {}
		     */
		    LRUProto.get = function(key) {
		        var entry = this._map[key];
		        var list = this._list;
		        if (entry != null) {
		            // Put the latest used entry in the tail
		            if (entry !== list.tail) {
		                list.remove(entry);
		                list.insertEntry(entry);
		            }

		            return entry.value;
		        }
		    };

		    /**
		     * Clear the cache
		     */
		    LRUProto.clear = function() {
		        this._list.clear();
		        this._map = {};
		    };

		    module.exports = LRU;


	/***/ },
	/* 63 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Text element
		 * @module zrender/graphic/Text
		 *
		 * TODO Wrapping
		 *
		 * Text not support gradient
		 */



		    var Displayable = __webpack_require__(46);
		    var zrUtil = __webpack_require__(4);
		    var textContain = __webpack_require__(8);

		    /**
		     * @alias zrender/graphic/Text
		     * @extends module:zrender/graphic/Displayable
		     * @constructor
		     * @param {Object} opts
		     */
		    var Text = function (opts) {
		        Displayable.call(this, opts);
		    };

		    Text.prototype = {

		        constructor: Text,

		        type: 'text',

		        brush: function (ctx, prevEl) {
		            var style = this.style;
		            var x = style.x || 0;
		            var y = style.y || 0;
		            // Convert to string
		            var text = style.text;

		            // Convert to string
		            text != null && (text += '');

		            // Always bind style
		            style.bind(ctx, this, prevEl);

		            if (text) {

		                this.setTransform(ctx);

		                var textBaseline;
		                var textAlign = style.textAlign;
		                var font = style.textFont || style.font;
		                if (style.textVerticalAlign) {
		                    var rect = textContain.getBoundingRect(
		                        text, font, style.textAlign, 'top'
		                    );
		                    // Ignore textBaseline
		                    textBaseline = 'middle';
		                    switch (style.textVerticalAlign) {
		                        case 'middle':
		                            y -= rect.height / 2 - rect.lineHeight / 2;
		                            break;
		                        case 'bottom':
		                            y -= rect.height - rect.lineHeight / 2;
		                            break;
		                        default:
		                            y += rect.lineHeight / 2;
		                    }
		                }
		                else {
		                    textBaseline = style.textBaseline;
		                }

		                // TODO Invalid font
		                ctx.font = font || '12px sans-serif';
		                ctx.textAlign = textAlign || 'left';
		                // Use canvas default left textAlign. Giving invalid value will cause state not change
		                if (ctx.textAlign !== textAlign) {
		                    ctx.textAlign = 'left';
		                }
		                ctx.textBaseline = textBaseline || 'alphabetic';
		                // Use canvas default alphabetic baseline
		                if (ctx.textBaseline !== textBaseline) {
		                    ctx.textBaseline = 'alphabetic';
		                }

		                var lineHeight = textContain.measureText('国', ctx.font).width;

		                var textLines = text.split('\n');
		                for (var i = 0; i < textLines.length; i++) {
		                    style.hasFill() && ctx.fillText(textLines[i], x, y);
		                    style.hasStroke() && ctx.strokeText(textLines[i], x, y);
		                    y += lineHeight;
		                }

		                this.restoreTransform(ctx);
		            }
		        },

		        getBoundingRect: function () {
		            if (!this._rect) {
		                var style = this.style;
		                var textVerticalAlign = style.textVerticalAlign;
		                var rect = textContain.getBoundingRect(
		                    style.text + '', style.textFont || style.font, style.textAlign,
		                    textVerticalAlign ? 'top' : style.textBaseline
		                );
		                switch (textVerticalAlign) {
		                    case 'middle':
		                        rect.y -= rect.height / 2;
		                        break;
		                    case 'bottom':
		                        rect.y -= rect.height;
		                        break;
		                }
		                rect.x += style.x || 0;
		                rect.y += style.y || 0;
		                this._rect = rect;
		            }
		            return this._rect;
		        }
		    };

		    zrUtil.inherits(Text, Displayable);

		    module.exports = Text;


	/***/ },
	/* 64 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * 圆形
		 * @module zrender/shape/Circle
		 */



		    module.exports = __webpack_require__(45).extend({

		        type: 'circle',

		        shape: {
		            cx: 0,
		            cy: 0,
		            r: 0
		        },


		        buildPath : function (ctx, shape, inBundle) {
		            // Better stroking in ShapeBundle
		            // Always do it may have performence issue ( fill may be 2x more cost)
		            if (inBundle) {
		                ctx.moveTo(shape.cx + shape.r, shape.cy);
		            }
		            // Better stroking in ShapeBundle
		            // ctx.moveTo(shape.cx + shape.r, shape.cy);
		            ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2, true);
		        }
		    });



	/***/ },
	/* 65 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 扇形
		 * @module zrender/graphic/shape/Sector
		 */



		    module.exports = __webpack_require__(45).extend({

		        type: 'sector',

		        shape: {

		            cx: 0,

		            cy: 0,

		            r0: 0,

		            r: 0,

		            startAngle: 0,

		            endAngle: Math.PI * 2,

		            clockwise: true
		        },

		        buildPath: function (ctx, shape) {

		            var x = shape.cx;
		            var y = shape.cy;
		            var r0 = Math.max(shape.r0 || 0, 0);
		            var r = Math.max(shape.r, 0);
		            var startAngle = shape.startAngle;
		            var endAngle = shape.endAngle;
		            var clockwise = shape.clockwise;

		            var unitX = Math.cos(startAngle);
		            var unitY = Math.sin(startAngle);

		            ctx.moveTo(unitX * r0 + x, unitY * r0 + y);

		            ctx.lineTo(unitX * r + x, unitY * r + y);

		            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);

		            ctx.lineTo(
		                Math.cos(endAngle) * r0 + x,
		                Math.sin(endAngle) * r0 + y
		            );

		            if (r0 !== 0) {
		                ctx.arc(x, y, r0, endAngle, startAngle, clockwise);
		            }

		            ctx.closePath();
		        }
		    });



	/***/ },
	/* 66 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 圆环
		 * @module zrender/graphic/shape/Ring
		 */


		    module.exports = __webpack_require__(45).extend({

		        type: 'ring',

		        shape: {
		            cx: 0,
		            cy: 0,
		            r: 0,
		            r0: 0
		        },

		        buildPath: function (ctx, shape) {
		            var x = shape.cx;
		            var y = shape.cy;
		            var PI2 = Math.PI * 2;
		            ctx.moveTo(x + shape.r, y);
		            ctx.arc(x, y, shape.r, 0, PI2, false);
		            ctx.moveTo(x + shape.r0, y);
		            ctx.arc(x, y, shape.r0, 0, PI2, true);
		        }
		    });



	/***/ },
	/* 67 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 多边形
		 * @module zrender/shape/Polygon
		 */


		    var polyHelper = __webpack_require__(68);

		    module.exports = __webpack_require__(45).extend({
		        
		        type: 'polygon',

		        shape: {
		            points: null,

		            smooth: false,

		            smoothConstraint: null
		        },

		        buildPath: function (ctx, shape) {
		            polyHelper.buildPath(ctx, shape, true);
		        }
		    });


	/***/ },
	/* 68 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var smoothSpline = __webpack_require__(69);
		    var smoothBezier = __webpack_require__(70);

		    module.exports = {
		        buildPath: function (ctx, shape, closePath) {
		            var points = shape.points;
		            var smooth = shape.smooth;
		            if (points && points.length >= 2) {
		                if (smooth && smooth !== 'spline') {
		                    var controlPoints = smoothBezier(
		                        points, smooth, closePath, shape.smoothConstraint
		                    );

		                    ctx.moveTo(points[0][0], points[0][1]);
		                    var len = points.length;
		                    for (var i = 0; i < (closePath ? len : len - 1); i++) {
		                        var cp1 = controlPoints[i * 2];
		                        var cp2 = controlPoints[i * 2 + 1];
		                        var p = points[(i + 1) % len];
		                        ctx.bezierCurveTo(
		                            cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]
		                        );
		                    }
		                }
		                else {
		                    if (smooth === 'spline') {
		                        points = smoothSpline(points, closePath);
		                    }

		                    ctx.moveTo(points[0][0], points[0][1]);
		                    for (var i = 1, l = points.length; i < l; i++) {
		                        ctx.lineTo(points[i][0], points[i][1]);
		                    }
		                }

		                closePath && ctx.closePath();
		            }
		        }
		    };


	/***/ },
	/* 69 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Catmull-Rom spline 插值折线
		 * @module zrender/shape/util/smoothSpline
		 * @author pissang (https://www.github.com/pissang)
		 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
		 *         errorrik (errorrik@gmail.com)
		 */

		    var vec2 = __webpack_require__(10);

		    /**
		     * @inner
		     */
		    function interpolate(p0, p1, p2, p3, t, t2, t3) {
		        var v0 = (p2 - p0) * 0.5;
		        var v1 = (p3 - p1) * 0.5;
		        return (2 * (p1 - p2) + v0 + v1) * t3
		                + (-3 * (p1 - p2) - 2 * v0 - v1) * t2
		                + v0 * t + p1;
		    }

		    /**
		     * @alias module:zrender/shape/util/smoothSpline
		     * @param {Array} points 线段顶点数组
		     * @param {boolean} isLoop
		     * @return {Array}
		     */
		    module.exports = function (points, isLoop) {
		        var len = points.length;
		        var ret = [];

		        var distance = 0;
		        for (var i = 1; i < len; i++) {
		            distance += vec2.distance(points[i - 1], points[i]);
		        }

		        var segs = distance / 2;
		        segs = segs < len ? len : segs;
		        for (var i = 0; i < segs; i++) {
		            var pos = i / (segs - 1) * (isLoop ? len : len - 1);
		            var idx = Math.floor(pos);

		            var w = pos - idx;

		            var p0;
		            var p1 = points[idx % len];
		            var p2;
		            var p3;
		            if (!isLoop) {
		                p0 = points[idx === 0 ? idx : idx - 1];
		                p2 = points[idx > len - 2 ? len - 1 : idx + 1];
		                p3 = points[idx > len - 3 ? len - 1 : idx + 2];
		            }
		            else {
		                p0 = points[(idx - 1 + len) % len];
		                p2 = points[(idx + 1) % len];
		                p3 = points[(idx + 2) % len];
		            }

		            var w2 = w * w;
		            var w3 = w * w2;

		            ret.push([
		                interpolate(p0[0], p1[0], p2[0], p3[0], w, w2, w3),
		                interpolate(p0[1], p1[1], p2[1], p3[1], w, w2, w3)
		            ]);
		        }
		        return ret;
		    };



	/***/ },
	/* 70 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 贝塞尔平滑曲线
		 * @module zrender/shape/util/smoothBezier
		 * @author pissang (https://www.github.com/pissang)
		 *         Kener (@Kener-林峰, kener.linfeng@gmail.com)
		 *         errorrik (errorrik@gmail.com)
		 */


		    var vec2 = __webpack_require__(10);
		    var v2Min = vec2.min;
		    var v2Max = vec2.max;
		    var v2Scale = vec2.scale;
		    var v2Distance = vec2.distance;
		    var v2Add = vec2.add;

		    /**
		     * 贝塞尔平滑曲线
		     * @alias module:zrender/shape/util/smoothBezier
		     * @param {Array} points 线段顶点数组
		     * @param {number} smooth 平滑等级, 0-1
		     * @param {boolean} isLoop
		     * @param {Array} constraint 将计算出来的控制点约束在一个包围盒内
		     *                           比如 [[0, 0], [100, 100]], 这个包围盒会与
		     *                           整个折线的包围盒做一个并集用来约束控制点。
		     * @param {Array} 计算出来的控制点数组
		     */
		    module.exports = function (points, smooth, isLoop, constraint) {
		        var cps = [];

		        var v = [];
		        var v1 = [];
		        var v2 = [];
		        var prevPoint;
		        var nextPoint;

		        var min, max;
		        if (constraint) {
		            min = [Infinity, Infinity];
		            max = [-Infinity, -Infinity];
		            for (var i = 0, len = points.length; i < len; i++) {
		                v2Min(min, min, points[i]);
		                v2Max(max, max, points[i]);
		            }
		            // 与指定的包围盒做并集
		            v2Min(min, min, constraint[0]);
		            v2Max(max, max, constraint[1]);
		        }

		        for (var i = 0, len = points.length; i < len; i++) {
		            var point = points[i];

		            if (isLoop) {
		                prevPoint = points[i ? i - 1 : len - 1];
		                nextPoint = points[(i + 1) % len];
		            }
		            else {
		                if (i === 0 || i === len - 1) {
		                    cps.push(vec2.clone(points[i]));
		                    continue;
		                }
		                else {
		                    prevPoint = points[i - 1];
		                    nextPoint = points[i + 1];
		                }
		            }

		            vec2.sub(v, nextPoint, prevPoint);

		            // use degree to scale the handle length
		            v2Scale(v, v, smooth);

		            var d0 = v2Distance(point, prevPoint);
		            var d1 = v2Distance(point, nextPoint);
		            var sum = d0 + d1;
		            if (sum !== 0) {
		                d0 /= sum;
		                d1 /= sum;
		            }

		            v2Scale(v1, v, -d0);
		            v2Scale(v2, v, d1);
		            var cp0 = v2Add([], point, v1);
		            var cp1 = v2Add([], point, v2);
		            if (constraint) {
		                v2Max(cp0, cp0, min);
		                v2Min(cp0, cp0, max);
		                v2Max(cp1, cp1, min);
		                v2Min(cp1, cp1, max);
		            }
		            cps.push(cp0);
		            cps.push(cp1);
		        }

		        if (isLoop) {
		            cps.push(cps.shift());
		        }

		        return cps;
		    };



	/***/ },
	/* 71 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module zrender/graphic/shape/Polyline
		 */


		    var polyHelper = __webpack_require__(68);

		    module.exports = __webpack_require__(45).extend({
		        
		        type: 'polyline',

		        shape: {
		            points: null,

		            smooth: false,

		            smoothConstraint: null
		        },

		        style: {
		            stroke: '#000',

		            fill: null
		        },

		        buildPath: function (ctx, shape) {
		            polyHelper.buildPath(ctx, shape, false);
		        }
		    });


	/***/ },
	/* 72 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 矩形
		 * @module zrender/graphic/shape/Rect
		 */


		    var roundRectHelper = __webpack_require__(73);

		    module.exports = __webpack_require__(45).extend({

		        type: 'rect',

		        shape: {
		            // 左上、右上、右下、左下角的半径依次为r1、r2、r3、r4
		            // r缩写为1         相当于 [1, 1, 1, 1]
		            // r缩写为[1]       相当于 [1, 1, 1, 1]
		            // r缩写为[1, 2]    相当于 [1, 2, 1, 2]
		            // r缩写为[1, 2, 3] 相当于 [1, 2, 3, 2]
		            r: 0,

		            x: 0,
		            y: 0,
		            width: 0,
		            height: 0
		        },

		        buildPath: function (ctx, shape) {
		            var x = shape.x;
		            var y = shape.y;
		            var width = shape.width;
		            var height = shape.height;
		            if (!shape.r) {
		                ctx.rect(x, y, width, height);
		            }
		            else {
		                roundRectHelper.buildPath(ctx, shape);
		            }
		            ctx.closePath();
		            return;
		        }
		    });



	/***/ },
	/* 73 */
	/***/ function(module, exports) {

		

		    module.exports = {
		        buildPath: function (ctx, shape) {
		            var x = shape.x;
		            var y = shape.y;
		            var width = shape.width;
		            var height = shape.height;
		            var r = shape.r;
		            var r1;
		            var r2;
		            var r3;
		            var r4;

		            // Convert width and height to positive for better borderRadius
		            if (width < 0) {
		                x = x + width;
		                width = -width;
		            }
		            if (height < 0) {
		                y = y + height;
		                height = -height;
		            }

		            if (typeof r === 'number') {
		                r1 = r2 = r3 = r4 = r;
		            }
		            else if (r instanceof Array) {
		                if (r.length === 1) {
		                    r1 = r2 = r3 = r4 = r[0];
		                }
		                else if (r.length === 2) {
		                    r1 = r3 = r[0];
		                    r2 = r4 = r[1];
		                }
		                else if (r.length === 3) {
		                    r1 = r[0];
		                    r2 = r4 = r[1];
		                    r3 = r[2];
		                }
		                else {
		                    r1 = r[0];
		                    r2 = r[1];
		                    r3 = r[2];
		                    r4 = r[3];
		                }
		            }
		            else {
		                r1 = r2 = r3 = r4 = 0;
		            }

		            var total;
		            if (r1 + r2 > width) {
		                total = r1 + r2;
		                r1 *= width / total;
		                r2 *= width / total;
		            }
		            if (r3 + r4 > width) {
		                total = r3 + r4;
		                r3 *= width / total;
		                r4 *= width / total;
		            }
		            if (r2 + r3 > height) {
		                total = r2 + r3;
		                r2 *= height / total;
		                r3 *= height / total;
		            }
		            if (r1 + r4 > height) {
		                total = r1 + r4;
		                r1 *= height / total;
		                r4 *= height / total;
		            }
		            ctx.moveTo(x + r1, y);
		            ctx.lineTo(x + width - r2, y);
		            r2 !== 0 && ctx.quadraticCurveTo(
		                x + width, y, x + width, y + r2
		            );
		            ctx.lineTo(x + width, y + height - r3);
		            r3 !== 0 && ctx.quadraticCurveTo(
		                x + width, y + height, x + width - r3, y + height
		            );
		            ctx.lineTo(x + r4, y + height);
		            r4 !== 0 && ctx.quadraticCurveTo(
		                x, y + height, x, y + height - r4
		            );
		            ctx.lineTo(x, y + r1);
		            r1 !== 0 && ctx.quadraticCurveTo(x, y, x + r1, y);
		        }
		    };


	/***/ },
	/* 74 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 直线
		 * @module zrender/graphic/shape/Line
		 */

		    module.exports = __webpack_require__(45).extend({

		        type: 'line',

		        shape: {
		            // Start point
		            x1: 0,
		            y1: 0,
		            // End point
		            x2: 0,
		            y2: 0,

		            percent: 1
		        },

		        style: {
		            stroke: '#000',
		            fill: null
		        },

		        buildPath: function (ctx, shape) {
		            var x1 = shape.x1;
		            var y1 = shape.y1;
		            var x2 = shape.x2;
		            var y2 = shape.y2;
		            var percent = shape.percent;

		            if (percent === 0) {
		                return;
		            }

		            ctx.moveTo(x1, y1);

		            if (percent < 1) {
		                x2 = x1 * (1 - percent) + x2 * percent;
		                y2 = y1 * (1 - percent) + y2 * percent;
		            }
		            ctx.lineTo(x2, y2);
		        },

		        /**
		         * Get point at percent
		         * @param  {number} percent
		         * @return {Array.<number>}
		         */
		        pointAt: function (p) {
		            var shape = this.shape;
		            return [
		                shape.x1 * (1 - p) + shape.x2 * p,
		                shape.y1 * (1 - p) + shape.y2 * p
		            ];
		        }
		    });



	/***/ },
	/* 75 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * 贝塞尔曲线
		 * @module zrender/shape/BezierCurve
		 */


		    var curveTool = __webpack_require__(50);
		    var vec2 = __webpack_require__(10);
		    var quadraticSubdivide = curveTool.quadraticSubdivide;
		    var cubicSubdivide = curveTool.cubicSubdivide;
		    var quadraticAt = curveTool.quadraticAt;
		    var cubicAt = curveTool.cubicAt;
		    var quadraticDerivativeAt = curveTool.quadraticDerivativeAt;
		    var cubicDerivativeAt = curveTool.cubicDerivativeAt;

		    var out = [];

		    function someVectorAt(shape, t, isTangent) {
		        var cpx2 = shape.cpx2;
		        var cpy2 = shape.cpy2;
		        if (cpx2 === null || cpy2 === null) {
		            return [
		                (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
		                (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
		            ];
		        }
		        else {
		            return [
		                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
		                (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
		            ];
		        }
		    }
		    module.exports = __webpack_require__(45).extend({

		        type: 'bezier-curve',

		        shape: {
		            x1: 0,
		            y1: 0,
		            x2: 0,
		            y2: 0,
		            cpx1: 0,
		            cpy1: 0,
		            // cpx2: 0,
		            // cpy2: 0

		            // Curve show percent, for animating
		            percent: 1
		        },

		        style: {
		            stroke: '#000',
		            fill: null
		        },

		        buildPath: function (ctx, shape) {
		            var x1 = shape.x1;
		            var y1 = shape.y1;
		            var x2 = shape.x2;
		            var y2 = shape.y2;
		            var cpx1 = shape.cpx1;
		            var cpy1 = shape.cpy1;
		            var cpx2 = shape.cpx2;
		            var cpy2 = shape.cpy2;
		            var percent = shape.percent;
		            if (percent === 0) {
		                return;
		            }

		            ctx.moveTo(x1, y1);

		            if (cpx2 == null || cpy2 == null) {
		                if (percent < 1) {
		                    quadraticSubdivide(
		                        x1, cpx1, x2, percent, out
		                    );
		                    cpx1 = out[1];
		                    x2 = out[2];
		                    quadraticSubdivide(
		                        y1, cpy1, y2, percent, out
		                    );
		                    cpy1 = out[1];
		                    y2 = out[2];
		                }

		                ctx.quadraticCurveTo(
		                    cpx1, cpy1,
		                    x2, y2
		                );
		            }
		            else {
		                if (percent < 1) {
		                    cubicSubdivide(
		                        x1, cpx1, cpx2, x2, percent, out
		                    );
		                    cpx1 = out[1];
		                    cpx2 = out[2];
		                    x2 = out[3];
		                    cubicSubdivide(
		                        y1, cpy1, cpy2, y2, percent, out
		                    );
		                    cpy1 = out[1];
		                    cpy2 = out[2];
		                    y2 = out[3];
		                }
		                ctx.bezierCurveTo(
		                    cpx1, cpy1,
		                    cpx2, cpy2,
		                    x2, y2
		                );
		            }
		        },

		        /**
		         * Get point at percent
		         * @param  {number} t
		         * @return {Array.<number>}
		         */
		        pointAt: function (t) {
		            return someVectorAt(this.shape, t, false);
		        },

		        /**
		         * Get tangent at percent
		         * @param  {number} t
		         * @return {Array.<number>}
		         */
		        tangentAt: function (t) {
		            var p = someVectorAt(this.shape, t, true);
		            return vec2.normalize(p, p);
		        }
		    });



	/***/ },
	/* 76 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * 圆弧
		 * @module zrender/graphic/shape/Arc
		 */
		 

		    module.exports = __webpack_require__(45).extend({

		        type: 'arc',

		        shape: {

		            cx: 0,

		            cy: 0,

		            r: 0,

		            startAngle: 0,

		            endAngle: Math.PI * 2,

		            clockwise: true
		        },

		        style: {

		            stroke: '#000',

		            fill: null
		        },

		        buildPath: function (ctx, shape) {

		            var x = shape.cx;
		            var y = shape.cy;
		            var r = Math.max(shape.r, 0);
		            var startAngle = shape.startAngle;
		            var endAngle = shape.endAngle;
		            var clockwise = shape.clockwise;

		            var unitX = Math.cos(startAngle);
		            var unitY = Math.sin(startAngle);

		            ctx.moveTo(unitX * r + x, unitY * r + y);
		            ctx.arc(x, y, r, startAngle, endAngle, !clockwise);
		        }
		    });


	/***/ },
	/* 77 */
	/***/ function(module, exports, __webpack_require__) {

		// CompoundPath to improve performance


		    var Path = __webpack_require__(45);
		    module.exports = Path.extend({

		        type: 'compound',

		        shape: {

		            paths: null
		        },

		        _updatePathDirty: function () {
		            var dirtyPath = this.__dirtyPath;
		            var paths = this.shape.paths;
		            for (var i = 0; i < paths.length; i++) {
		                // Mark as dirty if any subpath is dirty
		                dirtyPath = dirtyPath || paths[i].__dirtyPath;
		            }
		            this.__dirtyPath = dirtyPath;
		            this.__dirty = this.__dirty || dirtyPath;
		        },

		        beforeBrush: function () {
		            this._updatePathDirty();
		            var paths = this.shape.paths || [];
		            var scale = this.getGlobalScale();
		            // Update path scale
		            for (var i = 0; i < paths.length; i++) {
		                paths[i].path.setScale(scale[0], scale[1]);
		            }
		        },

		        buildPath: function (ctx, shape) {
		            var paths = shape.paths || [];
		            for (var i = 0; i < paths.length; i++) {
		                paths[i].buildPath(ctx, paths[i].shape, true);
		            }
		        },

		        afterBrush: function () {
		            var paths = this.shape.paths;
		            for (var i = 0; i < paths.length; i++) {
		                paths[i].__dirtyPath = false;
		            }
		        },

		        getBoundingRect: function () {
		            this._updatePathDirty();
		            return Path.prototype.getBoundingRect.call(this);
		        }
		    });


	/***/ },
	/* 78 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);

		    var Gradient = __webpack_require__(79);

		    /**
		     * x, y, x2, y2 are all percent from 0 to 1
		     * @param {number} [x=0]
		     * @param {number} [y=0]
		     * @param {number} [x2=1]
		     * @param {number} [y2=0]
		     * @param {Array.<Object>} colorStops
		     * @param {boolean} [globalCoord=false]
		     */
		    var LinearGradient = function (x, y, x2, y2, colorStops, globalCoord) {
		        this.x = x == null ? 0 : x;

		        this.y = y == null ? 0 : y;

		        this.x2 = x2 == null ? 1 : x2;

		        this.y2 = y2 == null ? 0 : y2;

		        // Can be cloned
		        this.type = 'linear';

		        // If use global coord
		        this.global = globalCoord || false;

		        Gradient.call(this, colorStops);
		    };

		    LinearGradient.prototype = {

		        constructor: LinearGradient
		    };

		    zrUtil.inherits(LinearGradient, Gradient);

		    module.exports = LinearGradient;


	/***/ },
	/* 79 */
	/***/ function(module, exports) {

		

		    /**
		     * @param {Array.<Object>} colorStops
		     */
		    var Gradient = function (colorStops) {

		        this.colorStops = colorStops || [];
		    };

		    Gradient.prototype = {

		        constructor: Gradient,

		        addColorStop: function (offset, color) {
		            this.colorStops.push({

		                offset: offset,

		                color: color
		            });
		        }
		    };

		    module.exports = Gradient;


	/***/ },
	/* 80 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);

		    var Gradient = __webpack_require__(79);

		    /**
		     * x, y, r are all percent from 0 to 1
		     * @param {number} [x=0.5]
		     * @param {number} [y=0.5]
		     * @param {number} [r=0.5]
		     * @param {Array.<Object>} [colorStops]
		     * @param {boolean} [globalCoord=false]
		     */
		    var RadialGradient = function (x, y, r, colorStops, globalCoord) {
		        this.x = x == null ? 0.5 : x;

		        this.y = y == null ? 0.5 : y;

		        this.r = r == null ? 0.5 : r;

		        // Can be cloned
		        this.type = 'radial';

		        // If use global coord
		        this.global = globalCoord || false;

		        Gradient.call(this, colorStops);
		    };

		    RadialGradient.prototype = {

		        constructor: RadialGradient
		    };

		    zrUtil.inherits(RadialGradient, Gradient);

		    module.exports = RadialGradient;


	/***/ },
	/* 81 */
	/***/ function(module, exports) {

		

		    var lib = {};

		    var ORIGIN_METHOD = '\0__throttleOriginMethod';
		    var RATE = '\0__throttleRate';
		    var THROTTLE_TYPE = '\0__throttleType';

		    /**
		     * @public
		     * @param {(Function)} fn
		     * @param {number} [delay=0] Unit: ms.
		     * @param {boolean} [debounce=false]
		     *        true: If call interval less than `delay`, only the last call works.
		     *        false: If call interval less than `delay, call works on fixed rate.
		     * @return {(Function)} throttled fn.
		     */
		    lib.throttle = function (fn, delay, debounce) {

		        var currCall;
		        var lastCall = 0;
		        var lastExec = 0;
		        var timer = null;
		        var diff;
		        var scope;
		        var args;

		        delay = delay || 0;

		        function exec() {
		            lastExec = (new Date()).getTime();
		            timer = null;
		            fn.apply(scope, args || []);
		        }

		        var cb = function () {
		            currCall = (new Date()).getTime();
		            scope = this;
		            args = arguments;
		            diff = currCall - (debounce ? lastCall : lastExec) - delay;

		            clearTimeout(timer);

		            if (debounce) {
		                timer = setTimeout(exec, delay);
		            }
		            else {
		                if (diff >= 0) {
		                    exec();
		                }
		                else {
		                    timer = setTimeout(exec, -diff);
		                }
		            }

		            lastCall = currCall;
		        };

		        /**
		         * Clear throttle.
		         * @public
		         */
		        cb.clear = function () {
		            if (timer) {
		                clearTimeout(timer);
		                timer = null;
		            }
		        };

		        return cb;
		    };

		    /**
		     * Create throttle method or update throttle rate.
		     *
		     * @example
		     * ComponentView.prototype.render = function () {
		     *     ...
		     *     throttle.createOrUpdate(
		     *         this,
		     *         '_dispatchAction',
		     *         this.model.get('throttle'),
		     *         'fixRate'
		     *     );
		     * };
		     * ComponentView.prototype.remove = function () {
		     *     throttle.clear(this, '_dispatchAction');
		     * };
		     * ComponentView.prototype.dispose = function () {
		     *     throttle.clear(this, '_dispatchAction');
		     * };
		     *
		     * @public
		     * @param {Object} obj
		     * @param {string} fnAttr
		     * @param {number} [rate]
		     * @param {string} [throttleType='fixRate'] 'fixRate' or 'debounce'
		     * @return {Function} throttled function.
		     */
		    lib.createOrUpdate = function (obj, fnAttr, rate, throttleType) {
		        var fn = obj[fnAttr];

		        if (!fn) {
		            return;
		        }

		        var originFn = fn[ORIGIN_METHOD] || fn;
		        var lastThrottleType = fn[THROTTLE_TYPE];
		        var lastRate = fn[RATE];

		        if (lastRate !== rate || lastThrottleType !== throttleType) {
		            if (rate == null || !throttleType) {
		                return (obj[fnAttr] = originFn);
		            }

		            fn = obj[fnAttr] = lib.throttle(
		                originFn, rate, throttleType === 'debounce'
		            );
		            fn[ORIGIN_METHOD] = originFn;
		            fn[THROTTLE_TYPE] = throttleType;
		            fn[RATE] = rate;
		        }

		        return fn;
		    };

		    /**
		     * Clear throttle. Example see throttle.createOrUpdate.
		     *
		     * @public
		     * @param {Object} obj
		     * @param {string} fnAttr
		     */
		    lib.clear = function (obj, fnAttr) {
		        var fn = obj[fnAttr];
		        if (fn && fn[ORIGIN_METHOD]) {
		            obj[fnAttr] = fn[ORIGIN_METHOD];
		        }
		    };

		    module.exports = lib;



	/***/ },
	/* 82 */
	/***/ function(module, exports, __webpack_require__) {

		/*!
		 * ZRender, a high performance 2d drawing library.
		 *
		 * Copyright (c) 2013, Baidu Inc.
		 * All rights reserved.
		 *
		 * LICENSE
		 * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
		 */
		// Global defines

		    var guid = __webpack_require__(32);
		    var env = __webpack_require__(2);
		    var zrUtil = __webpack_require__(4);

		    var Handler = __webpack_require__(83);
		    var Storage = __webpack_require__(85);
		    var Animation = __webpack_require__(87);
		    var HandlerProxy = __webpack_require__(90);

		    var useVML = !env.canvasSupported;

		    var painterCtors = {
		        canvas: __webpack_require__(92)
		    };

		    var instances = {};    // ZRender实例map索引

		    var zrender = {};

		    /**
		     * @type {string}
		     */
		    zrender.version = '3.2.2';

		    /**
		     * Initializing a zrender instance
		     * @param {HTMLElement} dom
		     * @param {Object} opts
		     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
		     * @param {number} [opts.devicePixelRatio]
		     * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
		     * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
		     * @return {module:zrender/ZRender}
		     */
		    zrender.init = function(dom, opts) {
		        var zr = new ZRender(guid(), dom, opts);
		        instances[zr.id] = zr;
		        return zr;
		    };

		    /**
		     * Dispose zrender instance
		     * @param {module:zrender/ZRender} zr
		     */
		    zrender.dispose = function (zr) {
		        if (zr) {
		            zr.dispose();
		        }
		        else {
		            for (var key in instances) {
		                if (instances.hasOwnProperty(key)) {
		                    instances[key].dispose();
		                }
		            }
		            instances = {};
		        }

		        return zrender;
		    };

		    /**
		     * Get zrender instance by id
		     * @param {string} id zrender instance id
		     * @return {module:zrender/ZRender}
		     */
		    zrender.getInstance = function (id) {
		        return instances[id];
		    };

		    zrender.registerPainter = function (name, Ctor) {
		        painterCtors[name] = Ctor;
		    };

		    function delInstance(id) {
		        delete instances[id];
		    }

		    /**
		     * @module zrender/ZRender
		     */
		    /**
		     * @constructor
		     * @alias module:zrender/ZRender
		     * @param {string} id
		     * @param {HTMLDomElement} dom
		     * @param {Object} opts
		     * @param {string} [opts.renderer='canvas'] 'canvas' or 'svg'
		     * @param {number} [opts.devicePixelRatio]
		     * @param {number} [opts.width] Can be 'auto' (the same as null/undefined)
		     * @param {number} [opts.height] Can be 'auto' (the same as null/undefined)
		     */
		    var ZRender = function(id, dom, opts) {

		        opts = opts || {};

		        /**
		         * @type {HTMLDomElement}
		         */
		        this.dom = dom;

		        /**
		         * @type {string}
		         */
		        this.id = id;

		        var self = this;
		        var storage = new Storage();

		        var rendererType = opts.renderer;
		        if (useVML) {
		            if (!painterCtors.vml) {
		                throw new Error('You need to require \'zrender/vml/vml\' to support IE8');
		            }
		            rendererType = 'vml';
		        }
		        else if (!rendererType || !painterCtors[rendererType]) {
		            rendererType = 'canvas';
		        }
		        var painter = new painterCtors[rendererType](dom, storage, opts);

		        this.storage = storage;
		        this.painter = painter;

		        var handerProxy = !env.node ? new HandlerProxy(painter.getViewportRoot()) : null;
		        this.handler = new Handler(storage, painter, handerProxy, painter.root);

		        /**
		         * @type {module:zrender/animation/Animation}
		         */
		        this.animation = new Animation({
		            stage: {
		                update: zrUtil.bind(this.flush, this)
		            }
		        });
		        this.animation.start();

		        /**
		         * @type {boolean}
		         * @private
		         */
		        this._needsRefresh;

		        // 修改 storage.delFromMap, 每次删除元素之前删除动画
		        // FIXME 有点ugly
		        var oldDelFromMap = storage.delFromMap;
		        var oldAddToMap = storage.addToMap;

		        storage.delFromMap = function (elId) {
		            var el = storage.get(elId);

		            oldDelFromMap.call(storage, elId);

		            el && el.removeSelfFromZr(self);
		        };

		        storage.addToMap = function (el) {
		            oldAddToMap.call(storage, el);

		            el.addSelfToZr(self);
		        };
		    };

		    ZRender.prototype = {

		        constructor: ZRender,
		        /**
		         * 获取实例唯一标识
		         * @return {string}
		         */
		        getId: function () {
		            return this.id;
		        },

		        /**
		         * 添加元素
		         * @param  {module:zrender/Element} el
		         */
		        add: function (el) {
		            this.storage.addRoot(el);
		            this._needsRefresh = true;
		        },

		        /**
		         * 删除元素
		         * @param  {module:zrender/Element} el
		         */
		        remove: function (el) {
		            this.storage.delRoot(el);
		            this._needsRefresh = true;
		        },

		        /**
		         * Change configuration of layer
		         * @param {string} zLevel
		         * @param {Object} config
		         * @param {string} [config.clearColor=0] Clear color
		         * @param {string} [config.motionBlur=false] If enable motion blur
		         * @param {number} [config.lastFrameAlpha=0.7] Motion blur factor. Larger value cause longer trailer
		        */
		        configLayer: function (zLevel, config) {
		            this.painter.configLayer(zLevel, config);
		            this._needsRefresh = true;
		        },

		        /**
		         * Repaint the canvas immediately
		         */
		        refreshImmediately: function () {
		            // Clear needsRefresh ahead to avoid something wrong happens in refresh
		            // Or it will cause zrender refreshes again and again.
		            this._needsRefresh = false;
		            this.painter.refresh();
		            /**
		             * Avoid trigger zr.refresh in Element#beforeUpdate hook
		             */
		            this._needsRefresh = false;
		        },

		        /**
		         * Mark and repaint the canvas in the next frame of browser
		         */
		        refresh: function() {
		            this._needsRefresh = true;
		        },

		        /**
		         * Perform all refresh
		         */
		        flush: function () {
		            if (this._needsRefresh) {
		                this.refreshImmediately();
		            }
		            if (this._needsRefreshHover) {
		                this.refreshHoverImmediately();
		            }
		        },

		        /**
		         * Add element to hover layer
		         * @param  {module:zrender/Element} el
		         * @param {Object} style
		         */
		        addHover: function (el, style) {
		            if (this.painter.addHover) {
		                this.painter.addHover(el, style);
		                this.refreshHover();
		            }
		        },

		        /**
		         * Add element from hover layer
		         * @param  {module:zrender/Element} el
		         */
		        removeHover: function (el) {
		            if (this.painter.removeHover) {
		                this.painter.removeHover(el);
		                this.refreshHover();
		            }
		        },

		        /**
		         * Clear all hover elements in hover layer
		         * @param  {module:zrender/Element} el
		         */
		        clearHover: function () {
		            if (this.painter.clearHover) {
		                this.painter.clearHover();
		                this.refreshHover();
		            }
		        },

		        /**
		         * Refresh hover in next frame
		         */
		        refreshHover: function () {
		            this._needsRefreshHover = true;
		        },

		        /**
		         * Refresh hover immediately
		         */
		        refreshHoverImmediately: function () {
		            this._needsRefreshHover = false;
		            this.painter.refreshHover && this.painter.refreshHover();
		        },

		        /**
		         * Resize the canvas.
		         * Should be invoked when container size is changed
		         * @param {Object} [opts]
		         * @param {number|string} [opts.width] Can be 'auto' (the same as null/undefined)
		         * @param {number|string} [opts.height] Can be 'auto' (the same as null/undefined)
		         */
		        resize: function(opts) {
		            opts = opts || {};
		            this.painter.resize(opts.width, opts.height);
		            this.handler.resize();
		        },

		        /**
		         * Stop and clear all animation immediately
		         */
		        clearAnimation: function () {
		            this.animation.clear();
		        },

		        /**
		         * Get container width
		         */
		        getWidth: function() {
		            return this.painter.getWidth();
		        },

		        /**
		         * Get container height
		         */
		        getHeight: function() {
		            return this.painter.getHeight();
		        },

		        /**
		         * Export the canvas as Base64 URL
		         * @param {string} type
		         * @param {string} [backgroundColor='#fff']
		         * @return {string} Base64 URL
		         */
		        // toDataURL: function(type, backgroundColor) {
		        //     return this.painter.getRenderedCanvas({
		        //         backgroundColor: backgroundColor
		        //     }).toDataURL(type);
		        // },

		        /**
		         * Converting a path to image.
		         * It has much better performance of drawing image rather than drawing a vector path.
		         * @param {module:zrender/graphic/Path} e
		         * @param {number} width
		         * @param {number} height
		         */
		        pathToImage: function(e, width, height) {
		            var id = guid();
		            return this.painter.pathToImage(id, e, width, height);
		        },

		        /**
		         * Set default cursor
		         * @param {string} [cursorStyle='default'] 例如 crosshair
		         */
		        setCursorStyle: function (cursorStyle) {
		            this.handler.setCursorStyle(cursorStyle);
		        },

		        /**
		         * Bind event
		         *
		         * @param {string} eventName Event name
		         * @param {Function} eventHandler Handler function
		         * @param {Object} [context] Context object
		         */
		        on: function(eventName, eventHandler, context) {
		            this.handler.on(eventName, eventHandler, context);
		        },

		        /**
		         * Unbind event
		         * @param {string} eventName Event name
		         * @param {Function} [eventHandler] Handler function
		         */
		        off: function(eventName, eventHandler) {
		            this.handler.off(eventName, eventHandler);
		        },

		        /**
		         * Trigger event manually
		         *
		         * @param {string} eventName Event name
		         * @param {event=} event Event object
		         */
		        trigger: function (eventName, event) {
		            this.handler.trigger(eventName, event);
		        },


		        /**
		         * Clear all objects and the canvas.
		         */
		        clear: function () {
		            this.storage.delRoot();
		            this.painter.clear();
		        },

		        /**
		         * Dispose self.
		         */
		        dispose: function () {
		            this.animation.stop();

		            this.clear();
		            this.storage.dispose();
		            this.painter.dispose();
		            this.handler.dispose();

		            this.animation =
		            this.storage =
		            this.painter =
		            this.handler = null;

		            delInstance(this.id);
		        }
		    };

		    module.exports = zrender;



	/***/ },
	/* 83 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * Handler
		 * @module zrender/Handler
		 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
		 *         errorrik (errorrik@gmail.com)
		 *         pissang (shenyi.914@gmail.com)
		 */


		    var util = __webpack_require__(4);
		    var Draggable = __webpack_require__(84);

		    var Eventful = __webpack_require__(33);

		    function makeEventPacket(eveType, target, event) {
		        return {
		            type: eveType,
		            event: event,
		            target: target,
		            cancelBubble: false,
		            offsetX: event.zrX,
		            offsetY: event.zrY,
		            gestureEvent: event.gestureEvent,
		            pinchX: event.pinchX,
		            pinchY: event.pinchY,
		            pinchScale: event.pinchScale,
		            wheelDelta: event.zrDelta,
		            zrByTouch: event.zrByTouch
		        };
		    }

		    function EmptyProxy () {}
		    EmptyProxy.prototype.dispose = function () {};

		    var handlerNames = [
		        'click', 'dblclick', 'mousewheel', 'mouseout',
		        'mouseup', 'mousedown', 'mousemove', 'contextmenu'
		    ];
		    /**
		     * @alias module:zrender/Handler
		     * @constructor
		     * @extends module:zrender/mixin/Eventful
		     * @param {module:zrender/Storage} storage Storage instance.
		     * @param {module:zrender/Painter} painter Painter instance.
		     * @param {module:zrender/dom/HandlerProxy} proxy HandlerProxy instance.
		     * @param {HTMLElement} painterRoot painter.root (not painter.getViewportRoot()).
		     */
		    var Handler = function(storage, painter, proxy, painterRoot) {
		        Eventful.call(this);

		        this.storage = storage;

		        this.painter = painter;

		        this.painterRoot = painterRoot;

		        proxy = proxy || new EmptyProxy();

		        /**
		         * Proxy of event. can be Dom, WebGLSurface, etc.
		         */
		        this.proxy = proxy;

		        // Attach handler
		        proxy.handler = this;

		        /**
		         * @private
		         * @type {boolean}
		         */
		        this._hovered;

		        /**
		         * @private
		         * @type {Date}
		         */
		        this._lastTouchMoment;

		        /**
		         * @private
		         * @type {number}
		         */
		        this._lastX;

		        /**
		         * @private
		         * @type {number}
		         */
		        this._lastY;


		        Draggable.call(this);

		        util.each(handlerNames, function (name) {
		            proxy.on && proxy.on(name, this[name], this);
		        }, this);
		    };

		    Handler.prototype = {

		        constructor: Handler,

		        mousemove: function (event) {
		            var x = event.zrX;
		            var y = event.zrY;

		            var hovered = this.findHover(x, y, null);
		            var lastHovered = this._hovered;
		            var proxy = this.proxy;

		            this._hovered = hovered;

		            proxy.setCursor && proxy.setCursor(hovered ? hovered.cursor : 'default');

		            // Mouse out on previous hovered element
		            if (lastHovered && hovered !== lastHovered && lastHovered.__zr) {
		                this.dispatchToElement(lastHovered, 'mouseout', event);
		            }

		            // Mouse moving on one element
		            this.dispatchToElement(hovered, 'mousemove', event);

		            // Mouse over on a new element
		            if (hovered && hovered !== lastHovered) {
		                this.dispatchToElement(hovered, 'mouseover', event);
		            }
		        },

		        mouseout: function (event) {
		            this.dispatchToElement(this._hovered, 'mouseout', event);

		            // There might be some doms created by upper layer application
		            // at the same level of painter.getViewportRoot() (e.g., tooltip
		            // dom created by echarts), where 'globalout' event should not
		            // be triggered when mouse enters these doms. (But 'mouseout'
		            // should be triggered at the original hovered element as usual).
		            var element = event.toElement || event.relatedTarget;
		            var innerDom;
		            do {
		                element = element && element.parentNode;
		            }
		            while (element && element.nodeType != 9 && !(
		                innerDom = element === this.painterRoot
		            ));

		            !innerDom && this.trigger('globalout', {event: event});
		        },

		        /**
		         * Resize
		         */
		        resize: function (event) {
		            this._hovered = null;
		        },

		        /**
		         * Dispatch event
		         * @param {string} eventName
		         * @param {event=} eventArgs
		         */
		        dispatch: function (eventName, eventArgs) {
		            var handler = this[eventName];
		            handler && handler.call(this, eventArgs);
		        },

		        /**
		         * Dispose
		         */
		        dispose: function () {

		            this.proxy.dispose();

		            this.storage =
		            this.proxy =
		            this.painter = null;
		        },

		        /**
		         * 设置默认的cursor style
		         * @param {string} [cursorStyle='default'] 例如 crosshair
		         */
		        setCursorStyle: function (cursorStyle) {
		            var proxy = this.proxy;
		            proxy.setCursor && proxy.setCursor(cursorStyle);
		        },

		        /**
		         * 事件分发代理
		         *
		         * @private
		         * @param {Object} targetEl 目标图形元素
		         * @param {string} eventName 事件名称
		         * @param {Object} event 事件对象
		         */
		        dispatchToElement: function (targetEl, eventName, event) {
		            var eventHandler = 'on' + eventName;
		            var eventPacket = makeEventPacket(eventName, targetEl, event);

		            var el = targetEl;

		            while (el) {
		                el[eventHandler]
		                    && (eventPacket.cancelBubble = el[eventHandler].call(el, eventPacket));

		                el.trigger(eventName, eventPacket);

		                el = el.parent;

		                if (eventPacket.cancelBubble) {
		                    break;
		                }
		            }

		            if (!eventPacket.cancelBubble) {
		                // 冒泡到顶级 zrender 对象
		                this.trigger(eventName, eventPacket);
		                // 分发事件到用户自定义层
		                // 用户有可能在全局 click 事件中 dispose，所以需要判断下 painter 是否存在
		                this.painter && this.painter.eachOtherLayer(function (layer) {
		                    if (typeof(layer[eventHandler]) == 'function') {
		                        layer[eventHandler].call(layer, eventPacket);
		                    }
		                    if (layer.trigger) {
		                        layer.trigger(eventName, eventPacket);
		                    }
		                });
		            }
		        },

		        /**
		         * @private
		         * @param {number} x
		         * @param {number} y
		         * @param {module:zrender/graphic/Displayable} exclude
		         * @method
		         */
		        findHover: function(x, y, exclude) {
		            var list = this.storage.getDisplayList();
		            for (var i = list.length - 1; i >= 0 ; i--) {
		                if (!list[i].silent
		                 && list[i] !== exclude
		                 // getDisplayList may include ignored item in VML mode
		                 && !list[i].ignore
		                 && isHover(list[i], x, y)) {
		                    return list[i];
		                }
		            }
		        }
		    };

		    // Common handlers
		    util.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
		        Handler.prototype[name] = function (event) {
		            // Find hover again to avoid click event is dispatched manually. Or click is triggered without mouseover
		            var hovered = this.findHover(event.zrX, event.zrY, null);

		            if (name === 'mousedown') {
		                this._downel = hovered;
		                // In case click triggered before mouseup
		                this._upel = hovered;
		            }
		            else if (name === 'mosueup') {
		                this._upel = hovered;
		            }
		            else if (name === 'click') {
		                if (this._downel !== this._upel) {
		                    return;
		                }
		            }

		            this.dispatchToElement(hovered, name, event);
		        };
		    });

		    function isHover(displayable, x, y) {
		        if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
		            var el = displayable;
		            while (el) {
		                // If ancestor is silent or clipped by ancestor
		                if (el.silent || (el.clipPath && !el.clipPath.contain(x, y)))  {
		                    return false;
		                }
		                el = el.parent;
		            }
		            return true;
		        }

		        return false;
		    }

		    util.mixin(Handler, Eventful);
		    util.mixin(Handler, Draggable);

		    module.exports = Handler;


	/***/ },
	/* 84 */
	/***/ function(module, exports) {

		// TODO Draggable for group
		// FIXME Draggable on element which has parent rotation or scale

		    function Draggable() {

		        this.on('mousedown', this._dragStart, this);
		        this.on('mousemove', this._drag, this);
		        this.on('mouseup', this._dragEnd, this);
		        this.on('globalout', this._dragEnd, this);
		        // this._dropTarget = null;
		        // this._draggingTarget = null;

		        // this._x = 0;
		        // this._y = 0;
		    }

		    Draggable.prototype = {

		        constructor: Draggable,

		        _dragStart: function (e) {
		            var draggingTarget = e.target;
		            if (draggingTarget && draggingTarget.draggable) {
		                this._draggingTarget = draggingTarget;
		                draggingTarget.dragging = true;
		                this._x = e.offsetX;
		                this._y = e.offsetY;

		                this.dispatchToElement(draggingTarget, 'dragstart', e.event);
		            }
		        },

		        _drag: function (e) {
		            var draggingTarget = this._draggingTarget;
		            if (draggingTarget) {

		                var x = e.offsetX;
		                var y = e.offsetY;

		                var dx = x - this._x;
		                var dy = y - this._y;
		                this._x = x;
		                this._y = y;

		                draggingTarget.drift(dx, dy, e);
		                this.dispatchToElement(draggingTarget, 'drag', e.event);

		                var dropTarget = this.findHover(x, y, draggingTarget);
		                var lastDropTarget = this._dropTarget;
		                this._dropTarget = dropTarget;

		                if (draggingTarget !== dropTarget) {
		                    if (lastDropTarget && dropTarget !== lastDropTarget) {
		                        this.dispatchToElement(lastDropTarget, 'dragleave', e.event);
		                    }
		                    if (dropTarget && dropTarget !== lastDropTarget) {
		                        this.dispatchToElement(dropTarget, 'dragenter', e.event);
		                    }
		                }
		            }
		        },

		        _dragEnd: function (e) {
		            var draggingTarget = this._draggingTarget;

		            if (draggingTarget) {
		                draggingTarget.dragging = false;
		            }

		            this.dispatchToElement(draggingTarget, 'dragend', e.event);

		            if (this._dropTarget) {
		                this.dispatchToElement(this._dropTarget, 'drop', e.event);
		            }

		            this._draggingTarget = null;
		            this._dropTarget = null;
		        }

		    };

		    module.exports = Draggable;


	/***/ },
	/* 85 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * Storage内容仓库模块
		 * @module zrender/Storage
		 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
		 * @author errorrik (errorrik@gmail.com)
		 * @author pissang (https://github.com/pissang/)
		 */


		    var util = __webpack_require__(4);
		    var env = __webpack_require__(2);

		    var Group = __webpack_require__(30);

		    // Use timsort because in most case elements are partially sorted
		    // https://jsfiddle.net/pissang/jr4x7mdm/8/
		    var timsort = __webpack_require__(86);

		    function shapeCompareFunc(a, b) {
		        if (a.zlevel === b.zlevel) {
		            if (a.z === b.z) {
		                // if (a.z2 === b.z2) {
		                //     // FIXME Slow has renderidx compare
		                //     // http://stackoverflow.com/questions/20883421/sorting-in-javascript-should-every-compare-function-have-a-return-0-statement
		                //     // https://github.com/v8/v8/blob/47cce544a31ed5577ffe2963f67acb4144ee0232/src/js/array.js#L1012
		                //     return a.__renderidx - b.__renderidx;
		                // }
		                return a.z2 - b.z2;
		            }
		            return a.z - b.z;
		        }
		        return a.zlevel - b.zlevel;
		    }
		    /**
		     * 内容仓库 (M)
		     * @alias module:zrender/Storage
		     * @constructor
		     */
		    var Storage = function () {
		        // 所有常规形状，id索引的map
		        this._elements = {};

		        this._roots = [];

		        this._displayList = [];

		        this._displayListLen = 0;
		    };

		    Storage.prototype = {

		        constructor: Storage,

		        /**
		         * @param  {Function} cb
		         *
		         */
		        traverse: function (cb, context) {
		            for (var i = 0; i < this._roots.length; i++) {
		                this._roots[i].traverse(cb, context);
		            }
		        },

		        /**
		         * 返回所有图形的绘制队列
		         * @param {boolean} [update=false] 是否在返回前更新该数组
		         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组, 在 update 为 true 的时候有效
		         *
		         * 详见{@link module:zrender/graphic/Displayable.prototype.updateDisplayList}
		         * @return {Array.<module:zrender/graphic/Displayable>}
		         */
		        getDisplayList: function (update, includeIgnore) {
		            includeIgnore = includeIgnore || false;
		            if (update) {
		                this.updateDisplayList(includeIgnore);
		            }
		            return this._displayList;
		        },

		        /**
		         * 更新图形的绘制队列。
		         * 每次绘制前都会调用，该方法会先深度优先遍历整个树，更新所有Group和Shape的变换并且把所有可见的Shape保存到数组中，
		         * 最后根据绘制的优先级（zlevel > z > 插入顺序）排序得到绘制队列
		         * @param {boolean} [includeIgnore=false] 是否包含 ignore 的数组
		         */
		        updateDisplayList: function (includeIgnore) {
		            this._displayListLen = 0;
		            var roots = this._roots;
		            var displayList = this._displayList;
		            for (var i = 0, len = roots.length; i < len; i++) {
		                this._updateAndAddDisplayable(roots[i], null, includeIgnore);
		            }
		            displayList.length = this._displayListLen;

		            // for (var i = 0, len = displayList.length; i < len; i++) {
		            //     displayList[i].__renderidx = i;
		            // }

		            // displayList.sort(shapeCompareFunc);
		            env.canvasSupported && timsort(displayList, shapeCompareFunc);
		        },

		        _updateAndAddDisplayable: function (el, clipPaths, includeIgnore) {

		            if (el.ignore && !includeIgnore) {
		                return;
		            }

		            el.beforeUpdate();

		            if (el.__dirty) {

		                el.update();

		            }

		            el.afterUpdate();

		            var clipPath = el.clipPath;
		            if (clipPath) {
		                // clipPath 的变换是基于 group 的变换
		                clipPath.parent = el;
		                clipPath.updateTransform();

		                // FIXME 效率影响
		                if (clipPaths) {
		                    clipPaths = clipPaths.slice();
		                    clipPaths.push(clipPath);
		                }
		                else {
		                    clipPaths = [clipPath];
		                }
		            }

		            if (el.isGroup) {
		                var children = el._children;

		                for (var i = 0; i < children.length; i++) {
		                    var child = children[i];

		                    // Force to mark as dirty if group is dirty
		                    // FIXME __dirtyPath ?
		                    if (el.__dirty) {
		                        child.__dirty = true;
		                    }

		                    this._updateAndAddDisplayable(child, clipPaths, includeIgnore);
		                }

		                // Mark group clean here
		                el.__dirty = false;

		            }
		            else {
		                el.__clipPaths = clipPaths;

		                this._displayList[this._displayListLen++] = el;
		            }
		        },

		        /**
		         * 添加图形(Shape)或者组(Group)到根节点
		         * @param {module:zrender/Element} el
		         */
		        addRoot: function (el) {
		            // Element has been added
		            if (this._elements[el.id]) {
		                return;
		            }

		            if (el instanceof Group) {
		                el.addChildrenToStorage(this);
		            }

		            this.addToMap(el);
		            this._roots.push(el);
		        },

		        /**
		         * 删除指定的图形(Shape)或者组(Group)
		         * @param {string|Array.<string>} [elId] 如果为空清空整个Storage
		         */
		        delRoot: function (elId) {
		            if (elId == null) {
		                // 不指定elId清空
		                for (var i = 0; i < this._roots.length; i++) {
		                    var root = this._roots[i];
		                    if (root instanceof Group) {
		                        root.delChildrenFromStorage(this);
		                    }
		                }

		                this._elements = {};
		                this._roots = [];
		                this._displayList = [];
		                this._displayListLen = 0;

		                return;
		            }

		            if (elId instanceof Array) {
		                for (var i = 0, l = elId.length; i < l; i++) {
		                    this.delRoot(elId[i]);
		                }
		                return;
		            }

		            var el;
		            if (typeof(elId) == 'string') {
		                el = this._elements[elId];
		            }
		            else {
		                el = elId;
		            }

		            var idx = util.indexOf(this._roots, el);
		            if (idx >= 0) {
		                this.delFromMap(el.id);
		                this._roots.splice(idx, 1);
		                if (el instanceof Group) {
		                    el.delChildrenFromStorage(this);
		                }
		            }
		        },

		        addToMap: function (el) {
		            if (el instanceof Group) {
		                el.__storage = this;
		            }
		            el.dirty(false);

		            this._elements[el.id] = el;

		            return this;
		        },

		        get: function (elId) {
		            return this._elements[elId];
		        },

		        delFromMap: function (elId) {
		            var elements = this._elements;
		            var el = elements[elId];
		            if (el) {
		                delete elements[elId];
		                if (el instanceof Group) {
		                    el.__storage = null;
		                }
		            }

		            return this;
		        },

		        /**
		         * 清空并且释放Storage
		         */
		        dispose: function () {
		            this._elements =
		            this._renderList =
		            this._roots = null;
		        },

		        displayableSortFunc: shapeCompareFunc
		    };

		    module.exports = Storage;



	/***/ },
	/* 86 */
	/***/ function(module, exports) {

		// https://github.com/mziccard/node-timsort

		    var DEFAULT_MIN_MERGE = 32;

		    var DEFAULT_MIN_GALLOPING = 7;

		    var DEFAULT_TMP_STORAGE_LENGTH = 256;

		    function minRunLength(n) {
		        var r = 0;

		        while (n >= DEFAULT_MIN_MERGE) {
		            r |= n & 1;
		            n >>= 1;
		        }

		        return n + r;
		    }

		    function makeAscendingRun(array, lo, hi, compare) {
		        var runHi = lo + 1;

		        if (runHi === hi) {
		            return 1;
		        }

		        if (compare(array[runHi++], array[lo]) < 0) {
		            while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
		                runHi++;
		            }

		            reverseRun(array, lo, runHi);
		        }
		        else {
		            while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
		                runHi++;
		            }
		        }

		        return runHi - lo;
		    }

		    function reverseRun(array, lo, hi) {
		        hi--;

		        while (lo < hi) {
		            var t = array[lo];
		            array[lo++] = array[hi];
		            array[hi--] = t;
		        }
		    }

		    function binaryInsertionSort(array, lo, hi, start, compare) {
		        if (start === lo) {
		            start++;
		        }

		        for (; start < hi; start++) {
		            var pivot = array[start];

		            var left = lo;
		            var right = start;
		            var mid;

		            while (left < right) {
		                mid = left + right >>> 1;

		                if (compare(pivot, array[mid]) < 0) {
		                    right = mid;
		                }
		                else {
		                    left = mid + 1;
		                }
		            }

		            var n = start - left;

		            switch (n) {
		                case 3:
		                    array[left + 3] = array[left + 2];

		                case 2:
		                    array[left + 2] = array[left + 1];

		                case 1:
		                    array[left + 1] = array[left];
		                    break;
		                default:
		                    while (n > 0) {
		                        array[left + n] = array[left + n - 1];
		                        n--;
		                    }
		            }

		            array[left] = pivot;
		        }
		    }

		    function gallopLeft(value, array, start, length, hint, compare) {
		        var lastOffset = 0;
		        var maxOffset = 0;
		        var offset = 1;

		        if (compare(value, array[start + hint]) > 0) {
		            maxOffset = length - hint;

		            while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
		                lastOffset = offset;
		                offset = (offset << 1) + 1;

		                if (offset <= 0) {
		                    offset = maxOffset;
		                }
		            }

		            if (offset > maxOffset) {
		                offset = maxOffset;
		            }

		            lastOffset += hint;
		            offset += hint;
		        }
		        else {
		            maxOffset = hint + 1;
		            while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
		                lastOffset = offset;
		                offset = (offset << 1) + 1;

		                if (offset <= 0) {
		                    offset = maxOffset;
		                }
		            }
		            if (offset > maxOffset) {
		                offset = maxOffset;
		            }

		            var tmp = lastOffset;
		            lastOffset = hint - offset;
		            offset = hint - tmp;
		        }

		        lastOffset++;
		        while (lastOffset < offset) {
		            var m = lastOffset + (offset - lastOffset >>> 1);

		            if (compare(value, array[start + m]) > 0) {
		                lastOffset = m + 1;
		            }
		            else {
		                offset = m;
		            }
		        }
		        return offset;
		    }

		    function gallopRight(value, array, start, length, hint, compare) {
		        var lastOffset = 0;
		        var maxOffset = 0;
		        var offset = 1;

		        if (compare(value, array[start + hint]) < 0) {
		            maxOffset = hint + 1;

		            while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
		                lastOffset = offset;
		                offset = (offset << 1) + 1;

		                if (offset <= 0) {
		                    offset = maxOffset;
		                }
		            }

		            if (offset > maxOffset) {
		                offset = maxOffset;
		            }

		            var tmp = lastOffset;
		            lastOffset = hint - offset;
		            offset = hint - tmp;
		        }
		        else {
		            maxOffset = length - hint;

		            while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
		                lastOffset = offset;
		                offset = (offset << 1) + 1;

		                if (offset <= 0) {
		                    offset = maxOffset;
		                }
		            }

		            if (offset > maxOffset) {
		                offset = maxOffset;
		            }

		            lastOffset += hint;
		            offset += hint;
		        }

		        lastOffset++;

		        while (lastOffset < offset) {
		            var m = lastOffset + (offset - lastOffset >>> 1);

		            if (compare(value, array[start + m]) < 0) {
		                offset = m;
		            }
		            else {
		                lastOffset = m + 1;
		            }
		        }

		        return offset;
		    }

		    function TimSort(array, compare) {
		        var minGallop = DEFAULT_MIN_GALLOPING;
		        var length = 0;
		        var tmpStorageLength = DEFAULT_TMP_STORAGE_LENGTH;
		        var stackLength = 0;
		        var runStart;
		        var runLength;
		        var stackSize = 0;

		        length = array.length;

		        if (length < 2 * DEFAULT_TMP_STORAGE_LENGTH) {
		            tmpStorageLength = length >>> 1;
		        }

		        var tmp = [];

		        stackLength = length < 120 ? 5 : length < 1542 ? 10 : length < 119151 ? 19 : 40;

		        runStart = [];
		        runLength = [];

		        function pushRun(_runStart, _runLength) {
		            runStart[stackSize] = _runStart;
		            runLength[stackSize] = _runLength;
		            stackSize += 1;
		        }

		        function mergeRuns() {
		            while (stackSize > 1) {
		                var n = stackSize - 2;

		                if (n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1] || n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1]) {
		                    if (runLength[n - 1] < runLength[n + 1]) {
		                        n--;
		                    }
		                }
		                else if (runLength[n] > runLength[n + 1]) {
		                    break;
		                }
		                mergeAt(n);
		            }
		        }

		        function forceMergeRuns() {
		            while (stackSize > 1) {
		                var n = stackSize - 2;

		                if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
		                    n--;
		                }

		                mergeAt(n);
		            }
		        }

		        function mergeAt(i) {
		            var start1 = runStart[i];
		            var length1 = runLength[i];
		            var start2 = runStart[i + 1];
		            var length2 = runLength[i + 1];

		            runLength[i] = length1 + length2;

		            if (i === stackSize - 3) {
		                runStart[i + 1] = runStart[i + 2];
		                runLength[i + 1] = runLength[i + 2];
		            }

		            stackSize--;

		            var k = gallopRight(array[start2], array, start1, length1, 0, compare);
		            start1 += k;
		            length1 -= k;

		            if (length1 === 0) {
		                return;
		            }

		            length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare);

		            if (length2 === 0) {
		                return;
		            }

		            if (length1 <= length2) {
		                mergeLow(start1, length1, start2, length2);
		            }
		            else {
		                mergeHigh(start1, length1, start2, length2);
		            }
		        }

		        function mergeLow(start1, length1, start2, length2) {
		            var i = 0;

		            for (i = 0; i < length1; i++) {
		                tmp[i] = array[start1 + i];
		            }

		            var cursor1 = 0;
		            var cursor2 = start2;
		            var dest = start1;

		            array[dest++] = array[cursor2++];

		            if (--length2 === 0) {
		                for (i = 0; i < length1; i++) {
		                    array[dest + i] = tmp[cursor1 + i];
		                }
		                return;
		            }

		            if (length1 === 1) {
		                for (i = 0; i < length2; i++) {
		                    array[dest + i] = array[cursor2 + i];
		                }
		                array[dest + length2] = tmp[cursor1];
		                return;
		            }

		            var _minGallop = minGallop;
		            var count1, count2, exit;

		            while (1) {
		                count1 = 0;
		                count2 = 0;
		                exit = false;

		                do {
		                    if (compare(array[cursor2], tmp[cursor1]) < 0) {
		                        array[dest++] = array[cursor2++];
		                        count2++;
		                        count1 = 0;

		                        if (--length2 === 0) {
		                            exit = true;
		                            break;
		                        }
		                    }
		                    else {
		                        array[dest++] = tmp[cursor1++];
		                        count1++;
		                        count2 = 0;
		                        if (--length1 === 1) {
		                            exit = true;
		                            break;
		                        }
		                    }
		                } while ((count1 | count2) < _minGallop);

		                if (exit) {
		                    break;
		                }

		                do {
		                    count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare);

		                    if (count1 !== 0) {
		                        for (i = 0; i < count1; i++) {
		                            array[dest + i] = tmp[cursor1 + i];
		                        }

		                        dest += count1;
		                        cursor1 += count1;
		                        length1 -= count1;
		                        if (length1 <= 1) {
		                            exit = true;
		                            break;
		                        }
		                    }

		                    array[dest++] = array[cursor2++];

		                    if (--length2 === 0) {
		                        exit = true;
		                        break;
		                    }

		                    count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare);

		                    if (count2 !== 0) {
		                        for (i = 0; i < count2; i++) {
		                            array[dest + i] = array[cursor2 + i];
		                        }

		                        dest += count2;
		                        cursor2 += count2;
		                        length2 -= count2;

		                        if (length2 === 0) {
		                            exit = true;
		                            break;
		                        }
		                    }
		                    array[dest++] = tmp[cursor1++];

		                    if (--length1 === 1) {
		                        exit = true;
		                        break;
		                    }

		                    _minGallop--;
		                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

		                if (exit) {
		                    break;
		                }

		                if (_minGallop < 0) {
		                    _minGallop = 0;
		                }

		                _minGallop += 2;
		            }

		            minGallop = _minGallop;

		            minGallop < 1 && (minGallop = 1);

		            if (length1 === 1) {
		                for (i = 0; i < length2; i++) {
		                    array[dest + i] = array[cursor2 + i];
		                }
		                array[dest + length2] = tmp[cursor1];
		            }
		            else if (length1 === 0) {
		                throw new Error();
		                // throw new Error('mergeLow preconditions were not respected');
		            }
		            else {
		                for (i = 0; i < length1; i++) {
		                    array[dest + i] = tmp[cursor1 + i];
		                }
		            }
		        }

		        function mergeHigh (start1, length1, start2, length2) {
		            var i = 0;

		            for (i = 0; i < length2; i++) {
		                tmp[i] = array[start2 + i];
		            }

		            var cursor1 = start1 + length1 - 1;
		            var cursor2 = length2 - 1;
		            var dest = start2 + length2 - 1;
		            var customCursor = 0;
		            var customDest = 0;

		            array[dest--] = array[cursor1--];

		            if (--length1 === 0) {
		                customCursor = dest - (length2 - 1);

		                for (i = 0; i < length2; i++) {
		                    array[customCursor + i] = tmp[i];
		                }

		                return;
		            }

		            if (length2 === 1) {
		                dest -= length1;
		                cursor1 -= length1;
		                customDest = dest + 1;
		                customCursor = cursor1 + 1;

		                for (i = length1 - 1; i >= 0; i--) {
		                    array[customDest + i] = array[customCursor + i];
		                }

		                array[dest] = tmp[cursor2];
		                return;
		            }

		            var _minGallop = minGallop;

		            while (true) {
		                var count1 = 0;
		                var count2 = 0;
		                var exit = false;

		                do {
		                    if (compare(tmp[cursor2], array[cursor1]) < 0) {
		                        array[dest--] = array[cursor1--];
		                        count1++;
		                        count2 = 0;
		                        if (--length1 === 0) {
		                            exit = true;
		                            break;
		                        }
		                    }
		                    else {
		                        array[dest--] = tmp[cursor2--];
		                        count2++;
		                        count1 = 0;
		                        if (--length2 === 1) {
		                            exit = true;
		                            break;
		                        }
		                    }
		                } while ((count1 | count2) < _minGallop);

		                if (exit) {
		                    break;
		                }

		                do {
		                    count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare);

		                    if (count1 !== 0) {
		                        dest -= count1;
		                        cursor1 -= count1;
		                        length1 -= count1;
		                        customDest = dest + 1;
		                        customCursor = cursor1 + 1;

		                        for (i = count1 - 1; i >= 0; i--) {
		                            array[customDest + i] = array[customCursor + i];
		                        }

		                        if (length1 === 0) {
		                            exit = true;
		                            break;
		                        }
		                    }

		                    array[dest--] = tmp[cursor2--];

		                    if (--length2 === 1) {
		                        exit = true;
		                        break;
		                    }

		                    count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare);

		                    if (count2 !== 0) {
		                        dest -= count2;
		                        cursor2 -= count2;
		                        length2 -= count2;
		                        customDest = dest + 1;
		                        customCursor = cursor2 + 1;

		                        for (i = 0; i < count2; i++) {
		                            array[customDest + i] = tmp[customCursor + i];
		                        }

		                        if (length2 <= 1) {
		                            exit = true;
		                            break;
		                        }
		                    }

		                    array[dest--] = array[cursor1--];

		                    if (--length1 === 0) {
		                        exit = true;
		                        break;
		                    }

		                    _minGallop--;
		                } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING);

		                if (exit) {
		                    break;
		                }

		                if (_minGallop < 0) {
		                    _minGallop = 0;
		                }

		                _minGallop += 2;
		            }

		            minGallop = _minGallop;

		            if (minGallop < 1) {
		                minGallop = 1;
		            }

		            if (length2 === 1) {
		                dest -= length1;
		                cursor1 -= length1;
		                customDest = dest + 1;
		                customCursor = cursor1 + 1;

		                for (i = length1 - 1; i >= 0; i--) {
		                    array[customDest + i] = array[customCursor + i];
		                }

		                array[dest] = tmp[cursor2];
		            }
		            else if (length2 === 0) {
		                throw new Error();
		                // throw new Error('mergeHigh preconditions were not respected');
		            }
		            else {
		                customCursor = dest - (length2 - 1);
		                for (i = 0; i < length2; i++) {
		                    array[customCursor + i] = tmp[i];
		                }
		            }
		        }

		        this.mergeRuns = mergeRuns;
		        this.forceMergeRuns = forceMergeRuns;
		        this.pushRun = pushRun;
		    }

		    function sort(array, compare, lo, hi) {
		        if (!lo) {
		            lo = 0;
		        }
		        if (!hi) {
		            hi = array.length;
		        }

		        var remaining = hi - lo;

		        if (remaining < 2) {
		            return;
		        }

		        var runLength = 0;

		        if (remaining < DEFAULT_MIN_MERGE) {
		            runLength = makeAscendingRun(array, lo, hi, compare);
		            binaryInsertionSort(array, lo, hi, lo + runLength, compare);
		            return;
		        }

		        var ts = new TimSort(array, compare);

		        var minRun = minRunLength(remaining);

		        do {
		            runLength = makeAscendingRun(array, lo, hi, compare);
		            if (runLength < minRun) {
		                var force = remaining;
		                if (force > minRun) {
		                    force = minRun;
		                }

		                binaryInsertionSort(array, lo, lo + force, lo + runLength, compare);
		                runLength = force;
		            }

		            ts.pushRun(lo, runLength);
		            ts.mergeRuns();

		            remaining -= runLength;
		            lo += runLength;
		        } while (remaining !== 0);

		        ts.forceMergeRuns();
		    }

		    module.exports = sort;


	/***/ },
	/* 87 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * 动画主类, 调度和管理所有动画控制器
		 *
		 * @module zrender/animation/Animation
		 * @author pissang(https://github.com/pissang)
		 */
		// TODO Additive animation
		// http://iosoteric.com/additive-animations-animatewithduration-in-ios-8/
		// https://developer.apple.com/videos/wwdc2014/#236


		    var util = __webpack_require__(4);
		    var Dispatcher = __webpack_require__(88).Dispatcher;

		    var requestAnimationFrame = __webpack_require__(89);

		    var Animator = __webpack_require__(36);
		    /**
		     * @typedef {Object} IZRenderStage
		     * @property {Function} update
		     */

		    /**
		     * @alias module:zrender/animation/Animation
		     * @constructor
		     * @param {Object} [options]
		     * @param {Function} [options.onframe]
		     * @param {IZRenderStage} [options.stage]
		     * @example
		     *     var animation = new Animation();
		     *     var obj = {
		     *         x: 100,
		     *         y: 100
		     *     };
		     *     animation.animate(node.position)
		     *         .when(1000, {
		     *             x: 500,
		     *             y: 500
		     *         })
		     *         .when(2000, {
		     *             x: 100,
		     *             y: 100
		     *         })
		     *         .start('spline');
		     */
		    var Animation = function (options) {

		        options = options || {};

		        this.stage = options.stage || {};

		        this.onframe = options.onframe || function() {};

		        // private properties
		        this._clips = [];

		        this._running = false;

		        this._time;

		        this._pausedTime;

		        this._pauseStart;

		        this._paused = false;

		        Dispatcher.call(this);
		    };

		    Animation.prototype = {

		        constructor: Animation,
		        /**
		         * 添加 clip
		         * @param {module:zrender/animation/Clip} clip
		         */
		        addClip: function (clip) {
		            this._clips.push(clip);
		        },
		        /**
		         * 添加 animator
		         * @param {module:zrender/animation/Animator} animator
		         */
		        addAnimator: function (animator) {
		            animator.animation = this;
		            var clips = animator.getClips();
		            for (var i = 0; i < clips.length; i++) {
		                this.addClip(clips[i]);
		            }
		        },
		        /**
		         * 删除动画片段
		         * @param {module:zrender/animation/Clip} clip
		         */
		        removeClip: function(clip) {
		            var idx = util.indexOf(this._clips, clip);
		            if (idx >= 0) {
		                this._clips.splice(idx, 1);
		            }
		        },

		        /**
		         * 删除动画片段
		         * @param {module:zrender/animation/Animator} animator
		         */
		        removeAnimator: function (animator) {
		            var clips = animator.getClips();
		            for (var i = 0; i < clips.length; i++) {
		                this.removeClip(clips[i]);
		            }
		            animator.animation = null;
		        },

		        _update: function() {

		            var time = new Date().getTime() - this._pausedTime;
		            var delta = time - this._time;
		            var clips = this._clips;
		            var len = clips.length;

		            var deferredEvents = [];
		            var deferredClips = [];
		            for (var i = 0; i < len; i++) {
		                var clip = clips[i];
		                var e = clip.step(time);
		                // Throw out the events need to be called after
		                // stage.update, like destroy
		                if (e) {
		                    deferredEvents.push(e);
		                    deferredClips.push(clip);
		                }
		            }

		            // Remove the finished clip
		            for (var i = 0; i < len;) {
		                if (clips[i]._needsRemove) {
		                    clips[i] = clips[len - 1];
		                    clips.pop();
		                    len--;
		                }
		                else {
		                    i++;
		                }
		            }

		            len = deferredEvents.length;
		            for (var i = 0; i < len; i++) {
		                deferredClips[i].fire(deferredEvents[i]);
		            }

		            this._time = time;

		            this.onframe(delta);

		            this.trigger('frame', delta);

		            if (this.stage.update) {
		                this.stage.update();
		            }
		        },

		        _startLoop: function () {
		            var self = this;

		            this._running = true;

		            function step() {
		                if (self._running) {

		                    requestAnimationFrame(step);

		                    !self._paused && self._update();
		                }
		            }

		            requestAnimationFrame(step);
		        },

		        /**
		         * 开始运行动画
		         */
		        start: function () {

		            this._time = new Date().getTime();
		            this._pausedTime = 0;

		            this._startLoop();
		        },
		        /**
		         * 停止运行动画
		         */
		        stop: function () {
		            this._running = false;
		        },

		        /**
		         * Pause
		         */
		        pause: function () {
		            if (!this._paused) {
		                this._pauseStart = new Date().getTime();
		                this._paused = true;
		            }
		        },

		        /**
		         * Resume
		         */
		        resume: function () {
		            if (this._paused) {
		                this._pausedTime += (new Date().getTime()) - this._pauseStart;
		                this._paused = false;
		            }
		        },

		        /**
		         * 清除所有动画片段
		         */
		        clear: function () {
		            this._clips = [];
		        },
		        /**
		         * 对一个目标创建一个animator对象，可以指定目标中的属性使用动画
		         * @param  {Object} target
		         * @param  {Object} options
		         * @param  {boolean} [options.loop=false] 是否循环播放动画
		         * @param  {Function} [options.getter=null]
		         *         如果指定getter函数，会通过getter函数取属性值
		         * @param  {Function} [options.setter=null]
		         *         如果指定setter函数，会通过setter函数设置属性值
		         * @return {module:zrender/animation/Animation~Animator}
		         */
		        // TODO Gap
		        animate: function (target, options) {
		            options = options || {};
		            var animator = new Animator(
		                target,
		                options.loop,
		                options.getter,
		                options.setter
		            );

		            return animator;
		        }
		    };

		    util.mixin(Animation, Dispatcher);

		    module.exports = Animation;



	/***/ },
	/* 88 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * 事件辅助类
		 * @module zrender/core/event
		 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
		 */


		    var Eventful = __webpack_require__(33);
		    var env = __webpack_require__(2);

		    var isDomLevel2 = (typeof window !== 'undefined') && !!window.addEventListener;

		    function getBoundingClientRect(el) {
		        // BlackBerry 5, iOS 3 (original iPhone) don't have getBoundingRect
		        return el.getBoundingClientRect ? el.getBoundingClientRect() : {left: 0, top: 0};
		    }

		    // `calculate` is optional, default false
		    function clientToLocal(el, e, out, calculate) {
		        out = out || {};

		        // According to the W3C Working Draft, offsetX and offsetY should be relative
		        // to the padding edge of the target element. The only browser using this convention
		        // is IE. Webkit uses the border edge, Opera uses the content edge, and FireFox does
		        // not support the properties.
		        // (see http://www.jacklmoore.com/notes/mouse-position/)
		        // In zr painter.dom, padding edge equals to border edge.

		        // FIXME
		        // When mousemove event triggered on ec tooltip, target is not zr painter.dom, and
		        // offsetX/Y is relative to e.target, where the calculation of zrX/Y via offsetX/Y
		        // is too complex. So css-transfrom dont support in this case temporarily.
		        if (calculate || !env.canvasSupported) {
		            defaultGetZrXY(el, e, out);
		        }
		        // Caution: In FireFox, layerX/layerY Mouse position relative to the closest positioned
		        // ancestor element, so we should make sure el is positioned (e.g., not position:static).
		        // BTW1, Webkit don't return the same results as FF in non-simple cases (like add
		        // zoom-factor, overflow / opacity layers, transforms ...)
		        // BTW2, (ev.offsetY || ev.pageY - $(ev.target).offset().top) is not correct in preserve-3d.
		        // <https://bugs.jquery.com/ticket/8523#comment:14>
		        // BTW3, In ff, offsetX/offsetY is always 0.
		        else if (env.browser.firefox && e.layerX != null && e.layerX !== e.offsetX) {
		            out.zrX = e.layerX;
		            out.zrY = e.layerY;
		        }
		        // For IE6+, chrome, safari, opera. (When will ff support offsetX?)
		        else if (e.offsetX != null) {
		            out.zrX = e.offsetX;
		            out.zrY = e.offsetY;
		        }
		        // For some other device, e.g., IOS safari.
		        else {
		            defaultGetZrXY(el, e, out);
		        }

		        return out;
		    }

		    function defaultGetZrXY(el, e, out) {
		        // This well-known method below does not support css transform.
		        var box = getBoundingClientRect(el);
		        out.zrX = e.clientX - box.left;
		        out.zrY = e.clientY - box.top;
		    }

		    /**
		     * 如果存在第三方嵌入的一些dom触发的事件，或touch事件，需要转换一下事件坐标.
		     * `calculate` is optional, default false.
		     */
		    function normalizeEvent(el, e, calculate) {

		        e = e || window.event;

		        if (e.zrX != null) {
		            return e;
		        }

		        var eventType = e.type;
		        var isTouch = eventType && eventType.indexOf('touch') >= 0;

		        if (!isTouch) {
		            clientToLocal(el, e, e, calculate);
		            e.zrDelta = (e.wheelDelta) ? e.wheelDelta / 120 : -(e.detail || 0) / 3;
		        }
		        else {
		            var touch = eventType != 'touchend'
		                ? e.targetTouches[0]
		                : e.changedTouches[0];
		            touch && clientToLocal(el, touch, e, calculate);
		        }

		        return e;
		    }

		    function addEventListener(el, name, handler) {
		        if (isDomLevel2) {
		            el.addEventListener(name, handler);
		        }
		        else {
		            el.attachEvent('on' + name, handler);
		        }
		    }

		    function removeEventListener(el, name, handler) {
		        if (isDomLevel2) {
		            el.removeEventListener(name, handler);
		        }
		        else {
		            el.detachEvent('on' + name, handler);
		        }
		    }

		    /**
		     * 停止冒泡和阻止默认行为
		     * @memberOf module:zrender/core/event
		     * @method
		     * @param {Event} e : event对象
		     */
		    var stop = isDomLevel2
		        ? function (e) {
		            e.preventDefault();
		            e.stopPropagation();
		            e.cancelBubble = true;
		        }
		        : function (e) {
		            e.returnValue = false;
		            e.cancelBubble = true;
		        };

		    module.exports = {
		        clientToLocal: clientToLocal,
		        normalizeEvent: normalizeEvent,
		        addEventListener: addEventListener,
		        removeEventListener: removeEventListener,

		        stop: stop,
		        // 做向上兼容
		        Dispatcher: Eventful
		    };



	/***/ },
	/* 89 */
	/***/ function(module, exports) {

		

		    module.exports = (typeof window !== 'undefined' &&
		                                    (window.requestAnimationFrame
		                                    || window.msRequestAnimationFrame
		                                    || window.mozRequestAnimationFrame
		                                    || window.webkitRequestAnimationFrame))
		                                || function (func) {
		                                    setTimeout(func, 16);
		                                };



	/***/ },
	/* 90 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var eventTool = __webpack_require__(88);
		    var zrUtil = __webpack_require__(4);
		    var Eventful = __webpack_require__(33);
		    var env = __webpack_require__(2);
		    var GestureMgr = __webpack_require__(91);

		    var addEventListener = eventTool.addEventListener;
		    var removeEventListener = eventTool.removeEventListener;
		    var normalizeEvent = eventTool.normalizeEvent;

		    var TOUCH_CLICK_DELAY = 300;

		    var mouseHandlerNames = [
		        'click', 'dblclick', 'mousewheel', 'mouseout',
		        'mouseup', 'mousedown', 'mousemove', 'contextmenu'
		    ];

		    var touchHandlerNames = [
		        'touchstart', 'touchend', 'touchmove'
		    ];

		    function eventNameFix(name) {
		        return (name === 'mousewheel' && env.browser.firefox) ? 'DOMMouseScroll' : name;
		    }

		    function processGesture(proxy, event, stage) {
		        var gestureMgr = proxy._gestureMgr;

		        stage === 'start' && gestureMgr.clear();

		        var gestureInfo = gestureMgr.recognize(
		            event,
		            proxy.handler.findHover(event.zrX, event.zrY, null),
		            proxy.dom
		        );

		        stage === 'end' && gestureMgr.clear();

		        if (gestureInfo) {
		            // eventTool.stop(event);
		            var type = gestureInfo.type;
		            event.gestureEvent = type;

		            proxy.handler.dispatchToElement(gestureInfo.target, type, gestureInfo.event);
		        }
		    }

		    /**
		     * Prevent mouse event from being dispatched after Touch Events action
		     * @see <https://github.com/deltakosh/handjs/blob/master/src/hand.base.js>
		     * 1. Mobile browsers dispatch mouse events 300ms after touchend.
		     * 2. Chrome for Android dispatch mousedown for long-touch about 650ms
		     * Result: Blocking Mouse Events for 700ms.
		     */
		    function setTouchTimer(instance) {
		        instance._touching = true;
		        clearTimeout(instance._touchTimer);
		        instance._touchTimer = setTimeout(function () {
		            instance._touching = false;
		        }, 700);
		    }

		    function useTouchEvent() {
		        return env.touchEventsSupported;
		    }

		    var domHandlers = {
		        /**
		         * Mouse move handler
		         * @inner
		         * @param {Event} event
		         */
		        mousemove: function (event) {
		            event = normalizeEvent(this.dom, event);

		            this.trigger('mousemove', event);
		        },

		        /**
		         * Mouse out handler
		         * @inner
		         * @param {Event} event
		         */
		        mouseout: function (event) {
		            event = normalizeEvent(this.dom, event);

		            var element = event.toElement || event.relatedTarget;
		            if (element != this.dom) {
		                while (element && element.nodeType != 9) {
		                    // 忽略包含在root中的dom引起的mouseOut
		                    if (element === this.dom) {
		                        return;
		                    }

		                    element = element.parentNode;
		                }
		            }

		            this.trigger('mouseout', event);
		        },

		        /**
		         * Touch开始响应函数
		         * @inner
		         * @param {Event} event
		         */
		        touchstart: function (event) {
		            // Default mouse behaviour should not be disabled here.
		            // For example, page may needs to be slided.

		            event = normalizeEvent(this.dom, event);

		            // Mark touch, which is useful in distinguish touch and
		            // mouse event in upper applicatoin.
		            event.zrByTouch = true;

		            this._lastTouchMoment = new Date();

		            processGesture(this, event, 'start');

		            // In touch device, trigger `mousemove`(`mouseover`) should
		            // be triggered.
		            domHandlers.mousemove.call(this, event);

		            domHandlers.mousedown.call(this, event);

		            setTouchTimer(this);
		        },

		        /**
		         * Touch移动响应函数
		         * @inner
		         * @param {Event} event
		         */
		        touchmove: function (event) {

		            event = normalizeEvent(this.dom, event);

		            // Mark touch, which is useful in distinguish touch and
		            // mouse event in upper applicatoin.
		            event.zrByTouch = true;

		            processGesture(this, event, 'change');

		            // Mouse move should always be triggered no matter whether
		            // there is gestrue event, because mouse move and pinch may
		            // be used at the same time.
		            domHandlers.mousemove.call(this, event);

		            setTouchTimer(this);
		        },

		        /**
		         * Touch结束响应函数
		         * @inner
		         * @param {Event} event
		         */
		        touchend: function (event) {

		            event = normalizeEvent(this.dom, event);

		            // Mark touch, which is useful in distinguish touch and
		            // mouse event in upper applicatoin.
		            event.zrByTouch = true;

		            processGesture(this, event, 'end');

		            domHandlers.mouseup.call(this, event);

		            // Do not trigger `mouseout` here, in spite of `mousemove`(`mouseover`) is
		            // triggered in `touchstart`. This seems to be illogical, but by this mechanism,
		            // we can conveniently implement "hover style" in both PC and touch device just
		            // by listening to `mouseover` to add "hover style" and listening to `mouseout`
		            // to remove "hover style" on an element, without any additional code for
		            // compatibility. (`mouseout` will not be triggered in `touchend`, so "hover
		            // style" will remain for user view)

		            // click event should always be triggered no matter whether
		            // there is gestrue event. System click can not be prevented.
		            if (+new Date() - this._lastTouchMoment < TOUCH_CLICK_DELAY) {
		                domHandlers.click.call(this, event);
		            }

		            setTouchTimer(this);
		        }
		    };

		    // Common handlers
		    zrUtil.each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
		        domHandlers[name] = function (event) {
		            event = normalizeEvent(this.dom, event);
		            this.trigger(name, event);
		        };
		    });

		    /**
		     * 为控制类实例初始化dom 事件处理函数
		     *
		     * @inner
		     * @param {module:zrender/Handler} instance 控制类实例
		     */
		    function initDomHandler(instance) {
		        for (var i = 0; i < touchHandlerNames.length; i++) {
		            var name = touchHandlerNames[i];
		            instance._handlers[name] = zrUtil.bind(domHandlers[name], instance);
		        }

		        for (var i = 0; i < mouseHandlerNames.length; i++) {
		            var name = mouseHandlerNames[i];
		            instance._handlers[name] = makeMouseHandler(domHandlers[name], instance);
		        }

		        function makeMouseHandler(fn, instance) {
		            return function () {
		                if (instance._touching) {
		                    return;
		                }
		                return fn.apply(instance, arguments);
		            };
		        }
		    }


		    function HandlerDomProxy(dom) {
		        Eventful.call(this);

		        this.dom = dom;

		        /**
		         * @private
		         * @type {boolean}
		         */
		        this._touching = false;

		        /**
		         * @private
		         * @type {number}
		         */
		        this._touchTimer;

		        /**
		         * @private
		         * @type {module:zrender/core/GestureMgr}
		         */
		        this._gestureMgr = new GestureMgr();

		        this._handlers = {};

		        initDomHandler(this);

		        if (useTouchEvent()) {
		            mountHandlers(touchHandlerNames, this);

		            // Handler of 'mouseout' event is needed in touch mode, which will be mounted below.
		            // addEventListener(root, 'mouseout', this._mouseoutHandler);
		        }

		        // Considering some devices that both enable touch and mouse event (like MS Surface
		        // and lenovo X240, @see #2350), we make mouse event be always listened, otherwise
		        // mouse event can not be handle in those devices.
		        mountHandlers(mouseHandlerNames, this);

		        function mountHandlers(handlerNames, instance) {
		            zrUtil.each(handlerNames, function (name) {
		                addEventListener(dom, eventNameFix(name), instance._handlers[name]);
		            }, instance);
		        }
		    }

		    var handlerDomProxyProto = HandlerDomProxy.prototype;
		    handlerDomProxyProto.dispose = function () {
		        var handlerNames = mouseHandlerNames.concat(touchHandlerNames);

		        for (var i = 0; i < handlerNames.length; i++) {
		            var name = handlerNames[i];
		            removeEventListener(this.dom, eventNameFix(name), this._handlers[name]);
		        }
		    };

		    handlerDomProxyProto.setCursor = function (cursorStyle) {
		        this.dom.style.cursor = cursorStyle || 'default';
		    };

		    zrUtil.mixin(HandlerDomProxy, Eventful);

		    module.exports = HandlerDomProxy;


	/***/ },
	/* 91 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * Only implements needed gestures for mobile.
		 */


		    var eventUtil = __webpack_require__(88);

		    var GestureMgr = function () {

		        /**
		         * @private
		         * @type {Array.<Object>}
		         */
		        this._track = [];
		    };

		    GestureMgr.prototype = {

		        constructor: GestureMgr,

		        recognize: function (event, target, root) {
		            this._doTrack(event, target, root);
		            return this._recognize(event);
		        },

		        clear: function () {
		            this._track.length = 0;
		            return this;
		        },

		        _doTrack: function (event, target, root) {
		            var touches = event.touches;

		            if (!touches) {
		                return;
		            }

		            var trackItem = {
		                points: [],
		                touches: [],
		                target: target,
		                event: event
		            };

		            for (var i = 0, len = touches.length; i < len; i++) {
		                var touch = touches[i];
		                var pos = eventUtil.clientToLocal(root, touch, {});
		                trackItem.points.push([pos.zrX, pos.zrY]);
		                trackItem.touches.push(touch);
		            }

		            this._track.push(trackItem);
		        },

		        _recognize: function (event) {
		            for (var eventName in recognizers) {
		                if (recognizers.hasOwnProperty(eventName)) {
		                    var gestureInfo = recognizers[eventName](this._track, event);
		                    if (gestureInfo) {
		                        return gestureInfo;
		                    }
		                }
		            }
		        }
		    };

		    function dist(pointPair) {
		        var dx = pointPair[1][0] - pointPair[0][0];
		        var dy = pointPair[1][1] - pointPair[0][1];

		        return Math.sqrt(dx * dx + dy * dy);
		    }

		    function center(pointPair) {
		        return [
		            (pointPair[0][0] + pointPair[1][0]) / 2,
		            (pointPair[0][1] + pointPair[1][1]) / 2
		        ];
		    }

		    var recognizers = {

		        pinch: function (track, event) {
		            var trackLen = track.length;

		            if (!trackLen) {
		                return;
		            }

		            var pinchEnd = (track[trackLen - 1] || {}).points;
		            var pinchPre = (track[trackLen - 2] || {}).points || pinchEnd;

		            if (pinchPre
		                && pinchPre.length > 1
		                && pinchEnd
		                && pinchEnd.length > 1
		            ) {
		                var pinchScale = dist(pinchEnd) / dist(pinchPre);
		                !isFinite(pinchScale) && (pinchScale = 1);

		                event.pinchScale = pinchScale;

		                var pinchCenter = center(pinchEnd);
		                event.pinchX = pinchCenter[0];
		                event.pinchY = pinchCenter[1];

		                return {
		                    type: 'pinch',
		                    target: track[0].target,
		                    event: event
		                };
		            }
		        }

		        // Only pinch currently.
		    };

		    module.exports = GestureMgr;



	/***/ },
	/* 92 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * Default canvas painter
		 * @module zrender/Painter
		 * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)
		 *         errorrik (errorrik@gmail.com)
		 *         pissang (https://www.github.com/pissang)
		 */
		 

		    var config = __webpack_require__(41);
		    var util = __webpack_require__(4);
		    var log = __webpack_require__(40);
		    var BoundingRect = __webpack_require__(9);
		    var timsort = __webpack_require__(86);

		    var Layer = __webpack_require__(93);

		    var requestAnimationFrame = __webpack_require__(89);

		    // PENDIGN
		    // Layer exceeds MAX_PROGRESSIVE_LAYER_NUMBER may have some problem when flush directly second time.
		    //
		    // Maximum progressive layer. When exceeding this number. All elements will be drawed in the last layer.
		    var MAX_PROGRESSIVE_LAYER_NUMBER = 5;

		    function parseInt10(val) {
		        return parseInt(val, 10);
		    }

		    function isLayerValid(layer) {
		        if (!layer) {
		            return false;
		        }

		        if (layer.isBuildin) {
		            return true;
		        }

		        if (typeof(layer.resize) !== 'function'
		            || typeof(layer.refresh) !== 'function'
		        ) {
		            return false;
		        }

		        return true;
		    }

		    function preProcessLayer(layer) {
		        layer.__unusedCount++;
		    }

		    function postProcessLayer(layer) {
		        if (layer.__unusedCount == 1) {
		            layer.clear();
		        }
		    }

		    var tmpRect = new BoundingRect(0, 0, 0, 0);
		    var viewRect = new BoundingRect(0, 0, 0, 0);
		    function isDisplayableCulled(el, width, height) {
		        tmpRect.copy(el.getBoundingRect());
		        if (el.transform) {
		            tmpRect.applyTransform(el.transform);
		        }
		        viewRect.width = width;
		        viewRect.height = height;
		        return !tmpRect.intersect(viewRect);
		    }

		    function isClipPathChanged(clipPaths, prevClipPaths) {
		        if (clipPaths == prevClipPaths) { // Can both be null or undefined
		            return false;
		        }

		        if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
		            return true;
		        }
		        for (var i = 0; i < clipPaths.length; i++) {
		            if (clipPaths[i] !== prevClipPaths[i]) {
		                return true;
		            }
		        }
		    }

		    function doClip(clipPaths, ctx) {
		        for (var i = 0; i < clipPaths.length; i++) {
		            var clipPath = clipPaths[i];
		            var path = clipPath.path;

		            clipPath.setTransform(ctx);
		            path.beginPath(ctx);
		            clipPath.buildPath(path, clipPath.shape);
		            ctx.clip();
		            // Transform back
		            clipPath.restoreTransform(ctx);
		        }
		    }

		    function createRoot(width, height) {
		        var domRoot = document.createElement('div');

		        // domRoot.onselectstart = returnFalse; // 避免页面选中的尴尬
		        domRoot.style.cssText = [
		            'position:relative',
		            'overflow:hidden',
		            'width:' + width + 'px',
		            'height:' + height + 'px',
		            'padding:0',
		            'margin:0',
		            'border-width:0'
		        ].join(';') + ';';

		        return domRoot;
		    }

		    /**
		     * @alias module:zrender/Painter
		     * @constructor
		     * @param {HTMLElement} root 绘图容器
		     * @param {module:zrender/Storage} storage
		     * @param {Ojbect} opts
		     */
		    var Painter = function (root, storage, opts) {
		        // In node environment using node-canvas
		        var singleCanvas = !root.nodeName // In node ?
		            || root.nodeName.toUpperCase() === 'CANVAS';

		        this._opts = opts = util.extend({}, opts || {});

		        /**
		         * @type {number}
		         */
		        this.dpr = opts.devicePixelRatio || config.devicePixelRatio;
		        /**
		         * @type {boolean}
		         * @private
		         */
		        this._singleCanvas = singleCanvas;
		        /**
		         * 绘图容器
		         * @type {HTMLElement}
		         */
		        this.root = root;

		        var rootStyle = root.style;

		        if (rootStyle) {
		            rootStyle['-webkit-tap-highlight-color'] = 'transparent';
		            rootStyle['-webkit-user-select'] =
		            rootStyle['user-select'] =
		            rootStyle['-webkit-touch-callout'] = 'none';

		            root.innerHTML = '';
		        }

		        /**
		         * @type {module:zrender/Storage}
		         */
		        this.storage = storage;

		        /**
		         * @type {Array.<number>}
		         * @private
		         */
		        var zlevelList = this._zlevelList = [];

		        /**
		         * @type {Object.<string, module:zrender/Layer>}
		         * @private
		         */
		        var layers = this._layers = {};

		        /**
		         * @type {Object.<string, Object>}
		         * @type {private}
		         */
		        this._layerConfig = {};

		        if (!singleCanvas) {
		            this._width = this._getSize(0);
		            this._height = this._getSize(1);

		            var domRoot = this._domRoot = createRoot(
		                this._width, this._height
		            );
		            root.appendChild(domRoot);
		        }
		        else {
		            // Use canvas width and height directly
		            var width = root.width;
		            var height = root.height;
		            this._width = width;
		            this._height = height;

		            // Create layer if only one given canvas
		            // Device pixel ratio is fixed to 1 because given canvas has its specified width and height
		            var mainLayer = new Layer(root, this, 1);
		            mainLayer.initContext();
		            // FIXME Use canvas width and height
		            // mainLayer.resize(width, height);
		            layers[0] = mainLayer;
		            zlevelList.push(0);
		        }

		        this.pathToImage = this._createPathToImage();

		        // Layers for progressive rendering
		        this._progressiveLayers = [];

		        /**
		         * @type {module:zrender/Layer}
		         * @private
		         */
		        this._hoverlayer;

		        this._hoverElements = [];
		    };

		    Painter.prototype = {

		        constructor: Painter,

		        /**
		         * If painter use a single canvas
		         * @return {boolean}
		         */
		        isSingleCanvas: function () {
		            return this._singleCanvas;
		        },
		        /**
		         * @return {HTMLDivElement}
		         */
		        getViewportRoot: function () {
		            return this._singleCanvas ? this._layers[0].dom : this._domRoot;
		        },

		        /**
		         * 刷新
		         * @param {boolean} [paintAll=false] 强制绘制所有displayable
		         */
		        refresh: function (paintAll) {

		            var list = this.storage.getDisplayList(true);

		            var zlevelList = this._zlevelList;

		            this._paintList(list, paintAll);

		            // Paint custum layers
		            for (var i = 0; i < zlevelList.length; i++) {
		                var z = zlevelList[i];
		                var layer = this._layers[z];
		                if (!layer.isBuildin && layer.refresh) {
		                    layer.refresh();
		                }
		            }

		            this.refreshHover();

		            if (this._progressiveLayers.length) {
		                this._startProgessive();
		            }

		            return this;
		        },

		        addHover: function (el, hoverStyle) {
		            if (el.__hoverMir) {
		                return;
		            }
		            var elMirror = new el.constructor({
		                style: el.style,
		                shape: el.shape
		            });
		            elMirror.__from = el;
		            el.__hoverMir = elMirror;
		            elMirror.setStyle(hoverStyle);
		            this._hoverElements.push(elMirror);
		        },

		        removeHover: function (el) {
		            var elMirror = el.__hoverMir;
		            var hoverElements = this._hoverElements;
		            var idx = util.indexOf(hoverElements, elMirror);
		            if (idx >= 0) {
		                hoverElements.splice(idx, 1);
		            }
		            el.__hoverMir = null;
		        },

		        clearHover: function (el) {
		            var hoverElements = this._hoverElements;
		            for (var i = 0; i < hoverElements.length; i++) {
		                var from = hoverElements[i].__from;
		                if (from) {
		                    from.__hoverMir = null;
		                }
		            }
		            hoverElements.length = 0;
		        },

		        refreshHover: function () {
		            var hoverElements = this._hoverElements;
		            var len = hoverElements.length;
		            var hoverLayer = this._hoverlayer;
		            hoverLayer && hoverLayer.clear();

		            if (!len) {
		                return;
		            }
		            timsort(hoverElements, this.storage.displayableSortFunc);

		            // Use a extream large zlevel
		            // FIXME?
		            if (!hoverLayer) {
		                hoverLayer = this._hoverlayer = this.getLayer(1e5);
		            }

		            var scope = {};
		            hoverLayer.ctx.save();
		            for (var i = 0; i < len;) {
		                var el = hoverElements[i];
		                var originalEl = el.__from;
		                // Original el is removed
		                // PENDING
		                if (!(originalEl && originalEl.__zr)) {
		                    hoverElements.splice(i, 1);
		                    originalEl.__hoverMir = null;
		                    len--;
		                    continue;
		                }
		                i++;

		                // Use transform
		                // FIXME style and shape ?
		                if (!originalEl.invisible) {
		                    el.transform = originalEl.transform;
		                    el.invTransform = originalEl.invTransform;
		                    el.__clipPaths = originalEl.__clipPaths;
		                    // el.
		                    this._doPaintEl(el, hoverLayer, true, scope);
		                }
		            }
		            hoverLayer.ctx.restore();
		        },

		        _startProgessive: function () {
		            var self = this;

		            if (!self._furtherProgressive) {
		                return;
		            }

		            // Use a token to stop progress steps triggered by
		            // previous zr.refresh calling.
		            var token = self._progressiveToken = +new Date();

		            self._progress++;
		            requestAnimationFrame(step);

		            function step() {
		                // In case refreshed or disposed
		                if (token === self._progressiveToken && self.storage) {

		                    self._doPaintList(self.storage.getDisplayList());

		                    if (self._furtherProgressive) {
		                        self._progress++;
		                        requestAnimationFrame(step);
		                    }
		                    else {
		                        self._progressiveToken = -1;
		                    }
		                }
		            }
		        },

		        _clearProgressive: function () {
		            this._progressiveToken = -1;
		            this._progress = 0;
		            util.each(this._progressiveLayers, function (layer) {
		                layer.__dirty && layer.clear();
		            });
		        },

		        _paintList: function (list, paintAll) {

		            if (paintAll == null) {
		                paintAll = false;
		            }

		            this._updateLayerStatus(list);

		            this._clearProgressive();

		            this.eachBuildinLayer(preProcessLayer);

		            this._doPaintList(list, paintAll);

		            this.eachBuildinLayer(postProcessLayer);
		        },

		        _doPaintList: function (list, paintAll) {
		            var currentLayer;
		            var currentZLevel;
		            var ctx;

		            // var invTransform = [];
		            var scope;

		            var progressiveLayerIdx = 0;
		            var currentProgressiveLayer;

		            var width = this._width;
		            var height = this._height;
		            var layerProgress;
		            var frame = this._progress;
		            function flushProgressiveLayer(layer) {
		                var dpr = ctx.dpr || 1;
		                ctx.save();
		                ctx.globalAlpha = 1;
		                ctx.shadowBlur = 0;
		                // Avoid layer don't clear in next progressive frame
		                currentLayer.__dirty = true;
		                ctx.setTransform(1, 0, 0, 1, 0, 0);
		                ctx.drawImage(layer.dom, 0, 0, width * dpr, height * dpr);
		                ctx.restore();
		            }

		            for (var i = 0, l = list.length; i < l; i++) {
		                var el = list[i];
		                var elZLevel = this._singleCanvas ? 0 : el.zlevel;

		                var elFrame = el.__frame;

		                // Flush at current context
		                // PENDING
		                if (elFrame < 0 && currentProgressiveLayer) {
		                    flushProgressiveLayer(currentProgressiveLayer);
		                    currentProgressiveLayer = null;
		                }

		                // Change draw layer
		                if (currentZLevel !== elZLevel) {
		                    if (ctx) {
		                        ctx.restore();
		                    }

		                    // Reset scope
		                    scope = {};

		                    // Only 0 zlevel if only has one canvas
		                    currentZLevel = elZLevel;
		                    currentLayer = this.getLayer(currentZLevel);

		                    if (!currentLayer.isBuildin) {
		                        log(
		                            'ZLevel ' + currentZLevel
		                            + ' has been used by unkown layer ' + currentLayer.id
		                        );
		                    }

		                    ctx = currentLayer.ctx;
		                    ctx.save();

		                    // Reset the count
		                    currentLayer.__unusedCount = 0;

		                    if (currentLayer.__dirty || paintAll) {
		                        currentLayer.clear();
		                    }
		                }

		                if (!(currentLayer.__dirty || paintAll)) {
		                    continue;
		                }

		                if (elFrame >= 0) {
		                    // Progressive layer changed
		                    if (!currentProgressiveLayer) {
		                        currentProgressiveLayer = this._progressiveLayers[
		                            Math.min(progressiveLayerIdx++, MAX_PROGRESSIVE_LAYER_NUMBER - 1)
		                        ];

		                        currentProgressiveLayer.ctx.save();
		                        currentProgressiveLayer.renderScope = {};

		                        if (currentProgressiveLayer
		                            && (currentProgressiveLayer.__progress > currentProgressiveLayer.__maxProgress)
		                        ) {
		                            // flushProgressiveLayer(currentProgressiveLayer);
		                            // Quick jump all progressive elements
		                            // All progressive element are not dirty, jump over and flush directly
		                            i = currentProgressiveLayer.__nextIdxNotProg - 1;
		                            // currentProgressiveLayer = null;
		                            continue;
		                        }

		                        layerProgress = currentProgressiveLayer.__progress;

		                        if (!currentProgressiveLayer.__dirty) {
		                            // Keep rendering
		                            frame = layerProgress;
		                        }

		                        currentProgressiveLayer.__progress = frame + 1;
		                    }

		                    if (elFrame === frame) {
		                        this._doPaintEl(el, currentProgressiveLayer, true, currentProgressiveLayer.renderScope);
		                    }
		                }
		                else {
		                    this._doPaintEl(el, currentLayer, paintAll, scope);
		                }

		                el.__dirty = false;
		            }

		            if (currentProgressiveLayer) {
		                flushProgressiveLayer(currentProgressiveLayer);
		            }

		            // Restore the lastLayer ctx
		            ctx && ctx.restore();
		            // If still has clipping state
		            // if (scope.prevElClipPaths) {
		            //     ctx.restore();
		            // }

		            this._furtherProgressive = false;
		            util.each(this._progressiveLayers, function (layer) {
		                if (layer.__maxProgress >= layer.__progress) {
		                    this._furtherProgressive = true;
		                }
		            }, this);
		        },

		        _doPaintEl: function (el, currentLayer, forcePaint, scope) {
		            var ctx = currentLayer.ctx;
		            var m = el.transform;
		            if (
		                (currentLayer.__dirty || forcePaint)
		                // Ignore invisible element
		                && !el.invisible
		                // Ignore transparent element
		                && el.style.opacity !== 0
		                // Ignore scale 0 element, in some environment like node-canvas
		                // Draw a scale 0 element can cause all following draw wrong
		                // And setTransform with scale 0 will cause set back transform failed.
		                && !(m && !m[0] && !m[3])
		                // Ignore culled element
		                && !(el.culling && isDisplayableCulled(el, this._width, this._height))
		            ) {

		                var clipPaths = el.__clipPaths;

		                // Optimize when clipping on group with several elements
		                if (scope.prevClipLayer !== currentLayer
		                    || isClipPathChanged(clipPaths, scope.prevElClipPaths)
		                ) {
		                    // If has previous clipping state, restore from it
		                    if (scope.prevElClipPaths) {
		                        scope.prevClipLayer.ctx.restore();
		                        scope.prevClipLayer = scope.prevElClipPaths = null;

		                        // Reset prevEl since context has been restored
		                        scope.prevEl = null;
		                    }
		                    // New clipping state
		                    if (clipPaths) {
		                        ctx.save();
		                        doClip(clipPaths, ctx);
		                        scope.prevClipLayer = currentLayer;
		                        scope.prevElClipPaths = clipPaths;
		                    }
		                }
		                el.beforeBrush && el.beforeBrush(ctx);

		                el.brush(ctx, scope.prevEl || null);
		                scope.prevEl = el;

		                el.afterBrush && el.afterBrush(ctx);
		            }
		        },

		        /**
		         * 获取 zlevel 所在层，如果不存在则会创建一个新的层
		         * @param {number} zlevel
		         * @return {module:zrender/Layer}
		         */
		        getLayer: function (zlevel) {
		            if (this._singleCanvas) {
		                return this._layers[0];
		            }

		            var layer = this._layers[zlevel];
		            if (!layer) {
		                // Create a new layer
		                layer = new Layer('zr_' + zlevel, this, this.dpr);
		                layer.isBuildin = true;

		                if (this._layerConfig[zlevel]) {
		                    util.merge(layer, this._layerConfig[zlevel], true);
		                }

		                this.insertLayer(zlevel, layer);

		                // Context is created after dom inserted to document
		                // Or excanvas will get 0px clientWidth and clientHeight
		                layer.initContext();
		            }

		            return layer;
		        },

		        insertLayer: function (zlevel, layer) {

		            var layersMap = this._layers;
		            var zlevelList = this._zlevelList;
		            var len = zlevelList.length;
		            var prevLayer = null;
		            var i = -1;
		            var domRoot = this._domRoot;

		            if (layersMap[zlevel]) {
		                log('ZLevel ' + zlevel + ' has been used already');
		                return;
		            }
		            // Check if is a valid layer
		            if (!isLayerValid(layer)) {
		                log('Layer of zlevel ' + zlevel + ' is not valid');
		                return;
		            }

		            if (len > 0 && zlevel > zlevelList[0]) {
		                for (i = 0; i < len - 1; i++) {
		                    if (
		                        zlevelList[i] < zlevel
		                        && zlevelList[i + 1] > zlevel
		                    ) {
		                        break;
		                    }
		                }
		                prevLayer = layersMap[zlevelList[i]];
		            }
		            zlevelList.splice(i + 1, 0, zlevel);

		            if (prevLayer) {
		                var prevDom = prevLayer.dom;
		                if (prevDom.nextSibling) {
		                    domRoot.insertBefore(
		                        layer.dom,
		                        prevDom.nextSibling
		                    );
		                }
		                else {
		                    domRoot.appendChild(layer.dom);
		                }
		            }
		            else {
		                if (domRoot.firstChild) {
		                    domRoot.insertBefore(layer.dom, domRoot.firstChild);
		                }
		                else {
		                    domRoot.appendChild(layer.dom);
		                }
		            }

		            layersMap[zlevel] = layer;
		        },

		        // Iterate each layer
		        eachLayer: function (cb, context) {
		            var zlevelList = this._zlevelList;
		            var z;
		            var i;
		            for (i = 0; i < zlevelList.length; i++) {
		                z = zlevelList[i];
		                cb.call(context, this._layers[z], z);
		            }
		        },

		        // Iterate each buildin layer
		        eachBuildinLayer: function (cb, context) {
		            var zlevelList = this._zlevelList;
		            var layer;
		            var z;
		            var i;
		            for (i = 0; i < zlevelList.length; i++) {
		                z = zlevelList[i];
		                layer = this._layers[z];
		                if (layer.isBuildin) {
		                    cb.call(context, layer, z);
		                }
		            }
		        },

		        // Iterate each other layer except buildin layer
		        eachOtherLayer: function (cb, context) {
		            var zlevelList = this._zlevelList;
		            var layer;
		            var z;
		            var i;
		            for (i = 0; i < zlevelList.length; i++) {
		                z = zlevelList[i];
		                layer = this._layers[z];
		                if (! layer.isBuildin) {
		                    cb.call(context, layer, z);
		                }
		            }
		        },

		        /**
		         * 获取所有已创建的层
		         * @param {Array.<module:zrender/Layer>} [prevLayer]
		         */
		        getLayers: function () {
		            return this._layers;
		        },

		        _updateLayerStatus: function (list) {

		            var layers = this._layers;
		            var progressiveLayers = this._progressiveLayers;

		            var elCountsLastFrame = {};
		            var progressiveElCountsLastFrame = {};

		            this.eachBuildinLayer(function (layer, z) {
		                elCountsLastFrame[z] = layer.elCount;
		                layer.elCount = 0;
		                layer.__dirty = false;
		            });

		            util.each(progressiveLayers, function (layer, idx) {
		                progressiveElCountsLastFrame[idx] = layer.elCount;
		                layer.elCount = 0;
		                layer.__dirty = false;
		            });

		            var progressiveLayerCount = 0;
		            var currentProgressiveLayer;
		            var lastProgressiveKey;
		            var frameCount = 0;
		            for (var i = 0, l = list.length; i < l; i++) {
		                var el = list[i];
		                var zlevel = this._singleCanvas ? 0 : el.zlevel;
		                var layer = layers[zlevel];
		                var elProgress = el.progressive;
		                if (layer) {
		                    layer.elCount++;
		                    layer.__dirty = layer.__dirty || el.__dirty;
		                }

		                /////// Update progressive
		                if (elProgress >= 0) {
		                    // Fix wrong progressive sequence problem.
		                    if (lastProgressiveKey !== elProgress) {
		                        lastProgressiveKey = elProgress;
		                        frameCount++;
		                    }
		                    var elFrame = el.__frame = frameCount - 1;
		                    if (!currentProgressiveLayer) {
		                        var idx = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER - 1);
		                        currentProgressiveLayer = progressiveLayers[idx];
		                        if (!currentProgressiveLayer) {
		                            currentProgressiveLayer = progressiveLayers[idx] = new Layer(
		                                'progressive', this, this.dpr
		                            );
		                            currentProgressiveLayer.initContext();
		                        }
		                        currentProgressiveLayer.__maxProgress = 0;
		                    }
		                    currentProgressiveLayer.__dirty = currentProgressiveLayer.__dirty || el.__dirty;
		                    currentProgressiveLayer.elCount++;

		                    currentProgressiveLayer.__maxProgress = Math.max(
		                        currentProgressiveLayer.__maxProgress, elFrame
		                    );

		                    if (currentProgressiveLayer.__maxProgress >= currentProgressiveLayer.__progress) {
		                        // Should keep rendering this  layer because progressive rendering is not finished yet
		                        layer.__dirty = true;
		                    }
		                }
		                else {
		                    el.__frame = -1;

		                    if (currentProgressiveLayer) {
		                        currentProgressiveLayer.__nextIdxNotProg = i;
		                        progressiveLayerCount++;
		                        currentProgressiveLayer = null;
		                    }
		                }
		            }

		            if (currentProgressiveLayer) {
		                progressiveLayerCount++;
		                currentProgressiveLayer.__nextIdxNotProg = i;
		            }

		            // 层中的元素数量有发生变化
		            this.eachBuildinLayer(function (layer, z) {
		                if (elCountsLastFrame[z] !== layer.elCount) {
		                    layer.__dirty = true;
		                }
		            });

		            progressiveLayers.length = Math.min(progressiveLayerCount, MAX_PROGRESSIVE_LAYER_NUMBER);
		            util.each(progressiveLayers, function (layer, idx) {
		                if (progressiveElCountsLastFrame[idx] !== layer.elCount) {
		                    el.__dirty = true;
		                }
		                if (layer.__dirty) {
		                    layer.__progress = 0;
		                }
		            });
		        },

		        /**
		         * 清除hover层外所有内容
		         */
		        clear: function () {
		            this.eachBuildinLayer(this._clearLayer);
		            return this;
		        },

		        _clearLayer: function (layer) {
		            layer.clear();
		        },

		        /**
		         * 修改指定zlevel的绘制参数
		         *
		         * @param {string} zlevel
		         * @param {Object} config 配置对象
		         * @param {string} [config.clearColor=0] 每次清空画布的颜色
		         * @param {string} [config.motionBlur=false] 是否开启动态模糊
		         * @param {number} [config.lastFrameAlpha=0.7]
		         *                 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
		         */
		        configLayer: function (zlevel, config) {
		            if (config) {
		                var layerConfig = this._layerConfig;
		                if (!layerConfig[zlevel]) {
		                    layerConfig[zlevel] = config;
		                }
		                else {
		                    util.merge(layerConfig[zlevel], config, true);
		                }

		                var layer = this._layers[zlevel];

		                if (layer) {
		                    util.merge(layer, layerConfig[zlevel], true);
		                }
		            }
		        },

		        /**
		         * 删除指定层
		         * @param {number} zlevel 层所在的zlevel
		         */
		        delLayer: function (zlevel) {
		            var layers = this._layers;
		            var zlevelList = this._zlevelList;
		            var layer = layers[zlevel];
		            if (!layer) {
		                return;
		            }
		            layer.dom.parentNode.removeChild(layer.dom);
		            delete layers[zlevel];

		            zlevelList.splice(util.indexOf(zlevelList, zlevel), 1);
		        },

		        /**
		         * 区域大小变化后重绘
		         */
		        resize: function (width, height) {
		            var domRoot = this._domRoot;
		            // FIXME Why ?
		            domRoot.style.display = 'none';

		            // Save input w/h
		            var opts = this._opts;
		            width != null && (opts.width = width);
		            height != null && (opts.height = height);

		            width = this._getSize(0);
		            height = this._getSize(1);

		            domRoot.style.display = '';

		            // 优化没有实际改变的resize
		            if (this._width != width || height != this._height) {
		                domRoot.style.width = width + 'px';
		                domRoot.style.height = height + 'px';

		                for (var id in this._layers) {
		                    if (this._layers.hasOwnProperty(id)) {
		                        this._layers[id].resize(width, height);
		                    }
		                }
		                util.each(this._progressiveLayers, function (layer) {
		                    layer.resize(width, height);
		                });

		                this.refresh(true);
		            }

		            this._width = width;
		            this._height = height;

		            return this;
		        },

		        /**
		         * 清除单独的一个层
		         * @param {number} zlevel
		         */
		        clearLayer: function (zlevel) {
		            var layer = this._layers[zlevel];
		            if (layer) {
		                layer.clear();
		            }
		        },

		        /**
		         * 释放
		         */
		        dispose: function () {
		            this.root.innerHTML = '';

		            this.root =
		            this.storage =

		            this._domRoot =
		            this._layers = null;
		        },

		        /**
		         * Get canvas which has all thing rendered
		         * @param {Object} opts
		         * @param {string} [opts.backgroundColor]
		         */
		        getRenderedCanvas: function (opts) {
		            opts = opts || {};
		            if (this._singleCanvas) {
		                return this._layers[0].dom;
		            }

		            var imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr);
		            imageLayer.initContext();

		            imageLayer.clearColor = opts.backgroundColor;
		            imageLayer.clear();

		            var displayList = this.storage.getDisplayList(true);

		            var scope = {};
		            for (var i = 0; i < displayList.length; i++) {
		                var el = displayList[i];
		                this._doPaintEl(el, imageLayer, true, scope);
		            }

		            return imageLayer.dom;
		        },
		        /**
		         * 获取绘图区域宽度
		         */
		        getWidth: function () {
		            return this._width;
		        },

		        /**
		         * 获取绘图区域高度
		         */
		        getHeight: function () {
		            return this._height;
		        },

		        _getSize: function (whIdx) {
		            var opts = this._opts;
		            var wh = ['width', 'height'][whIdx];
		            var cwh = ['clientWidth', 'clientHeight'][whIdx];
		            var plt = ['paddingLeft', 'paddingTop'][whIdx];
		            var prb = ['paddingRight', 'paddingBottom'][whIdx];

		            if (opts[wh] != null && opts[wh] !== 'auto') {
		                return parseFloat(opts[wh]);
		            }

		            var root = this.root;
		            var stl = document.defaultView.getComputedStyle(root);

		            return (
		                (root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh]))
		                - (parseInt10(stl[plt]) || 0)
		                - (parseInt10(stl[prb]) || 0)
		            ) | 0;
		        },

		        _pathToImage: function (id, path, width, height, dpr) {
		            var canvas = document.createElement('canvas');
		            var ctx = canvas.getContext('2d');

		            canvas.width = width * dpr;
		            canvas.height = height * dpr;

		            ctx.clearRect(0, 0, width * dpr, height * dpr);

		            var pathTransform = {
		                position: path.position,
		                rotation: path.rotation,
		                scale: path.scale
		            };
		            path.position = [0, 0, 0];
		            path.rotation = 0;
		            path.scale = [1, 1];
		            if (path) {
		                path.brush(ctx);
		            }

		            var ImageShape = __webpack_require__(61);
		            var imgShape = new ImageShape({
		                id: id,
		                style: {
		                    x: 0,
		                    y: 0,
		                    image: canvas
		                }
		            });

		            if (pathTransform.position != null) {
		                imgShape.position = path.position = pathTransform.position;
		            }

		            if (pathTransform.rotation != null) {
		                imgShape.rotation = path.rotation = pathTransform.rotation;
		            }

		            if (pathTransform.scale != null) {
		                imgShape.scale = path.scale = pathTransform.scale;
		            }

		            return imgShape;
		        },

		        _createPathToImage: function () {
		            var me = this;

		            return function (id, e, width, height) {
		                return me._pathToImage(
		                    id, e, width, height, me.dpr
		                );
		            };
		        }
		    };

		    module.exports = Painter;



	/***/ },
	/* 93 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module zrender/Layer
		 * @author pissang(https://www.github.com/pissang)
		 */


		    var util = __webpack_require__(4);
		    var config = __webpack_require__(41);
		    var Style = __webpack_require__(47);
		    var Pattern = __webpack_require__(59);

		    function returnFalse() {
		        return false;
		    }

		    /**
		     * 创建dom
		     *
		     * @inner
		     * @param {string} id dom id 待用
		     * @param {string} type dom type，such as canvas, div etc.
		     * @param {Painter} painter painter instance
		     * @param {number} number
		     */
		    function createDom(id, type, painter, dpr) {
		        var newDom = document.createElement(type);
		        var width = painter.getWidth();
		        var height = painter.getHeight();

		        var newDomStyle = newDom.style;
		        // 没append呢，请原谅我这样写，清晰~
		        newDomStyle.position = 'absolute';
		        newDomStyle.left = 0;
		        newDomStyle.top = 0;
		        newDomStyle.width = width + 'px';
		        newDomStyle.height = height + 'px';
		        newDom.width = width * dpr;
		        newDom.height = height * dpr;

		        // id不作为索引用，避免可能造成的重名，定义为私有属性
		        newDom.setAttribute('data-zr-dom-id', id);
		        return newDom;
		    }

		    /**
		     * @alias module:zrender/Layer
		     * @constructor
		     * @extends module:zrender/mixin/Transformable
		     * @param {string} id
		     * @param {module:zrender/Painter} painter
		     * @param {number} [dpr]
		     */
		    var Layer = function(id, painter, dpr) {
		        var dom;
		        dpr = dpr || config.devicePixelRatio;
		        if (typeof id === 'string') {
		            dom = createDom(id, 'canvas', painter, dpr);
		        }
		        // Not using isDom because in node it will return false
		        else if (util.isObject(id)) {
		            dom = id;
		            id = dom.id;
		        }
		        this.id = id;
		        this.dom = dom;

		        var domStyle = dom.style;
		        if (domStyle) { // Not in node
		            dom.onselectstart = returnFalse; // 避免页面选中的尴尬
		            domStyle['-webkit-user-select'] = 'none';
		            domStyle['user-select'] = 'none';
		            domStyle['-webkit-touch-callout'] = 'none';
		            domStyle['-webkit-tap-highlight-color'] = 'rgba(0,0,0,0)';
		            domStyle['padding'] = 0;
		            domStyle['margin'] = 0;
		            domStyle['border-width'] = 0;
		        }

		        this.domBack = null;
		        this.ctxBack = null;

		        this.painter = painter;

		        this.config = null;

		        // Configs
		        /**
		         * 每次清空画布的颜色
		         * @type {string}
		         * @default 0
		         */
		        this.clearColor = 0;
		        /**
		         * 是否开启动态模糊
		         * @type {boolean}
		         * @default false
		         */
		        this.motionBlur = false;
		        /**
		         * 在开启动态模糊的时候使用，与上一帧混合的alpha值，值越大尾迹越明显
		         * @type {number}
		         * @default 0.7
		         */
		        this.lastFrameAlpha = 0.7;

		        /**
		         * Layer dpr
		         * @type {number}
		         */
		        this.dpr = dpr;
		    };

		    Layer.prototype = {

		        constructor: Layer,

		        elCount: 0,

		        __dirty: true,

		        initContext: function () {
		            this.ctx = this.dom.getContext('2d');

		            this.ctx.dpr = this.dpr;
		        },

		        createBackBuffer: function () {
		            var dpr = this.dpr;

		            this.domBack = createDom('back-' + this.id, 'canvas', this.painter, dpr);
		            this.ctxBack = this.domBack.getContext('2d');

		            if (dpr != 1) {
		                this.ctxBack.scale(dpr, dpr);
		            }
		        },

		        /**
		         * @param  {number} width
		         * @param  {number} height
		         */
		        resize: function (width, height) {
		            var dpr = this.dpr;

		            var dom = this.dom;
		            var domStyle = dom.style;
		            var domBack = this.domBack;

		            domStyle.width = width + 'px';
		            domStyle.height = height + 'px';

		            dom.width = width * dpr;
		            dom.height = height * dpr;

		            if (domBack) {
		                domBack.width = width * dpr;
		                domBack.height = height * dpr;

		                if (dpr != 1) {
		                    this.ctxBack.scale(dpr, dpr);
		                }
		            }
		        },

		        /**
		         * 清空该层画布
		         * @param {boolean} clearAll Clear all with out motion blur
		         */
		        clear: function (clearAll) {
		            var dom = this.dom;
		            var ctx = this.ctx;
		            var width = dom.width;
		            var height = dom.height;

		            var clearColor = this.clearColor;
		            var haveMotionBLur = this.motionBlur && !clearAll;
		            var lastFrameAlpha = this.lastFrameAlpha;

		            var dpr = this.dpr;

		            if (haveMotionBLur) {
		                if (!this.domBack) {
		                    this.createBackBuffer();
		                }

		                this.ctxBack.globalCompositeOperation = 'copy';
		                this.ctxBack.drawImage(
		                    dom, 0, 0,
		                    width / dpr,
		                    height / dpr
		                );
		            }

		            ctx.clearRect(0, 0, width, height);
		            if (clearColor) {
		                var clearColorGradientOrPattern;
		                // Gradient
		                if (clearColor.colorStops) {
		                    // Cache canvas gradient
		                    clearColorGradientOrPattern = clearColor.__canvasGradient || Style.getGradient(ctx, clearColor, {
		                        x: 0,
		                        y: 0,
		                        width: width,
		                        height: height
		                    });

		                    clearColor.__canvasGradient = clearColorGradientOrPattern;
		                }
		                // Pattern
		                else if (clearColor.image) {
		                    clearColorGradientOrPattern = Pattern.prototype.getCanvasPattern.call(clearColor, ctx);
		                }
		                ctx.save();
		                ctx.fillStyle = clearColorGradientOrPattern || clearColor;
		                ctx.fillRect(0, 0, width, height);
		                ctx.restore();
		            }

		            if (haveMotionBLur) {
		                var domBack = this.domBack;
		                ctx.save();
		                ctx.globalAlpha = lastFrameAlpha;
		                ctx.drawImage(domBack, 0, 0, width, height);
		                ctx.restore();
		            }
		        }
		    };

		    module.exports = Layer;


	/***/ },
	/* 94 */
	/***/ function(module, exports, __webpack_require__) {

		
		    var Gradient = __webpack_require__(79);
		    module.exports = function (ecModel) {
		        function encodeColor(seriesModel) {
		            var colorAccessPath = (seriesModel.visualColorAccessPath || 'itemStyle.normal.color').split('.');
		            var data = seriesModel.getData();
		            var color = seriesModel.get(colorAccessPath) // Set in itemStyle
		                || seriesModel.getColorFromPalette(seriesModel.get('name'));  // Default color

		            // FIXME Set color function or use the platte color
		            data.setVisual('color', color);

		            // Only visible series has each data be visual encoded
		            if (!ecModel.isSeriesFiltered(seriesModel)) {
		                if (typeof color === 'function' && !(color instanceof Gradient)) {
		                    data.each(function (idx) {
		                        data.setItemVisual(
		                            idx, 'color', color(seriesModel.getDataParams(idx))
		                        );
		                    });
		                }

		                // itemStyle in each data item
		                data.each(function (idx) {
		                    var itemModel = data.getItemModel(idx);
		                    var color = itemModel.get(colorAccessPath, true);
		                    if (color != null) {
		                        data.setItemVisual(idx, 'color', color);
		                    }
		                });
		            }
		        }
		        ecModel.eachRawSeries(encodeColor);
		    };


	/***/ },
	/* 95 */
	/***/ function(module, exports, __webpack_require__) {

		// Compatitable with 2.0


		    var zrUtil = __webpack_require__(4);
		    var compatStyle = __webpack_require__(96);

		    function get(opt, path) {
		        path = path.split(',');
		        var obj = opt;
		        for (var i = 0; i < path.length; i++) {
		            obj = obj && obj[path[i]];
		            if (obj == null) {
		                break;
		            }
		        }
		        return obj;
		    }

		    function set(opt, path, val, overwrite) {
		        path = path.split(',');
		        var obj = opt;
		        var key;
		        for (var i = 0; i < path.length - 1; i++) {
		            key = path[i];
		            if (obj[key] == null) {
		                obj[key] = {};
		            }
		            obj = obj[key];
		        }
		        if (overwrite || obj[path[i]] == null) {
		            obj[path[i]] = val;
		        }
		    }

		    function compatLayoutProperties(option) {
		        each(LAYOUT_PROPERTIES, function (prop) {
		            if (prop[0] in option && !(prop[1] in option)) {
		                option[prop[1]] = option[prop[0]];
		            }
		        });
		    }

		    var LAYOUT_PROPERTIES = [
		        ['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']
		    ];

		    var COMPATITABLE_COMPONENTS = [
		        'grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline'
		    ];

		    var COMPATITABLE_SERIES = [
		        'bar', 'boxplot', 'candlestick', 'chord', 'effectScatter',
		        'funnel', 'gauge', 'lines', 'graph', 'heatmap', 'line', 'map', 'parallel',
		        'pie', 'radar', 'sankey', 'scatter', 'treemap'
		    ];

		    var each = zrUtil.each;

		    module.exports = function (option) {
		        each(option.series, function (seriesOpt) {
		            if (!zrUtil.isObject(seriesOpt)) {
		                return;
		            }

		            var seriesType = seriesOpt.type;

		            compatStyle(seriesOpt);

		            if (seriesType === 'pie' || seriesType === 'gauge') {
		                if (seriesOpt.clockWise != null) {
		                    seriesOpt.clockwise = seriesOpt.clockWise;
		                }
		            }
		            if (seriesType === 'gauge') {
		                var pointerColor = get(seriesOpt, 'pointer.color');
		                pointerColor != null
		                    && set(seriesOpt, 'itemStyle.normal.color', pointerColor);
		            }

		            for (var i = 0; i < COMPATITABLE_SERIES.length; i++) {
		                if (COMPATITABLE_SERIES[i] === seriesOpt.type) {
		                    compatLayoutProperties(seriesOpt);
		                    break;
		                }
		            }
		        });

		        // dataRange has changed to visualMap
		        if (option.dataRange) {
		            option.visualMap = option.dataRange;
		        }

		        each(COMPATITABLE_COMPONENTS, function (componentName) {
		            var options = option[componentName];
		            if (options) {
		                if (!zrUtil.isArray(options)) {
		                    options = [options];
		                }
		                each(options, function (option) {
		                    compatLayoutProperties(option);
		                });
		            }
		        });
		    };


	/***/ },
	/* 96 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    var POSSIBLE_STYLES = [
		        'areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle',
		        'chordStyle', 'label', 'labelLine'
		    ];

		    function compatItemStyle(opt) {
		        var itemStyleOpt = opt && opt.itemStyle;
		        if (itemStyleOpt) {
		            zrUtil.each(POSSIBLE_STYLES, function (styleName) {
		                var normalItemStyleOpt = itemStyleOpt.normal;
		                var emphasisItemStyleOpt = itemStyleOpt.emphasis;
		                if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
		                    opt[styleName] = opt[styleName] || {};
		                    if (!opt[styleName].normal) {
		                        opt[styleName].normal = normalItemStyleOpt[styleName];
		                    }
		                    else {
		                        zrUtil.merge(opt[styleName].normal, normalItemStyleOpt[styleName]);
		                    }
		                    normalItemStyleOpt[styleName] = null;
		                }
		                if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
		                    opt[styleName] = opt[styleName] || {};
		                    if (!opt[styleName].emphasis) {
		                        opt[styleName].emphasis = emphasisItemStyleOpt[styleName];
		                    }
		                    else {
		                        zrUtil.merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName]);
		                    }
		                    emphasisItemStyleOpt[styleName] = null;
		                }
		            });
		        }
		    }

		    module.exports = function (seriesOpt) {
		        if (!seriesOpt) {
		            return;
		        }
		        compatItemStyle(seriesOpt);
		        compatItemStyle(seriesOpt.markPoint);
		        compatItemStyle(seriesOpt.markLine);
		        var data = seriesOpt.data;
		        if (data) {
		            for (var i = 0; i < data.length; i++) {
		                compatItemStyle(data[i]);
		            }
		            // mark point data
		            var markPoint = seriesOpt.markPoint;
		            if (markPoint && markPoint.data) {
		                var mpData = markPoint.data;
		                for (var i = 0; i < mpData.length; i++) {
		                    compatItemStyle(mpData[i]);
		                }
		            }
		            // mark line data
		            var markLine = seriesOpt.markLine;
		            if (markLine && markLine.data) {
		                var mlData = markLine.data;
		                for (var i = 0; i < mlData.length; i++) {
		                    if (zrUtil.isArray(mlData[i])) {
		                        compatItemStyle(mlData[i][0]);
		                        compatItemStyle(mlData[i][1]);
		                    }
		                    else {
		                        compatItemStyle(mlData[i]);
		                    }
		                }
		            }
		        }
		    };


	/***/ },
	/* 97 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var graphic = __webpack_require__(43);
		    var zrUtil = __webpack_require__(4);
		    var PI = Math.PI;
		    /**
		     * @param {module:echarts/ExtensionAPI} api
		     * @param {Object} [opts]
		     * @param {string} [opts.text]
		     * @param {string} [opts.color]
		     * @param {string} [opts.textColor]
		     * @return {module:zrender/Element}
		     */
		    module.exports = function (api, opts) {
		        opts = opts || {};
		        zrUtil.defaults(opts, {
		            text: 'loading',
		            color: '#c23531',
		            textColor: '#000',
		            maskColor: 'rgba(255, 255, 255, 0.8)',
		            zlevel: 0
		        });
		        var mask = new graphic.Rect({
		            style: {
		                fill: opts.maskColor
		            },
		            zlevel: opts.zlevel,
		            z: 10000
		        });
		        var arc = new graphic.Arc({
		            shape: {
		                startAngle: -PI / 2,
		                endAngle: -PI / 2 + 0.1,
		                r: 10
		            },
		            style: {
		                stroke: opts.color,
		                lineCap: 'round',
		                lineWidth: 5
		            },
		            zlevel: opts.zlevel,
		            z: 10001
		        });
		        var labelRect = new graphic.Rect({
		            style: {
		                fill: 'none',
		                text: opts.text,
		                textPosition: 'right',
		                textDistance: 10,
		                textFill: opts.textColor
		            },
		            zlevel: opts.zlevel,
		            z: 10001
		        });

		        arc.animateShape(true)
		            .when(1000, {
		                endAngle: PI * 3 / 2
		            })
		            .start('circularInOut');
		        arc.animateShape(true)
		            .when(1000, {
		                startAngle: PI * 3 / 2
		            })
		            .delay(300)
		            .start('circularInOut');

		        var group = new graphic.Group();
		        group.add(arc);
		        group.add(labelRect);
		        group.add(mask);
		        // Inject resize
		        group.resize = function () {
		            var cx = api.getWidth() / 2;
		            var cy = api.getHeight() / 2;
		            arc.setShape({
		                cx: cx,
		                cy: cy
		            });
		            var r = arc.shape.r;
		            labelRect.setShape({
		                x: cx - r,
		                y: cy - r,
		                width: r * 2,
		                height: r * 2
		            });

		            mask.setShape({
		                x: 0,
		                y: 0,
		                width: api.getWidth(),
		                height: api.getHeight()
		            });
		        };
		        group.resize();
		        return group;
		    };


	/***/ },
	/* 98 */
	/***/ function(module, exports, __webpack_require__) {

		/* WEBPACK VAR INJECTION */(function(global) {/**
		 * List for data storage
		 * @module echarts/data/List
		 */


		    var UNDEFINED = 'undefined';
		    var globalObj = typeof window === 'undefined' ? global : window;
		    var Float64Array = typeof globalObj.Float64Array === UNDEFINED
		        ? Array : globalObj.Float64Array;
		    var Int32Array = typeof globalObj.Int32Array === UNDEFINED
		        ? Array : globalObj.Int32Array;

		    var dataCtors = {
		        'float': Float64Array,
		        'int': Int32Array,
		        // Ordinal data type can be string or int
		        'ordinal': Array,
		        'number': Array,
		        'time': Array
		    };

		    var Model = __webpack_require__(12);
		    var DataDiffer = __webpack_require__(99);

		    var zrUtil = __webpack_require__(4);
		    var modelUtil = __webpack_require__(5);
		    var isObject = zrUtil.isObject;

		    var TRANSFERABLE_PROPERTIES = [
		        'stackedOn', 'hasItemOption', '_nameList', '_idList', '_rawData'
		    ];

		    var transferProperties = function (a, b) {
		        zrUtil.each(TRANSFERABLE_PROPERTIES.concat(b.__wrappedMethods || []), function (propName) {
		            if (b.hasOwnProperty(propName)) {
		                a[propName] = b[propName];
		            }
		        });

		        a.__wrappedMethods = b.__wrappedMethods;
		    };

		    /**
		     * @constructor
		     * @alias module:echarts/data/List
		     *
		     * @param {Array.<string>} dimensions
		     *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
		     * @param {module:echarts/model/Model} hostModel
		     */
		    var List = function (dimensions, hostModel) {

		        dimensions = dimensions || ['x', 'y'];

		        var dimensionInfos = {};
		        var dimensionNames = [];
		        for (var i = 0; i < dimensions.length; i++) {
		            var dimensionName;
		            var dimensionInfo = {};
		            if (typeof dimensions[i] === 'string') {
		                dimensionName = dimensions[i];
		                dimensionInfo = {
		                    name: dimensionName,
		                    stackable: false,
		                    // Type can be 'float', 'int', 'number'
		                    // Default is number, Precision of float may not enough
		                    type: 'number'
		                };
		            }
		            else {
		                dimensionInfo = dimensions[i];
		                dimensionName = dimensionInfo.name;
		                dimensionInfo.type = dimensionInfo.type || 'number';
		            }
		            dimensionNames.push(dimensionName);
		            dimensionInfos[dimensionName] = dimensionInfo;
		        }
		        /**
		         * @readOnly
		         * @type {Array.<string>}
		         */
		        this.dimensions = dimensionNames;

		        /**
		         * Infomation of each data dimension, like data type.
		         * @type {Object}
		         */
		        this._dimensionInfos = dimensionInfos;

		        /**
		         * @type {module:echarts/model/Model}
		         */
		        this.hostModel = hostModel;

		        /**
		         * @type {module:echarts/model/Model}
		         */
		        this.dataType;

		        /**
		         * Indices stores the indices of data subset after filtered.
		         * This data subset will be used in chart.
		         * @type {Array.<number>}
		         * @readOnly
		         */
		        this.indices = [];

		        /**
		         * Data storage
		         * @type {Object.<key, TypedArray|Array>}
		         * @private
		         */
		        this._storage = {};

		        /**
		         * @type {Array.<string>}
		         */
		        this._nameList = [];
		        /**
		         * @type {Array.<string>}
		         */
		        this._idList = [];
		        /**
		         * Models of data option is stored sparse for optimizing memory cost
		         * @type {Array.<module:echarts/model/Model>}
		         * @private
		         */
		        this._optionModels = [];

		        /**
		         * @param {module:echarts/data/List}
		         */
		        this.stackedOn = null;

		        /**
		         * Global visual properties after visual coding
		         * @type {Object}
		         * @private
		         */
		        this._visual = {};

		        /**
		         * Globel layout properties.
		         * @type {Object}
		         * @private
		         */
		        this._layout = {};

		        /**
		         * Item visual properties after visual coding
		         * @type {Array.<Object>}
		         * @private
		         */
		        this._itemVisuals = [];

		        /**
		         * Item layout properties after layout
		         * @type {Array.<Object>}
		         * @private
		         */
		        this._itemLayouts = [];

		        /**
		         * Graphic elemnents
		         * @type {Array.<module:zrender/Element>}
		         * @private
		         */
		        this._graphicEls = [];

		        /**
		         * @type {Array.<Array|Object>}
		         * @private
		         */
		        this._rawData;

		        /**
		         * @type {Object}
		         * @private
		         */
		        this._extent;
		    };

		    var listProto = List.prototype;

		    listProto.type = 'list';
		    /**
		     * If each data item has it's own option
		     * @type {boolean}
		     */
		    listProto.hasItemOption = true;

		    /**
		     * Get dimension name
		     * @param {string|number} dim
		     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
		     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
		     * @return {string} Concrete dim name.
		     */
		    listProto.getDimension = function (dim) {
		        if (!isNaN(dim)) {
		            dim = this.dimensions[dim] || dim;
		        }
		        return dim;
		    };
		    /**
		     * Get type and stackable info of particular dimension
		     * @param {string|number} dim
		     *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
		     *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
		     */
		    listProto.getDimensionInfo = function (dim) {
		        return zrUtil.clone(this._dimensionInfos[this.getDimension(dim)]);
		    };

		    /**
		     * Initialize from data
		     * @param {Array.<Object|number|Array>} data
		     * @param {Array.<string>} [nameList]
		     * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number
		     */
		    listProto.initData = function (data, nameList, dimValueGetter) {
		        data = data || [];

		        if (true) {
		            if (!zrUtil.isArray(data)) {
		                throw new Error('Invalid data.');
		            }
		        }

		        this._rawData = data;

		        // Clear
		        var storage = this._storage = {};
		        var indices = this.indices = [];

		        var dimensions = this.dimensions;
		        var size = data.length;
		        var dimensionInfoMap = this._dimensionInfos;

		        var idList = [];
		        var nameRepeatCount = {};

		        nameList = nameList || [];

		        // Init storage
		        for (var i = 0; i < dimensions.length; i++) {
		            var dimInfo = dimensionInfoMap[dimensions[i]];
		            var DataCtor = dataCtors[dimInfo.type];
		            storage[dimensions[i]] = new DataCtor(size);
		        }

		        var self = this;
		        if (!dimValueGetter) {
		            self.hasItemOption = false;
		        }
		        // Default dim value getter
		        dimValueGetter = dimValueGetter || function (dataItem, dimName, dataIndex, dimIndex) {
		            var value = modelUtil.getDataItemValue(dataItem);
		            // If any dataItem is like { value: 10 }
		            if (modelUtil.isDataItemOption(dataItem)) {
		                self.hasItemOption = true;
		            }
		            return modelUtil.converDataValue(
		                (value instanceof Array)
		                    ? value[dimIndex]
		                    // If value is a single number or something else not array.
		                    : value,
		                dimensionInfoMap[dimName]
		            );
		        };

		        for (var idx = 0; idx < data.length; idx++) {
		            var dataItem = data[idx];
		            // Each data item is value
		            // [1, 2]
		            // 2
		            // Bar chart, line chart which uses category axis
		            // only gives the 'y' value. 'x' value is the indices of cateogry
		            // Use a tempValue to normalize the value to be a (x, y) value

		            // Store the data by dimensions
		            for (var k = 0; k < dimensions.length; k++) {
		                var dim = dimensions[k];
		                var dimStorage = storage[dim];
		                // PENDING NULL is empty or zero
		                dimStorage[idx] = dimValueGetter(dataItem, dim, idx, k);
		            }

		            indices.push(idx);
		        }

		        // Use the name in option and create id
		        for (var i = 0; i < data.length; i++) {
		            if (!nameList[i]) {
		                if (data[i] && data[i].name != null) {
		                    nameList[i] = data[i].name;
		                }
		            }
		            var name = nameList[i] || '';
		            // Try using the id in option
		            var id = data[i] && data[i].id;

		            if (!id && name) {
		                // Use name as id and add counter to avoid same name
		                nameRepeatCount[name] = nameRepeatCount[name] || 0;
		                id = name;
		                if (nameRepeatCount[name] > 0) {
		                    id += '__ec__' + nameRepeatCount[name];
		                }
		                nameRepeatCount[name]++;
		            }
		            id && (idList[i] = id);
		        }

		        this._nameList = nameList;
		        this._idList = idList;
		    };

		    /**
		     * @return {number}
		     */
		    listProto.count = function () {
		        return this.indices.length;
		    };

		    /**
		     * Get value. Return NaN if idx is out of range.
		     * @param {string} dim Dim must be concrete name.
		     * @param {number} idx
		     * @param {boolean} stack
		     * @return {number}
		     */
		    listProto.get = function (dim, idx, stack) {
		        var storage = this._storage;
		        var dataIndex = this.indices[idx];

		        // If value not exists
		        if (dataIndex == null) {
		            return NaN;
		        }

		        var value = storage[dim] && storage[dim][dataIndex];
		        // FIXME ordinal data type is not stackable
		        if (stack) {
		            var dimensionInfo = this._dimensionInfos[dim];
		            if (dimensionInfo && dimensionInfo.stackable) {
		                var stackedOn = this.stackedOn;
		                while (stackedOn) {
		                    // Get no stacked data of stacked on
		                    var stackedValue = stackedOn.get(dim, idx);
		                    // Considering positive stack, negative stack and empty data
		                    if ((value >= 0 && stackedValue > 0)  // Positive stack
		                        || (value <= 0 && stackedValue < 0) // Negative stack
		                    ) {
		                        value += stackedValue;
		                    }
		                    stackedOn = stackedOn.stackedOn;
		                }
		            }
		        }
		        return value;
		    };

		    /**
		     * Get value for multi dimensions.
		     * @param {Array.<string>} [dimensions] If ignored, using all dimensions.
		     * @param {number} idx
		     * @param {boolean} stack
		     * @return {number}
		     */
		    listProto.getValues = function (dimensions, idx, stack) {
		        var values = [];

		        if (!zrUtil.isArray(dimensions)) {
		            stack = idx;
		            idx = dimensions;
		            dimensions = this.dimensions;
		        }

		        for (var i = 0, len = dimensions.length; i < len; i++) {
		            values.push(this.get(dimensions[i], idx, stack));
		        }

		        return values;
		    };

		    /**
		     * If value is NaN. Inlcuding '-'
		     * @param {string} dim
		     * @param {number} idx
		     * @return {number}
		     */
		    listProto.hasValue = function (idx) {
		        var dimensions = this.dimensions;
		        var dimensionInfos = this._dimensionInfos;
		        for (var i = 0, len = dimensions.length; i < len; i++) {
		            if (
		                // Ordinal type can be string or number
		                dimensionInfos[dimensions[i]].type !== 'ordinal'
		                && isNaN(this.get(dimensions[i], idx))
		            ) {
		                return false;
		            }
		        }
		        return true;
		    };

		    /**
		     * Get extent of data in one dimension
		     * @param {string} dim
		     * @param {boolean} stack
		     */
		    listProto.getDataExtent = function (dim, stack) {
		        dim = this.getDimension(dim);
		        var dimData = this._storage[dim];
		        var dimInfo = this.getDimensionInfo(dim);
		        stack = (dimInfo && dimInfo.stackable) && stack;
		        var dimExtent = (this._extent || (this._extent = {}))[dim + (!!stack)];
		        var value;
		        if (dimExtent) {
		            return dimExtent;
		        }
		        // var dimInfo = this._dimensionInfos[dim];
		        if (dimData) {
		            var min = Infinity;
		            var max = -Infinity;
		            // var isOrdinal = dimInfo.type === 'ordinal';
		            for (var i = 0, len = this.count(); i < len; i++) {
		                value = this.get(dim, i, stack);
		                // FIXME
		                // if (isOrdinal && typeof value === 'string') {
		                //     value = zrUtil.indexOf(dimData, value);
		                // }
		                value < min && (min = value);
		                value > max && (max = value);
		            }
		            return (this._extent[dim + !!stack] = [min, max]);
		        }
		        else {
		            return [Infinity, -Infinity];
		        }
		    };

		    /**
		     * Get sum of data in one dimension
		     * @param {string} dim
		     * @param {boolean} stack
		     */
		    listProto.getSum = function (dim, stack) {
		        var dimData = this._storage[dim];
		        var sum = 0;
		        if (dimData) {
		            for (var i = 0, len = this.count(); i < len; i++) {
		                var value = this.get(dim, i, stack);
		                if (!isNaN(value)) {
		                    sum += value;
		                }
		            }
		        }
		        return sum;
		    };

		    /**
		     * Retreive the index with given value
		     * @param {number} idx
		     * @param {number} value
		     * @return {number}
		     */
		    // FIXME Precision of float value
		    listProto.indexOf = function (dim, value) {
		        var storage = this._storage;
		        var dimData = storage[dim];
		        var indices = this.indices;

		        if (dimData) {
		            for (var i = 0, len = indices.length; i < len; i++) {
		                var rawIndex = indices[i];
		                if (dimData[rawIndex] === value) {
		                    return i;
		                }
		            }
		        }
		        return -1;
		    };

		    /**
		     * Retreive the index with given name
		     * @param {number} idx
		     * @param {number} name
		     * @return {number}
		     */
		    listProto.indexOfName = function (name) {
		        var indices = this.indices;
		        var nameList = this._nameList;

		        for (var i = 0, len = indices.length; i < len; i++) {
		            var rawIndex = indices[i];
		            if (nameList[rawIndex] === name) {
		                return i;
		            }
		        }

		        return -1;
		    };

		    /**
		     * Retreive the index with given raw data index
		     * @param {number} idx
		     * @param {number} name
		     * @return {number}
		     */
		    listProto.indexOfRawIndex = function (rawIndex) {
		        // Indices are ascending
		        var indices = this.indices;

		        // If rawIndex === dataIndex
		        var rawDataIndex = indices[rawIndex];
		        if (rawDataIndex != null && rawDataIndex === rawIndex) {
		            return rawIndex;
		        }

		        var left = 0;
		        var right = indices.length - 1;
		        while (left <= right) {
		            var mid = (left + right) / 2 | 0;
		            if (indices[mid] < rawIndex) {
		                left = mid + 1;
		            }
		            else if (indices[mid] > rawIndex) {
		                right = mid - 1;
		            }
		            else {
		                return mid;
		            }
		        }
		        return -1;
		    };

		    /**
		     * Retreive the index of nearest value
		     * @param {string} dim
		     * @param {number} value
		     * @param {boolean} stack If given value is after stacked
		     * @param {number} [maxDistance=Infinity]
		     * @return {number}
		     */
		    listProto.indexOfNearest = function (dim, value, stack, maxDistance) {
		        var storage = this._storage;
		        var dimData = storage[dim];

		        if (maxDistance == null) {
		            maxDistance = Infinity;
		        }

		        var nearestIdx = -1;
		        if (dimData) {
		            var minDist = Number.MAX_VALUE;
		            for (var i = 0, len = this.count(); i < len; i++) {
		                var diff = value - this.get(dim, i, stack);
		                var dist = Math.abs(diff);
		                if (
		                    diff <= maxDistance
		                    && (dist < minDist
		                        // For the case of two data are same on xAxis, which has sequence data.
		                        // Show the nearest index
		                        // https://github.com/ecomfe/echarts/issues/2869
		                        || (dist === minDist && diff > 0)
		                    )
		                ) {
		                    minDist = dist;
		                    nearestIdx = i;
		                }
		            }
		        }
		        return nearestIdx;
		    };

		    /**
		     * Get raw data index
		     * @param {number} idx
		     * @return {number}
		     */
		    listProto.getRawIndex = function (idx) {
		        var rawIdx = this.indices[idx];
		        return rawIdx == null ? -1 : rawIdx;
		    };

		    /**
		     * Get raw data item
		     * @param {number} idx
		     * @return {number}
		     */
		    listProto.getRawDataItem = function (idx) {
		        return this._rawData[this.getRawIndex(idx)];
		    };

		    /**
		     * @param {number} idx
		     * @param {boolean} [notDefaultIdx=false]
		     * @return {string}
		     */
		    listProto.getName = function (idx) {
		        return this._nameList[this.indices[idx]] || '';
		    };

		    /**
		     * @param {number} idx
		     * @param {boolean} [notDefaultIdx=false]
		     * @return {string}
		     */
		    listProto.getId = function (idx) {
		        return this._idList[this.indices[idx]] || (this.getRawIndex(idx) + '');
		    };


		    function normalizeDimensions(dimensions) {
		        if (!zrUtil.isArray(dimensions)) {
		            dimensions = [dimensions];
		        }
		        return dimensions;
		    }

		    /**
		     * Data iteration
		     * @param {string|Array.<string>}
		     * @param {Function} cb
		     * @param {boolean} [stack=false]
		     * @param {*} [context=this]
		     *
		     * @example
		     *  list.each('x', function (x, idx) {});
		     *  list.each(['x', 'y'], function (x, y, idx) {});
		     *  list.each(function (idx) {})
		     */
		    listProto.each = function (dims, cb, stack, context) {
		        if (typeof dims === 'function') {
		            context = stack;
		            stack = cb;
		            cb = dims;
		            dims = [];
		        }

		        dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);

		        var value = [];
		        var dimSize = dims.length;
		        var indices = this.indices;

		        context = context || this;

		        for (var i = 0; i < indices.length; i++) {
		            // Simple optimization
		            switch (dimSize) {
		                case 0:
		                    cb.call(context, i);
		                    break;
		                case 1:
		                    cb.call(context, this.get(dims[0], i, stack), i);
		                    break;
		                case 2:
		                    cb.call(context, this.get(dims[0], i, stack), this.get(dims[1], i, stack), i);
		                    break;
		                default:
		                    for (var k = 0; k < dimSize; k++) {
		                        value[k] = this.get(dims[k], i, stack);
		                    }
		                    // Index
		                    value[k] = i;
		                    cb.apply(context, value);
		            }
		        }
		    };

		    /**
		     * Data filter
		     * @param {string|Array.<string>}
		     * @param {Function} cb
		     * @param {boolean} [stack=false]
		     * @param {*} [context=this]
		     */
		    listProto.filterSelf = function (dimensions, cb, stack, context) {
		        if (typeof dimensions === 'function') {
		            context = stack;
		            stack = cb;
		            cb = dimensions;
		            dimensions = [];
		        }

		        dimensions = zrUtil.map(
		            normalizeDimensions(dimensions), this.getDimension, this
		        );

		        var newIndices = [];
		        var value = [];
		        var dimSize = dimensions.length;
		        var indices = this.indices;

		        context = context || this;

		        for (var i = 0; i < indices.length; i++) {
		            var keep;
		            // Simple optimization
		            if (dimSize === 1) {
		                keep = cb.call(
		                    context, this.get(dimensions[0], i, stack), i
		                );
		            }
		            else {
		                for (var k = 0; k < dimSize; k++) {
		                    value[k] = this.get(dimensions[k], i, stack);
		                }
		                value[k] = i;
		                keep = cb.apply(context, value);
		            }
		            if (keep) {
		                newIndices.push(indices[i]);
		            }
		        }

		        this.indices = newIndices;

		        // Reset data extent
		        this._extent = {};

		        return this;
		    };

		    /**
		     * Data mapping to a plain array
		     * @param {string|Array.<string>} [dimensions]
		     * @param {Function} cb
		     * @param {boolean} [stack=false]
		     * @param {*} [context=this]
		     * @return {Array}
		     */
		    listProto.mapArray = function (dimensions, cb, stack, context) {
		        if (typeof dimensions === 'function') {
		            context = stack;
		            stack = cb;
		            cb = dimensions;
		            dimensions = [];
		        }

		        var result = [];
		        this.each(dimensions, function () {
		            result.push(cb && cb.apply(this, arguments));
		        }, stack, context);
		        return result;
		    };

		    function cloneListForMapAndSample(original, excludeDimensions) {
		        var allDimensions = original.dimensions;
		        var list = new List(
		            zrUtil.map(allDimensions, original.getDimensionInfo, original),
		            original.hostModel
		        );
		        // FIXME If needs stackedOn, value may already been stacked
		        transferProperties(list, original);

		        var storage = list._storage = {};
		        var originalStorage = original._storage;
		        // Init storage
		        for (var i = 0; i < allDimensions.length; i++) {
		            var dim = allDimensions[i];
		            var dimStore = originalStorage[dim];
		            if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {
		                storage[dim] = new dimStore.constructor(
		                    originalStorage[dim].length
		                );
		            }
		            else {
		                // Direct reference for other dimensions
		                storage[dim] = originalStorage[dim];
		            }
		        }
		        return list;
		    }

		    /**
		     * Data mapping to a new List with given dimensions
		     * @param {string|Array.<string>} dimensions
		     * @param {Function} cb
		     * @param {boolean} [stack=false]
		     * @param {*} [context=this]
		     * @return {Array}
		     */
		    listProto.map = function (dimensions, cb, stack, context) {
		        dimensions = zrUtil.map(
		            normalizeDimensions(dimensions), this.getDimension, this
		        );

		        var list = cloneListForMapAndSample(this, dimensions);
		        // Following properties are all immutable.
		        // So we can reference to the same value
		        var indices = list.indices = this.indices;

		        var storage = list._storage;

		        var tmpRetValue = [];
		        this.each(dimensions, function () {
		            var idx = arguments[arguments.length - 1];
		            var retValue = cb && cb.apply(this, arguments);
		            if (retValue != null) {
		                // a number
		                if (typeof retValue === 'number') {
		                    tmpRetValue[0] = retValue;
		                    retValue = tmpRetValue;
		                }
		                for (var i = 0; i < retValue.length; i++) {
		                    var dim = dimensions[i];
		                    var dimStore = storage[dim];
		                    var rawIdx = indices[idx];
		                    if (dimStore) {
		                        dimStore[rawIdx] = retValue[i];
		                    }
		                }
		            }
		        }, stack, context);

		        return list;
		    };

		    /**
		     * Large data down sampling on given dimension
		     * @param {string} dimension
		     * @param {number} rate
		     * @param {Function} sampleValue
		     * @param {Function} sampleIndex Sample index for name and id
		     */
		    listProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {
		        var list = cloneListForMapAndSample(this, [dimension]);
		        var storage = this._storage;
		        var targetStorage = list._storage;

		        var originalIndices = this.indices;
		        var indices = list.indices = [];

		        var frameValues = [];
		        var frameIndices = [];
		        var frameSize = Math.floor(1 / rate);

		        var dimStore = targetStorage[dimension];
		        var len = this.count();
		        // Copy data from original data
		        for (var i = 0; i < storage[dimension].length; i++) {
		            targetStorage[dimension][i] = storage[dimension][i];
		        }
		        for (var i = 0; i < len; i += frameSize) {
		            // Last frame
		            if (frameSize > len - i) {
		                frameSize = len - i;
		                frameValues.length = frameSize;
		            }
		            for (var k = 0; k < frameSize; k++) {
		                var idx = originalIndices[i + k];
		                frameValues[k] = dimStore[idx];
		                frameIndices[k] = idx;
		            }
		            var value = sampleValue(frameValues);
		            var idx = frameIndices[sampleIndex(frameValues, value) || 0];
		            // Only write value on the filtered data
		            dimStore[idx] = value;
		            indices.push(idx);
		        }

		        return list;
		    };

		    /**
		     * Get model of one data item.
		     *
		     * @param {number} idx
		     */
		    // FIXME Model proxy ?
		    listProto.getItemModel = function (idx) {
		        var hostModel = this.hostModel;
		        idx = this.indices[idx];
		        return new Model(this._rawData[idx], hostModel, hostModel && hostModel.ecModel);
		    };

		    /**
		     * Create a data differ
		     * @param {module:echarts/data/List} otherList
		     * @return {module:echarts/data/DataDiffer}
		     */
		    listProto.diff = function (otherList) {
		        var idList = this._idList;
		        var otherIdList = otherList && otherList._idList;
		        var val;
		        // Use prefix to avoid index to be the same as otherIdList[idx],
		        // which will cause weird udpate animation.
		        var prefix = 'e\0\0';

		        return new DataDiffer(
		            otherList ? otherList.indices : [],
		            this.indices,
		            function (idx) {
		                return (val = otherIdList[idx]) != null ? val : prefix + idx;
		            },
		            function (idx) {
		                return (val = idList[idx]) != null ? val : prefix + idx;
		            }
		        );
		    };
		    /**
		     * Get visual property.
		     * @param {string} key
		     */
		    listProto.getVisual = function (key) {
		        var visual = this._visual;
		        return visual && visual[key];
		    };

		    /**
		     * Set visual property
		     * @param {string|Object} key
		     * @param {*} [value]
		     *
		     * @example
		     *  setVisual('color', color);
		     *  setVisual({
		     *      'color': color
		     *  });
		     */
		    listProto.setVisual = function (key, val) {
		        if (isObject(key)) {
		            for (var name in key) {
		                if (key.hasOwnProperty(name)) {
		                    this.setVisual(name, key[name]);
		                }
		            }
		            return;
		        }
		        this._visual = this._visual || {};
		        this._visual[key] = val;
		    };

		    /**
		     * Set layout property.
		     * @param {string} key
		     * @param {*} [val]
		     */
		    listProto.setLayout = function (key, val) {
		        if (isObject(key)) {
		            for (var name in key) {
		                if (key.hasOwnProperty(name)) {
		                    this.setLayout(name, key[name]);
		                }
		            }
		            return;
		        }
		        this._layout[key] = val;
		    };

		    /**
		     * Get layout property.
		     * @param  {string} key.
		     * @return {*}
		     */
		    listProto.getLayout = function (key) {
		        return this._layout[key];
		    };

		    /**
		     * Get layout of single data item
		     * @param {number} idx
		     */
		    listProto.getItemLayout = function (idx) {
		        return this._itemLayouts[idx];
		    };

		    /**
		     * Set layout of single data item
		     * @param {number} idx
		     * @param {Object} layout
		     * @param {boolean=} [merge=false]
		     */
		    listProto.setItemLayout = function (idx, layout, merge) {
		        this._itemLayouts[idx] = merge
		            ? zrUtil.extend(this._itemLayouts[idx] || {}, layout)
		            : layout;
		    };

		    /**
		     * Clear all layout of single data item
		     */
		    listProto.clearItemLayouts = function () {
		        this._itemLayouts.length = 0;
		    };

		    /**
		     * Get visual property of single data item
		     * @param {number} idx
		     * @param {string} key
		     * @param {boolean} ignoreParent
		     */
		    listProto.getItemVisual = function (idx, key, ignoreParent) {
		        var itemVisual = this._itemVisuals[idx];
		        var val = itemVisual && itemVisual[key];
		        if (val == null && !ignoreParent) {
		            // Use global visual property
		            return this.getVisual(key);
		        }
		        return val;
		    };

		    /**
		     * Set visual property of single data item
		     *
		     * @param {number} idx
		     * @param {string|Object} key
		     * @param {*} [value]
		     *
		     * @example
		     *  setItemVisual(0, 'color', color);
		     *  setItemVisual(0, {
		     *      'color': color
		     *  });
		     */
		    listProto.setItemVisual = function (idx, key, value) {
		        var itemVisual = this._itemVisuals[idx] || {};
		        this._itemVisuals[idx] = itemVisual;

		        if (isObject(key)) {
		            for (var name in key) {
		                if (key.hasOwnProperty(name)) {
		                    itemVisual[name] = key[name];
		                }
		            }
		            return;
		        }
		        itemVisual[key] = value;
		    };

		    /**
		     * Clear itemVisuals and list visual.
		     */
		    listProto.clearAllVisual = function () {
		        this._visual = {};
		        this._itemVisuals = [];
		    };

		    var setItemDataAndSeriesIndex = function (child) {
		        child.seriesIndex = this.seriesIndex;
		        child.dataIndex = this.dataIndex;
		        child.dataType = this.dataType;
		    };
		    /**
		     * Set graphic element relative to data. It can be set as null
		     * @param {number} idx
		     * @param {module:zrender/Element} [el]
		     */
		    listProto.setItemGraphicEl = function (idx, el) {
		        var hostModel = this.hostModel;

		        if (el) {
		            // Add data index and series index for indexing the data by element
		            // Useful in tooltip
		            el.dataIndex = idx;
		            el.dataType = this.dataType;
		            el.seriesIndex = hostModel && hostModel.seriesIndex;
		            if (el.type === 'group') {
		                el.traverse(setItemDataAndSeriesIndex, el);
		            }
		        }

		        this._graphicEls[idx] = el;
		    };

		    /**
		     * @param {number} idx
		     * @return {module:zrender/Element}
		     */
		    listProto.getItemGraphicEl = function (idx) {
		        return this._graphicEls[idx];
		    };

		    /**
		     * @param {Function} cb
		     * @param {*} context
		     */
		    listProto.eachItemGraphicEl = function (cb, context) {
		        zrUtil.each(this._graphicEls, function (el, idx) {
		            if (el) {
		                cb && cb.call(context, el, idx);
		            }
		        });
		    };

		    /**
		     * Shallow clone a new list except visual and layout properties, and graph elements.
		     * New list only change the indices.
		     */
		    listProto.cloneShallow = function () {
		        var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);
		        var list = new List(dimensionInfoList, this.hostModel);

		        // FIXME
		        list._storage = this._storage;

		        transferProperties(list, this);


		        // Clone will not change the data extent and indices
		        list.indices = this.indices.slice();

		        if (this._extent) {
		            list._extent = zrUtil.extend({}, this._extent);
		        }

		        return list;
		    };

		    /**
		     * Wrap some method to add more feature
		     * @param {string} methodName
		     * @param {Function} injectFunction
		     */
		    listProto.wrapMethod = function (methodName, injectFunction) {
		        var originalMethod = this[methodName];
		        if (typeof originalMethod !== 'function') {
		            return;
		        }
		        this.__wrappedMethods = this.__wrappedMethods || [];
		        this.__wrappedMethods.push(methodName);
		        this[methodName] = function () {
		            var res = originalMethod.apply(this, arguments);
		            return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));
		        };
		    };

		    // Methods that create a new list based on this list should be listed here.
		    // Notice that those method should `RETURN` the new list.
		    listProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map'];
		    // Methods that change indices of this list should be listed here.
		    listProto.CHANGABLE_METHODS = ['filterSelf'];

		    module.exports = List;

		/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

	/***/ },
	/* 99 */
	/***/ function(module, exports) {

		'use strict';


		    function defaultKeyGetter(item) {
		        return item;
		    }

		    function DataDiffer(oldArr, newArr, oldKeyGetter, newKeyGetter) {
		        this._old = oldArr;
		        this._new = newArr;

		        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter;
		        this._newKeyGetter = newKeyGetter || defaultKeyGetter;
		    }

		    DataDiffer.prototype = {

		        constructor: DataDiffer,

		        /**
		         * Callback function when add a data
		         */
		        add: function (func) {
		            this._add = func;
		            return this;
		        },

		        /**
		         * Callback function when update a data
		         */
		        update: function (func) {
		            this._update = func;
		            return this;
		        },

		        /**
		         * Callback function when remove a data
		         */
		        remove: function (func) {
		            this._remove = func;
		            return this;
		        },

		        execute: function () {
		            var oldArr = this._old;
		            var newArr = this._new;
		            var oldKeyGetter = this._oldKeyGetter;
		            var newKeyGetter = this._newKeyGetter;

		            var oldDataIndexMap = {};
		            var newDataIndexMap = {};
		            var oldDataKeyArr = [];
		            var newDataKeyArr = [];
		            var i;

		            initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, oldKeyGetter);
		            initIndexMap(newArr, newDataIndexMap, newDataKeyArr, newKeyGetter);

		            // Travel by inverted order to make sure order consistency
		            // when duplicate keys exists (consider newDataIndex.pop() below).
		            // For performance consideration, these code below do not look neat.
		            for (i = 0; i < oldArr.length; i++) {
		                var key = oldDataKeyArr[i];
		                var idx = newDataIndexMap[key];

		                // idx can never be empty array here. see 'set null' logic below.
		                if (idx != null) {
		                    // Consider there is duplicate key (for example, use dataItem.name as key).
		                    // We should make sure every item in newArr and oldArr can be visited.
		                    var len = idx.length;
		                    if (len) {
		                        len === 1 && (newDataIndexMap[key] = null);
		                        idx = idx.unshift();
		                    }
		                    else {
		                        newDataIndexMap[key] = null;
		                    }
		                    this._update && this._update(idx, i);
		                }
		                else {
		                    this._remove && this._remove(i);
		                }
		            }

		            for (var i = 0; i < newDataKeyArr.length; i++) {
		                var key = newDataKeyArr[i];
		                if (newDataIndexMap.hasOwnProperty(key)) {
		                    var idx = newDataIndexMap[key];
		                    if (idx == null) {
		                        continue;
		                    }
		                    // idx can never be empty array here. see 'set null' logic above.
		                    if (!idx.length) {
		                        this._add && this._add(idx);
		                    }
		                    else {
		                        for (var j = 0, len = idx.length; j < len; j++) {
		                            this._add && this._add(idx[j]);
		                        }
		                    }
		                }
		            }
		        }
		    };

		    function initIndexMap(arr, map, keyArr, keyGetter) {
		        for (var i = 0; i < arr.length; i++) {
		            var key = keyGetter(arr[i], i);
		            var existence = map[key];
		            if (existence == null) {
		                keyArr.push(key);
		                map[key] = i;
		            }
		            else {
		                if (!existence.length) {
		                    map[key] = existence = [existence];
		                }
		                existence.push(i);
		            }
		        }
		    }

		    module.exports = DataDiffer;


	/***/ },
	/* 100 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var echarts = __webpack_require__(1);
		    var PRIORITY = echarts.PRIORITY;

		    __webpack_require__(101);
		    __webpack_require__(104);

		    echarts.registerVisual(zrUtil.curry(
		        __webpack_require__(110), 'line', 'circle', 'line'
		    ));
		    echarts.registerLayout(zrUtil.curry(
		        __webpack_require__(111), 'line'
		    ));

		    // Down sample after filter
		    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, zrUtil.curry(
		        __webpack_require__(112), 'line'
		    ));

		    // In case developer forget to include grid component
		    __webpack_require__(113);


	/***/ },
	/* 101 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var createListFromArray = __webpack_require__(102);
		    var SeriesModel = __webpack_require__(28);

		    module.exports = SeriesModel.extend({

		        type: 'series.line',

		        dependencies: ['grid', 'polar'],

		        getInitialData: function (option, ecModel) {
		            if (true) {
		                var coordSys = option.coordinateSystem;
		                if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {
		                    throw new Error('Line not support coordinateSystem besides cartesian and polar');
		                }
		            }
		            return createListFromArray(option.data, this, ecModel);
		        },

		        defaultOption: {
		            zlevel: 0,                  // 一级层叠
		            z: 2,                       // 二级层叠
		            coordinateSystem: 'cartesian2d',
		            legendHoverLink: true,

		            hoverAnimation: true,
		            // stack: null
		            // xAxisIndex: 0,
		            // yAxisIndex: 0,

		            // polarIndex: 0,

		            // If clip the overflow value
		            clipOverflow: true,

		            label: {
		                normal: {
		                    position: 'top'
		                }
		            },
		            // itemStyle: {
		            //     normal: {},
		            //     emphasis: {}
		            // },
		            lineStyle: {
		                normal: {
		                    width: 2,
		                    type: 'solid'
		                }
		            },
		            // areaStyle: {},
		            // false, 'start', 'end', 'middle'
		            step: false,

		            // Disabled if step is true
		            smooth: false,
		            smoothMonotone: null,
		            // 拐点图形类型
		            symbol: 'emptyCircle',
		            // 拐点图形大小
		            symbolSize: 4,
		            // 拐点图形旋转控制
		            symbolRotate: null,

		            // 是否显示 symbol, 只有在 tooltip hover 的时候显示
		            showSymbol: true,
		            // 标志图形默认只有主轴显示（随主轴标签间隔隐藏策略）
		            showAllSymbol: false,

		            // 是否连接断点
		            connectNulls: false,

		            // 数据过滤，'average', 'max', 'min', 'sum'
		            sampling: 'none',

		            animationEasing: 'linear',

		            // Disable progressive
		            progressive: 0,
		            hoverLayerThreshold: Infinity
		        }
		    });


	/***/ },
	/* 102 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var List = __webpack_require__(98);
		    var completeDimensions = __webpack_require__(103);
		    var zrUtil = __webpack_require__(4);
		    var modelUtil = __webpack_require__(5);
		    var CoordinateSystem = __webpack_require__(26);
		    var getDataItemValue = modelUtil.getDataItemValue;
		    var converDataValue = modelUtil.converDataValue;

		    function firstDataNotNull(data) {
		        var i = 0;
		        while (i < data.length && data[i] == null) {
		            i++;
		        }
		        return data[i];
		    }
		    function ifNeedCompleteOrdinalData(data) {
		        var sampleItem = firstDataNotNull(data);
		        return sampleItem != null
		            && !zrUtil.isArray(getDataItemValue(sampleItem));
		    }

		    /**
		     * Helper function to create a list from option data
		     */
		    function createListFromArray(data, seriesModel, ecModel) {
		        // If data is undefined
		        data = data || [];

		        if (true) {
		            if (!zrUtil.isArray(data)) {
		                throw new Error('Invalid data.');
		            }
		        }

		        var coordSysName = seriesModel.get('coordinateSystem');
		        var creator = creators[coordSysName];
		        var registeredCoordSys = CoordinateSystem.get(coordSysName);
		        // FIXME
		        var axesInfo = creator && creator(data, seriesModel, ecModel);
		        var dimensions = axesInfo && axesInfo.dimensions;
		        if (!dimensions) {
		            // Get dimensions from registered coordinate system
		            dimensions = (registeredCoordSys && registeredCoordSys.dimensions) || ['x', 'y'];
		            dimensions = completeDimensions(dimensions, data, dimensions.concat(['value']));
		        }
		        var categoryIndex = axesInfo ? axesInfo.categoryIndex : -1;

		        var list = new List(dimensions, seriesModel);

		        var nameList = createNameList(axesInfo, data);

		        var categories = {};
		        var dimValueGetter = (categoryIndex >= 0 && ifNeedCompleteOrdinalData(data))
		            ? function (itemOpt, dimName, dataIndex, dimIndex) {
		                // If any dataItem is like { value: 10 }
		                if (modelUtil.isDataItemOption(itemOpt)) {
		                    list.hasItemOption = true;
		                }

		                // Use dataIndex as ordinal value in categoryAxis
		                return dimIndex === categoryIndex
		                    ? dataIndex
		                    : converDataValue(getDataItemValue(itemOpt), dimensions[dimIndex]);
		            }
		            : function (itemOpt, dimName, dataIndex, dimIndex) {
		                var value = getDataItemValue(itemOpt);
		                var val = converDataValue(value && value[dimIndex], dimensions[dimIndex]);
		                // If any dataItem is like { value: 10 }
		                if (modelUtil.isDataItemOption(itemOpt)) {
		                    list.hasItemOption = true;
		                }

		                var categoryAxesModels = axesInfo && axesInfo.categoryAxesModels;
		                if (categoryAxesModels && categoryAxesModels[dimName]) {
		                    // If given value is a category string
		                    if (typeof val === 'string') {
		                        // Lazy get categories
		                        categories[dimName] = categories[dimName]
		                            || categoryAxesModels[dimName].getCategories();
		                        val = zrUtil.indexOf(categories[dimName], val);
		                        if (val < 0 && !isNaN(val)) {
		                            // In case some one write '1', '2' istead of 1, 2
		                            val = +val;
		                        }
		                    }
		                }
		                return val;
		            };

		        list.hasItemOption = false;
		        list.initData(data, nameList, dimValueGetter);

		        return list;
		    }

		    function isStackable(axisType) {
		        return axisType !== 'category' && axisType !== 'time';
		    }

		    function getDimTypeByAxis(axisType) {
		        return axisType === 'category'
		            ? 'ordinal'
		            : axisType === 'time'
		            ? 'time'
		            : 'float';
		    }

		    /**
		     * Creaters for each coord system.
		     */
		    var creators = {

		        cartesian2d: function (data, seriesModel, ecModel) {

		            var axesModels = zrUtil.map(['xAxis', 'yAxis'], function (name) {
		                return ecModel.queryComponents({
		                    mainType: name,
		                    index: seriesModel.get(name + 'Index'),
		                    id: seriesModel.get(name + 'Id')
		                })[0];
		            });
		            var xAxisModel = axesModels[0];
		            var yAxisModel = axesModels[1];

		            if (true) {
		                if (!xAxisModel) {
		                    throw new Error('xAxis "' + zrUtil.retrieve(
		                        seriesModel.get('xAxisIndex'),
		                        seriesModel.get('xAxisId'),
		                        0
		                    ) + '" not found');
		                }
		                if (!yAxisModel) {
		                    throw new Error('yAxis "' + zrUtil.retrieve(
		                        seriesModel.get('xAxisIndex'),
		                        seriesModel.get('yAxisId'),
		                        0
		                    ) + '" not found');
		                }
		            }

		            var xAxisType = xAxisModel.get('type');
		            var yAxisType = yAxisModel.get('type');

		            var dimensions = [
		                {
		                    name: 'x',
		                    type: getDimTypeByAxis(xAxisType),
		                    stackable: isStackable(xAxisType)
		                },
		                {
		                    name: 'y',
		                    // If two category axes
		                    type: getDimTypeByAxis(yAxisType),
		                    stackable: isStackable(yAxisType)
		                }
		            ];

		            var isXAxisCateogry = xAxisType === 'category';
		            var isYAxisCategory = yAxisType === 'category';

		            completeDimensions(dimensions, data, ['x', 'y', 'z']);

		            var categoryAxesModels = {};
		            if (isXAxisCateogry) {
		                categoryAxesModels.x = xAxisModel;
		            }
		            if (isYAxisCategory) {
		                categoryAxesModels.y = yAxisModel;
		            }
		            return {
		                dimensions: dimensions,
		                categoryIndex: isXAxisCateogry ? 0 : (isYAxisCategory ? 1 : -1),
		                categoryAxesModels: categoryAxesModels
		            };
		        },

		        polar: function (data, seriesModel, ecModel) {
		            var polarModel = ecModel.queryComponents({
		                mainType: 'polar',
		                index: seriesModel.get('polarIndex'),
		                id: seriesModel.get('polarId')
		            })[0];

		            var angleAxisModel = polarModel.findAxisModel('angleAxis');
		            var radiusAxisModel = polarModel.findAxisModel('radiusAxis');

		            if (true) {
		                if (!angleAxisModel) {
		                    throw new Error('angleAxis option not found');
		                }
		                if (!radiusAxisModel) {
		                    throw new Error('radiusAxis option not found');
		                }
		            }

		            var radiusAxisType = radiusAxisModel.get('type');
		            var angleAxisType = angleAxisModel.get('type');

		            var dimensions = [
		                {
		                    name: 'radius',
		                    type: getDimTypeByAxis(radiusAxisType),
		                    stackable: isStackable(radiusAxisType)
		                },
		                {
		                    name: 'angle',
		                    type: getDimTypeByAxis(angleAxisType),
		                    stackable: isStackable(angleAxisType)
		                }
		            ];
		            var isAngleAxisCateogry = angleAxisType === 'category';
		            var isRadiusAxisCateogry = radiusAxisType === 'category';

		            completeDimensions(dimensions, data, ['radius', 'angle', 'value']);

		            var categoryAxesModels = {};
		            if (isRadiusAxisCateogry) {
		                categoryAxesModels.radius = radiusAxisModel;
		            }
		            if (isAngleAxisCateogry) {
		                categoryAxesModels.angle = angleAxisModel;
		            }
		            return {
		                dimensions: dimensions,
		                categoryIndex: isAngleAxisCateogry ? 1 : (isRadiusAxisCateogry ? 0 : -1),
		                categoryAxesModels: categoryAxesModels
		            };
		        },

		        geo: function (data, seriesModel, ecModel) {
		            // TODO Region
		            // 多个散点图系列在同一个地区的时候
		            return {
		                dimensions: completeDimensions([
		                    {name: 'lng'},
		                    {name: 'lat'}
		                ], data, ['lng', 'lat', 'value'])
		            };
		        }
		    };

		    function createNameList(result, data) {
		        var nameList = [];

		        var categoryDim = result && result.dimensions[result.categoryIndex];
		        var categoryAxisModel;
		        if (categoryDim) {
		            categoryAxisModel = result.categoryAxesModels[categoryDim.name];
		        }

		        if (categoryAxisModel) {
		            // FIXME Two category axis
		            var categories = categoryAxisModel.getCategories();
		            if (categories) {
		                var dataLen = data.length;
		                // Ordered data is given explicitly like
		                // [[3, 0.2], [1, 0.3], [2, 0.15]]
		                // or given scatter data,
		                // pick the category
		                if (zrUtil.isArray(data[0]) && data[0].length > 1) {
		                    nameList = [];
		                    for (var i = 0; i < dataLen; i++) {
		                        nameList[i] = categories[data[i][result.categoryIndex || 0]];
		                    }
		                }
		                else {
		                    nameList = categories.slice(0);
		                }
		            }
		        }

		        return nameList;
		    }

		    module.exports = createListFromArray;



	/***/ },
	/* 103 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Complete dimensions by data (guess dimension).
		 */


		    var zrUtil = __webpack_require__(4);

		    /**
		     * Complete the dimensions array guessed from the data structure.
		     * @param  {Array.<string>} dimensions      Necessary dimensions, like ['x', 'y']
		     * @param  {Array} data                     Data list. [[1, 2, 3], [2, 3, 4]]
		     * @param  {Array.<string>} defaultNames    Default names to fill not necessary dimensions, like ['value']
		     * @param  {string} extraPrefix             Prefix of name when filling the left dimensions.
		     * @return {Array.<string>}
		     */
		    function completeDimensions(dimensions, data, defaultNames, extraPrefix) {
		        if (!data) {
		            return dimensions;
		        }

		        var value0 = retrieveValue(data[0]);
		        var dimSize = zrUtil.isArray(value0) && value0.length || 1;

		        defaultNames = defaultNames || [];
		        extraPrefix = extraPrefix || 'extra';
		        for (var i = 0; i < dimSize; i++) {
		            if (!dimensions[i]) {
		                var name = defaultNames[i] || (extraPrefix + (i - defaultNames.length));
		                dimensions[i] = guessOrdinal(data, i)
		                    ? {type: 'ordinal', name: name}
		                    : name;
		            }
		        }

		        return dimensions;
		    }

		    // The rule should not be complex, otherwise user might not
		    // be able to known where the data is wrong.
		    var guessOrdinal = completeDimensions.guessOrdinal = function (data, dimIndex) {
		        for (var i = 0, len = data.length; i < len; i++) {
		            var value = retrieveValue(data[i]);

		            if (!zrUtil.isArray(value)) {
		                return false;
		            }

		            var value = value[dimIndex];
		            if (value != null && isFinite(value)) {
		                return false;
		            }
		            else if (zrUtil.isString(value) && value !== '-') {
		                return true;
		            }
		        }
		        return false;
		    };

		    function retrieveValue(o) {
		        return zrUtil.isArray(o) ? o : zrUtil.isObject(o) ? o.value: o;
		    }

		    module.exports = completeDimensions;



	/***/ },
	/* 104 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		// FIXME step not support polar


		    var zrUtil = __webpack_require__(4);
		    var SymbolDraw = __webpack_require__(105);
		    var Symbol = __webpack_require__(106);
		    var lineAnimationDiff = __webpack_require__(108);
		    var graphic = __webpack_require__(43);
		    var modelUtil = __webpack_require__(5);
		    var polyHelper = __webpack_require__(109);
		    var ChartView = __webpack_require__(42);

		    function isPointsSame(points1, points2) {
		        if (points1.length !== points2.length) {
		            return;
		        }
		        for (var i = 0; i < points1.length; i++) {
		            var p1 = points1[i];
		            var p2 = points2[i];
		            if (p1[0] !== p2[0] || p1[1] !== p2[1]) {
		                return;
		            }
		        }
		        return true;
		    }

		    function getSmooth(smooth) {
		        return typeof (smooth) === 'number' ? smooth : (smooth ? 0.3 : 0);
		    }

		    function getAxisExtentWithGap(axis) {
		        var extent = axis.getGlobalExtent();
		        if (axis.onBand) {
		            // Remove extra 1px to avoid line miter in clipped edge
		            var halfBandWidth = axis.getBandWidth() / 2 - 1;
		            var dir = extent[1] > extent[0] ? 1 : -1;
		            extent[0] += dir * halfBandWidth;
		            extent[1] -= dir * halfBandWidth;
		        }
		        return extent;
		    }

		    function sign(val) {
		        return val >= 0 ? 1 : -1;
		    }
		    /**
		     * @param {module:echarts/coord/cartesian/Cartesian2D|module:echarts/coord/polar/Polar} coordSys
		     * @param {module:echarts/data/List} data
		     * @param {Array.<Array.<number>>} points
		     * @private
		     */
		    function getStackedOnPoints(coordSys, data) {
		        var baseAxis = coordSys.getBaseAxis();
		        var valueAxis = coordSys.getOtherAxis(baseAxis);
		        var valueStart = baseAxis.onZero
		            ? 0 : valueAxis.scale.getExtent()[0];

		        var valueDim = valueAxis.dim;

		        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;

		        return data.mapArray([valueDim], function (val, idx) {
		            var stackedOnSameSign;
		            var stackedOn = data.stackedOn;
		            // Find first stacked value with same sign
		            while (stackedOn &&
		                sign(stackedOn.get(valueDim, idx)) === sign(val)
		            ) {
		                stackedOnSameSign = stackedOn;
		                break;
		            }
		            var stackedData = [];
		            stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
		            stackedData[1 - baseDataOffset] = stackedOnSameSign
		                ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;

		            return coordSys.dataToPoint(stackedData);
		        }, true);
		    }

		    function createGridClipShape(cartesian, hasAnimation, seriesModel) {
		        var xExtent = getAxisExtentWithGap(cartesian.getAxis('x'));
		        var yExtent = getAxisExtentWithGap(cartesian.getAxis('y'));
		        var isHorizontal = cartesian.getBaseAxis().isHorizontal();

		        var x = Math.min(xExtent[0], xExtent[1]);
		        var y = Math.min(yExtent[0], yExtent[1]);
		        var width = Math.max(xExtent[0], xExtent[1]) - x;
		        var height = Math.max(yExtent[0], yExtent[1]) - y;
		        var lineWidth = seriesModel.get('lineStyle.normal.width') || 2;
		        // Expand clip shape to avoid clipping when line value exceeds axis
		        var expandSize = seriesModel.get('clipOverflow') ? lineWidth / 2 : Math.max(width, height);
		        if (isHorizontal) {
		            y -= expandSize;
		            height += expandSize * 2;
		        }
		        else {
		            x -= expandSize;
		            width += expandSize * 2;
		        }

		        var clipPath = new graphic.Rect({
		            shape: {
		                x: x,
		                y: y,
		                width: width,
		                height: height
		            }
		        });

		        if (hasAnimation) {
		            clipPath.shape[isHorizontal ? 'width' : 'height'] = 0;
		            graphic.initProps(clipPath, {
		                shape: {
		                    width: width,
		                    height: height
		                }
		            }, seriesModel);
		        }

		        return clipPath;
		    }

		    function createPolarClipShape(polar, hasAnimation, seriesModel) {
		        var angleAxis = polar.getAngleAxis();
		        var radiusAxis = polar.getRadiusAxis();

		        var radiusExtent = radiusAxis.getExtent();
		        var angleExtent = angleAxis.getExtent();

		        var RADIAN = Math.PI / 180;

		        var clipPath = new graphic.Sector({
		            shape: {
		                cx: polar.cx,
		                cy: polar.cy,
		                r0: radiusExtent[0],
		                r: radiusExtent[1],
		                startAngle: -angleExtent[0] * RADIAN,
		                endAngle: -angleExtent[1] * RADIAN,
		                clockwise: angleAxis.inverse
		            }
		        });

		        if (hasAnimation) {
		            clipPath.shape.endAngle = -angleExtent[0] * RADIAN;
		            graphic.initProps(clipPath, {
		                shape: {
		                    endAngle: -angleExtent[1] * RADIAN
		                }
		            }, seriesModel);
		        }

		        return clipPath;
		    }

		    function createClipShape(coordSys, hasAnimation, seriesModel) {
		        return coordSys.type === 'polar'
		            ? createPolarClipShape(coordSys, hasAnimation, seriesModel)
		            : createGridClipShape(coordSys, hasAnimation, seriesModel);
		    }

		    function turnPointsIntoStep(points, coordSys, stepTurnAt) {
		        var baseAxis = coordSys.getBaseAxis();
		        var baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1;

		        var stepPoints = [];
		        for (var i = 0; i < points.length - 1; i++) {
		            var nextPt = points[i + 1];
		            var pt = points[i];
		            stepPoints.push(pt);

		            var stepPt = [];
		            switch (stepTurnAt) {
		                case 'end':
		                    stepPt[baseIndex] = nextPt[baseIndex];
		                    stepPt[1 - baseIndex] = pt[1 - baseIndex];
		                    // default is start
		                    stepPoints.push(stepPt);
		                    break;
		                case 'middle':
		                    // default is start
		                    var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2;
		                    var stepPt2 = [];
		                    stepPt[baseIndex] = stepPt2[baseIndex] = middle;
		                    stepPt[1 - baseIndex] = pt[1 - baseIndex];
		                    stepPt2[1 - baseIndex] = nextPt[1 - baseIndex];
		                    stepPoints.push(stepPt);
		                    stepPoints.push(stepPt2);
		                    break;
		                default:
		                    stepPt[baseIndex] = pt[baseIndex];
		                    stepPt[1 - baseIndex] = nextPt[1 - baseIndex];
		                    // default is start
		                    stepPoints.push(stepPt);
		            }
		        }
		        // Last points
		        points[i] && stepPoints.push(points[i]);
		        return stepPoints;
		    }

		    function getVisualGradient(data, coordSys) {
		        var visualMetaList = data.getVisual('visualMeta');
		        if (!visualMetaList || !visualMetaList.length || !data.count()) {
		            // When data.count() is 0, gradient range can not be calculated.
		            return;
		        }

		        var visualMeta;
		        for (var i = visualMetaList.length - 1; i >= 0; i--) {
		            // Can only be x or y
		            if (visualMetaList[i].dimension < 2) {
		                visualMeta = visualMetaList[i];
		                break;
		            }
		        }
		        if (!visualMeta || coordSys.type !== 'cartesian2d') {
		            if (true) {
		                console.warn('Visual map on line style only support x or y dimension.');
		            }
		            return;
		        }

		        // If the area to be rendered is bigger than area defined by LinearGradient,
		        // the canvas spec prescribes that the color of the first stop and the last
		        // stop should be used. But if two stops are added at offset 0, in effect
		        // browsers use the color of the second stop to render area outside
		        // LinearGradient. So we can only infinitesimally extend area defined in
		        // LinearGradient to render `outerColors`.

		        var dimension = visualMeta.dimension;
		        var dimName = data.dimensions[dimension];
		        var axis = coordSys.getAxis(dimName);

		        // dataToCoor mapping may not be linear, but must be monotonic.
		        var colorStops = zrUtil.map(visualMeta.stops, function (stop) {
		            return {
		                coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
		                color: stop.color
		            };
		        });
		        var stopLen = colorStops.length;
		        var outerColors = visualMeta.outerColors.slice();

		        if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
		            colorStops.reverse();
		            outerColors.reverse();
		        }

		        var tinyExtent = 10; // Arbitrary value: 10px
		        var minCoord = colorStops[0].coord - tinyExtent;
		        var maxCoord = colorStops[stopLen - 1].coord + tinyExtent;
		        var coordSpan = maxCoord - minCoord;

		        if (coordSpan < 1e-3) {
		            return 'transparent';
		        }

		        zrUtil.each(colorStops, function (stop) {
		            stop.offset = (stop.coord - minCoord) / coordSpan;
		        });
		        colorStops.push({
		            offset: stopLen ? colorStops[stopLen - 1].offset : 0.5,
		            color: outerColors[1] || 'transparent'
		        });
		        colorStops.unshift({ // notice colorStops.length have been changed.
		            offset: stopLen ? colorStops[0].offset : 0.5,
		            color: outerColors[0] || 'transparent'
		        });

		        // zrUtil.each(colorStops, function (colorStop) {
		        //     // Make sure each offset has rounded px to avoid not sharp edge
		        //     colorStop.offset = (Math.round(colorStop.offset * (end - start) + start) - start) / (end - start);
		        // });

		        var gradient = new graphic.LinearGradient(0, 0, 0, 0, colorStops, true);
		        gradient[dimName] = minCoord;
		        gradient[dimName + '2'] = maxCoord;

		        return gradient;
		    }

		    module.exports = ChartView.extend({

		        type: 'line',

		        init: function () {
		            var lineGroup = new graphic.Group();

		            var symbolDraw = new SymbolDraw();
		            this.group.add(symbolDraw.group);

		            this._symbolDraw = symbolDraw;
		            this._lineGroup = lineGroup;
		        },

		        render: function (seriesModel, ecModel, api) {
		            var coordSys = seriesModel.coordinateSystem;
		            var group = this.group;
		            var data = seriesModel.getData();
		            var lineStyleModel = seriesModel.getModel('lineStyle.normal');
		            var areaStyleModel = seriesModel.getModel('areaStyle.normal');

		            var points = data.mapArray(data.getItemLayout, true);

		            var isCoordSysPolar = coordSys.type === 'polar';
		            var prevCoordSys = this._coordSys;

		            var symbolDraw = this._symbolDraw;
		            var polyline = this._polyline;
		            var polygon = this._polygon;

		            var lineGroup = this._lineGroup;

		            var hasAnimation = seriesModel.get('animation');

		            var isAreaChart = !areaStyleModel.isEmpty();
		            var stackedOnPoints = getStackedOnPoints(coordSys, data);

		            var showSymbol = seriesModel.get('showSymbol');

		            var isSymbolIgnore = showSymbol && !isCoordSysPolar && !seriesModel.get('showAllSymbol')
		                && this._getSymbolIgnoreFunc(data, coordSys);

		            // Remove temporary symbols
		            var oldData = this._data;
		            oldData && oldData.eachItemGraphicEl(function (el, idx) {
		                if (el.__temp) {
		                    group.remove(el);
		                    oldData.setItemGraphicEl(idx, null);
		                }
		            });

		            // Remove previous created symbols if showSymbol changed to false
		            if (!showSymbol) {
		                symbolDraw.remove();
		            }

		            group.add(lineGroup);

		            // FIXME step not support polar
		            var step = !isCoordSysPolar && seriesModel.get('step');
		            // Initialization animation or coordinate system changed
		            if (
		                !(polyline && prevCoordSys.type === coordSys.type && step === this._step)
		            ) {
		                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);

		                if (step) {
		                    // TODO If stacked series is not step
		                    points = turnPointsIntoStep(points, coordSys, step);
		                    stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
		                }

		                polyline = this._newPolyline(points, coordSys, hasAnimation);
		                if (isAreaChart) {
		                    polygon = this._newPolygon(
		                        points, stackedOnPoints,
		                        coordSys, hasAnimation
		                    );
		                }
		                lineGroup.setClipPath(createClipShape(coordSys, true, seriesModel));
		            }
		            else {
		                if (isAreaChart && !polygon) {
		                    // If areaStyle is added
		                    polygon = this._newPolygon(
		                        points, stackedOnPoints,
		                        coordSys, hasAnimation
		                    );
		                }
		                else if (polygon && !isAreaChart) {
		                    // If areaStyle is removed
		                    lineGroup.remove(polygon);
		                    polygon = this._polygon = null;
		                }

		                // Update clipPath
		                lineGroup.setClipPath(createClipShape(coordSys, false, seriesModel));

		                // Always update, or it is wrong in the case turning on legend
		                // because points are not changed
		                showSymbol && symbolDraw.updateData(data, isSymbolIgnore);

		                // Stop symbol animation and sync with line points
		                // FIXME performance?
		                data.eachItemGraphicEl(function (el) {
		                    el.stopAnimation(true);
		                });

		                // In the case data zoom triggerred refreshing frequently
		                // Data may not change if line has a category axis. So it should animate nothing
		                if (!isPointsSame(this._stackedOnPoints, stackedOnPoints)
		                    || !isPointsSame(this._points, points)
		                ) {
		                    if (hasAnimation) {
		                        this._updateAnimation(
		                            data, stackedOnPoints, coordSys, api, step
		                        );
		                    }
		                    else {
		                        // Not do it in update with animation
		                        if (step) {
		                            // TODO If stacked series is not step
		                            points = turnPointsIntoStep(points, coordSys, step);
		                            stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step);
		                        }

		                        polyline.setShape({
		                            points: points
		                        });
		                        polygon && polygon.setShape({
		                            points: points,
		                            stackedOnPoints: stackedOnPoints
		                        });
		                    }
		                }
		            }

		            var visualColor = getVisualGradient(data, coordSys) || data.getVisual('color');

		            polyline.useStyle(zrUtil.defaults(
		                // Use color in lineStyle first
		                lineStyleModel.getLineStyle(),
		                {
		                    fill: 'none',
		                    stroke: visualColor,
		                    lineJoin: 'bevel'
		                }
		            ));

		            var smooth = seriesModel.get('smooth');
		            smooth = getSmooth(seriesModel.get('smooth'));
		            polyline.setShape({
		                smooth: smooth,
		                smoothMonotone: seriesModel.get('smoothMonotone'),
		                connectNulls: seriesModel.get('connectNulls')
		            });

		            if (polygon) {
		                var stackedOn = data.stackedOn;
		                var stackedOnSmooth = 0;

		                polygon.useStyle(zrUtil.defaults(
		                    areaStyleModel.getAreaStyle(),
		                    {
		                        fill: visualColor,
		                        opacity: 0.7,
		                        lineJoin: 'bevel'
		                    }
		                ));

		                if (stackedOn) {
		                    var stackedOnSeries = stackedOn.hostModel;
		                    stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'));
		                }

		                polygon.setShape({
		                    smooth: smooth,
		                    stackedOnSmooth: stackedOnSmooth,
		                    smoothMonotone: seriesModel.get('smoothMonotone'),
		                    connectNulls: seriesModel.get('connectNulls')
		                });
		            }

		            this._data = data;
		            // Save the coordinate system for transition animation when data changed
		            this._coordSys = coordSys;
		            this._stackedOnPoints = stackedOnPoints;
		            this._points = points;
		            this._step = step;
		        },

		        dispose: function () {},

		        highlight: function (seriesModel, ecModel, api, payload) {
		            var data = seriesModel.getData();
		            var dataIndex = modelUtil.queryDataIndex(data, payload);

		            if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
		                var symbol = data.getItemGraphicEl(dataIndex);
		                if (!symbol) {
		                    // Create a temporary symbol if it is not exists
		                    var pt = data.getItemLayout(dataIndex);
		                    if (!pt) {
		                        // Null data
		                        return;
		                    }
		                    symbol = new Symbol(data, dataIndex);
		                    symbol.position = pt;
		                    symbol.setZ(
		                        seriesModel.get('zlevel'),
		                        seriesModel.get('z')
		                    );
		                    symbol.ignore = isNaN(pt[0]) || isNaN(pt[1]);
		                    symbol.__temp = true;
		                    data.setItemGraphicEl(dataIndex, symbol);

		                    // Stop scale animation
		                    symbol.stopSymbolAnimation(true);

		                    this.group.add(symbol);
		                }
		                symbol.highlight();
		            }
		            else {
		                // Highlight whole series
		                ChartView.prototype.highlight.call(
		                    this, seriesModel, ecModel, api, payload
		                );
		            }
		        },

		        downplay: function (seriesModel, ecModel, api, payload) {
		            var data = seriesModel.getData();
		            var dataIndex = modelUtil.queryDataIndex(data, payload);
		            if (dataIndex != null && dataIndex >= 0) {
		                var symbol = data.getItemGraphicEl(dataIndex);
		                if (symbol) {
		                    if (symbol.__temp) {
		                        data.setItemGraphicEl(dataIndex, null);
		                        this.group.remove(symbol);
		                    }
		                    else {
		                        symbol.downplay();
		                    }
		                }
		            }
		            else {
		                // Downplay whole series
		                ChartView.prototype.downplay.call(
		                    this, seriesModel, ecModel, api, payload
		                );
		            }
		        },

		        /**
		         * @param {module:zrender/container/Group} group
		         * @param {Array.<Array.<number>>} points
		         * @private
		         */
		        _newPolyline: function (points) {
		            var polyline = this._polyline;
		            // Remove previous created polyline
		            if (polyline) {
		                this._lineGroup.remove(polyline);
		            }

		            polyline = new polyHelper.Polyline({
		                shape: {
		                    points: points
		                },
		                silent: true,
		                z2: 10
		            });

		            this._lineGroup.add(polyline);

		            this._polyline = polyline;

		            return polyline;
		        },

		        /**
		         * @param {module:zrender/container/Group} group
		         * @param {Array.<Array.<number>>} stackedOnPoints
		         * @param {Array.<Array.<number>>} points
		         * @private
		         */
		        _newPolygon: function (points, stackedOnPoints) {
		            var polygon = this._polygon;
		            // Remove previous created polygon
		            if (polygon) {
		                this._lineGroup.remove(polygon);
		            }

		            polygon = new polyHelper.Polygon({
		                shape: {
		                    points: points,
		                    stackedOnPoints: stackedOnPoints
		                },
		                silent: true
		            });

		            this._lineGroup.add(polygon);

		            this._polygon = polygon;
		            return polygon;
		        },
		        /**
		         * @private
		         */
		        _getSymbolIgnoreFunc: function (data, coordSys) {
		            var categoryAxis = coordSys.getAxesByScale('ordinal')[0];
		            // `getLabelInterval` is provided by echarts/component/axis
		            if (categoryAxis && categoryAxis.isLabelIgnored) {
		                return zrUtil.bind(categoryAxis.isLabelIgnored, categoryAxis);
		            }
		        },

		        /**
		         * @private
		         */
		        // FIXME Two value axis
		        _updateAnimation: function (data, stackedOnPoints, coordSys, api, step) {
		            var polyline = this._polyline;
		            var polygon = this._polygon;
		            var seriesModel = data.hostModel;

		            var diff = lineAnimationDiff(
		                this._data, data,
		                this._stackedOnPoints, stackedOnPoints,
		                this._coordSys, coordSys
		            );

		            var current = diff.current;
		            var stackedOnCurrent = diff.stackedOnCurrent;
		            var next = diff.next;
		            var stackedOnNext = diff.stackedOnNext;
		            if (step) {
		                // TODO If stacked series is not step
		                current = turnPointsIntoStep(diff.current, coordSys, step);
		                stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step);
		                next = turnPointsIntoStep(diff.next, coordSys, step);
		                stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step);
		            }
		            // `diff.current` is subset of `current` (which should be ensured by
		            // turnPointsIntoStep), so points in `__points` can be updated when
		            // points in `current` are update during animation.
		            polyline.shape.__points = diff.current;
		            polyline.shape.points = current;

		            graphic.updateProps(polyline, {
		                shape: {
		                    points: next
		                }
		            }, seriesModel);

		            if (polygon) {
		                polygon.setShape({
		                    points: current,
		                    stackedOnPoints: stackedOnCurrent
		                });
		                graphic.updateProps(polygon, {
		                    shape: {
		                        points: next,
		                        stackedOnPoints: stackedOnNext
		                    }
		                }, seriesModel);
		            }

		            var updatedDataInfo = [];
		            var diffStatus = diff.status;

		            for (var i = 0; i < diffStatus.length; i++) {
		                var cmd = diffStatus[i].cmd;
		                if (cmd === '=') {
		                    var el = data.getItemGraphicEl(diffStatus[i].idx1);
		                    if (el) {
		                        updatedDataInfo.push({
		                            el: el,
		                            ptIdx: i    // Index of points
		                        });
		                    }
		                }
		            }

		            if (polyline.animators && polyline.animators.length) {
		                polyline.animators[0].during(function () {
		                    for (var i = 0; i < updatedDataInfo.length; i++) {
		                        var el = updatedDataInfo[i].el;
		                        el.attr('position', polyline.shape.__points[updatedDataInfo[i].ptIdx]);
		                    }
		                });
		            }
		        },

		        remove: function (ecModel) {
		            var group = this.group;
		            var oldData = this._data;
		            this._lineGroup.removeAll();
		            this._symbolDraw.remove(true);
		            // Remove temporary created elements when highlighting
		            oldData && oldData.eachItemGraphicEl(function (el, idx) {
		                if (el.__temp) {
		                    group.remove(el);
		                    oldData.setItemGraphicEl(idx, null);
		                }
		            });

		            this._polyline =
		            this._polygon =
		            this._coordSys =
		            this._points =
		            this._stackedOnPoints =
		            this._data = null;
		        }
		    });


	/***/ },
	/* 105 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/chart/helper/SymbolDraw
		 */


		    var graphic = __webpack_require__(43);
		    var Symbol = __webpack_require__(106);

		    /**
		     * @constructor
		     * @alias module:echarts/chart/helper/SymbolDraw
		     * @param {module:zrender/graphic/Group} [symbolCtor]
		     */
		    function SymbolDraw(symbolCtor) {
		        this.group = new graphic.Group();

		        this._symbolCtor = symbolCtor || Symbol;
		    }

		    var symbolDrawProto = SymbolDraw.prototype;

		    function symbolNeedsDraw(data, idx, isIgnore) {
		        var point = data.getItemLayout(idx);
		        // Is an object
		        // if (point && point.hasOwnProperty('point')) {
		        //     point = point.point;
		        // }
		        return point && !isNaN(point[0]) && !isNaN(point[1]) && !(isIgnore && isIgnore(idx))
		                    && data.getItemVisual(idx, 'symbol') !== 'none';
		    }
		    /**
		     * Update symbols draw by new data
		     * @param {module:echarts/data/List} data
		     * @param {Array.<boolean>} [isIgnore]
		     */
		    symbolDrawProto.updateData = function (data, isIgnore) {
		        var group = this.group;
		        var seriesModel = data.hostModel;
		        var oldData = this._data;

		        var SymbolCtor = this._symbolCtor;

		        var seriesScope = {
		            itemStyle: seriesModel.getModel('itemStyle.normal').getItemStyle(['color']),
		            hoverItemStyle: seriesModel.getModel('itemStyle.emphasis').getItemStyle(),
		            symbolRotate: seriesModel.get('symbolRotate'),
		            symbolOffset: seriesModel.get('symbolOffset'),
		            hoverAnimation: seriesModel.get('hoverAnimation'),

		            labelModel: seriesModel.getModel('label.normal'),
		            hoverLabelModel: seriesModel.getModel('label.emphasis')
		        };

		        data.diff(oldData)
		            .add(function (newIdx) {
		                var point = data.getItemLayout(newIdx);
		                if (symbolNeedsDraw(data, newIdx, isIgnore)) {
		                    var symbolEl = new SymbolCtor(data, newIdx, seriesScope);
		                    symbolEl.attr('position', point);
		                    data.setItemGraphicEl(newIdx, symbolEl);
		                    group.add(symbolEl);
		                }
		            })
		            .update(function (newIdx, oldIdx) {
		                var symbolEl = oldData.getItemGraphicEl(oldIdx);
		                var point = data.getItemLayout(newIdx);
		                if (!symbolNeedsDraw(data, newIdx, isIgnore)) {
		                    group.remove(symbolEl);
		                    return;
		                }
		                if (!symbolEl) {
		                    symbolEl = new SymbolCtor(data, newIdx);
		                    symbolEl.attr('position', point);
		                }
		                else {
		                    symbolEl.updateData(data, newIdx, seriesScope);
		                    graphic.updateProps(symbolEl, {
		                        position: point
		                    }, seriesModel);
		                }

		                // Add back
		                group.add(symbolEl);

		                data.setItemGraphicEl(newIdx, symbolEl);
		            })
		            .remove(function (oldIdx) {
		                var el = oldData.getItemGraphicEl(oldIdx);
		                el && el.fadeOut(function () {
		                    group.remove(el);
		                });
		            })
		            .execute();

		        this._data = data;
		    };

		    symbolDrawProto.updateLayout = function () {
		        var data = this._data;
		        if (data) {
		            // Not use animation
		            data.eachItemGraphicEl(function (el, idx) {
		                var point = data.getItemLayout(idx);
		                el.attr('position', point);
		            });
		        }
		    };

		    symbolDrawProto.remove = function (enableAnimation) {
		        var group = this.group;
		        var data = this._data;
		        if (data) {
		            if (enableAnimation) {
		                data.eachItemGraphicEl(function (el) {
		                    el.fadeOut(function () {
		                        group.remove(el);
		                    });
		                });
		            }
		            else {
		                group.removeAll();
		            }
		        }
		    };

		    module.exports = SymbolDraw;


	/***/ },
	/* 106 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/chart/helper/Symbol
		 */


		    var zrUtil = __webpack_require__(4);
		    var symbolUtil = __webpack_require__(107);
		    var graphic = __webpack_require__(43);
		    var numberUtil = __webpack_require__(7);

		    function normalizeSymbolSize(symbolSize) {
		        symbolSize = symbolSize instanceof Array
		            ? symbolSize.slice()
		            : [+symbolSize, +symbolSize];
		        symbolSize[0] /= 2;
		        symbolSize[1] /= 2;
		        return symbolSize;
		    }

		    /**
		     * @constructor
		     * @alias {module:echarts/chart/helper/Symbol}
		     * @param {module:echarts/data/List} data
		     * @param {number} idx
		     * @extends {module:zrender/graphic/Group}
		     */
		    function Symbol(data, idx, seriesScope) {
		        graphic.Group.call(this);

		        this.updateData(data, idx, seriesScope);
		    }

		    var symbolProto = Symbol.prototype;

		    function driftSymbol(dx, dy) {
		        this.parent.drift(dx, dy);
		    }

		    symbolProto._createSymbol = function (symbolType, data, idx) {
		        // Remove paths created before
		        this.removeAll();

		        var seriesModel = data.hostModel;
		        var color = data.getItemVisual(idx, 'color');

		        // var symbolPath = symbolUtil.createSymbol(
		        //     symbolType, -0.5, -0.5, 1, 1, color
		        // );
		        // If width/height are set too small (e.g., set to 1) on ios10
		        // and macOS Sierra, a circle stroke become a rect, no matter what
		        // the scale is set. So we set width/height as 2. See #4150.
		        var symbolPath = symbolUtil.createSymbol(
		            symbolType, -1, -1, 2, 2, color
		        );

		        symbolPath.attr({
		            z2: 100,
		            culling: true,
		            scale: [0, 0]
		        });
		        // Rewrite drift method
		        symbolPath.drift = driftSymbol;

		        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));

		        graphic.initProps(symbolPath, {
		            scale: size
		        }, seriesModel, idx);
		        this._symbolType = symbolType;

		        this.add(symbolPath);
		    };

		    /**
		     * Stop animation
		     * @param {boolean} toLastFrame
		     */
		    symbolProto.stopSymbolAnimation = function (toLastFrame) {
		        this.childAt(0).stopAnimation(toLastFrame);
		    };

		    /**
		     * Get symbol path element
		     */
		    symbolProto.getSymbolPath = function () {
		        return this.childAt(0);
		    };

		    /**
		     * Get scale(aka, current symbol size).
		     * Including the change caused by animation
		     */
		    symbolProto.getScale = function () {
		        return this.childAt(0).scale;
		    };

		    /**
		     * Highlight symbol
		     */
		    symbolProto.highlight = function () {
		        this.childAt(0).trigger('emphasis');
		    };

		    /**
		     * Downplay symbol
		     */
		    symbolProto.downplay = function () {
		        this.childAt(0).trigger('normal');
		    };

		    /**
		     * @param {number} zlevel
		     * @param {number} z
		     */
		    symbolProto.setZ = function (zlevel, z) {
		        var symbolPath = this.childAt(0);
		        symbolPath.zlevel = zlevel;
		        symbolPath.z = z;
		    };

		    symbolProto.setDraggable = function (draggable) {
		        var symbolPath = this.childAt(0);
		        symbolPath.draggable = draggable;
		        symbolPath.cursor = draggable ? 'move' : 'pointer';
		    };

		    /**
		     * Update symbol properties
		     * @param  {module:echarts/data/List} data
		     * @param  {number} idx
		     */
		    symbolProto.updateData = function (data, idx, seriesScope) {
		        this.silent = false;

		        var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
		        var seriesModel = data.hostModel;
		        var symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));
		        if (symbolType !== this._symbolType) {
		            this._createSymbol(symbolType, data, idx);
		        }
		        else {
		            var symbolPath = this.childAt(0);
		            graphic.updateProps(symbolPath, {
		                scale: symbolSize
		            }, seriesModel, idx);
		        }
		        this._updateCommon(data, idx, symbolSize, seriesScope);
		        this._seriesModel = seriesModel;
		    };

		    // Update common properties
		    var normalStyleAccessPath = ['itemStyle', 'normal'];
		    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];
		    var normalLabelAccessPath = ['label', 'normal'];
		    var emphasisLabelAccessPath = ['label', 'emphasis'];

		    symbolProto._updateCommon = function (data, idx, symbolSize, seriesScope) {
		        var symbolPath = this.childAt(0);
		        var seriesModel = data.hostModel;
		        var color = data.getItemVisual(idx, 'color');

		        // Reset style
		        if (symbolPath.type !== 'image') {
		            symbolPath.useStyle({
		                strokeNoScale: true
		            });
		        }

		        seriesScope = seriesScope || null;

		        var itemStyle = seriesScope && seriesScope.itemStyle;
		        var hoverItemStyle = seriesScope && seriesScope.hoverItemStyle;
		        var symbolRotate = seriesScope && seriesScope.symbolRotate;
		        var symbolOffset = seriesScope && seriesScope.symbolOffset;
		        var labelModel = seriesScope && seriesScope.labelModel;
		        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;
		        var hoverAnimation = seriesScope && seriesScope.hoverAnimation;

		        if (!seriesScope || data.hasItemOption) {
		            var itemModel = data.getItemModel(idx);

		            // Color must be excluded.
		            // Because symbol provide setColor individually to set fill and stroke
		            itemStyle = itemModel.getModel(normalStyleAccessPath).getItemStyle(['color']);
		            hoverItemStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();

		            symbolRotate = itemModel.getShallow('symbolRotate');
		            symbolOffset = itemModel.getShallow('symbolOffset');

		            labelModel = itemModel.getModel(normalLabelAccessPath);
		            hoverLabelModel = itemModel.getModel(emphasisLabelAccessPath);
		            hoverAnimation = itemModel.getShallow('hoverAnimation');
		        }
		        else {
		            hoverItemStyle = zrUtil.extend({}, hoverItemStyle);
		        }

		        var elStyle = symbolPath.style;

		        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0);

		        if (symbolOffset) {
		            symbolPath.attr('position', [
		                numberUtil.parsePercent(symbolOffset[0], symbolSize[0]),
		                numberUtil.parsePercent(symbolOffset[1], symbolSize[1])
		            ]);
		        }

		        // PENDING setColor before setStyle!!!
		        symbolPath.setColor(color);

		        symbolPath.setStyle(itemStyle);

		        var opacity = data.getItemVisual(idx, 'opacity');
		        if (opacity != null) {
		            elStyle.opacity = opacity;
		        }

		        // Get last value dim
		        var dimensions = data.dimensions.slice();
		        var valueDim;
		        var dataType;
		        while (dimensions.length && (
		            valueDim = dimensions.pop(),
		            dataType = data.getDimensionInfo(valueDim).type,
		            dataType === 'ordinal' || dataType === 'time'
		        )) {} // jshint ignore:line

		        if (valueDim != null && labelModel.getShallow('show')) {
		            graphic.setText(elStyle, labelModel, color);
		            elStyle.text = zrUtil.retrieve(
		                seriesModel.getFormattedLabel(idx, 'normal'),
		                data.get(valueDim, idx)
		            );
		        }
		        else {
		            elStyle.text = '';
		        }

		        if (valueDim != null && hoverLabelModel.getShallow('show')) {
		            graphic.setText(hoverItemStyle, hoverLabelModel, color);
		            hoverItemStyle.text = zrUtil.retrieve(
		                seriesModel.getFormattedLabel(idx, 'emphasis'),
		                data.get(valueDim, idx)
		            );
		        }
		        else {
		            hoverItemStyle.text = '';
		        }

		        var size = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'));

		        symbolPath.off('mouseover')
		            .off('mouseout')
		            .off('emphasis')
		            .off('normal');

		        symbolPath.hoverStyle = hoverItemStyle;

		        graphic.setHoverStyle(symbolPath);

		        if (hoverAnimation && seriesModel.ifEnableAnimation()) {
		            var onEmphasis = function() {
		                var ratio = size[1] / size[0];
		                this.animateTo({
		                    scale: [
		                        Math.max(size[0] * 1.1, size[0] + 3),
		                        Math.max(size[1] * 1.1, size[1] + 3 * ratio)
		                    ]
		                }, 400, 'elasticOut');
		            };
		            var onNormal = function() {
		                this.animateTo({
		                    scale: size
		                }, 400, 'elasticOut');
		            };
		            symbolPath.on('mouseover', onEmphasis)
		                .on('mouseout', onNormal)
		                .on('emphasis', onEmphasis)
		                .on('normal', onNormal);
		        }
		    };

		    symbolProto.fadeOut = function (cb) {
		        var symbolPath = this.childAt(0);
		        // Avoid mistaken hover when fading out
		        this.silent = true;
		        // Not show text when animating
		        symbolPath.style.text = '';
		        graphic.updateProps(symbolPath, {
		            scale: [0, 0]
		        }, this._seriesModel, this.dataIndex, cb);
		    };

		    zrUtil.inherits(Symbol, graphic.Group);

		    module.exports = Symbol;


	/***/ },
	/* 107 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		// Symbol factory


		    var graphic = __webpack_require__(43);
		    var BoundingRect = __webpack_require__(9);

		    /**
		     * Triangle shape
		     * @inner
		     */
		    var Triangle = graphic.extendShape({
		        type: 'triangle',
		        shape: {
		            cx: 0,
		            cy: 0,
		            width: 0,
		            height: 0
		        },
		        buildPath: function (path, shape) {
		            var cx = shape.cx;
		            var cy = shape.cy;
		            var width = shape.width / 2;
		            var height = shape.height / 2;
		            path.moveTo(cx, cy - height);
		            path.lineTo(cx + width, cy + height);
		            path.lineTo(cx - width, cy + height);
		            path.closePath();
		        }
		    });
		    /**
		     * Diamond shape
		     * @inner
		     */
		    var Diamond = graphic.extendShape({
		        type: 'diamond',
		        shape: {
		            cx: 0,
		            cy: 0,
		            width: 0,
		            height: 0
		        },
		        buildPath: function (path, shape) {
		            var cx = shape.cx;
		            var cy = shape.cy;
		            var width = shape.width / 2;
		            var height = shape.height / 2;
		            path.moveTo(cx, cy - height);
		            path.lineTo(cx + width, cy);
		            path.lineTo(cx, cy + height);
		            path.lineTo(cx - width, cy);
		            path.closePath();
		        }
		    });

		    /**
		     * Pin shape
		     * @inner
		     */
		    var Pin = graphic.extendShape({
		        type: 'pin',
		        shape: {
		            // x, y on the cusp
		            x: 0,
		            y: 0,
		            width: 0,
		            height: 0
		        },

		        buildPath: function (path, shape) {
		            var x = shape.x;
		            var y = shape.y;
		            var w = shape.width / 5 * 3;
		            // Height must be larger than width
		            var h = Math.max(w, shape.height);
		            var r = w / 2;

		            // Dist on y with tangent point and circle center
		            var dy = r * r / (h - r);
		            var cy = y - h + r + dy;
		            var angle = Math.asin(dy / r);
		            // Dist on x with tangent point and circle center
		            var dx = Math.cos(angle) * r;

		            var tanX = Math.sin(angle);
		            var tanY = Math.cos(angle);

		            path.arc(
		                x, cy, r,
		                Math.PI - angle,
		                Math.PI * 2 + angle
		            );

		            var cpLen = r * 0.6;
		            var cpLen2 = r * 0.7;
		            path.bezierCurveTo(
		                x + dx - tanX * cpLen, cy + dy + tanY * cpLen,
		                x, y - cpLen2,
		                x, y
		            );
		            path.bezierCurveTo(
		                x, y - cpLen2,
		                x - dx + tanX * cpLen, cy + dy + tanY * cpLen,
		                x - dx, cy + dy
		            );
		            path.closePath();
		        }
		    });

		    /**
		     * Arrow shape
		     * @inner
		     */
		    var Arrow = graphic.extendShape({

		        type: 'arrow',

		        shape: {
		            x: 0,
		            y: 0,
		            width: 0,
		            height: 0
		        },

		        buildPath: function (ctx, shape) {
		            var height = shape.height;
		            var width = shape.width;
		            var x = shape.x;
		            var y = shape.y;
		            var dx = width / 3 * 2;
		            ctx.moveTo(x, y);
		            ctx.lineTo(x + dx, y + height);
		            ctx.lineTo(x, y + height / 4 * 3);
		            ctx.lineTo(x - dx, y + height);
		            ctx.lineTo(x, y);
		            ctx.closePath();
		        }
		    });

		    /**
		     * Map of path contructors
		     * @type {Object.<string, module:zrender/graphic/Path>}
		     */
		    var symbolCtors = {
		        line: graphic.Line,

		        rect: graphic.Rect,

		        roundRect: graphic.Rect,

		        square: graphic.Rect,

		        circle: graphic.Circle,

		        diamond: Diamond,

		        pin: Pin,

		        arrow: Arrow,

		        triangle: Triangle
		    };

		    var symbolShapeMakers = {

		        line: function (x, y, w, h, shape) {
		            // FIXME
		            shape.x1 = x;
		            shape.y1 = y + h / 2;
		            shape.x2 = x + w;
		            shape.y2 = y + h / 2;
		        },

		        rect: function (x, y, w, h, shape) {
		            shape.x = x;
		            shape.y = y;
		            shape.width = w;
		            shape.height = h;
		        },

		        roundRect: function (x, y, w, h, shape) {
		            shape.x = x;
		            shape.y = y;
		            shape.width = w;
		            shape.height = h;
		            shape.r = Math.min(w, h) / 4;
		        },

		        square: function (x, y, w, h, shape) {
		            var size = Math.min(w, h);
		            shape.x = x;
		            shape.y = y;
		            shape.width = size;
		            shape.height = size;
		        },

		        circle: function (x, y, w, h, shape) {
		            // Put circle in the center of square
		            shape.cx = x + w / 2;
		            shape.cy = y + h / 2;
		            shape.r = Math.min(w, h) / 2;
		        },

		        diamond: function (x, y, w, h, shape) {
		            shape.cx = x + w / 2;
		            shape.cy = y + h / 2;
		            shape.width = w;
		            shape.height = h;
		        },

		        pin: function (x, y, w, h, shape) {
		            shape.x = x + w / 2;
		            shape.y = y + h / 2;
		            shape.width = w;
		            shape.height = h;
		        },

		        arrow: function (x, y, w, h, shape) {
		            shape.x = x + w / 2;
		            shape.y = y + h / 2;
		            shape.width = w;
		            shape.height = h;
		        },

		        triangle: function (x, y, w, h, shape) {
		            shape.cx = x + w / 2;
		            shape.cy = y + h / 2;
		            shape.width = w;
		            shape.height = h;
		        }
		    };

		    var symbolBuildProxies = {};
		    for (var name in symbolCtors) {
		        if (symbolCtors.hasOwnProperty(name)) {
		            symbolBuildProxies[name] = new symbolCtors[name]();
		        }
		    }

		    var Symbol = graphic.extendShape({

		        type: 'symbol',

		        shape: {
		            symbolType: '',
		            x: 0,
		            y: 0,
		            width: 0,
		            height: 0
		        },

		        beforeBrush: function () {
		            var style = this.style;
		            var shape = this.shape;
		            // FIXME
		            if (shape.symbolType === 'pin' && style.textPosition === 'inside') {
		                style.textPosition = ['50%', '40%'];
		                style.textAlign = 'center';
		                style.textVerticalAlign = 'middle';
		            }
		        },

		        buildPath: function (ctx, shape, inBundle) {
		            var symbolType = shape.symbolType;
		            var proxySymbol = symbolBuildProxies[symbolType];
		            if (shape.symbolType !== 'none') {
		                if (!proxySymbol) {
		                    // Default rect
		                    symbolType = 'rect';
		                    proxySymbol = symbolBuildProxies[symbolType];
		                }
		                symbolShapeMakers[symbolType](
		                    shape.x, shape.y, shape.width, shape.height, proxySymbol.shape
		                );
		                proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle);
		            }
		        }
		    });

		    // Provide setColor helper method to avoid determine if set the fill or stroke outside
		    var symbolPathSetColor = function (color) {
		        if (this.type !== 'image') {
		            var symbolStyle = this.style;
		            var symbolShape = this.shape;
		            if (symbolShape && symbolShape.symbolType === 'line') {
		                symbolStyle.stroke = color;
		            }
		            else if (this.__isEmptyBrush) {
		                symbolStyle.stroke = color;
		                symbolStyle.fill = '#fff';
		            }
		            else {
		                // FIXME 判断图形默认是填充还是描边，使用 onlyStroke ?
		                symbolStyle.fill && (symbolStyle.fill = color);
		                symbolStyle.stroke && (symbolStyle.stroke = color);
		            }
		            this.dirty(false);
		        }
		    };

		    var symbolUtil = {
		        /**
		         * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
		         * @param {string} symbolType
		         * @param {number} x
		         * @param {number} y
		         * @param {number} w
		         * @param {number} h
		         * @param {string} color
		         */
		        createSymbol: function (symbolType, x, y, w, h, color) {
		            var isEmpty = symbolType.indexOf('empty') === 0;
		            if (isEmpty) {
		                symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6);
		            }
		            var symbolPath;

		            if (symbolType.indexOf('image://') === 0) {
		                symbolPath = new graphic.Image({
		                    style: {
		                        image: symbolType.slice(8),
		                        x: x,
		                        y: y,
		                        width: w,
		                        height: h
		                    }
		                });
		            }
		            else if (symbolType.indexOf('path://') === 0) {
		                symbolPath = graphic.makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h));
		            }
		            else {
		                symbolPath = new Symbol({
		                    shape: {
		                        symbolType: symbolType,
		                        x: x,
		                        y: y,
		                        width: w,
		                        height: h
		                    }
		                });
		            }

		            symbolPath.__isEmptyBrush = isEmpty;

		            symbolPath.setColor = symbolPathSetColor;

		            symbolPath.setColor(color);

		            return symbolPath;
		        }
		    };

		    module.exports = symbolUtil;


	/***/ },
	/* 108 */
	/***/ function(module, exports) {

		

		    // var arrayDiff = require('zrender/lib/core/arrayDiff');
		    // 'zrender/core/arrayDiff' has been used before, but it did
		    // not do well in performance when roam with fixed dataZoom window.

		    function sign(val) {
		        return val >= 0 ? 1 : -1;
		    }

		    function getStackedOnPoint(coordSys, data, idx) {
		        var baseAxis = coordSys.getBaseAxis();
		        var valueAxis = coordSys.getOtherAxis(baseAxis);
		        var valueStart = baseAxis.onZero
		            ? 0 : valueAxis.scale.getExtent()[0];

		        var valueDim = valueAxis.dim;
		        var baseDataOffset = valueDim === 'x' || valueDim === 'radius' ? 1 : 0;

		        var stackedOnSameSign;
		        var stackedOn = data.stackedOn;
		        var val = data.get(valueDim, idx);
		        // Find first stacked value with same sign
		        while (stackedOn &&
		            sign(stackedOn.get(valueDim, idx)) === sign(val)
		        ) {
		            stackedOnSameSign = stackedOn;
		            break;
		        }
		        var stackedData = [];
		        stackedData[baseDataOffset] = data.get(baseAxis.dim, idx);
		        stackedData[1 - baseDataOffset] = stackedOnSameSign
		            ? stackedOnSameSign.get(valueDim, idx, true) : valueStart;

		        return coordSys.dataToPoint(stackedData);
		    }

		    // function convertToIntId(newIdList, oldIdList) {
		    //     // Generate int id instead of string id.
		    //     // Compare string maybe slow in score function of arrDiff

		    //     // Assume id in idList are all unique
		    //     var idIndicesMap = {};
		    //     var idx = 0;
		    //     for (var i = 0; i < newIdList.length; i++) {
		    //         idIndicesMap[newIdList[i]] = idx;
		    //         newIdList[i] = idx++;
		    //     }
		    //     for (var i = 0; i < oldIdList.length; i++) {
		    //         var oldId = oldIdList[i];
		    //         // Same with newIdList
		    //         if (idIndicesMap[oldId]) {
		    //             oldIdList[i] = idIndicesMap[oldId];
		    //         }
		    //         else {
		    //             oldIdList[i] = idx++;
		    //         }
		    //     }
		    // }

		    function diffData(oldData, newData) {
		        var diffResult = [];

		        newData.diff(oldData)
		            .add(function (idx) {
		                diffResult.push({cmd: '+', idx: idx});
		            })
		            .update(function (newIdx, oldIdx) {
		                diffResult.push({cmd: '=', idx: oldIdx, idx1: newIdx});
		            })
		            .remove(function (idx) {
		                diffResult.push({cmd: '-', idx: idx});
		            })
		            .execute();

		        return diffResult;
		    }

		    module.exports = function (
		        oldData, newData,
		        oldStackedOnPoints, newStackedOnPoints,
		        oldCoordSys, newCoordSys
		    ) {
		        var diff = diffData(oldData, newData);

		        // var newIdList = newData.mapArray(newData.getId);
		        // var oldIdList = oldData.mapArray(oldData.getId);

		        // convertToIntId(newIdList, oldIdList);

		        // // FIXME One data ?
		        // diff = arrayDiff(oldIdList, newIdList);

		        var currPoints = [];
		        var nextPoints = [];
		        // Points for stacking base line
		        var currStackedPoints = [];
		        var nextStackedPoints = [];

		        var status = [];
		        var sortedIndices = [];
		        var rawIndices = [];
		        var dims = newCoordSys.dimensions;
		        for (var i = 0; i < diff.length; i++) {
		            var diffItem = diff[i];
		            var pointAdded = true;

		            // FIXME, animation is not so perfect when dataZoom window moves fast
		            // Which is in case remvoing or add more than one data in the tail or head
		            switch (diffItem.cmd) {
		                case '=':
		                    var currentPt = oldData.getItemLayout(diffItem.idx);
		                    var nextPt = newData.getItemLayout(diffItem.idx1);
		                    // If previous data is NaN, use next point directly
		                    if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {
		                        currentPt = nextPt.slice();
		                    }
		                    currPoints.push(currentPt);
		                    nextPoints.push(nextPt);

		                    currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);
		                    nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);

		                    rawIndices.push(newData.getRawIndex(diffItem.idx1));
		                    break;
		                case '+':
		                    var idx = diffItem.idx;
		                    currPoints.push(
		                        oldCoordSys.dataToPoint([
		                            newData.get(dims[0], idx, true), newData.get(dims[1], idx, true)
		                        ])
		                    );

		                    nextPoints.push(newData.getItemLayout(idx).slice());

		                    currStackedPoints.push(
		                        getStackedOnPoint(oldCoordSys, newData, idx)
		                    );
		                    nextStackedPoints.push(newStackedOnPoints[idx]);

		                    rawIndices.push(newData.getRawIndex(idx));
		                    break;
		                case '-':
		                    var idx = diffItem.idx;
		                    var rawIndex = oldData.getRawIndex(idx);
		                    // Data is replaced. In the case of dynamic data queue
		                    // FIXME FIXME FIXME
		                    if (rawIndex !== idx) {
		                        currPoints.push(oldData.getItemLayout(idx));
		                        nextPoints.push(newCoordSys.dataToPoint([
		                            oldData.get(dims[0], idx, true), oldData.get(dims[1], idx, true)
		                        ]));

		                        currStackedPoints.push(oldStackedOnPoints[idx]);
		                        nextStackedPoints.push(
		                            getStackedOnPoint(
		                                newCoordSys, oldData, idx
		                            )
		                        );

		                        rawIndices.push(rawIndex);
		                    }
		                    else {
		                        pointAdded = false;
		                    }
		            }

		            // Original indices
		            if (pointAdded) {
		                status.push(diffItem);
		                sortedIndices.push(sortedIndices.length);
		            }
		        }

		        // Diff result may be crossed if all items are changed
		        // Sort by data index
		        sortedIndices.sort(function (a, b) {
		            return rawIndices[a] - rawIndices[b];
		        });

		        var sortedCurrPoints = [];
		        var sortedNextPoints = [];

		        var sortedCurrStackedPoints = [];
		        var sortedNextStackedPoints = [];

		        var sortedStatus = [];
		        for (var i = 0; i < sortedIndices.length; i++) {
		            var idx = sortedIndices[i];
		            sortedCurrPoints[i] = currPoints[idx];
		            sortedNextPoints[i] = nextPoints[idx];

		            sortedCurrStackedPoints[i] = currStackedPoints[idx];
		            sortedNextStackedPoints[i] = nextStackedPoints[idx];

		            sortedStatus[i] = status[idx];
		        }

		        return {
		            current: sortedCurrPoints,
		            next: sortedNextPoints,

		            stackedOnCurrent: sortedCurrStackedPoints,
		            stackedOnNext: sortedNextStackedPoints,

		            status: sortedStatus
		        };
		    };


	/***/ },
	/* 109 */
	/***/ function(module, exports, __webpack_require__) {

		// Poly path support NaN point


		    var Path = __webpack_require__(45);
		    var vec2 = __webpack_require__(10);

		    var vec2Min = vec2.min;
		    var vec2Max = vec2.max;

		    var scaleAndAdd = vec2.scaleAndAdd;
		    var v2Copy = vec2.copy;

		    // Temporary variable
		    var v = [];
		    var cp0 = [];
		    var cp1 = [];

		    function isPointNull(p) {
		        return isNaN(p[0]) || isNaN(p[1]);
		    }

		    function drawSegment(
		        ctx, points, start, segLen, allLen,
		        dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls
		    ) {
		        var prevIdx = 0;
		        var idx = start;
		        for (var k = 0; k < segLen; k++) {
		            var p = points[idx];
		            if (idx >= allLen || idx < 0) {
		                break;
		            }
		            if (isPointNull(p)) {
		                if (connectNulls) {
		                    idx += dir;
		                    continue;
		                }
		                break;
		            }

		            if (idx === start) {
		                ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);
		                v2Copy(cp0, p);
		            }
		            else {
		                if (smooth > 0) {
		                    var nextIdx = idx + dir;
		                    var nextP = points[nextIdx];
		                    if (connectNulls) {
		                        // Find next point not null
		                        while (nextP && isPointNull(points[nextIdx])) {
		                            nextIdx += dir;
		                            nextP = points[nextIdx];
		                        }
		                    }

		                    var ratioNextSeg = 0.5;
		                    var prevP = points[prevIdx];
		                    var nextP = points[nextIdx];
		                    // Last point
		                    if (!nextP || isPointNull(nextP)) {
		                        v2Copy(cp1, p);
		                    }
		                    else {
		                        // If next data is null in not connect case
		                        if (isPointNull(nextP) && !connectNulls) {
		                            nextP = p;
		                        }

		                        vec2.sub(v, nextP, prevP);

		                        var lenPrevSeg;
		                        var lenNextSeg;
		                        if (smoothMonotone === 'x' || smoothMonotone === 'y') {
		                            var dim = smoothMonotone === 'x' ? 0 : 1;
		                            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);
		                            lenNextSeg = Math.abs(p[dim] - nextP[dim]);
		                        }
		                        else {
		                            lenPrevSeg = vec2.dist(p, prevP);
		                            lenNextSeg = vec2.dist(p, nextP);
		                        }

		                        // Use ratio of seg length
		                        ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);

		                        scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));
		                    }
		                    // Smooth constraint
		                    vec2Min(cp0, cp0, smoothMax);
		                    vec2Max(cp0, cp0, smoothMin);
		                    vec2Min(cp1, cp1, smoothMax);
		                    vec2Max(cp1, cp1, smoothMin);

		                    ctx.bezierCurveTo(
		                        cp0[0], cp0[1],
		                        cp1[0], cp1[1],
		                        p[0], p[1]
		                    );
		                    // cp0 of next segment
		                    scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);
		                }
		                else {
		                    ctx.lineTo(p[0], p[1]);
		                }
		            }

		            prevIdx = idx;
		            idx += dir;
		        }

		        return k;
		    }

		    function getBoundingBox(points, smoothConstraint) {
		        var ptMin = [Infinity, Infinity];
		        var ptMax = [-Infinity, -Infinity];
		        if (smoothConstraint) {
		            for (var i = 0; i < points.length; i++) {
		                var pt = points[i];
		                if (pt[0] < ptMin[0]) { ptMin[0] = pt[0]; }
		                if (pt[1] < ptMin[1]) { ptMin[1] = pt[1]; }
		                if (pt[0] > ptMax[0]) { ptMax[0] = pt[0]; }
		                if (pt[1] > ptMax[1]) { ptMax[1] = pt[1]; }
		            }
		        }
		        return {
		            min: smoothConstraint ? ptMin : ptMax,
		            max: smoothConstraint ? ptMax : ptMin
		        };
		    }

		    module.exports = {

		        Polyline: Path.extend({

		            type: 'ec-polyline',

		            shape: {
		                points: [],

		                smooth: 0,

		                smoothConstraint: true,

		                smoothMonotone: null,

		                connectNulls: false
		            },

		            style: {
		                fill: null,

		                stroke: '#000'
		            },

		            buildPath: function (ctx, shape) {
		                var points = shape.points;

		                var i = 0;
		                var len = points.length;

		                var result = getBoundingBox(points, shape.smoothConstraint);

		                if (shape.connectNulls) {
		                    // Must remove first and last null values avoid draw error in polygon
		                    for (; len > 0; len--) {
		                        if (!isPointNull(points[len - 1])) {
		                            break;
		                        }
		                    }
		                    for (; i < len; i++) {
		                        if (!isPointNull(points[i])) {
		                            break;
		                        }
		                    }
		                }
		                while (i < len) {
		                    i += drawSegment(
		                        ctx, points, i, len, len,
		                        1, result.min, result.max, shape.smooth,
		                        shape.smoothMonotone, shape.connectNulls
		                    ) + 1;
		                }
		            }
		        }),

		        Polygon: Path.extend({

		            type: 'ec-polygon',

		            shape: {
		                points: [],

		                // Offset between stacked base points and points
		                stackedOnPoints: [],

		                smooth: 0,

		                stackedOnSmooth: 0,

		                smoothConstraint: true,

		                smoothMonotone: null,

		                connectNulls: false
		            },

		            buildPath: function (ctx, shape) {
		                var points = shape.points;
		                var stackedOnPoints = shape.stackedOnPoints;

		                var i = 0;
		                var len = points.length;
		                var smoothMonotone = shape.smoothMonotone;
		                var bbox = getBoundingBox(points, shape.smoothConstraint);
		                var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);

		                if (shape.connectNulls) {
		                    // Must remove first and last null values avoid draw error in polygon
		                    for (; len > 0; len--) {
		                        if (!isPointNull(points[len - 1])) {
		                            break;
		                        }
		                    }
		                    for (; i < len; i++) {
		                        if (!isPointNull(points[i])) {
		                            break;
		                        }
		                    }
		                }
		                while (i < len) {
		                    var k = drawSegment(
		                        ctx, points, i, len, len,
		                        1, bbox.min, bbox.max, shape.smooth,
		                        smoothMonotone, shape.connectNulls
		                    );
		                    drawSegment(
		                        ctx, stackedOnPoints, i + k - 1, k, len,
		                        -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth,
		                        smoothMonotone, shape.connectNulls
		                    );
		                    i += k + 1;

		                    ctx.closePath();
		                }
		            }
		        })
		    };


	/***/ },
	/* 110 */
	/***/ function(module, exports) {

		

		    module.exports = function (seriesType, defaultSymbolType, legendSymbol, ecModel, api) {

		        // Encoding visual for all series include which is filtered for legend drawing
		        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {
		            var data = seriesModel.getData();

		            var symbolType = seriesModel.get('symbol') || defaultSymbolType;
		            var symbolSize = seriesModel.get('symbolSize');

		            data.setVisual({
		                legendSymbol: legendSymbol || symbolType,
		                symbol: symbolType,
		                symbolSize: symbolSize
		            });

		            // Only visible series has each data be visual encoded
		            if (!ecModel.isSeriesFiltered(seriesModel)) {
		                if (typeof symbolSize === 'function') {
		                    data.each(function (idx) {
		                        var rawValue = seriesModel.getRawValue(idx);
		                        // FIXME
		                        var params = seriesModel.getDataParams(idx);
		                        data.setItemVisual(idx, 'symbolSize', symbolSize(rawValue, params));
		                    });
		                }
		                data.each(function (idx) {
		                    var itemModel = data.getItemModel(idx);
		                    var itemSymbolType = itemModel.getShallow('symbol', true);
		                    var itemSymbolSize = itemModel.getShallow('symbolSize', true);
		                    // If has item symbol
		                    if (itemSymbolType != null) {
		                        data.setItemVisual(idx, 'symbol', itemSymbolType);
		                    }
		                    if (itemSymbolSize != null) {
		                        // PENDING Transform symbolSize ?
		                        data.setItemVisual(idx, 'symbolSize', itemSymbolSize);
		                    }
		                });
		            }
		        });
		    };


	/***/ },
	/* 111 */
	/***/ function(module, exports) {

		

		    module.exports = function (seriesType, ecModel) {
		        ecModel.eachSeriesByType(seriesType, function (seriesModel) {
		            var data = seriesModel.getData();
		            var coordSys = seriesModel.coordinateSystem;

		            if (coordSys) {
		                var dims = coordSys.dimensions;

		                if (coordSys.type === 'singleAxis') {
		                    data.each(dims[0], function (x, idx) {
		                        // Also {Array.<number>}, not undefined to avoid if...else... statement
		                        data.setItemLayout(idx, isNaN(x) ? [NaN, NaN] : coordSys.dataToPoint(x));
		                    });
		                }
		                else {
		                    data.each(dims, function (x, y, idx) {
		                        // Also {Array.<number>}, not undefined to avoid if...else... statement
		                        data.setItemLayout(
		                            idx, (isNaN(x) || isNaN(y)) ? [NaN, NaN] : coordSys.dataToPoint([x, y])
		                        );
		                    }, true);
		                }
		            }
		        });
		    };


	/***/ },
	/* 112 */
	/***/ function(module, exports) {

		
		    var samplers = {
		        average: function (frame) {
		            var sum = 0;
		            var count = 0;
		            for (var i = 0; i < frame.length; i++) {
		                if (!isNaN(frame[i])) {
		                    sum += frame[i];
		                    count++;
		                }
		            }
		            // Return NaN if count is 0
		            return count === 0 ? NaN : sum / count;
		        },
		        sum: function (frame) {
		            var sum = 0;
		            for (var i = 0; i < frame.length; i++) {
		                // Ignore NaN
		                sum += frame[i] || 0;
		            }
		            return sum;
		        },
		        max: function (frame) {
		            var max = -Infinity;
		            for (var i = 0; i < frame.length; i++) {
		                frame[i] > max && (max = frame[i]);
		            }
		            return max;
		        },
		        min: function (frame) {
		            var min = Infinity;
		            for (var i = 0; i < frame.length; i++) {
		                frame[i] < min && (min = frame[i]);
		            }
		            return min;
		        },
		        // TODO
		        // Median
		        nearest: function (frame) {
		            return frame[0];
		        }
		    };

		    var indexSampler = function (frame, value) {
		        return Math.round(frame.length / 2);
		    };
		    module.exports = function (seriesType, ecModel, api) {
		        ecModel.eachSeriesByType(seriesType, function (seriesModel) {
		            var data = seriesModel.getData();
		            var sampling = seriesModel.get('sampling');
		            var coordSys = seriesModel.coordinateSystem;
		            // Only cartesian2d support down sampling
		            if (coordSys.type === 'cartesian2d' && sampling) {
		                var baseAxis = coordSys.getBaseAxis();
		                var valueAxis = coordSys.getOtherAxis(baseAxis);
		                var extent = baseAxis.getExtent();
		                // Coordinste system has been resized
		                var size = extent[1] - extent[0];
		                var rate = Math.round(data.count() / size);
		                if (rate > 1) {
		                    var sampler;
		                    if (typeof sampling === 'string') {
		                        sampler = samplers[sampling];
		                    }
		                    else if (typeof sampling === 'function') {
		                        sampler = sampling;
		                    }
		                    if (sampler) {
		                        data = data.downSample(
		                            valueAxis.dim, 1 / rate, sampler, indexSampler
		                        );
		                        seriesModel.setData(data);
		                    }
		                }
		            }
		        }, this);
		    };


	/***/ },
	/* 113 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var graphic = __webpack_require__(43);
		    var zrUtil = __webpack_require__(4);
		    var echarts = __webpack_require__(1);

		    __webpack_require__(114);

		    __webpack_require__(132);

		    // Grid view
		    echarts.extendComponentView({

		        type: 'grid',

		        render: function (gridModel, ecModel) {
		            this.group.removeAll();
		            if (gridModel.get('show')) {
		                this.group.add(new graphic.Rect({
		                    shape: gridModel.coordinateSystem.getRect(),
		                    style: zrUtil.defaults({
		                        fill: gridModel.get('backgroundColor')
		                    }, gridModel.getItemStyle()),
		                    silent: true,
		                    z2: -1
		                }));
		            }
		        }

		    });

		    echarts.registerPreprocessor(function (option) {
		        // Only create grid when need
		        if (option.xAxis && option.yAxis && !option.grid) {
		            option.grid = {};
		        }
		    });


	/***/ },
	/* 114 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Grid is a region which contains at most 4 cartesian systems
		 *
		 * TODO Default cartesian
		 */
		var factory = exports;

		    var layout = __webpack_require__(21);
		    var axisHelper = __webpack_require__(115);

		    var zrUtil = __webpack_require__(4);
		    var Cartesian2D = __webpack_require__(121);
		    var Axis2D = __webpack_require__(123);

		    var each = zrUtil.each;

		    var ifAxisCrossZero = axisHelper.ifAxisCrossZero;
		    var niceScaleExtent = axisHelper.niceScaleExtent;

		    // 依赖 GridModel, AxisModel 做预处理
		    __webpack_require__(126);

		    /**
		     * Check if the axis is used in the specified grid
		     * @inner
		     */
		    function isAxisUsedInTheGrid(axisModel, gridModel, ecModel) {
		        return axisModel.findGridModel() === gridModel;
		    }

		    function getLabelUnionRect(axis) {
		        var axisModel = axis.model;
		        var labels = axisModel.getFormattedLabels();
		        var textStyleModel = axisModel.getModel('axisLabel.textStyle');
		        var rect;
		        var step = 1;
		        var labelCount = labels.length;
		        if (labelCount > 40) {
		            // Simple optimization for large amount of labels
		            step = Math.ceil(labelCount / 40);
		        }
		        for (var i = 0; i < labelCount; i += step) {
		            if (!axis.isLabelIgnored(i)) {
		                var singleRect = textStyleModel.getTextRect(labels[i]);
		                // FIXME consider label rotate
		                rect ? rect.union(singleRect) : (rect = singleRect);
		            }
		        }
		        return rect;
		    }

		    function Grid(gridModel, ecModel, api) {
		        /**
		         * @type {Object.<string, module:echarts/coord/cartesian/Cartesian2D>}
		         * @private
		         */
		        this._coordsMap = {};

		        /**
		         * @type {Array.<module:echarts/coord/cartesian/Cartesian>}
		         * @private
		         */
		        this._coordsList = [];

		        /**
		         * @type {Object.<string, module:echarts/coord/cartesian/Axis2D>}
		         * @private
		         */
		        this._axesMap = {};

		        /**
		         * @type {Array.<module:echarts/coord/cartesian/Axis2D>}
		         * @private
		         */
		        this._axesList = [];

		        this._initCartesian(gridModel, ecModel, api);

		        this._model = gridModel;
		    }

		    var gridProto = Grid.prototype;

		    gridProto.type = 'grid';

		    gridProto.getRect = function () {
		        return this._rect;
		    };

		    gridProto.update = function (ecModel, api) {

		        var axesMap = this._axesMap;

		        this._updateScale(ecModel, this._model);

		        function ifAxisCanNotOnZero(otherAxisDim) {
		            var axes = axesMap[otherAxisDim];
		            for (var idx in axes) {
		                if (axes.hasOwnProperty(idx)) {
		                    var axis = axes[idx];
		                    if (axis && (axis.type === 'category' || !ifAxisCrossZero(axis))) {
		                        return true;
		                    }
		                }
		            }
		            return false;
		        }

		        each(axesMap.x, function (xAxis) {
		            niceScaleExtent(xAxis, xAxis.model);
		        });
		        each(axesMap.y, function (yAxis) {
		            niceScaleExtent(yAxis, yAxis.model);
		        });
		        // Fix configuration
		        each(axesMap.x, function (xAxis) {
		            // onZero can not be enabled in these two situations
		            // 1. When any other axis is a category axis
		            // 2. When any other axis not across 0 point
		            if (ifAxisCanNotOnZero('y')) {
		                xAxis.onZero = false;
		            }
		        });
		        each(axesMap.y, function (yAxis) {
		            if (ifAxisCanNotOnZero('x')) {
		                yAxis.onZero = false;
		            }
		        });

		        // Resize again if containLabel is enabled
		        // FIXME It may cause getting wrong grid size in data processing stage
		        this.resize(this._model, api);
		    };

		    /**
		     * Resize the grid
		     * @param {module:echarts/coord/cartesian/GridModel} gridModel
		     * @param {module:echarts/ExtensionAPI} api
		     */
		    gridProto.resize = function (gridModel, api) {

		        var gridRect = layout.getLayoutRect(
		            gridModel.getBoxLayoutParams(), {
		                width: api.getWidth(),
		                height: api.getHeight()
		            });

		        this._rect = gridRect;

		        var axesList = this._axesList;

		        adjustAxes();

		        // Minus label size
		        if (gridModel.get('containLabel')) {
		            each(axesList, function (axis) {
		                if (!axis.model.get('axisLabel.inside')) {
		                    var labelUnionRect = getLabelUnionRect(axis);
		                    if (labelUnionRect) {
		                        var dim = axis.isHorizontal() ? 'height' : 'width';
		                        var margin = axis.model.get('axisLabel.margin');
		                        gridRect[dim] -= labelUnionRect[dim] + margin;
		                        if (axis.position === 'top') {
		                            gridRect.y += labelUnionRect.height + margin;
		                        }
		                        else if (axis.position === 'left')  {
		                            gridRect.x += labelUnionRect.width + margin;
		                        }
		                    }
		                }
		            });

		            adjustAxes();
		        }

		        function adjustAxes() {
		            each(axesList, function (axis) {
		                var isHorizontal = axis.isHorizontal();
		                var extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height];
		                var idx = axis.inverse ? 1 : 0;
		                axis.setExtent(extent[idx], extent[1 - idx]);
		                updateAxisTransfrom(axis, isHorizontal ? gridRect.x : gridRect.y);
		            });
		        }
		    };

		    /**
		     * @param {string} axisType
		     * @param {ndumber} [axisIndex]
		     */
		    gridProto.getAxis = function (axisType, axisIndex) {
		        var axesMapOnDim = this._axesMap[axisType];
		        if (axesMapOnDim != null) {
		            if (axisIndex == null) {
		                // Find first axis
		                for (var name in axesMapOnDim) {
		                    if (axesMapOnDim.hasOwnProperty(name)) {
		                        return axesMapOnDim[name];
		                    }
		                }
		            }
		            return axesMapOnDim[axisIndex];
		        }
		    };

		    gridProto.getCartesian = function (xAxisIndex, yAxisIndex) {
		        if (xAxisIndex != null && yAxisIndex != null) {
		            var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
		            return this._coordsMap[key];
		        }
		        else {
		            // When only xAxisIndex or yAxisIndex given, find its first cartesian.
		            for (var i = 0, coordList = this._coordsList; i < coordList.length; i++) {
		                if (coordList[i].getAxis('x').index === xAxisIndex
		                    || coordList[i].getAxis('y').index === yAxisIndex
		                ) {
		                    return coordList[i];
		                }
		            }
		        }
		    };

		    /**
		     * @implements
		     * see {module:echarts/CoodinateSystem}
		     */
		    gridProto.convertToPixel = function (ecModel, finder, value) {
		        var target = this._findConvertTarget(ecModel, finder);

		        return target.cartesian
		            ? target.cartesian.dataToPoint(value)
		            : target.axis
		            ? target.axis.toGlobalCoord(target.axis.dataToCoord(value))
		            : null;
		    };

		    /**
		     * @implements
		     * see {module:echarts/CoodinateSystem}
		     */
		    gridProto.convertFromPixel = function (ecModel, finder, value) {
		        var target = this._findConvertTarget(ecModel, finder);

		        return target.cartesian
		            ? target.cartesian.pointToData(value)
		            : target.axis
		            ? target.axis.coordToData(target.axis.toLocalCoord(value))
		            : null;
		    };

		    /**
		     * @inner
		     */
		    gridProto._findConvertTarget = function (ecModel, finder) {
		        var seriesModel = finder.seriesModel;
		        var xAxisModel = finder.xAxisModel
		            || (seriesModel && seriesModel.getReferringComponents('xAxis')[0]);
		        var yAxisModel = finder.yAxisModel
		            || (seriesModel && seriesModel.getReferringComponents('yAxis')[0]);
		        var gridModel = finder.gridModel;
		        var coordsList = this._coordsList;
		        var cartesian;
		        var axis;

		        if (seriesModel) {
		            cartesian = seriesModel.coordinateSystem;
		            zrUtil.indexOf(coordsList, cartesian) < 0 && (cartesian = null);
		        }
		        else if (xAxisModel && yAxisModel) {
		            cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex);
		        }
		        else if (xAxisModel) {
		            axis = this.getAxis('x', xAxisModel.componentIndex);
		        }
		        else if (yAxisModel) {
		            axis = this.getAxis('y', yAxisModel.componentIndex);
		        }
		        // Lowest priority.
		        else if (gridModel) {
		            var grid = gridModel.coordinateSystem;
		            if (grid === this) {
		                cartesian = this._coordsList[0];
		            }
		        }

		        return {cartesian: cartesian, axis: axis};
		    };

		    /**
		     * @implements
		     * see {module:echarts/CoodinateSystem}
		     */
		    gridProto.containPoint = function (point) {
		        var coord = this._coordsList[0];
		        if (coord) {
		            return coord.containPoint(point);
		        }
		    };

		    /**
		     * Initialize cartesian coordinate systems
		     * @private
		     */
		    gridProto._initCartesian = function (gridModel, ecModel, api) {
		        var axisPositionUsed = {
		            left: false,
		            right: false,
		            top: false,
		            bottom: false
		        };

		        var axesMap = {
		            x: {},
		            y: {}
		        };
		        var axesCount = {
		            x: 0,
		            y: 0
		        };

		        /// Create axis
		        ecModel.eachComponent('xAxis', createAxisCreator('x'), this);
		        ecModel.eachComponent('yAxis', createAxisCreator('y'), this);

		        if (!axesCount.x || !axesCount.y) {
		            // Roll back when there no either x or y axis
		            this._axesMap = {};
		            this._axesList = [];
		            return;
		        }

		        this._axesMap = axesMap;

		        /// Create cartesian2d
		        each(axesMap.x, function (xAxis, xAxisIndex) {
		            each(axesMap.y, function (yAxis, yAxisIndex) {
		                var key = 'x' + xAxisIndex + 'y' + yAxisIndex;
		                var cartesian = new Cartesian2D(key);

		                cartesian.grid = this;

		                this._coordsMap[key] = cartesian;
		                this._coordsList.push(cartesian);

		                cartesian.addAxis(xAxis);
		                cartesian.addAxis(yAxis);
		            }, this);
		        }, this);

		        function createAxisCreator(axisType) {
		            return function (axisModel, idx) {
		                if (!isAxisUsedInTheGrid(axisModel, gridModel, ecModel)) {
		                    return;
		                }

		                var axisPosition = axisModel.get('position');
		                if (axisType === 'x') {
		                    // Fix position
		                    if (axisPosition !== 'top' && axisPosition !== 'bottom') {
		                        // Default bottom of X
		                        axisPosition = 'bottom';
		                        if (axisPositionUsed[axisPosition]) {
		                            axisPosition = axisPosition === 'top' ? 'bottom' : 'top';
		                        }
		                    }
		                }
		                else {
		                    // Fix position
		                    if (axisPosition !== 'left' && axisPosition !== 'right') {
		                        // Default left of Y
		                        axisPosition = 'left';
		                        if (axisPositionUsed[axisPosition]) {
		                            axisPosition = axisPosition === 'left' ? 'right' : 'left';
		                        }
		                    }
		                }
		                axisPositionUsed[axisPosition] = true;

		                var axis = new Axis2D(
		                    axisType, axisHelper.createScaleByModel(axisModel),
		                    [0, 0],
		                    axisModel.get('type'),
		                    axisPosition
		                );

		                var isCategory = axis.type === 'category';
		                axis.onBand = isCategory && axisModel.get('boundaryGap');
		                axis.inverse = axisModel.get('inverse');

		                axis.onZero = axisModel.get('axisLine.onZero');

		                // Inject axis into axisModel
		                axisModel.axis = axis;

		                // Inject axisModel into axis
		                axis.model = axisModel;

		                // Inject grid info axis
		                axis.grid = this;

		                // Index of axis, can be used as key
		                axis.index = idx;

		                this._axesList.push(axis);

		                axesMap[axisType][idx] = axis;
		                axesCount[axisType]++;
		            };
		        }
		    };

		    /**
		     * Update cartesian properties from series
		     * @param  {module:echarts/model/Option} option
		     * @private
		     */
		    gridProto._updateScale = function (ecModel, gridModel) {
		        // Reset scale
		        zrUtil.each(this._axesList, function (axis) {
		            axis.scale.setExtent(Infinity, -Infinity);
		        });
		        ecModel.eachSeries(function (seriesModel) {
		            if (isCartesian2D(seriesModel)) {
		                var axesModels = findAxesModels(seriesModel, ecModel);
		                var xAxisModel = axesModels[0];
		                var yAxisModel = axesModels[1];

		                if (!isAxisUsedInTheGrid(xAxisModel, gridModel, ecModel)
		                    || !isAxisUsedInTheGrid(yAxisModel, gridModel, ecModel)
		                 ) {
		                    return;
		                }

		                var cartesian = this.getCartesian(
		                    xAxisModel.componentIndex, yAxisModel.componentIndex
		                );
		                var data = seriesModel.getData();
		                var xAxis = cartesian.getAxis('x');
		                var yAxis = cartesian.getAxis('y');

		                if (data.type === 'list') {
		                    unionExtent(data, xAxis, seriesModel);
		                    unionExtent(data, yAxis, seriesModel);
		                }
		            }
		        }, this);

		        function unionExtent(data, axis, seriesModel) {
		            each(seriesModel.coordDimToDataDim(axis.dim), function (dim) {
		                axis.scale.unionExtent(data.getDataExtent(
		                    dim, axis.scale.type !== 'ordinal'
		                ));
		            });
		        }
		    };

		    /**
		     * @inner
		     */
		    function updateAxisTransfrom(axis, coordBase) {
		        var axisExtent = axis.getExtent();
		        var axisExtentSum = axisExtent[0] + axisExtent[1];

		        // Fast transform
		        axis.toGlobalCoord = axis.dim === 'x'
		            ? function (coord) {
		                return coord + coordBase;
		            }
		            : function (coord) {
		                return axisExtentSum - coord + coordBase;
		            };
		        axis.toLocalCoord = axis.dim === 'x'
		            ? function (coord) {
		                return coord - coordBase;
		            }
		            : function (coord) {
		                return axisExtentSum - coord + coordBase;
		            };
		    }

		    var axesTypes = ['xAxis', 'yAxis'];
		    /**
		     * @inner
		     */
		    function findAxesModels(seriesModel, ecModel) {
		        return zrUtil.map(axesTypes, function (axisType) {
		            var axisModel = seriesModel.getReferringComponents(axisType)[0];

		            if (true) {
		                if (!axisModel) {
		                    throw new Error(axisType + ' "' + zrUtil.retrieve(
		                        seriesModel.get(axisType + 'Index'),
		                        seriesModel.get(axisType + 'Id'),
		                        0
		                    ) + '" not found');
		                }
		            }
		            return axisModel;
		        });
		    }

		    /**
		     * @inner
		     */
		    function isCartesian2D(seriesModel) {
		        return seriesModel.get('coordinateSystem') === 'cartesian2d';
		    }

		    Grid.create = function (ecModel, api) {
		        var grids = [];
		        ecModel.eachComponent('grid', function (gridModel, idx) {
		            var grid = new Grid(gridModel, ecModel, api);
		            grid.name = 'grid_' + idx;
		            grid.resize(gridModel, api);

		            gridModel.coordinateSystem = grid;

		            grids.push(grid);
		        });

		        // Inject the coordinateSystems into seriesModel
		        ecModel.eachSeries(function (seriesModel) {
		            if (!isCartesian2D(seriesModel)) {
		                return;
		            }

		            var axesModels = findAxesModels(seriesModel, ecModel);
		            var xAxisModel = axesModels[0];
		            var yAxisModel = axesModels[1];

		            var gridModel = xAxisModel.findGridModel();

		            if (true) {
		                if (!gridModel) {
		                    throw new Error(
		                        'Grid "' + zrUtil.retrieve(
		                            xAxisModel.get('gridIndex'),
		                            xAxisModel.get('gridId'),
		                            0
		                        ) + '" not found'
		                    );
		                }
		                if (xAxisModel.findGridModel() !== yAxisModel.findGridModel()) {
		                    throw new Error('xAxis and yAxis must use the same grid');
		                }
		            }

		            var grid = gridModel.coordinateSystem;

		            seriesModel.coordinateSystem = grid.getCartesian(
		                xAxisModel.componentIndex, yAxisModel.componentIndex
		            );
		        });

		        return grids;
		    };

		    // For deciding which dimensions to use when creating list data
		    Grid.dimensions = Cartesian2D.prototype.dimensions;

		    __webpack_require__(26).register('cartesian2d', Grid);

		    module.exports = Grid;


	/***/ },
	/* 115 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var OrdinalScale = __webpack_require__(116);
		    var IntervalScale = __webpack_require__(118);
		    __webpack_require__(119);
		    __webpack_require__(120);
		    var Scale = __webpack_require__(117);

		    var numberUtil = __webpack_require__(7);
		    var zrUtil = __webpack_require__(4);
		    var textContain = __webpack_require__(8);
		    var axisHelper = {};

		    /**
		     * Get axis scale extent before niced.
		     */
		    axisHelper.getScaleExtent = function (axis, model) {
		        var scale = axis.scale;
		        var originalExtent = scale.getExtent();
		        var span = originalExtent[1] - originalExtent[0];
		        if (scale.type === 'ordinal') {
		            // If series has no data, scale extent may be wrong
		            if (!isFinite(span)) {
		                return [0, 0];
		            }
		            else {
		                return originalExtent;
		            }
		        }
		        var min = model.getMin ? model.getMin() : model.get('min');
		        var max = model.getMax ? model.getMax() : model.get('max');
		        var crossZero = model.getNeedCrossZero
		            ? model.getNeedCrossZero() : !model.get('scale');
		        var boundaryGap = model.get('boundaryGap');
		        if (!zrUtil.isArray(boundaryGap)) {
		            boundaryGap = [boundaryGap || 0, boundaryGap || 0];
		        }
		        boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);
		        boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);
		        var fixMin = true;
		        var fixMax = true;
		        // Add boundary gap
		        if (min == null) {
		            min = originalExtent[0] - boundaryGap[0] * span;
		            fixMin = false;
		        }
		        if (max == null) {
		            max = originalExtent[1] + boundaryGap[1] * span;
		            fixMax = false;
		        }
		        if (min === 'dataMin') {
		            min = originalExtent[0];
		        }
		        if (max === 'dataMax') {
		            max = originalExtent[1];
		        }
		        // Evaluate if axis needs cross zero
		        if (crossZero) {
		            // Axis is over zero and min is not set
		            if (min > 0 && max > 0 && !fixMin) {
		                min = 0;
		            }
		            // Axis is under zero and max is not set
		            if (min < 0 && max < 0 && !fixMax) {
		                max = 0;
		            }
		        }
		        return [min, max];
		    };

		    axisHelper.niceScaleExtent = function (axis, model) {
		        var scale = axis.scale;
		        var extent = axisHelper.getScaleExtent(axis, model);
		        var fixMin = (model.getMin ? model.getMin() : model.get('min')) != null;
		        var fixMax = (model.getMax ? model.getMax() : model.get('max')) != null;
		        var splitNumber = model.get('splitNumber');

		        if (scale.type === 'log') {
		            scale.base = model.get('logBase');
		        }

		        scale.setExtent(extent[0], extent[1]);
		        scale.niceExtent(splitNumber, fixMin, fixMax);

		        // Use minInterval to constraint the calculated interval.
		        // If calculated interval is less than minInterval. increase the interval quantity until
		        // it is larger than minInterval.
		        // For example:
		        //  minInterval is 1, calculated interval is 0.2, so increase it to be 1. In this way we can get
		        //  an integer axis.
		        var minInterval = model.get('minInterval');
		        if (isFinite(minInterval) && !fixMin && !fixMax && scale.type === 'interval') {
		            var interval = scale.getInterval();
		            var intervalScale = Math.max(Math.abs(interval), minInterval) / interval;
		            // while (interval < minInterval) {
		            //     var quantity = numberUtil.quantity(interval);
		            //     interval = quantity * 10;
		            //     scaleQuantity *= 10;
		            // }
		            extent = scale.getExtent();
		            var origin = (extent[1] + extent[0]) / 2;
		            scale.setExtent(
		                intervalScale * (extent[0] - origin) + origin,
		                intervalScale * (extent[1] - origin) + origin
		            );
		            scale.niceExtent(splitNumber);
		        }

		        // If some one specified the min, max. And the default calculated interval
		        // is not good enough. He can specify the interval. It is often appeared
		        // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
		        // to be 60.
		        // FIXME
		        var interval = model.get('interval');
		        if (interval != null) {
		            scale.setInterval && scale.setInterval(interval);
		        }
		    };

		    /**
		     * @param {module:echarts/model/Model} model
		     * @param {string} [axisType] Default retrieve from model.type
		     * @return {module:echarts/scale/*}
		     */
		    axisHelper.createScaleByModel = function(model, axisType) {
		        axisType = axisType || model.get('type');
		        if (axisType) {
		            switch (axisType) {
		                // Buildin scale
		                case 'category':
		                    return new OrdinalScale(
		                        model.getCategories(), [Infinity, -Infinity]
		                    );
		                case 'value':
		                    return new IntervalScale();
		                // Extended scale, like time and log
		                default:
		                    return (Scale.getClass(axisType) || IntervalScale).create(model);
		            }
		        }
		    };

		    /**
		     * Check if the axis corss 0
		     */
		    axisHelper.ifAxisCrossZero = function (axis) {
		        var dataExtent = axis.scale.getExtent();
		        var min = dataExtent[0];
		        var max = dataExtent[1];
		        return !((min > 0 && max > 0) || (min < 0 && max < 0));
		    };

		    /**
		     * @param {Array.<number>} tickCoords In axis self coordinate.
		     * @param {Array.<string>} labels
		     * @param {string} font
		     * @param {boolean} isAxisHorizontal
		     * @return {number}
		     */
		    axisHelper.getAxisLabelInterval = function (tickCoords, labels, font, isAxisHorizontal) {
		        // FIXME
		        // 不同角的axis和label，不只是horizontal和vertical.

		        var textSpaceTakenRect;
		        var autoLabelInterval = 0;
		        var accumulatedLabelInterval = 0;

		        var step = 1;
		        if (labels.length > 40) {
		            // Simple optimization for large amount of labels
		            step = Math.floor(labels.length / 40);
		        }

		        for (var i = 0; i < tickCoords.length; i += step) {
		            var tickCoord = tickCoords[i];
		            var rect = textContain.getBoundingRect(
		                labels[i], font, 'center', 'top'
		            );
		            rect[isAxisHorizontal ? 'x' : 'y'] += tickCoord;
		            // FIXME Magic number 1.5
		            rect[isAxisHorizontal ? 'width' : 'height'] *= 1.3;
		            if (!textSpaceTakenRect) {
		                textSpaceTakenRect = rect.clone();
		            }
		            // There is no space for current label;
		            else if (textSpaceTakenRect.intersect(rect)) {
		                accumulatedLabelInterval++;
		                autoLabelInterval = Math.max(autoLabelInterval, accumulatedLabelInterval);
		            }
		            else {
		                textSpaceTakenRect.union(rect);
		                // Reset
		                accumulatedLabelInterval = 0;
		            }
		        }
		        if (autoLabelInterval === 0 && step > 1) {
		            return step;
		        }
		        return (autoLabelInterval + 1) * step - 1;
		    };

		    /**
		     * @param {Object} axis
		     * @param {Function} labelFormatter
		     * @return {Array.<string>}
		     */
		    axisHelper.getFormattedLabels = function (axis, labelFormatter) {
		        var scale = axis.scale;
		        var labels = scale.getTicksLabels();
		        var ticks = scale.getTicks();
		        if (typeof labelFormatter === 'string') {
		            labelFormatter = (function (tpl) {
		                return function (val) {
		                    return tpl.replace('{value}', val != null ? val : '');
		                };
		            })(labelFormatter);
		            // Consider empty array
		            return zrUtil.map(labels, labelFormatter);
		        }
		        else if (typeof labelFormatter === 'function') {
		            return zrUtil.map(ticks, function (tick, idx) {
		                return labelFormatter(
		                    axis.type === 'category' ? scale.getLabel(tick) : tick,
		                    idx
		                );
		            }, this);
		        }
		        else {
		            return labels;
		        }
		    };

		    module.exports = axisHelper;


	/***/ },
	/* 116 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Linear continuous scale
		 * @module echarts/coord/scale/Ordinal
		 *
		 * http://en.wikipedia.org/wiki/Level_of_measurement
		 */

		// FIXME only one data


		    var zrUtil = __webpack_require__(4);
		    var Scale = __webpack_require__(117);

		    var scaleProto = Scale.prototype;

		    var OrdinalScale = Scale.extend({

		        type: 'ordinal',

		        init: function (data, extent) {
		            this._data = data;
		            this._extent = extent || [0, data.length - 1];
		        },

		        parse: function (val) {
		            return typeof val === 'string'
		                ? zrUtil.indexOf(this._data, val)
		                // val might be float.
		                : Math.round(val);
		        },

		        contain: function (rank) {
		            rank = this.parse(rank);
		            return scaleProto.contain.call(this, rank)
		                && this._data[rank] != null;
		        },

		        /**
		         * Normalize given rank or name to linear [0, 1]
		         * @param {number|string} [val]
		         * @return {number}
		         */
		        normalize: function (val) {
		            return scaleProto.normalize.call(this, this.parse(val));
		        },

		        scale: function (val) {
		            return Math.round(scaleProto.scale.call(this, val));
		        },

		        /**
		         * @return {Array}
		         */
		        getTicks: function () {
		            var ticks = [];
		            var extent = this._extent;
		            var rank = extent[0];

		            while (rank <= extent[1]) {
		                ticks.push(rank);
		                rank++;
		            }

		            return ticks;
		        },

		        /**
		         * Get item on rank n
		         * @param {number} n
		         * @return {string}
		         */
		        getLabel: function (n) {
		            return this._data[n];
		        },

		        /**
		         * @return {number}
		         */
		        count: function () {
		            return this._extent[1] - this._extent[0] + 1;
		        },

		        niceTicks: zrUtil.noop,
		        niceExtent: zrUtil.noop
		    });

		    /**
		     * @return {module:echarts/scale/Time}
		     */
		    OrdinalScale.create = function () {
		        return new OrdinalScale();
		    };

		    module.exports = OrdinalScale;


	/***/ },
	/* 117 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * // Scale class management
		 * @module echarts/scale/Scale
		 */


		    var clazzUtil = __webpack_require__(13);

		    function Scale() {
		        /**
		         * Extent
		         * @type {Array.<number>}
		         * @protected
		         */
		        this._extent = [Infinity, -Infinity];

		        /**
		         * Step is calculated in adjustExtent
		         * @type {Array.<number>}
		         * @protected
		         */
		        this._interval = 0;

		        this.init && this.init.apply(this, arguments);
		    }

		    var scaleProto = Scale.prototype;

		    /**
		     * Parse input val to valid inner number.
		     * @param {*} val
		     * @return {number}
		     */
		    scaleProto.parse = function (val) {
		        // Notice: This would be a trap here, If the implementation
		        // of this method depends on extent, and this method is used
		        // before extent set (like in dataZoom), it would be wrong.
		        // Nevertheless, parse does not depend on extent generally.
		        return val;
		    };

		    scaleProto.contain = function (val) {
		        var extent = this._extent;
		        return val >= extent[0] && val <= extent[1];
		    };

		    /**
		     * Normalize value to linear [0, 1], return 0.5 if extent span is 0
		     * @param {number} val
		     * @return {number}
		     */
		    scaleProto.normalize = function (val) {
		        var extent = this._extent;
		        if (extent[1] === extent[0]) {
		            return 0.5;
		        }
		        return (val - extent[0]) / (extent[1] - extent[0]);
		    };

		    /**
		     * Scale normalized value
		     * @param {number} val
		     * @return {number}
		     */
		    scaleProto.scale = function (val) {
		        var extent = this._extent;
		        return val * (extent[1] - extent[0]) + extent[0];
		    };

		    /**
		     * Set extent from data
		     * @param {Array.<number>} other
		     */
		    scaleProto.unionExtent = function (other) {
		        var extent = this._extent;
		        other[0] < extent[0] && (extent[0] = other[0]);
		        other[1] > extent[1] && (extent[1] = other[1]);
		        // not setExtent because in log axis it may transformed to power
		        // this.setExtent(extent[0], extent[1]);
		    };

		    /**
		     * Get extent
		     * @return {Array.<number>}
		     */
		    scaleProto.getExtent = function () {
		        return this._extent.slice();
		    };

		    /**
		     * Set extent
		     * @param {number} start
		     * @param {number} end
		     */
		    scaleProto.setExtent = function (start, end) {
		        var thisExtent = this._extent;
		        if (!isNaN(start)) {
		            thisExtent[0] = start;
		        }
		        if (!isNaN(end)) {
		            thisExtent[1] = end;
		        }
		    };

		    /**
		     * @return {Array.<string>}
		     */
		    scaleProto.getTicksLabels = function () {
		        var labels = [];
		        var ticks = this.getTicks();
		        for (var i = 0; i < ticks.length; i++) {
		            labels.push(this.getLabel(ticks[i]));
		        }
		        return labels;
		    };

		    clazzUtil.enableClassExtend(Scale);
		    clazzUtil.enableClassManagement(Scale, {
		        registerWhenExtend: true
		    });

		    module.exports = Scale;


	/***/ },
	/* 118 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Interval scale
		 * @module echarts/scale/Interval
		 */



		    var numberUtil = __webpack_require__(7);
		    var formatUtil = __webpack_require__(6);
		    var Scale = __webpack_require__(117);

		    var mathFloor = Math.floor;
		    var mathCeil = Math.ceil;

		    var getPrecisionSafe = numberUtil.getPrecisionSafe;
		    var roundingErrorFix = numberUtil.round;
		    /**
		     * @alias module:echarts/coord/scale/Interval
		     * @constructor
		     */
		    var IntervalScale = Scale.extend({

		        type: 'interval',

		        _interval: 0,

		        setExtent: function (start, end) {
		            var thisExtent = this._extent;
		            //start,end may be a Number like '25',so...
		            if (!isNaN(start)) {
		                thisExtent[0] = parseFloat(start);
		            }
		            if (!isNaN(end)) {
		                thisExtent[1] = parseFloat(end);
		            }
		        },

		        unionExtent: function (other) {
		            var extent = this._extent;
		            other[0] < extent[0] && (extent[0] = other[0]);
		            other[1] > extent[1] && (extent[1] = other[1]);

		            // unionExtent may called by it's sub classes
		            IntervalScale.prototype.setExtent.call(this, extent[0], extent[1]);
		        },
		        /**
		         * Get interval
		         */
		        getInterval: function () {
		            if (!this._interval) {
		                this.niceTicks();
		            }
		            return this._interval;
		        },

		        /**
		         * Set interval
		         */
		        setInterval: function (interval) {
		            this._interval = interval;
		            // Dropped auto calculated niceExtent and use user setted extent
		            // We assume user wan't to set both interval, min, max to get a better result
		            this._niceExtent = this._extent.slice();
		        },

		        /**
		         * @return {Array.<number>}
		         */
		        getTicks: function () {
		            if (!this._interval) {
		                this.niceTicks();
		            }
		            var interval = this._interval;
		            var extent = this._extent;
		            var ticks = [];

		            // Consider this case: using dataZoom toolbox, zoom and zoom.
		            var safeLimit = 10000;

		            if (interval) {
		                var niceExtent = this._niceExtent;
		                var precision = getPrecisionSafe(interval) + 2;

		                if (extent[0] < niceExtent[0]) {
		                    ticks.push(extent[0]);
		                }
		                var tick = niceExtent[0];

		                while (tick <= niceExtent[1]) {
		                    ticks.push(tick);
		                    // Avoid rounding error
		                    tick = roundingErrorFix(tick + interval, precision);
		                    if (ticks.length > safeLimit) {
		                        return [];
		                    }
		                }
		                // Consider this case: the last item of ticks is smaller
		                // than niceExtent[1] and niceExtent[1] === extent[1].
		                if (extent[1] > (ticks.length ? ticks[ticks.length - 1] : niceExtent[1])) {
		                    ticks.push(extent[1]);
		                }
		            }

		            return ticks;
		        },

		        /**
		         * @return {Array.<string>}
		         */
		        getTicksLabels: function () {
		            var labels = [];
		            var ticks = this.getTicks();
		            for (var i = 0; i < ticks.length; i++) {
		                labels.push(this.getLabel(ticks[i]));
		            }
		            return labels;
		        },

		        /**
		         * @param {number} n
		         * @return {number}
		         */
		        getLabel: function (data) {
		            return formatUtil.addCommas(data);
		        },

		        /**
		         * Update interval and extent of intervals for nice ticks
		         *
		         * @param {number} [splitNumber = 5] Desired number of ticks
		         */
		        niceTicks: function (splitNumber) {
		            splitNumber = splitNumber || 5;
		            var extent = this._extent;
		            var span = extent[1] - extent[0];
		            if (!isFinite(span)) {
		                return;
		            }
		            // User may set axis min 0 and data are all negative
		            // FIXME If it needs to reverse ?
		            if (span < 0) {
		                span = -span;
		                extent.reverse();
		            }

		            // From "Nice Numbers for Graph Labels" of Graphic Gems
		            // var niceSpan = numberUtil.nice(span, false);
		            var step = roundingErrorFix(
		                numberUtil.nice(span / splitNumber, true),
		                Math.max(
		                    getPrecisionSafe(extent[0]),
		                    getPrecisionSafe(extent[1])
		                // extent may be [0, 1], and step should have 1 more digits.
		                // To make it safe we add 2 more digits
		                ) + 2
		            );

		            var precision = getPrecisionSafe(step) + 2;
		            // Niced extent inside original extent
		            var niceExtent = [
		                roundingErrorFix(mathCeil(extent[0] / step) * step, precision),
		                roundingErrorFix(mathFloor(extent[1] / step) * step, precision)
		            ];

		            this._interval = step;
		            this._niceExtent = niceExtent;
		        },

		        /**
		         * Nice extent.
		         * @param {number} [splitNumber = 5] Given approx tick number
		         * @param {boolean} [fixMin=false]
		         * @param {boolean} [fixMax=false]
		         */
		        niceExtent: function (splitNumber, fixMin, fixMax) {
		            var extent = this._extent;
		            // If extent start and end are same, expand them
		            if (extent[0] === extent[1]) {
		                if (extent[0] !== 0) {
		                    // Expand extent
		                    var expandSize = extent[0];
		                    // In the fowllowing case
		                    //      Axis has been fixed max 100
		                    //      Plus data are all 100 and axis extent are [100, 100].
		                    // Extend to the both side will cause expanded max is larger than fixed max.
		                    // So only expand to the smaller side.
		                    if (!fixMax) {
		                        extent[1] += expandSize / 2;
		                        extent[0] -= expandSize / 2;
		                    }
		                    else {
		                        extent[0] -= expandSize / 2;
		                    }
		                }
		                else {
		                    extent[1] = 1;
		                }
		            }
		            var span = extent[1] - extent[0];
		            // If there are no data and extent are [Infinity, -Infinity]
		            if (!isFinite(span)) {
		                extent[0] = 0;
		                extent[1] = 1;
		            }

		            this.niceTicks(splitNumber);

		            // var extent = this._extent;
		            var interval = this._interval;

		            if (!fixMin) {
		                extent[0] = roundingErrorFix(mathFloor(extent[0] / interval) * interval);
		            }
		            if (!fixMax) {
		                extent[1] = roundingErrorFix(mathCeil(extent[1] / interval) * interval);
		            }
		        }
		    });

		    /**
		     * @return {module:echarts/scale/Time}
		     */
		    IntervalScale.create = function () {
		        return new IntervalScale();
		    };

		    module.exports = IntervalScale;



	/***/ },
	/* 119 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Interval scale
		 * @module echarts/coord/scale/Time
		 */



		    var zrUtil = __webpack_require__(4);
		    var numberUtil = __webpack_require__(7);
		    var formatUtil = __webpack_require__(6);

		    var IntervalScale = __webpack_require__(118);

		    var intervalScaleProto = IntervalScale.prototype;

		    var mathCeil = Math.ceil;
		    var mathFloor = Math.floor;
		    var ONE_SECOND = 1000;
		    var ONE_MINUTE = ONE_SECOND * 60;
		    var ONE_HOUR = ONE_MINUTE * 60;
		    var ONE_DAY = ONE_HOUR * 24;

		    // FIXME 公用？
		    var bisect = function (a, x, lo, hi) {
		        while (lo < hi) {
		            var mid = lo + hi >>> 1;
		            if (a[mid][2] < x) {
		                lo = mid + 1;
		            }
		            else {
		                hi  = mid;
		            }
		        }
		        return lo;
		    };

		    /**
		     * @alias module:echarts/coord/scale/Time
		     * @constructor
		     */
		    var TimeScale = IntervalScale.extend({
		        type: 'time',

		        // Overwrite
		        getLabel: function (val) {
		            var stepLvl = this._stepLvl;

		            var date = new Date(val);

		            return formatUtil.formatTime(stepLvl[0], date);
		        },

		        // Overwrite
		        niceExtent: function (approxTickNum, fixMin, fixMax) {
		            var extent = this._extent;
		            // If extent start and end are same, expand them
		            if (extent[0] === extent[1]) {
		                // Expand extent
		                extent[0] -= ONE_DAY;
		                extent[1] += ONE_DAY;
		            }
		            // If there are no data and extent are [Infinity, -Infinity]
		            if (extent[1] === -Infinity && extent[0] === Infinity) {
		                var d = new Date();
		                extent[1] = new Date(d.getFullYear(), d.getMonth(), d.getDate());
		                extent[0] = extent[1] - ONE_DAY;
		            }

		            this.niceTicks(approxTickNum);

		            // var extent = this._extent;
		            var interval = this._interval;

		            if (!fixMin) {
		                extent[0] = numberUtil.round(mathFloor(extent[0] / interval) * interval);
		            }
		            if (!fixMax) {
		                extent[1] = numberUtil.round(mathCeil(extent[1] / interval) * interval);
		            }
		        },

		        // Overwrite
		        niceTicks: function (approxTickNum) {
		            approxTickNum = approxTickNum || 10;

		            var extent = this._extent;
		            var span = extent[1] - extent[0];
		            var approxInterval = span / approxTickNum;
		            var scaleLevelsLen = scaleLevels.length;
		            var idx = bisect(scaleLevels, approxInterval, 0, scaleLevelsLen);

		            var level = scaleLevels[Math.min(idx, scaleLevelsLen - 1)];
		            var interval = level[2];
		            // Same with interval scale if span is much larger than 1 year
		            if (level[0] === 'year') {
		                var yearSpan = span / interval;

		                // From "Nice Numbers for Graph Labels" of Graphic Gems
		                // var niceYearSpan = numberUtil.nice(yearSpan, false);
		                var yearStep = numberUtil.nice(yearSpan / approxTickNum, true);

		                interval *= yearStep;
		            }

		            var niceExtent = [
		                mathCeil(extent[0] / interval) * interval,
		                mathFloor(extent[1] / interval) * interval
		            ];

		            this._stepLvl = level;
		            // Interval will be used in getTicks
		            this._interval = interval;
		            this._niceExtent = niceExtent;
		        },

		        parse: function (val) {
		            // val might be float.
		            return +numberUtil.parseDate(val);
		        }
		    });

		    zrUtil.each(['contain', 'normalize'], function (methodName) {
		        TimeScale.prototype[methodName] = function (val) {
		            return intervalScaleProto[methodName].call(this, this.parse(val));
		        };
		    });

		    // Steps from d3
		    var scaleLevels = [
		        // Format       step    interval
		        ['hh:mm:ss',    1,      ONE_SECOND],           // 1s
		        ['hh:mm:ss',    5,      ONE_SECOND * 5],       // 5s
		        ['hh:mm:ss',    10,     ONE_SECOND * 10],      // 10s
		        ['hh:mm:ss',    15,     ONE_SECOND * 15],      // 15s
		        ['hh:mm:ss',    30,     ONE_SECOND * 30],      // 30s
		        ['hh:mm\nMM-dd',1,      ONE_MINUTE],          // 1m
		        ['hh:mm\nMM-dd',5,      ONE_MINUTE * 5],      // 5m
		        ['hh:mm\nMM-dd',10,     ONE_MINUTE * 10],     // 10m
		        ['hh:mm\nMM-dd',15,     ONE_MINUTE * 15],     // 15m
		        ['hh:mm\nMM-dd',30,     ONE_MINUTE * 30],     // 30m
		        ['hh:mm\nMM-dd',1,      ONE_HOUR],        // 1h
		        ['hh:mm\nMM-dd',2,      ONE_HOUR * 2],    // 2h
		        ['hh:mm\nMM-dd',6,      ONE_HOUR * 6],    // 6h
		        ['hh:mm\nMM-dd',12,     ONE_HOUR * 12],   // 12h
		        ['MM-dd\nyyyy', 1,      ONE_DAY],   // 1d
		        ['week',        7,      ONE_DAY * 7],        // 7d
		        ['month',       1,      ONE_DAY * 31],       // 1M
		        ['quarter',     3,      ONE_DAY * 380 / 4],  // 3M
		        ['half-year',   6,      ONE_DAY * 380 / 2],  // 6M
		        ['year',        1,      ONE_DAY * 380]       // 1Y
		    ];

		    /**
		     * @return {module:echarts/scale/Time}
		     */
		    TimeScale.create = function () {
		        return new TimeScale();
		    };

		    module.exports = TimeScale;


	/***/ },
	/* 120 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Log scale
		 * @module echarts/scale/Log
		 */


		    var zrUtil = __webpack_require__(4);
		    var Scale = __webpack_require__(117);
		    var numberUtil = __webpack_require__(7);

		    // Use some method of IntervalScale
		    var IntervalScale = __webpack_require__(118);

		    var scaleProto = Scale.prototype;
		    var intervalScaleProto = IntervalScale.prototype;

		    var getPrecisionSafe = numberUtil.getPrecisionSafe;
		    var roundingErrorFix = numberUtil.round;

		    var mathFloor = Math.floor;
		    var mathCeil = Math.ceil;
		    var mathPow = Math.pow;

		    var mathLog = Math.log;

		    var LogScale = Scale.extend({

		        type: 'log',

		        base: 10,

		        $constructor: function () {
		            Scale.apply(this, arguments);
		            this._originalScale = new IntervalScale();
		        },

		        /**
		         * @return {Array.<number>}
		         */
		        getTicks: function () {
		            var originalScale = this._originalScale;
		            var extent = this._extent;
		            var originalExtent = originalScale.getExtent();

		            return zrUtil.map(intervalScaleProto.getTicks.call(this), function (val) {
		                var powVal = numberUtil.round(mathPow(this.base, val));

		                // Fix #4158
		                powVal = (val === extent[0] && originalScale.__fixMin)
		                    ? fixRoundingError(powVal, originalExtent[0])
		                    : powVal;
		                powVal = (val === extent[1] && originalScale.__fixMax)
		                    ? fixRoundingError(powVal, originalExtent[1])
		                    : powVal;

		                return powVal;
		            }, this);
		        },

		        /**
		         * @param {number} val
		         * @return {string}
		         */
		        getLabel: intervalScaleProto.getLabel,

		        /**
		         * @param  {number} val
		         * @return {number}
		         */
		        scale: function (val) {
		            val = scaleProto.scale.call(this, val);
		            return mathPow(this.base, val);
		        },

		        /**
		         * @param {number} start
		         * @param {number} end
		         */
		        setExtent: function (start, end) {
		            var base = this.base;
		            start = mathLog(start) / mathLog(base);
		            end = mathLog(end) / mathLog(base);
		            intervalScaleProto.setExtent.call(this, start, end);
		        },

		        /**
		         * @return {number} end
		         */
		        getExtent: function () {
		            var base = this.base;
		            var extent = scaleProto.getExtent.call(this);
		            extent[0] = mathPow(base, extent[0]);
		            extent[1] = mathPow(base, extent[1]);

		            // Fix #4158
		            var originalScale = this._originalScale;
		            var originalExtent = originalScale.getExtent();
		            originalScale.__fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]));
		            originalScale.__fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]));

		            return extent;
		        },

		        /**
		         * @param  {Array.<number>} extent
		         */
		        unionExtent: function (extent) {
		            this._originalScale.unionExtent(extent);

		            var base = this.base;
		            extent[0] = mathLog(extent[0]) / mathLog(base);
		            extent[1] = mathLog(extent[1]) / mathLog(base);
		            scaleProto.unionExtent.call(this, extent);
		        },

		        /**
		         * Update interval and extent of intervals for nice ticks
		         * @param  {number} [approxTickNum = 10] Given approx tick number
		         */
		        niceTicks: function (approxTickNum) {
		            approxTickNum = approxTickNum || 10;
		            var extent = this._extent;
		            var span = extent[1] - extent[0];
		            if (span === Infinity || span <= 0) {
		                return;
		            }

		            var interval = numberUtil.quantity(span);
		            var err = approxTickNum / span * interval;

		            // Filter ticks to get closer to the desired count.
		            if (err <= 0.5) {
		                interval *= 10;
		            }

		            // Interval should be integer
		            while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
		                interval *= 10;
		            }

		            var niceExtent = [
		                numberUtil.round(mathCeil(extent[0] / interval) * interval),
		                numberUtil.round(mathFloor(extent[1] / interval) * interval)
		            ];

		            this._interval = interval;
		            this._niceExtent = niceExtent;
		        },

		        /**
		         * Nice extent.
		         * @param {number} [approxTickNum = 10] Given approx tick number
		         * @param {boolean} [fixMin=false]
		         * @param {boolean} [fixMax=false]
		         */
		        niceExtent: function (splitNumber, fixMin, fixMax) {
		            intervalScaleProto.niceExtent.call(this, splitNumber, fixMin, fixMax);

		            var originalScale = this._originalScale;
		            originalScale.__fixMin = fixMin;
		            originalScale.__fixMax = fixMax;
		        }

		    });

		    zrUtil.each(['contain', 'normalize'], function (methodName) {
		        LogScale.prototype[methodName] = function (val) {
		            val = mathLog(val) / mathLog(this.base);
		            return scaleProto[methodName].call(this, val);
		        };
		    });

		    LogScale.create = function () {
		        return new LogScale();
		    };

		    function fixRoundingError(val, originalVal) {
		        return roundingErrorFix(val, getPrecisionSafe(originalVal));
		    }

		    module.exports = LogScale;


	/***/ },
	/* 121 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);
		    var Cartesian = __webpack_require__(122);

		    function Cartesian2D(name) {

		        Cartesian.call(this, name);
		    }

		    Cartesian2D.prototype = {

		        constructor: Cartesian2D,

		        type: 'cartesian2d',

		        /**
		         * @type {Array.<string>}
		         * @readOnly
		         */
		        dimensions: ['x', 'y'],

		        /**
		         * Base axis will be used on stacking.
		         *
		         * @return {module:echarts/coord/cartesian/Axis2D}
		         */
		        getBaseAxis: function () {
		            return this.getAxesByScale('ordinal')[0]
		                || this.getAxesByScale('time')[0]
		                || this.getAxis('x');
		        },

		        /**
		         * If contain point
		         * @param {Array.<number>} point
		         * @return {boolean}
		         */
		        containPoint: function (point) {
		            var axisX = this.getAxis('x');
		            var axisY = this.getAxis('y');
		            return axisX.contain(axisX.toLocalCoord(point[0]))
		                && axisY.contain(axisY.toLocalCoord(point[1]));
		        },

		        /**
		         * If contain data
		         * @param {Array.<number>} data
		         * @return {boolean}
		         */
		        containData: function (data) {
		            return this.getAxis('x').containData(data[0])
		                && this.getAxis('y').containData(data[1]);
		        },

		        /**
		         * Convert series data to an array of points
		         * @param {module:echarts/data/List} data
		         * @param {boolean} stack
		         * @return {Array}
		         *  Return array of points. For example:
		         *  `[[10, 10], [20, 20], [30, 30]]`
		         */
		        dataToPoints: function (data, stack) {
		            return data.mapArray(['x', 'y'], function (x, y) {
		                return this.dataToPoint([x, y]);
		            }, stack, this);
		        },

		        /**
		         * @param {Array.<number>} data
		         * @param {boolean} [clamp=false]
		         * @return {Array.<number>}
		         */
		        dataToPoint: function (data, clamp) {
		            var xAxis = this.getAxis('x');
		            var yAxis = this.getAxis('y');
		            return [
		                xAxis.toGlobalCoord(xAxis.dataToCoord(data[0], clamp)),
		                yAxis.toGlobalCoord(yAxis.dataToCoord(data[1], clamp))
		            ];
		        },

		        /**
		         * @param {Array.<number>} point
		         * @param {boolean} [clamp=false]
		         * @return {Array.<number>}
		         */
		        pointToData: function (point, clamp) {
		            var xAxis = this.getAxis('x');
		            var yAxis = this.getAxis('y');
		            return [
		                xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp),
		                yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)
		            ];
		        },

		        /**
		         * Get other axis
		         * @param {module:echarts/coord/cartesian/Axis2D} axis
		         */
		        getOtherAxis: function (axis) {
		            return this.getAxis(axis.dim === 'x' ? 'y' : 'x');
		        }
		    };

		    zrUtil.inherits(Cartesian2D, Cartesian);

		    module.exports = Cartesian2D;


	/***/ },
	/* 122 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * Cartesian coordinate system
		 * @module  echarts/coord/Cartesian
		 *
		 */


		    var zrUtil = __webpack_require__(4);

		    function dimAxisMapper(dim) {
		        return this._axes[dim];
		    }

		    /**
		     * @alias module:echarts/coord/Cartesian
		     * @constructor
		     */
		    var Cartesian = function (name) {
		        this._axes = {};

		        this._dimList = [];

		        /**
		         * @type {string}
		         */
		        this.name = name || '';
		    };

		    Cartesian.prototype = {

		        constructor: Cartesian,

		        type: 'cartesian',

		        /**
		         * Get axis
		         * @param  {number|string} dim
		         * @return {module:echarts/coord/Cartesian~Axis}
		         */
		        getAxis: function (dim) {
		            return this._axes[dim];
		        },

		        /**
		         * Get axes list
		         * @return {Array.<module:echarts/coord/Cartesian~Axis>}
		         */
		        getAxes: function () {
		            return zrUtil.map(this._dimList, dimAxisMapper, this);
		        },

		        /**
		         * Get axes list by given scale type
		         */
		        getAxesByScale: function (scaleType) {
		            scaleType = scaleType.toLowerCase();
		            return zrUtil.filter(
		                this.getAxes(),
		                function (axis) {
		                    return axis.scale.type === scaleType;
		                }
		            );
		        },

		        /**
		         * Add axis
		         * @param {module:echarts/coord/Cartesian.Axis}
		         */
		        addAxis: function (axis) {
		            var dim = axis.dim;

		            this._axes[dim] = axis;

		            this._dimList.push(dim);
		        },

		        /**
		         * Convert data to coord in nd space
		         * @param {Array.<number>|Object.<string, number>} val
		         * @return {Array.<number>|Object.<string, number>}
		         */
		        dataToCoord: function (val) {
		            return this._dataCoordConvert(val, 'dataToCoord');
		        },

		        /**
		         * Convert coord in nd space to data
		         * @param  {Array.<number>|Object.<string, number>} val
		         * @return {Array.<number>|Object.<string, number>}
		         */
		        coordToData: function (val) {
		            return this._dataCoordConvert(val, 'coordToData');
		        },

		        _dataCoordConvert: function (input, method) {
		            var dimList = this._dimList;

		            var output = input instanceof Array ? [] : {};

		            for (var i = 0; i < dimList.length; i++) {
		                var dim = dimList[i];
		                var axis = this._axes[dim];

		                output[dim] = axis[method](input[dim]);
		            }

		            return output;
		        }
		    };

		    module.exports = Cartesian;


	/***/ },
	/* 123 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var Axis = __webpack_require__(124);
		    var axisLabelInterval = __webpack_require__(125);

		    /**
		     * Extend axis 2d
		     * @constructor module:echarts/coord/cartesian/Axis2D
		     * @extends {module:echarts/coord/cartesian/Axis}
		     * @param {string} dim
		     * @param {*} scale
		     * @param {Array.<number>} coordExtent
		     * @param {string} axisType
		     * @param {string} position
		     */
		    var Axis2D = function (dim, scale, coordExtent, axisType, position) {
		        Axis.call(this, dim, scale, coordExtent);
		        /**
		         * Axis type
		         *  - 'category'
		         *  - 'value'
		         *  - 'time'
		         *  - 'log'
		         * @type {string}
		         */
		        this.type = axisType || 'value';

		        /**
		         * Axis position
		         *  - 'top'
		         *  - 'bottom'
		         *  - 'left'
		         *  - 'right'
		         */
		        this.position = position || 'bottom';
		    };

		    Axis2D.prototype = {

		        constructor: Axis2D,

		        /**
		         * Index of axis, can be used as key
		         */
		        index: 0,
		        /**
		         * If axis is on the zero position of the other axis
		         * @type {boolean}
		         */
		        onZero: false,

		        /**
		         * Axis model
		         * @param {module:echarts/coord/cartesian/AxisModel}
		         */
		        model: null,

		        isHorizontal: function () {
		            var position = this.position;
		            return position === 'top' || position === 'bottom';
		        },

		        getGlobalExtent: function () {
		            var ret = this.getExtent();
		            ret[0] = this.toGlobalCoord(ret[0]);
		            ret[1] = this.toGlobalCoord(ret[1]);
		            return ret;
		        },

		        /**
		         * @return {number}
		         */
		        getLabelInterval: function () {
		            var labelInterval = this._labelInterval;
		            if (!labelInterval) {
		                labelInterval = this._labelInterval = axisLabelInterval(this);
		            }
		            return labelInterval;
		        },

		        /**
		         * If label is ignored.
		         * Automatically used when axis is category and label can not be all shown
		         * @param  {number}  idx
		         * @return {boolean}
		         */
		        isLabelIgnored: function (idx) {
		            if (this.type === 'category') {
		                var labelInterval = this.getLabelInterval();
		                return ((typeof labelInterval === 'function')
		                    && !labelInterval(idx, this.scale.getLabel(idx)))
		                    || idx % (labelInterval + 1);
		            }
		        },

		        /**
		         * Transform global coord to local coord,
		         * i.e. var localCoord = axis.toLocalCoord(80);
		         * designate by module:echarts/coord/cartesian/Grid.
		         * @type {Function}
		         */
		        toLocalCoord: null,

		        /**
		         * Transform global coord to local coord,
		         * i.e. var globalCoord = axis.toLocalCoord(40);
		         * designate by module:echarts/coord/cartesian/Grid.
		         * @type {Function}
		         */
		        toGlobalCoord: null

		    };
		    zrUtil.inherits(Axis2D, Axis);

		    module.exports = Axis2D;


	/***/ },
	/* 124 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var numberUtil = __webpack_require__(7);
		    var linearMap = numberUtil.linearMap;
		    var zrUtil = __webpack_require__(4);

		    function fixExtentWithBands(extent, nTick) {
		        var size = extent[1] - extent[0];
		        var len = nTick;
		        var margin = size / len / 2;
		        extent[0] += margin;
		        extent[1] -= margin;
		    }

		    var normalizedExtent = [0, 1];
		    /**
		     * @name module:echarts/coord/CartesianAxis
		     * @constructor
		     */
		    var Axis = function (dim, scale, extent) {

		        /**
		         * Axis dimension. Such as 'x', 'y', 'z', 'angle', 'radius'
		         * @type {string}
		         */
		        this.dim = dim;

		        /**
		         * Axis scale
		         * @type {module:echarts/coord/scale/*}
		         */
		        this.scale = scale;

		        /**
		         * @type {Array.<number>}
		         * @private
		         */
		        this._extent = extent || [0, 0];

		        /**
		         * @type {boolean}
		         */
		        this.inverse = false;

		        /**
		         * Usually true when axis has a ordinal scale
		         * @type {boolean}
		         */
		        this.onBand = false;
		    };

		    Axis.prototype = {

		        constructor: Axis,

		        /**
		         * If axis extent contain given coord
		         * @param {number} coord
		         * @return {boolean}
		         */
		        contain: function (coord) {
		            var extent = this._extent;
		            var min = Math.min(extent[0], extent[1]);
		            var max = Math.max(extent[0], extent[1]);
		            return coord >= min && coord <= max;
		        },

		        /**
		         * If axis extent contain given data
		         * @param {number} data
		         * @return {boolean}
		         */
		        containData: function (data) {
		            return this.contain(this.dataToCoord(data));
		        },

		        /**
		         * Get coord extent.
		         * @return {Array.<number>}
		         */
		        getExtent: function () {
		            var ret = this._extent.slice();
		            return ret;
		        },

		        /**
		         * Get precision used for formatting
		         * @param {Array.<number>} [dataExtent]
		         * @return {number}
		         */
		        getPixelPrecision: function (dataExtent) {
		            return numberUtil.getPixelPrecision(
		                dataExtent || this.scale.getExtent(),
		                this._extent
		            );
		        },

		        /**
		         * Set coord extent
		         * @param {number} start
		         * @param {number} end
		         */
		        setExtent: function (start, end) {
		            var extent = this._extent;
		            extent[0] = start;
		            extent[1] = end;
		        },

		        /**
		         * Convert data to coord. Data is the rank if it has a ordinal scale
		         * @param {number} data
		         * @param  {boolean} clamp
		         * @return {number}
		         */
		        dataToCoord: function (data, clamp) {
		            var extent = this._extent;
		            var scale = this.scale;
		            data = scale.normalize(data);

		            if (this.onBand && scale.type === 'ordinal') {
		                extent = extent.slice();
		                fixExtentWithBands(extent, scale.count());
		            }

		            return linearMap(data, normalizedExtent, extent, clamp);
		        },

		        /**
		         * Convert coord to data. Data is the rank if it has a ordinal scale
		         * @param {number} coord
		         * @param  {boolean} clamp
		         * @return {number}
		         */
		        coordToData: function (coord, clamp) {
		            var extent = this._extent;
		            var scale = this.scale;

		            if (this.onBand && scale.type === 'ordinal') {
		                extent = extent.slice();
		                fixExtentWithBands(extent, scale.count());
		            }

		            var t = linearMap(coord, extent, normalizedExtent, clamp);

		            return this.scale.scale(t);
		        },
		        /**
		         * @return {Array.<number>}
		         */
		        getTicksCoords: function (alignWithLabel) {
		            if (this.onBand && !alignWithLabel) {
		                var bands = this.getBands();
		                var coords = [];
		                for (var i = 0; i < bands.length; i++) {
		                    coords.push(bands[i][0]);
		                }
		                if (bands[i - 1]) {
		                    coords.push(bands[i - 1][1]);
		                }
		                return coords;
		            }
		            else {
		                return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
		            }
		        },

		        /**
		         * Coords of labels are on the ticks or on the middle of bands
		         * @return {Array.<number>}
		         */
		        getLabelsCoords: function () {
		            return zrUtil.map(this.scale.getTicks(), this.dataToCoord, this);
		        },

		        /**
		         * Get bands.
		         *
		         * If axis has labels [1, 2, 3, 4]. Bands on the axis are
		         * |---1---|---2---|---3---|---4---|.
		         *
		         * @return {Array}
		         */
		         // FIXME Situation when labels is on ticks
		        getBands: function () {
		            var extent = this.getExtent();
		            var bands = [];
		            var len = this.scale.count();
		            var start = extent[0];
		            var end = extent[1];
		            var span = end - start;

		            for (var i = 0; i < len; i++) {
		                bands.push([
		                    span * i / len + start,
		                    span * (i + 1) / len + start
		                ]);
		            }
		            return bands;
		        },

		        /**
		         * Get width of band
		         * @return {number}
		         */
		        getBandWidth: function () {
		            var axisExtent = this._extent;
		            var dataExtent = this.scale.getExtent();

		            var len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0);
		            // Fix #2728, avoid NaN when only one data.
		            len === 0 && (len = 1);

		            var size = Math.abs(axisExtent[1] - axisExtent[0]);

		            return Math.abs(size) / len;
		        }
		    };

		    module.exports = Axis;


	/***/ },
	/* 125 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * Helper function for axisLabelInterval calculation
		 */



		    var zrUtil = __webpack_require__(4);
		    var axisHelper = __webpack_require__(115);

		    module.exports = function (axis) {
		        var axisModel = axis.model;
		        var labelModel = axisModel.getModel('axisLabel');
		        var labelInterval = labelModel.get('interval');
		        if (!(axis.type === 'category' && labelInterval === 'auto')) {
		            return labelInterval === 'auto' ? 0 : labelInterval;
		        }

		        return axisHelper.getAxisLabelInterval(
		            zrUtil.map(axis.scale.getTicks(), axis.dataToCoord, axis),
		            axisModel.getFormattedLabels(),
		            labelModel.getModel('textStyle').getFont(),
		            axis.isHorizontal()
		        );
		    };


	/***/ },
	/* 126 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		// Grid 是在有直角坐标系的时候必须要存在的
		// 所以这里也要被 Cartesian2D 依赖


		    __webpack_require__(127);
		    var ComponentModel = __webpack_require__(19);

		    module.exports = ComponentModel.extend({

		        type: 'grid',

		        dependencies: ['xAxis', 'yAxis'],

		        layoutMode: 'box',

		        /**
		         * @type {module:echarts/coord/cartesian/Grid}
		         */
		        coordinateSystem: null,

		        defaultOption: {
		            show: false,
		            zlevel: 0,
		            z: 0,
		            left: '10%',
		            top: 60,
		            right: '10%',
		            bottom: 60,
		            // If grid size contain label
		            containLabel: false,
		            // width: {totalWidth} - left - right,
		            // height: {totalHeight} - top - bottom,
		            backgroundColor: 'rgba(0,0,0,0)',
		            borderWidth: 1,
		            borderColor: '#ccc'
		        }
		    });


	/***/ },
	/* 127 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var ComponentModel = __webpack_require__(19);
		    var zrUtil = __webpack_require__(4);
		    var axisModelCreator = __webpack_require__(128);

		    var AxisModel = ComponentModel.extend({

		        type: 'cartesian2dAxis',

		        /**
		         * @type {module:echarts/coord/cartesian/Axis2D}
		         */
		        axis: null,

		        /**
		         * @override
		         */
		        init: function () {
		            AxisModel.superApply(this, 'init', arguments);
		            this.resetRange();
		        },

		        /**
		         * @override
		         */
		        mergeOption: function () {
		            AxisModel.superApply(this, 'mergeOption', arguments);
		            this.resetRange();
		        },

		        /**
		         * @override
		         */
		        restoreData: function () {
		            AxisModel.superApply(this, 'restoreData', arguments);
		            this.resetRange();
		        },

		        /**
		         * @return {module:echarts/model/Model}
		         */
		        findGridModel: function () {
		            return this.ecModel.queryComponents({
		                mainType: 'grid',
		                index: this.get('gridIndex'),
		                id: this.get('gridId')
		            })[0];
		        }

		    });

		    function getAxisType(axisDim, option) {
		        // Default axis with data is category axis
		        return option.type || (option.data ? 'category' : 'value');
		    }

		    zrUtil.merge(AxisModel.prototype, __webpack_require__(130));
		    zrUtil.merge(AxisModel.prototype, __webpack_require__(131));

		    var extraOption = {
		        // gridIndex: 0,
		        // gridId: '',

		        // Offset is for multiple axis on the same position
		        offset: 0
		    };

		    axisModelCreator('x', AxisModel, getAxisType, extraOption);
		    axisModelCreator('y', AxisModel, getAxisType, extraOption);

		    module.exports = AxisModel;


	/***/ },
	/* 128 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var axisDefault = __webpack_require__(129);
		    var zrUtil = __webpack_require__(4);
		    var ComponentModel = __webpack_require__(19);
		    var layout = __webpack_require__(21);

		    // FIXME axisType is fixed ?
		    var AXIS_TYPES = ['value', 'category', 'time', 'log'];

		    /**
		     * Generate sub axis model class
		     * @param {string} axisName 'x' 'y' 'radius' 'angle' 'parallel'
		     * @param {module:echarts/model/Component} BaseAxisModelClass
		     * @param {Function} axisTypeDefaulter
		     * @param {Object} [extraDefaultOption]
		     */
		    module.exports = function (axisName, BaseAxisModelClass, axisTypeDefaulter, extraDefaultOption) {

		        zrUtil.each(AXIS_TYPES, function (axisType) {

		            BaseAxisModelClass.extend({

		                type: axisName + 'Axis.' + axisType,

		                mergeDefaultAndTheme: function (option, ecModel) {
		                    var layoutMode = this.layoutMode;
		                    var inputPositionParams = layoutMode
		                        ? layout.getLayoutParams(option) : {};

		                    var themeModel = ecModel.getTheme();
		                    zrUtil.merge(option, themeModel.get(axisType + 'Axis'));
		                    zrUtil.merge(option, this.getDefaultOption());

		                    option.type = axisTypeDefaulter(axisName, option);

		                    if (layoutMode) {
		                        layout.mergeLayoutParam(option, inputPositionParams, layoutMode);
		                    }
		                },

		                defaultOption: zrUtil.mergeAll(
		                    [
		                        {},
		                        axisDefault[axisType + 'Axis'],
		                        extraDefaultOption
		                    ],
		                    true
		                )
		            });
		        });

		        ComponentModel.registerSubTypeDefaulter(
		            axisName + 'Axis',
		            zrUtil.curry(axisTypeDefaulter, axisName)
		        );
		    };


	/***/ },
	/* 129 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    var defaultOption = {
		        show: true,
		        zlevel: 0,                  // 一级层叠
		        z: 0,                       // 二级层叠
		        // 反向坐标轴
		        inverse: false,

		        // 坐标轴名字，默认为空
		        name: '',
		        // 坐标轴名字位置，支持'start' | 'middle' | 'end'
		        nameLocation: 'end',
		        // 坐标轴名字旋转，degree。
		        nameRotate: null, // Adapt to axis rotate, when nameLocation is 'middle'.
		        nameTruncate: {
		            maxWidth: null,
		            ellipsis: '...',
		            placeholder: '.'
		        },
		        // 坐标轴文字样式，默认取全局样式
		        nameTextStyle: {},
		        // 文字与轴线距离
		        nameGap: 15,

		        silent: false, // Default false to support tooltip.
		        triggerEvent: false, // Default false to avoid legacy user event listener fail.

		        tooltip: {
		            show: false
		        },

		        // 坐标轴线
		        axisLine: {
		            // 默认显示，属性show控制显示与否
		            show: true,
		            onZero: true,
		            // 属性lineStyle控制线条样式
		            lineStyle: {
		                color: '#333',
		                width: 1,
		                type: 'solid'
		            }
		        },
		        // 坐标轴小标记
		        axisTick: {
		            // 属性show控制显示与否，默认显示
		            show: true,
		            // 控制小标记是否在grid里
		            inside: false,
		            // 属性length控制线长
		            length: 5,
		            // 属性lineStyle控制线条样式
		            lineStyle: {
		                width: 1
		            }
		        },
		        // 坐标轴文本标签，详见axis.axisLabel
		        axisLabel: {
		            show: true,
		            // 控制文本标签是否在grid里
		            inside: false,
		            rotate: 0,
		            margin: 8,
		            // formatter: null,
		            // 其余属性默认使用全局文本样式，详见TEXTSTYLE
		            textStyle: {
		                fontSize: 12
		            }
		        },
		        // 分隔线
		        splitLine: {
		            // 默认显示，属性show控制显示与否
		            show: true,
		            // 属性lineStyle（详见lineStyle）控制线条样式
		            lineStyle: {
		                color: ['#ccc'],
		                width: 1,
		                type: 'solid'
		            }
		        },
		        // 分隔区域
		        splitArea: {
		            // 默认不显示，属性show控制显示与否
		            show: false,
		            // 属性areaStyle（详见areaStyle）控制区域样式
		            areaStyle: {
		                color: ['rgba(250,250,250,0.3)','rgba(200,200,200,0.3)']
		            }
		        }
		    };

		    var categoryAxis = zrUtil.merge({
		        // 类目起始和结束两端空白策略
		        boundaryGap: true,
		        // splitArea: {
		            // show: false
		        // },
		        splitLine: {
		            show: false
		        },
		        // 坐标轴小标记
		        axisTick: {
		            // If tick is align with label when boundaryGap is true
		            // Default with axisTick
		            alignWithLabel: false,
		            interval: 'auto'
		        },
		        // 坐标轴文本标签，详见axis.axisLabel
		        axisLabel: {
		            interval: 'auto'
		        }
		    }, defaultOption);

		    var valueAxis = zrUtil.merge({
		        // 数值起始和结束两端空白策略
		        boundaryGap: [0, 0],
		        // 最小值, 设置成 'dataMin' 则从数据中计算最小值
		        // min: null,
		        // 最大值，设置成 'dataMax' 则从数据中计算最大值
		        // max: null,
		        // Readonly prop, specifies start value of the range when using data zoom.
		        // rangeStart: null
		        // Readonly prop, specifies end value of the range when using data zoom.
		        // rangeEnd: null
		        // 脱离0值比例，放大聚焦到最终_min，_max区间
		        // scale: false,
		        // 分割段数，默认为5
		        splitNumber: 5
		        // Minimum interval
		        // minInterval: null
		    }, defaultOption);

		    // FIXME
		    var timeAxis = zrUtil.defaults({
		        scale: true,
		        min: 'dataMin',
		        max: 'dataMax'
		    }, valueAxis);
		    var logAxis = zrUtil.defaults({
		        logBase: 10
		    }, valueAxis);
		    logAxis.scale = true;

		    module.exports = {
		        categoryAxis: categoryAxis,
		        valueAxis: valueAxis,
		        timeAxis: timeAxis,
		        logAxis: logAxis
		    };


	/***/ },
	/* 130 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var axisHelper = __webpack_require__(115);

		    function getName(obj) {
		        if (zrUtil.isObject(obj) && obj.value != null) {
		            return obj.value;
		        }
		        else {
		            return obj;
		        }
		    }
		    /**
		     * Get categories
		     */
		    function getCategories() {
		        return this.get('type') === 'category'
		            && zrUtil.map(this.get('data'), getName);
		    }

		    /**
		     * Format labels
		     * @return {Array.<string>}
		     */
		    function getFormattedLabels() {
		        return axisHelper.getFormattedLabels(
		            this.axis,
		            this.get('axisLabel.formatter')
		        );
		    }

		    module.exports = {

		        getFormattedLabels: getFormattedLabels,

		        getCategories: getCategories
		    };


	/***/ },
	/* 131 */
	/***/ function(module, exports) {

		

		    module.exports = {

		        /**
		         * @public
		         * @return {Array.<number|string|Date>}
		         */
		        getMin: function () {
		            var option = this.option;
		            var min = option.rangeStart != null ? option.rangeStart : option.min;
		            // In case of axis.type === 'time', Date should be converted to timestamp.
		            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.
		            if (min instanceof Date) {
		                min = +min;
		            }
		            return min;
		        },

		        /**
		         * @public
		         * @return {Array.<number|string|Date>}
		         */
		        getMax: function () {
		            var option = this.option;
		            var max = option.rangeEnd != null ? option.rangeEnd : option.max;
		            // In case of axis.type === 'time', Date should be converted to timestamp.
		            // In other cases, min/max should be a number or null/undefined or 'dataMin/Max'.
		            if (max instanceof Date) {
		                max = +max;
		            }
		            return max;
		        },

		        /**
		         * @public
		         * @return {boolean}
		         */
		        getNeedCrossZero: function () {
		            var option = this.option;
		            return (option.rangeStart != null || option.rangeEnd != null)
		                ? false : !option.scale;
		        },

		        /**
		         * @public
		         * @param {number} rangeStart
		         * @param {number} rangeEnd
		         */
		        setRange: function (rangeStart, rangeEnd) {
		            this.option.rangeStart = rangeStart;
		            this.option.rangeEnd = rangeEnd;
		        },

		        /**
		         * @public
		         */
		        resetRange: function () {
		            // rangeStart and rangeEnd is readonly.
		            this.option.rangeStart = this.option.rangeEnd = null;
		        }
		    };



	/***/ },
	/* 132 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		// TODO boundaryGap


		    __webpack_require__(127);

		    __webpack_require__(133);


	/***/ },
	/* 133 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var graphic = __webpack_require__(43);
		    var AxisBuilder = __webpack_require__(134);
		    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick;
		    var getInterval = AxisBuilder.getInterval;

		    var axisBuilderAttrs = [
		        'axisLine', 'axisLabel', 'axisTick', 'axisName'
		    ];
		    var selfBuilderAttrs = [
		        'splitArea', 'splitLine'
		    ];

		    // function getAlignWithLabel(model, axisModel) {
		    //     var alignWithLabel = model.get('alignWithLabel');
		    //     if (alignWithLabel === 'auto') {
		    //         alignWithLabel = axisModel.get('axisTick.alignWithLabel');
		    //     }
		    //     return alignWithLabel;
		    // }

		    var AxisView = __webpack_require__(1).extendComponentView({

		        type: 'axis',

		        render: function (axisModel, ecModel) {

		            this.group.removeAll();

		            var oldAxisGroup = this._axisGroup;
		            this._axisGroup = new graphic.Group();

		            this.group.add(this._axisGroup);

		            if (!axisModel.get('show')) {
		                return;
		            }

		            var gridModel = axisModel.findGridModel();

		            var layout = layoutAxis(gridModel, axisModel);

		            var axisBuilder = new AxisBuilder(axisModel, layout);

		            zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);

		            this._axisGroup.add(axisBuilder.getGroup());

		            zrUtil.each(selfBuilderAttrs, function (name) {
		                if (axisModel.get(name + '.show')) {
		                    this['_' + name](axisModel, gridModel, layout.labelInterval);
		                }
		            }, this);

		            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
		        },

		        /**
		         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
		         * @param {module:echarts/coord/cartesian/GridModel} gridModel
		         * @param {number|Function} labelInterval
		         * @private
		         */
		        _splitLine: function (axisModel, gridModel, labelInterval) {
		            var axis = axisModel.axis;

		            var splitLineModel = axisModel.getModel('splitLine');
		            var lineStyleModel = splitLineModel.getModel('lineStyle');
		            var lineColors = lineStyleModel.get('color');

		            var lineInterval = getInterval(splitLineModel, labelInterval);

		            lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];

		            var gridRect = gridModel.coordinateSystem.getRect();
		            var isHorizontal = axis.isHorizontal();

		            var lineCount = 0;

		            var ticksCoords = axis.getTicksCoords(
		                // splitLineModel.get('alignWithLabel')
		            );
		            var ticks = axis.scale.getTicks();

		            var p1 = [];
		            var p2 = [];
		            // Simple optimization
		            // Batching the lines if color are the same
		            var lineStyle = lineStyleModel.getLineStyle();
		            for (var i = 0; i < ticksCoords.length; i++) {
		                if (ifIgnoreOnTick(axis, i, lineInterval)) {
		                    continue;
		                }

		                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);

		                if (isHorizontal) {
		                    p1[0] = tickCoord;
		                    p1[1] = gridRect.y;
		                    p2[0] = tickCoord;
		                    p2[1] = gridRect.y + gridRect.height;
		                }
		                else {
		                    p1[0] = gridRect.x;
		                    p1[1] = tickCoord;
		                    p2[0] = gridRect.x + gridRect.width;
		                    p2[1] = tickCoord;
		                }

		                var colorIndex = (lineCount++) % lineColors.length;
		                this._axisGroup.add(new graphic.Line(graphic.subPixelOptimizeLine({
		                    anid: 'line_' + ticks[i],

		                    shape: {
		                        x1: p1[0],
		                        y1: p1[1],
		                        x2: p2[0],
		                        y2: p2[1]
		                    },
		                    style: zrUtil.defaults({
		                        stroke: lineColors[colorIndex]
		                    }, lineStyle),
		                    silent: true
		                })));
		            }
		        },

		        /**
		         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
		         * @param {module:echarts/coord/cartesian/GridModel} gridModel
		         * @param {number|Function} labelInterval
		         * @private
		         */
		        _splitArea: function (axisModel, gridModel, labelInterval) {
		            var axis = axisModel.axis;

		            var splitAreaModel = axisModel.getModel('splitArea');
		            var areaStyleModel = splitAreaModel.getModel('areaStyle');
		            var areaColors = areaStyleModel.get('color');

		            var gridRect = gridModel.coordinateSystem.getRect();

		            var ticksCoords = axis.getTicksCoords(
		                // splitAreaModel.get('alignWithLabel')
		            );
		            var ticks = axis.scale.getTicks();

		            var prevX = axis.toGlobalCoord(ticksCoords[0]);
		            var prevY = axis.toGlobalCoord(ticksCoords[0]);

		            var count = 0;

		            var areaInterval = getInterval(splitAreaModel, labelInterval);

		            var areaStyle = areaStyleModel.getAreaStyle();
		            areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];

		            for (var i = 1; i < ticksCoords.length; i++) {
		                if (ifIgnoreOnTick(axis, i, areaInterval)) {
		                    continue;
		                }

		                var tickCoord = axis.toGlobalCoord(ticksCoords[i]);

		                var x;
		                var y;
		                var width;
		                var height;
		                if (axis.isHorizontal()) {
		                    x = prevX;
		                    y = gridRect.y;
		                    width = tickCoord - x;
		                    height = gridRect.height;
		                }
		                else {
		                    x = gridRect.x;
		                    y = prevY;
		                    width = gridRect.width;
		                    height = tickCoord - y;
		                }

		                var colorIndex = (count++) % areaColors.length;
		                this._axisGroup.add(new graphic.Rect({
		                    anid: 'area_' + ticks[i],

		                    shape: {
		                        x: x,
		                        y: y,
		                        width: width,
		                        height: height
		                    },
		                    style: zrUtil.defaults({
		                        fill: areaColors[colorIndex]
		                    }, areaStyle),
		                    silent: true
		                }));

		                prevX = x + width;
		                prevY = y + height;
		            }
		        }
		    });

		    AxisView.extend({
		        type: 'xAxis'
		    });
		    AxisView.extend({
		        type: 'yAxis'
		    });

		    /**
		     * @inner
		     */
		    function layoutAxis(gridModel, axisModel) {
		        var grid = gridModel.coordinateSystem;
		        var axis = axisModel.axis;
		        var layout = {};

		        var rawAxisPosition = axis.position;
		        var axisPosition = axis.onZero ? 'onZero' : rawAxisPosition;
		        var axisDim = axis.dim;

		        // [left, right, top, bottom]
		        var rect = grid.getRect();
		        var rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height];

		        var axisOffset = axisModel.get('offset') || 0;

		        var posMap = {
		            x: { top: rectBound[2] - axisOffset, bottom: rectBound[3] + axisOffset },
		            y: { left: rectBound[0] - axisOffset, right: rectBound[1] + axisOffset }
		        };

		        posMap.x.onZero = Math.max(Math.min(getZero('y'), posMap.x.bottom), posMap.x.top);
		        posMap.y.onZero = Math.max(Math.min(getZero('x'), posMap.y.right), posMap.y.left);

		        function getZero(dim, val) {
		            var theAxis = grid.getAxis(dim);
		            return theAxis.toGlobalCoord(theAxis.dataToCoord(0));
		        }

		        // Axis position
		        layout.position = [
		            axisDim === 'y' ? posMap.y[axisPosition] : rectBound[0],
		            axisDim === 'x' ? posMap.x[axisPosition] : rectBound[3]
		        ];

		        // Axis rotation
		        layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1);

		        // Tick and label direction, x y is axisDim
		        var dirMap = {top: -1, bottom: 1, left: -1, right: 1};

		        layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition];
		        if (axis.onZero) {
		            layout.labelOffset = posMap[axisDim][rawAxisPosition] - posMap[axisDim].onZero;
		        }

		        if (axisModel.getModel('axisTick').get('inside')) {
		            layout.tickDirection = -layout.tickDirection;
		        }
		        if (axisModel.getModel('axisLabel').get('inside')) {
		            layout.labelDirection = -layout.labelDirection;
		        }

		        // Special label rotation
		        var labelRotation = axisModel.getModel('axisLabel').get('rotate');
		        layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation;

		        // label interval when auto mode.
		        layout.labelInterval = axis.getLabelInterval();

		        // Over splitLine and splitArea
		        layout.z2 = 1;

		        return layout;
		    }


	/***/ },
	/* 134 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var formatUtil = __webpack_require__(6);
		    var graphic = __webpack_require__(43);
		    var Model = __webpack_require__(12);
		    var numberUtil = __webpack_require__(7);
		    var remRadian = numberUtil.remRadian;
		    var isRadianAroundZero = numberUtil.isRadianAroundZero;
		    var vec2 = __webpack_require__(10);
		    var v2ApplyTransform = vec2.applyTransform;
		    var retrieve = zrUtil.retrieve;

		    var PI = Math.PI;

		    function makeAxisEventDataBase(axisModel) {
		        var eventData = {
		            componentType: axisModel.mainType
		        };
		        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;
		        return eventData;
		    }

		    /**
		     * A final axis is translated and rotated from a "standard axis".
		     * So opt.position and opt.rotation is required.
		     *
		     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
		     * for example: (0, 0) ------------> (0, 50)
		     *
		     * nameDirection or tickDirection or labelDirection is 1 means tick
		     * or label is below the standard axis, whereas is -1 means above
		     * the standard axis. labelOffset means offset between label and axis,
		     * which is useful when 'onZero', where axisLabel is in the grid and
		     * label in outside grid.
		     *
		     * Tips: like always,
		     * positive rotation represents anticlockwise, and negative rotation
		     * represents clockwise.
		     * The direction of position coordinate is the same as the direction
		     * of screen coordinate.
		     *
		     * Do not need to consider axis 'inverse', which is auto processed by
		     * axis extent.
		     *
		     * @param {module:zrender/container/Group} group
		     * @param {Object} axisModel
		     * @param {Object} opt Standard axis parameters.
		     * @param {Array.<number>} opt.position [x, y]
		     * @param {number} opt.rotation by radian
		     * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle'.
		     * @param {number} [opt.tickDirection=1] 1 or -1
		     * @param {number} [opt.labelDirection=1] 1 or -1
		     * @param {number} [opt.labelOffset=0] Usefull when onZero.
		     * @param {string} [opt.axisLabelShow] default get from axisModel.
		     * @param {string} [opt.axisName] default get from axisModel.
		     * @param {number} [opt.axisNameAvailableWidth]
		     * @param {number} [opt.labelRotation] by degree, default get from axisModel.
		     * @param {number} [opt.labelInterval] Default label interval when label
		     *                                     interval from model is null or 'auto'.
		     * @param {number} [opt.strokeContainThreshold] Default label interval when label
		     */
		    var AxisBuilder = function (axisModel, opt) {

		        /**
		         * @readOnly
		         */
		        this.opt = opt;

		        /**
		         * @readOnly
		         */
		        this.axisModel = axisModel;

		        // Default value
		        zrUtil.defaults(
		            opt,
		            {
		                labelOffset: 0,
		                nameDirection: 1,
		                tickDirection: 1,
		                labelDirection: 1,
		                silent: true
		            }
		        );

		        /**
		         * @readOnly
		         */
		        this.group = new graphic.Group();

		        // FIXME Not use a seperate text group?
		        var dumbGroup = new graphic.Group({
		            position: opt.position.slice(),
		            rotation: opt.rotation
		        });

		        // this.group.add(dumbGroup);
		        // this._dumbGroup = dumbGroup;

		        dumbGroup.updateTransform();
		        this._transform = dumbGroup.transform;

		        this._dumbGroup = dumbGroup;
		    };

		    AxisBuilder.prototype = {

		        constructor: AxisBuilder,

		        hasBuilder: function (name) {
		            return !!builders[name];
		        },

		        add: function (name) {
		            builders[name].call(this);
		        },

		        getGroup: function () {
		            return this.group;
		        }

		    };

		    var builders = {

		        /**
		         * @private
		         */
		        axisLine: function () {
		            var opt = this.opt;
		            var axisModel = this.axisModel;

		            if (!axisModel.get('axisLine.show')) {
		                return;
		            }

		            var extent = this.axisModel.axis.getExtent();

		            var matrix = this._transform;
		            var pt1 = [extent[0], 0];
		            var pt2 = [extent[1], 0];
		            if (matrix) {
		                v2ApplyTransform(pt1, pt1, matrix);
		                v2ApplyTransform(pt2, pt2, matrix);
		            }

		            this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({

		                // Id for animation
		                anid: 'line',

		                shape: {
		                    x1: pt1[0],
		                    y1: pt1[1],
		                    x2: pt2[0],
		                    y2: pt2[1]
		                },
		                style: zrUtil.extend(
		                    {lineCap: 'round'},
		                    axisModel.getModel('axisLine.lineStyle').getLineStyle()
		                ),
		                strokeContainThreshold: opt.strokeContainThreshold || 5,
		                silent: true,
		                z2: 1
		            })));
		        },

		        /**
		         * @private
		         */
		        axisTick: function () {
		            var axisModel = this.axisModel;

		            if (!axisModel.get('axisTick.show')) {
		                return;
		            }

		            var axis = axisModel.axis;
		            var tickModel = axisModel.getModel('axisTick');
		            var opt = this.opt;

		            var lineStyleModel = tickModel.getModel('lineStyle');
		            var tickLen = tickModel.get('length');

		            var tickInterval = getInterval(tickModel, opt.labelInterval);
		            var ticksCoords = axis.getTicksCoords(tickModel.get('alignWithLabel'));
		            var ticks = axis.scale.getTicks();

		            var pt1 = [];
		            var pt2 = [];
		            var matrix = this._transform;

		            for (var i = 0; i < ticksCoords.length; i++) {
		                // Only ordinal scale support tick interval
		                if (ifIgnoreOnTick(axis, i, tickInterval)) {
		                     continue;
		                }

		                var tickCoord = ticksCoords[i];

		                pt1[0] = tickCoord;
		                pt1[1] = 0;
		                pt2[0] = tickCoord;
		                pt2[1] = opt.tickDirection * tickLen;

		                if (matrix) {
		                    v2ApplyTransform(pt1, pt1, matrix);
		                    v2ApplyTransform(pt2, pt2, matrix);
		                }
		                // Tick line, Not use group transform to have better line draw
		                this.group.add(new graphic.Line(graphic.subPixelOptimizeLine({

		                    // Id for animation
		                    anid: 'tick_' + ticks[i],

		                    shape: {
		                        x1: pt1[0],
		                        y1: pt1[1],
		                        x2: pt2[0],
		                        y2: pt2[1]
		                    },
		                    style: zrUtil.defaults(
		                        lineStyleModel.getLineStyle(),
		                        {
		                            stroke: axisModel.get('axisLine.lineStyle.color')
		                        }
		                    ),
		                    z2: 2,
		                    silent: true
		                })));
		            }
		        },

		        /**
		         * @param {module:echarts/coord/cartesian/AxisModel} axisModel
		         * @param {module:echarts/coord/cartesian/GridModel} gridModel
		         * @private
		         */
		        axisLabel: function () {
		            var opt = this.opt;
		            var axisModel = this.axisModel;
		            var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));

		            if (!show) {
		                return;
		            }

		            var axis = axisModel.axis;
		            var labelModel = axisModel.getModel('axisLabel');
		            var textStyleModel = labelModel.getModel('textStyle');
		            var labelMargin = labelModel.get('margin');
		            var ticks = axis.scale.getTicks();
		            var labels = axisModel.getFormattedLabels();

		            // Special label rotate.
		            var labelRotation = retrieve(opt.labelRotation, labelModel.get('rotate')) || 0;
		            // To radian.
		            labelRotation = labelRotation * PI / 180;

		            var labelLayout = innerTextLayout(opt, labelRotation, opt.labelDirection);
		            var categoryData = axisModel.get('data');

		            var textEls = [];
		            var silent = isSilent(axisModel);
		            var triggerEvent = axisModel.get('triggerEvent');

		            zrUtil.each(ticks, function (tickVal, index) {
		                if (ifIgnoreOnTick(axis, index, opt.labelInterval)) {
		                     return;
		                }

		                var itemTextStyleModel = textStyleModel;
		                if (categoryData && categoryData[tickVal] && categoryData[tickVal].textStyle) {
		                    itemTextStyleModel = new Model(
		                        categoryData[tickVal].textStyle, textStyleModel, axisModel.ecModel
		                    );
		                }
		                var textColor = itemTextStyleModel.getTextColor()
		                    || axisModel.get('axisLine.lineStyle.color');

		                var tickCoord = axis.dataToCoord(tickVal);
		                var pos = [
		                    tickCoord,
		                    opt.labelOffset + opt.labelDirection * labelMargin
		                ];
		                var labelBeforeFormat = axis.scale.getLabel(tickVal);

		                var textEl = new graphic.Text({

		                    // Id for animation
		                    anid: 'label_' + tickVal,

		                    style: {
		                        text: labels[index],
		                        textAlign: itemTextStyleModel.get('align', true) || labelLayout.textAlign,
		                        textVerticalAlign: itemTextStyleModel.get('baseline', true) || labelLayout.verticalAlign,
		                        textFont: itemTextStyleModel.getFont(),
		                        fill: typeof textColor === 'function' ? textColor(labelBeforeFormat) : textColor
		                    },
		                    position: pos,
		                    rotation: labelLayout.rotation,
		                    silent: silent,
		                    z2: 10
		                });

		                // Pack data for mouse event
		                if (triggerEvent) {
		                    textEl.eventData = makeAxisEventDataBase(axisModel);
		                    textEl.eventData.targetType = 'axisLabel';
		                    textEl.eventData.value = labelBeforeFormat;
		                }

		                // FIXME
		                this._dumbGroup.add(textEl);
		                textEl.updateTransform();

		                textEls.push(textEl);
		                this.group.add(textEl);

		                textEl.decomposeTransform();

		            }, this);

		            function isTwoLabelOverlapped(current, next) {
		                var firstRect = current && current.getBoundingRect().clone();
		                var nextRect = next && next.getBoundingRect().clone();
		                if (firstRect && nextRect) {
		                    firstRect.applyTransform(current.getLocalTransform());
		                    nextRect.applyTransform(next.getLocalTransform());
		                    return firstRect.intersect(nextRect);
		                }
		            }
		            if (axis.type !== 'category') {
		                // If min or max are user set, we need to check
		                // If the tick on min(max) are overlap on their neighbour tick
		                // If they are overlapped, we need to hide the min(max) tick label
		                if (axisModel.getMin ? axisModel.getMin() : axisModel.get('min')) {
		                    var firstLabel = textEls[0];
		                    var nextLabel = textEls[1];
		                    if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
		                        firstLabel.ignore = true;
		                    }
		                }
		                if (axisModel.getMax ? axisModel.getMax() : axisModel.get('max')) {
		                    var lastLabel = textEls[textEls.length - 1];
		                    var prevLabel = textEls[textEls.length - 2];
		                    if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
		                        lastLabel.ignore = true;
		                    }
		                }
		            }
		        },

		        /**
		         * @private
		         */
		        axisName: function () {
		            var opt = this.opt;
		            var axisModel = this.axisModel;
		            var name = retrieve(opt.axisName, axisModel.get('name'));

		            if (!name) {
		                return;
		            }

		            var nameLocation = axisModel.get('nameLocation');
		            var nameDirection = opt.nameDirection;
		            var textStyleModel = axisModel.getModel('nameTextStyle');
		            var gap = axisModel.get('nameGap') || 0;

		            var extent = this.axisModel.axis.getExtent();
		            var gapSignal = extent[0] > extent[1] ? -1 : 1;
		            var pos = [
		                nameLocation === 'start'
		                    ? extent[0] - gapSignal * gap
		                    : nameLocation === 'end'
		                    ? extent[1] + gapSignal * gap
		                    : (extent[0] + extent[1]) / 2, // 'middle'
		                // Reuse labelOffset.
		                nameLocation === 'middle' ? opt.labelOffset + nameDirection * gap : 0
		            ];

		            var labelLayout;

		            var nameRotation = axisModel.get('nameRotate');
		            if (nameRotation != null) {
		                nameRotation = nameRotation * PI / 180; // To radian.
		            }

		            var axisNameAvailableWidth;

		            if (nameLocation === 'middle') {
		                labelLayout = innerTextLayout(
		                    opt,
		                    nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
		                    nameDirection
		                );
		            }
		            else {
		                labelLayout = endTextLayout(
		                    opt, nameLocation, nameRotation || 0, extent
		                );

		                axisNameAvailableWidth = opt.axisNameAvailableWidth;
		                if (axisNameAvailableWidth != null) {
		                    axisNameAvailableWidth = Math.abs(
		                        axisNameAvailableWidth / Math.sin(labelLayout.rotation)
		                    );
		                    !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);
		                }
		            }

		            var textFont = textStyleModel.getFont();

		            var truncateOpt = axisModel.get('nameTruncate', true) || {};
		            var ellipsis = truncateOpt.ellipsis;
		            var maxWidth = retrieve(truncateOpt.maxWidth, axisNameAvailableWidth);
		            var truncatedText = (ellipsis != null && maxWidth != null)
		                ? formatUtil.truncateText(
		                    name, maxWidth, textFont, ellipsis,
		                    {minChar: 2, placeholder: truncateOpt.placeholder}
		                )
		                : name;

		            var tooltipOpt = axisModel.get('tooltip', true);

		            var mainType = axisModel.mainType;
		            var formatterParams = {
		                componentType: mainType,
		                name: name,
		                $vars: ['name']
		            };
		            formatterParams[mainType + 'Index'] = axisModel.componentIndex;

		            var textEl = new graphic.Text({

		                // Id for animation
		                anid: 'name',

		                __fullText: name,
		                __truncatedText: truncatedText,

		                style: {
		                    text: truncatedText,
		                    textFont: textFont,
		                    fill: textStyleModel.getTextColor()
		                        || axisModel.get('axisLine.lineStyle.color'),
		                    textAlign: labelLayout.textAlign,
		                    textVerticalAlign: labelLayout.verticalAlign
		                },
		                position: pos,
		                rotation: labelLayout.rotation,
		                silent: isSilent(axisModel),
		                z2: 1,
		                tooltip: (tooltipOpt && tooltipOpt.show)
		                    ? zrUtil.extend({
		                        content: name,
		                        formatter: function () {
		                            return name;
		                        },
		                        formatterParams: formatterParams
		                    }, tooltipOpt)
		                    : null
		            });

		            if (axisModel.get('triggerEvent')) {
		                textEl.eventData = makeAxisEventDataBase(axisModel);
		                textEl.eventData.targetType = 'axisName';
		                textEl.eventData.name = name;
		            }

		            // FIXME
		            this._dumbGroup.add(textEl);
		            textEl.updateTransform();

		            this.group.add(textEl);

		            textEl.decomposeTransform();
		        }

		    };

		    /**
		     * @inner
		     */
		    function innerTextLayout(opt, textRotation, direction) {
		        var rotationDiff = remRadian(textRotation - opt.rotation);
		        var textAlign;
		        var verticalAlign;

		        if (isRadianAroundZero(rotationDiff)) { // Label is parallel with axis line.
		            verticalAlign = direction > 0 ? 'top' : 'bottom';
		            textAlign = 'center';
		        }
		        else if (isRadianAroundZero(rotationDiff - PI)) { // Label is inverse parallel with axis line.
		            verticalAlign = direction > 0 ? 'bottom' : 'top';
		            textAlign = 'center';
		        }
		        else {
		            verticalAlign = 'middle';

		            if (rotationDiff > 0 && rotationDiff < PI) {
		                textAlign = direction > 0 ? 'right' : 'left';
		            }
		            else {
		                textAlign = direction > 0 ? 'left' : 'right';
		            }
		        }

		        return {
		            rotation: rotationDiff,
		            textAlign: textAlign,
		            verticalAlign: verticalAlign
		        };
		    }

		    /**
		     * @inner
		     */
		    function endTextLayout(opt, textPosition, textRotate, extent) {
		        var rotationDiff = remRadian(textRotate - opt.rotation);
		        var textAlign;
		        var verticalAlign;
		        var inverse = extent[0] > extent[1];
		        var onLeft = (textPosition === 'start' && !inverse)
		            || (textPosition !== 'start' && inverse);

		        if (isRadianAroundZero(rotationDiff - PI / 2)) {
		            verticalAlign = onLeft ? 'bottom' : 'top';
		            textAlign = 'center';
		        }
		        else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {
		            verticalAlign = onLeft ? 'top' : 'bottom';
		            textAlign = 'center';
		        }
		        else {
		            verticalAlign = 'middle';
		            if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {
		                textAlign = onLeft ? 'left' : 'right';
		            }
		            else {
		                textAlign = onLeft ? 'right' : 'left';
		            }
		        }

		        return {
		            rotation: rotationDiff,
		            textAlign: textAlign,
		            verticalAlign: verticalAlign
		        };
		    }

		    /**
		     * @inner
		     */
		    function isSilent(axisModel) {
		        var tooltipOpt = axisModel.get('tooltip');
		        return axisModel.get('silent')
		            // Consider mouse cursor, add these restrictions.
		            || !(
		                axisModel.get('triggerEvent') || (tooltipOpt && tooltipOpt.show)
		            );
		    }

		    /**
		     * @static
		     */
		    var ifIgnoreOnTick = AxisBuilder.ifIgnoreOnTick = function (axis, i, interval) {
		        var rawTick;
		        var scale = axis.scale;
		        return scale.type === 'ordinal'
		            && (
		                typeof interval === 'function'
		                    ? (
		                        rawTick = scale.getTicks()[i],
		                        !interval(rawTick, scale.getLabel(rawTick))
		                    )
		                    : i % (interval + 1)
		            );
		    };

		    /**
		     * @static
		     */
		    var getInterval = AxisBuilder.getInterval = function (model, labelInterval) {
		        var interval = model.get('interval');
		        if (interval == null || interval == 'auto') {
		            interval = labelInterval;
		        }
		        return interval;
		    };

		    module.exports = AxisBuilder;



	/***/ },
	/* 135 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    __webpack_require__(114);

		    __webpack_require__(136);
		    __webpack_require__(137);

		    var barLayoutGrid = __webpack_require__(139);
		    var echarts = __webpack_require__(1);

		    echarts.registerLayout(zrUtil.curry(barLayoutGrid, 'bar'));
		    // Visual coding for legend
		    echarts.registerVisual(function (ecModel) {
		        ecModel.eachSeriesByType('bar', function (seriesModel) {
		            var data = seriesModel.getData();
		            data.setVisual('legendSymbol', 'roundRect');
		        });
		    });

		    // In case developer forget to include grid component
		    __webpack_require__(113);


	/***/ },
	/* 136 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var SeriesModel = __webpack_require__(28);
		    var createListFromArray = __webpack_require__(102);

		    module.exports = SeriesModel.extend({

		        type: 'series.bar',

		        dependencies: ['grid', 'polar'],

		        getInitialData: function (option, ecModel) {
		            if (true) {
		                var coordSys = option.coordinateSystem;
		                if (coordSys !== 'cartesian2d') {
		                    throw new Error('Bar only support cartesian2d coordinateSystem');
		                }
		            }
		            return createListFromArray(option.data, this, ecModel);
		        },

		        getMarkerPosition: function (value) {
		            var coordSys = this.coordinateSystem;
		            if (coordSys) {
		                // PENDING if clamp ?
		                var pt = coordSys.dataToPoint(value, true);
		                var data = this.getData();
		                var offset = data.getLayout('offset');
		                var size = data.getLayout('size');
		                var offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1;
		                pt[offsetIndex] += offset + size / 2;
		                return pt;
		            }
		            return [NaN, NaN];
		        },

		        brushSelector: 'rect',

		        defaultOption: {
		            zlevel: 0,                  // 一级层叠
		            z: 2,                       // 二级层叠
		            coordinateSystem: 'cartesian2d',
		            legendHoverLink: true,
		            // stack: null

		            // Cartesian coordinate system
		            // xAxisIndex: 0,
		            // yAxisIndex: 0,

		            // 最小高度改为0
		            barMinHeight: 0,

		            // barMaxWidth: null,
		            // 默认自适应
		            // barWidth: null,
		            // 柱间距离，默认为柱形宽度的30%，可设固定值
		            // barGap: '30%',
		            // 类目间柱形距离，默认为类目间距的20%，可设固定值
		            // barCategoryGap: '20%',
		            // label: {
		            //     normal: {
		            //         show: false
		            //     }
		            // },
		            itemStyle: {
		                normal: {
		                    // color: '各异'
		                },
		                emphasis: {}
		            }
		        }
		    });


	/***/ },
	/* 137 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);
		    var graphic = __webpack_require__(43);

		    zrUtil.extend(__webpack_require__(12).prototype, __webpack_require__(138));

		    function fixLayoutWithLineWidth(layout, lineWidth) {
		        var signX = layout.width > 0 ? 1 : -1;
		        var signY = layout.height > 0 ? 1 : -1;
		        // In case width or height are too small.
		        lineWidth = Math.min(lineWidth, Math.abs(layout.width), Math.abs(layout.height));
		        layout.x += signX * lineWidth / 2;
		        layout.y += signY * lineWidth / 2;
		        layout.width -= signX * lineWidth;
		        layout.height -= signY * lineWidth;
		    }

		    module.exports = __webpack_require__(1).extendChartView({

		        type: 'bar',

		        render: function (seriesModel, ecModel, api) {
		            var coordinateSystemType = seriesModel.get('coordinateSystem');

		            if (coordinateSystemType === 'cartesian2d') {
		                this._renderOnCartesian(seriesModel, ecModel, api);
		            }

		            return this.group;
		        },

		        dispose: zrUtil.noop,

		        _renderOnCartesian: function (seriesModel, ecModel, api) {
		            var group = this.group;
		            var data = seriesModel.getData();
		            var oldData = this._data;

		            var cartesian = seriesModel.coordinateSystem;
		            var baseAxis = cartesian.getBaseAxis();
		            var isHorizontal = baseAxis.isHorizontal();

		            var enableAnimation = seriesModel.get('animation');

		            var barBorderWidthQuery = ['itemStyle', 'normal', 'barBorderWidth'];

		            function createRect(dataIndex, isUpdate) {
		                var layout = data.getItemLayout(dataIndex);
		                var lineWidth = data.getItemModel(dataIndex).get(barBorderWidthQuery) || 0;
		                fixLayoutWithLineWidth(layout, lineWidth);

		                var rect = new graphic.Rect({
		                    shape: zrUtil.extend({}, layout)
		                });
		                // Animation
		                if (enableAnimation) {
		                    var rectShape = rect.shape;
		                    var animateProperty = isHorizontal ? 'height' : 'width';
		                    var animateTarget = {};
		                    rectShape[animateProperty] = 0;
		                    animateTarget[animateProperty] = layout[animateProperty];
		                    graphic[isUpdate? 'updateProps' : 'initProps'](rect, {
		                        shape: animateTarget
		                    }, seriesModel, dataIndex);
		                }
		                return rect;
		            }
		            data.diff(oldData)
		                .add(function (dataIndex) {
		                    // 空数据
		                    if (!data.hasValue(dataIndex)) {
		                        return;
		                    }

		                    var rect = createRect(dataIndex);

		                    data.setItemGraphicEl(dataIndex, rect);

		                    group.add(rect);

		                })
		                .update(function (newIndex, oldIndex) {
		                    var rect = oldData.getItemGraphicEl(oldIndex);
		                    // 空数据
		                    if (!data.hasValue(newIndex)) {
		                        group.remove(rect);
		                        return;
		                    }
		                    if (!rect) {
		                        rect = createRect(newIndex, true);
		                    }

		                    var layout = data.getItemLayout(newIndex);
		                    var lineWidth = data.getItemModel(newIndex).get(barBorderWidthQuery) || 0;
		                    fixLayoutWithLineWidth(layout, lineWidth);

		                    graphic.updateProps(rect, {
		                        shape: layout
		                    }, seriesModel, newIndex);

		                    data.setItemGraphicEl(newIndex, rect);

		                    // Add back
		                    group.add(rect);
		                })
		                .remove(function (idx) {
		                    var rect = oldData.getItemGraphicEl(idx);
		                    if (rect) {
		                        // Not show text when animating
		                        rect.style.text = '';
		                        graphic.updateProps(rect, {
		                            shape: {
		                                width: 0
		                            }
		                        }, seriesModel, idx, function () {
		                            group.remove(rect);
		                        });
		                    }
		                })
		                .execute();

		            this._updateStyle(seriesModel, data, isHorizontal);

		            this._data = data;
		        },

		        _updateStyle: function (seriesModel, data, isHorizontal) {
		            function setLabel(style, model, color, labelText, labelPositionOutside) {
		                graphic.setText(style, model, color);
		                style.text = labelText;
		                if (style.textPosition === 'outside') {
		                    style.textPosition = labelPositionOutside;
		                }
		            }

		            data.eachItemGraphicEl(function (rect, idx) {
		                var itemModel = data.getItemModel(idx);
		                var color = data.getItemVisual(idx, 'color');
		                var opacity = data.getItemVisual(idx, 'opacity');
		                var layout = data.getItemLayout(idx);
		                var itemStyleModel = itemModel.getModel('itemStyle.normal');

		                var hoverStyle = itemModel.getModel('itemStyle.emphasis').getBarItemStyle();

		                rect.setShape('r', itemStyleModel.get('barBorderRadius') || 0);

		                rect.useStyle(zrUtil.defaults(
		                    {
		                        fill: color,
		                        opacity: opacity
		                    },
		                    itemStyleModel.getBarItemStyle()
		                ));

		                var labelPositionOutside = isHorizontal
		                    ? (layout.height > 0 ? 'bottom' : 'top')
		                    : (layout.width > 0 ? 'left' : 'right');

		                var labelModel = itemModel.getModel('label.normal');
		                var hoverLabelModel = itemModel.getModel('label.emphasis');
		                var rectStyle = rect.style;
		                if (labelModel.get('show')) {
		                    setLabel(
		                        rectStyle, labelModel, color,
		                        zrUtil.retrieve(
		                            seriesModel.getFormattedLabel(idx, 'normal'),
		                            seriesModel.getRawValue(idx)
		                        ),
		                        labelPositionOutside
		                    );
		                }
		                else {
		                    rectStyle.text = '';
		                }
		                if (hoverLabelModel.get('show')) {
		                    setLabel(
		                        hoverStyle, hoverLabelModel, color,
		                        zrUtil.retrieve(
		                            seriesModel.getFormattedLabel(idx, 'emphasis'),
		                            seriesModel.getRawValue(idx)
		                        ),
		                        labelPositionOutside
		                    );
		                }
		                else {
		                    hoverStyle.text = '';
		                }
		                graphic.setHoverStyle(rect, hoverStyle);
		            });
		        },

		        remove: function (ecModel, api) {
		            var group = this.group;
		            if (ecModel.get('animation')) {
		                if (this._data) {
		                    this._data.eachItemGraphicEl(function (el) {
		                        // Not show text when animating
		                        el.style.text = '';
		                        graphic.updateProps(el, {
		                            shape: {
		                                width: 0
		                            }
		                        }, ecModel, el.dataIndex, function () {
		                            group.remove(el);
		                        });
		                    });
		                }
		            }
		            else {
		                group.removeAll();
		            }
		        }
		    });


	/***/ },
	/* 138 */
	/***/ function(module, exports, __webpack_require__) {

		


		    var getBarItemStyle = __webpack_require__(15)(
		        [
		            ['fill', 'color'],
		            ['stroke', 'borderColor'],
		            ['lineWidth', 'borderWidth'],
		            // Compatitable with 2
		            ['stroke', 'barBorderColor'],
		            ['lineWidth', 'barBorderWidth'],
		            ['opacity'],
		            ['shadowBlur'],
		            ['shadowOffsetX'],
		            ['shadowOffsetY'],
		            ['shadowColor']
		        ]
		    );
		    module.exports = {
		        getBarItemStyle: function (excludes) {
		            var style = getBarItemStyle.call(this, excludes);
		            if (this.getBorderLineDash) {
		                var lineDash = this.getBorderLineDash();
		                lineDash && (style.lineDash = lineDash);
		            }
		            return style;
		        }
		    };


	/***/ },
	/* 139 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);
		    var numberUtil = __webpack_require__(7);
		    var parsePercent = numberUtil.parsePercent;

		    function getSeriesStackId(seriesModel) {
		        return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex;
		    }

		    function getAxisKey(axis) {
		        return axis.dim + axis.index;
		    }

		    function calBarWidthAndOffset(barSeries, api) {
		        // Columns info on each category axis. Key is cartesian name
		        var columnsMap = {};

		        zrUtil.each(barSeries, function (seriesModel, idx) {
		            var data = seriesModel.getData();
		            var cartesian = seriesModel.coordinateSystem;

		            var baseAxis = cartesian.getBaseAxis();
		            var axisExtent = baseAxis.getExtent();
		            var bandWidth = baseAxis.type === 'category'
		                ? baseAxis.getBandWidth()
		                : (Math.abs(axisExtent[1] - axisExtent[0]) / data.count());

		            var columnsOnAxis = columnsMap[getAxisKey(baseAxis)] || {
		                bandWidth: bandWidth,
		                remainedWidth: bandWidth,
		                autoWidthCount: 0,
		                categoryGap: '20%',
		                gap: '30%',
		                stacks: {}
		            };
		            var stacks = columnsOnAxis.stacks;
		            columnsMap[getAxisKey(baseAxis)] = columnsOnAxis;

		            var stackId = getSeriesStackId(seriesModel);

		            if (!stacks[stackId]) {
		                columnsOnAxis.autoWidthCount++;
		            }
		            stacks[stackId] = stacks[stackId] || {
		                width: 0,
		                maxWidth: 0
		            };

		            var barWidth = parsePercent(
		                seriesModel.get('barWidth'), bandWidth
		            );
		            var barMaxWidth = parsePercent(
		                seriesModel.get('barMaxWidth'), bandWidth
		            );
		            var barGap = seriesModel.get('barGap');
		            var barCategoryGap = seriesModel.get('barCategoryGap');
		            // TODO
		            if (barWidth && !stacks[stackId].width) {
		                barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth);
		                stacks[stackId].width = barWidth;
		                columnsOnAxis.remainedWidth -= barWidth;
		            }

		            barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth);
		            (barGap != null) && (columnsOnAxis.gap = barGap);
		            (barCategoryGap != null) && (columnsOnAxis.categoryGap = barCategoryGap);
		        });

		        var result = {};

		        zrUtil.each(columnsMap, function (columnsOnAxis, coordSysName) {

		            result[coordSysName] = {};

		            var stacks = columnsOnAxis.stacks;
		            var bandWidth = columnsOnAxis.bandWidth;
		            var categoryGap = parsePercent(columnsOnAxis.categoryGap, bandWidth);
		            var barGapPercent = parsePercent(columnsOnAxis.gap, 1);

		            var remainedWidth = columnsOnAxis.remainedWidth;
		            var autoWidthCount = columnsOnAxis.autoWidthCount;
		            var autoWidth = (remainedWidth - categoryGap)
		                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
		            autoWidth = Math.max(autoWidth, 0);

		            // Find if any auto calculated bar exceeded maxBarWidth
		            zrUtil.each(stacks, function (column, stack) {
		                var maxWidth = column.maxWidth;
		                if (!column.width && maxWidth && maxWidth < autoWidth) {
		                    maxWidth = Math.min(maxWidth, remainedWidth);
		                    remainedWidth -= maxWidth;
		                    column.width = maxWidth;
		                    autoWidthCount--;
		                }
		            });

		            // Recalculate width again
		            autoWidth = (remainedWidth - categoryGap)
		                / (autoWidthCount + (autoWidthCount - 1) * barGapPercent);
		            autoWidth = Math.max(autoWidth, 0);

		            var widthSum = 0;
		            var lastColumn;
		            zrUtil.each(stacks, function (column, idx) {
		                if (!column.width) {
		                    column.width = autoWidth;
		                }
		                lastColumn = column;
		                widthSum += column.width * (1 + barGapPercent);
		            });
		            if (lastColumn) {
		                widthSum -= lastColumn.width * barGapPercent;
		            }

		            var offset = -widthSum / 2;
		            zrUtil.each(stacks, function (column, stackId) {
		                result[coordSysName][stackId] = result[coordSysName][stackId] || {
		                    offset: offset,
		                    width: column.width
		                };

		                offset += column.width * (1 + barGapPercent);
		            });
		        });

		        return result;
		    }

		    /**
		     * @param {string} seriesType
		     * @param {module:echarts/model/Global} ecModel
		     * @param {module:echarts/ExtensionAPI} api
		     */
		    function barLayoutGrid(seriesType, ecModel, api) {

		        var barWidthAndOffset = calBarWidthAndOffset(
		            zrUtil.filter(
		                ecModel.getSeriesByType(seriesType),
		                function (seriesModel) {
		                    return !ecModel.isSeriesFiltered(seriesModel)
		                        && seriesModel.coordinateSystem
		                        && seriesModel.coordinateSystem.type === 'cartesian2d';
		                }
		            )
		        );

		        var lastStackCoords = {};
		        var lastStackCoordsOrigin = {};

		        ecModel.eachSeriesByType(seriesType, function (seriesModel) {

		            var data = seriesModel.getData();
		            var cartesian = seriesModel.coordinateSystem;
		            var baseAxis = cartesian.getBaseAxis();

		            var stackId = getSeriesStackId(seriesModel);
		            var columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId];
		            var columnOffset = columnLayoutInfo.offset;
		            var columnWidth = columnLayoutInfo.width;
		            var valueAxis = cartesian.getOtherAxis(baseAxis);

		            var barMinHeight = seriesModel.get('barMinHeight') || 0;

		            var valueAxisStart = baseAxis.onZero
		                ? valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))
		                : valueAxis.getGlobalExtent()[0];

		            var coords = cartesian.dataToPoints(data, true);
		            lastStackCoords[stackId] = lastStackCoords[stackId] || [];
		            lastStackCoordsOrigin[stackId] = lastStackCoordsOrigin[stackId] || []; // Fix #4243

		            data.setLayout({
		                offset: columnOffset,
		                size: columnWidth
		            });

		            data.each(valueAxis.dim, function (value, idx) {
		                // 空数据
		                if (isNaN(value)) {
		                    return;
		                }
		                if (!lastStackCoords[stackId][idx]) {
		                    lastStackCoords[stackId][idx] = {
		                        p: valueAxisStart, // Positive stack
		                        n: valueAxisStart  // Negative stack
		                    };
		                    lastStackCoordsOrigin[stackId][idx] = {
		                        p: valueAxisStart, // Positive stack
		                        n: valueAxisStart  // Negative stack
		                    };
		                }
		                var sign = value >= 0 ? 'p' : 'n';
		                var coord = coords[idx];
		                var lastCoord = lastStackCoords[stackId][idx][sign];
		                var lastCoordOrigin = lastStackCoordsOrigin[stackId][idx][sign];
		                var x;
		                var y;
		                var width;
		                var height;

		                if (valueAxis.isHorizontal()) {
		                    x = lastCoord;
		                    y = coord[1] + columnOffset;
		                    width = coord[0] - lastCoordOrigin;
		                    height = columnWidth;

		                    lastStackCoordsOrigin[stackId][idx][sign] += width;
		                    if (Math.abs(width) < barMinHeight) {
		                        width = (width < 0 ? -1 : 1) * barMinHeight;
		                    }
		                    lastStackCoords[stackId][idx][sign] += width;
		                }
		                else {
		                    x = coord[0] + columnOffset;
		                    y = lastCoord;
		                    width = columnWidth;
		                    height = coord[1] - lastCoordOrigin;

		                    lastStackCoordsOrigin[stackId][idx][sign] += height;
		                    if (Math.abs(height) < barMinHeight) {
		                        // Include zero to has a positive bar
		                        height = (height <= 0 ? -1 : 1) * barMinHeight;
		                    }
		                    lastStackCoords[stackId][idx][sign] += height;
		                }

		                data.setItemLayout(idx, {
		                    x: x,
		                    y: y,
		                    width: width,
		                    height: height
		                });
		            }, true);

		        }, this);
		    }

		    module.exports = barLayoutGrid;


	/***/ },
	/* 140 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var echarts = __webpack_require__(1);

		    __webpack_require__(141);
		    __webpack_require__(143);

		    __webpack_require__(144)('pie', [{
		        type: 'pieToggleSelect',
		        event: 'pieselectchanged',
		        method: 'toggleSelected'
		    }, {
		        type: 'pieSelect',
		        event: 'pieselected',
		        method: 'select'
		    }, {
		        type: 'pieUnSelect',
		        event: 'pieunselected',
		        method: 'unSelect'
		    }]);

		    echarts.registerVisual(zrUtil.curry(__webpack_require__(145), 'pie'));

		    echarts.registerLayout(zrUtil.curry(
		        __webpack_require__(146), 'pie'
		    ));

		    echarts.registerProcessor(zrUtil.curry(__webpack_require__(148), 'pie'));


	/***/ },
	/* 141 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var List = __webpack_require__(98);
		    var zrUtil = __webpack_require__(4);
		    var modelUtil = __webpack_require__(5);
		    var completeDimensions = __webpack_require__(103);

		    var dataSelectableMixin = __webpack_require__(142);

		    var PieSeries = __webpack_require__(1).extendSeriesModel({

		        type: 'series.pie',

		        // Overwrite
		        init: function (option) {
		            PieSeries.superApply(this, 'init', arguments);

		            // Enable legend selection for each data item
		            // Use a function instead of direct access because data reference may changed
		            this.legendDataProvider = function () {
		                return this._dataBeforeProcessed;
		            };

		            this.updateSelectedMap(option.data);

		            this._defaultLabelLine(option);
		        },

		        // Overwrite
		        mergeOption: function (newOption) {
		            PieSeries.superCall(this, 'mergeOption', newOption);
		            this.updateSelectedMap(this.option.data);
		        },

		        getInitialData: function (option, ecModel) {
		            var dimensions = completeDimensions(['value'], option.data);
		            var list = new List(dimensions, this);
		            list.initData(option.data);
		            return list;
		        },

		        // Overwrite
		        getDataParams: function (dataIndex) {
		            var data = this._data;
		            var params = PieSeries.superCall(this, 'getDataParams', dataIndex);
		            var sum = data.getSum('value');
		            // FIXME toFixed?
		            //
		            // Percent is 0 if sum is 0
		            params.percent = !sum ? 0 : +(data.get('value', dataIndex) / sum * 100).toFixed(2);

		            params.$vars.push('percent');
		            return params;
		        },

		        _defaultLabelLine: function (option) {
		            // Extend labelLine emphasis
		            modelUtil.defaultEmphasis(option.labelLine, ['show']);

		            var labelLineNormalOpt = option.labelLine.normal;
		            var labelLineEmphasisOpt = option.labelLine.emphasis;
		            // Not show label line if `label.normal.show = false`
		            labelLineNormalOpt.show = labelLineNormalOpt.show
		                && option.label.normal.show;
		            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show
		                && option.label.emphasis.show;
		        },

		        defaultOption: {
		            zlevel: 0,
		            z: 2,
		            legendHoverLink: true,

		            hoverAnimation: true,
		            // 默认全局居中
		            center: ['50%', '50%'],
		            radius: [0, '75%'],
		            // 默认顺时针
		            clockwise: true,
		            startAngle: 90,
		            // 最小角度改为0
		            minAngle: 0,
		            // 选中是扇区偏移量
		            selectedOffset: 10,

		            // If use strategy to avoid label overlapping
		            avoidLabelOverlap: true,
		            // 选择模式，默认关闭，可选single，multiple
		            // selectedMode: false,
		            // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
		            // roseType: null,

		            label: {
		                normal: {
		                    // If rotate around circle
		                    rotate: false,
		                    show: true,
		                    // 'outer', 'inside', 'center'
		                    position: 'outer'
		                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
		                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
		                    // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数
		                },
		                emphasis: {}
		            },
		            // Enabled when label.normal.position is 'outer'
		            labelLine: {
		                normal: {
		                    show: true,
		                    // 引导线两段中的第一段长度
		                    length: 15,
		                    // 引导线两段中的第二段长度
		                    length2: 15,
		                    smooth: false,
		                    lineStyle: {
		                        // color: 各异,
		                        width: 1,
		                        type: 'solid'
		                    }
		                }
		            },
		            itemStyle: {
		                normal: {
		                    borderWidth: 1
		                },
		                emphasis: {}
		            },

		            animationEasing: 'cubicOut',

		            data: []
		        }
		    });

		    zrUtil.mixin(PieSeries, dataSelectableMixin);

		    module.exports = PieSeries;


	/***/ },
	/* 142 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Data selectable mixin for chart series.
		 * To eanble data select, option of series must have `selectedMode`.
		 * And each data item will use `selected` to toggle itself selected status
		 *
		 * @module echarts/chart/helper/DataSelectable
		 */


		    var zrUtil = __webpack_require__(4);

		    module.exports = {

		        updateSelectedMap: function (targetList) {
		            this._selectTargetMap = zrUtil.reduce(targetList || [], function (targetMap, target) {
		                targetMap[target.name] = target;
		                return targetMap;
		            }, {});
		        },
		        /**
		         * @param {string} name
		         */
		        // PENGING If selectedMode is null ?
		        select: function (name) {
		            var targetMap = this._selectTargetMap;
		            var target = targetMap[name];
		            var selectedMode = this.get('selectedMode');
		            if (selectedMode === 'single') {
		                zrUtil.each(targetMap, function (target) {
		                    target.selected = false;
		                });
		            }
		            target && (target.selected = true);
		        },

		        /**
		         * @param {string} name
		         */
		        unSelect: function (name) {
		            var target = this._selectTargetMap[name];
		            // var selectedMode = this.get('selectedMode');
		            // selectedMode !== 'single' && target && (target.selected = false);
		            target && (target.selected = false);
		        },

		        /**
		         * @param {string} name
		         */
		        toggleSelected: function (name) {
		            var target = this._selectTargetMap[name];
		            if (target != null) {
		                this[target.selected ? 'unSelect' : 'select'](name);
		                return target.selected;
		            }
		        },

		        /**
		         * @param {string} name
		         */
		        isSelected: function (name) {
		            var target = this._selectTargetMap[name];
		            return target && target.selected;
		        }
		    };


	/***/ },
	/* 143 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var graphic = __webpack_require__(43);
		    var zrUtil = __webpack_require__(4);

		    /**
		     * @param {module:echarts/model/Series} seriesModel
		     * @param {boolean} hasAnimation
		     * @inner
		     */
		    function updateDataSelected(uid, seriesModel, hasAnimation, api) {
		        var data = seriesModel.getData();
		        var dataIndex = this.dataIndex;
		        var name = data.getName(dataIndex);
		        var selectedOffset = seriesModel.get('selectedOffset');

		        api.dispatchAction({
		            type: 'pieToggleSelect',
		            from: uid,
		            name: name,
		            seriesId: seriesModel.id
		        });

		        data.each(function (idx) {
		            toggleItemSelected(
		                data.getItemGraphicEl(idx),
		                data.getItemLayout(idx),
		                seriesModel.isSelected(data.getName(idx)),
		                selectedOffset,
		                hasAnimation
		            );
		        });
		    }

		    /**
		     * @param {module:zrender/graphic/Sector} el
		     * @param {Object} layout
		     * @param {boolean} isSelected
		     * @param {number} selectedOffset
		     * @param {boolean} hasAnimation
		     * @inner
		     */
		    function toggleItemSelected(el, layout, isSelected, selectedOffset, hasAnimation) {
		        var midAngle = (layout.startAngle + layout.endAngle) / 2;

		        var dx = Math.cos(midAngle);
		        var dy = Math.sin(midAngle);

		        var offset = isSelected ? selectedOffset : 0;
		        var position = [dx * offset, dy * offset];

		        hasAnimation
		            // animateTo will stop revious animation like update transition
		            ? el.animate()
		                .when(200, {
		                    position: position
		                })
		                .start('bounceOut')
		            : el.attr('position', position);
		    }

		    /**
		     * Piece of pie including Sector, Label, LabelLine
		     * @constructor
		     * @extends {module:zrender/graphic/Group}
		     */
		    function PiePiece(data, idx) {

		        graphic.Group.call(this);

		        var sector = new graphic.Sector({
		            z2: 2
		        });
		        var polyline = new graphic.Polyline();
		        var text = new graphic.Text();
		        this.add(sector);
		        this.add(polyline);
		        this.add(text);

		        this.updateData(data, idx, true);

		        // Hover to change label and labelLine
		        function onEmphasis() {
		            polyline.ignore = polyline.hoverIgnore;
		            text.ignore = text.hoverIgnore;
		        }
		        function onNormal() {
		            polyline.ignore = polyline.normalIgnore;
		            text.ignore = text.normalIgnore;
		        }
		        this.on('emphasis', onEmphasis)
		            .on('normal', onNormal)
		            .on('mouseover', onEmphasis)
		            .on('mouseout', onNormal);
		    }

		    var piePieceProto = PiePiece.prototype;

		    function getLabelStyle(data, idx, state, labelModel, labelPosition) {
		        var textStyleModel = labelModel.getModel('textStyle');
		        var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';
		        return {
		            fill: textStyleModel.getTextColor()
		                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),
		            opacity: data.getItemVisual(idx, 'opacity'),
		            textFont: textStyleModel.getFont(),
		            text: zrUtil.retrieve(
		                data.hostModel.getFormattedLabel(idx, state), data.getName(idx)
		            )
		        };
		    }

		    piePieceProto.updateData = function (data, idx, firstCreate) {

		        var sector = this.childAt(0);

		        var seriesModel = data.hostModel;
		        var itemModel = data.getItemModel(idx);
		        var layout = data.getItemLayout(idx);
		        var sectorShape = zrUtil.extend({}, layout);
		        sectorShape.label = null;
		        if (firstCreate) {
		            sector.setShape(sectorShape);
		            sector.shape.endAngle = layout.startAngle;
		            graphic.updateProps(sector, {
		                shape: {
		                    endAngle: layout.endAngle
		                }
		            }, seriesModel, idx);
		        }
		        else {
		            graphic.updateProps(sector, {
		                shape: sectorShape
		            }, seriesModel, idx);
		        }

		        // Update common style
		        var itemStyleModel = itemModel.getModel('itemStyle');
		        var visualColor = data.getItemVisual(idx, 'color');

		        sector.useStyle(
		            zrUtil.defaults(
		                {
		                    lineJoin: 'bevel',
		                    fill: visualColor
		                },
		                itemStyleModel.getModel('normal').getItemStyle()
		            )
		        );
		        sector.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();

		        // Toggle selected
		        toggleItemSelected(
		            this,
		            data.getItemLayout(idx),
		            itemModel.get('selected'),
		            seriesModel.get('selectedOffset'),
		            seriesModel.get('animation')
		        );

		        function onEmphasis() {
		            // Sector may has animation of updating data. Force to move to the last frame
		            // Or it may stopped on the wrong shape
		            sector.stopAnimation(true);
		            sector.animateTo({
		                shape: {
		                    r: layout.r + 10
		                }
		            }, 300, 'elasticOut');
		        }
		        function onNormal() {
		            sector.stopAnimation(true);
		            sector.animateTo({
		                shape: {
		                    r: layout.r
		                }
		            }, 300, 'elasticOut');
		        }
		        sector.off('mouseover').off('mouseout').off('emphasis').off('normal');
		        if (itemModel.get('hoverAnimation') && seriesModel.ifEnableAnimation()) {
		            sector
		                .on('mouseover', onEmphasis)
		                .on('mouseout', onNormal)
		                .on('emphasis', onEmphasis)
		                .on('normal', onNormal);
		        }

		        this._updateLabel(data, idx);

		        graphic.setHoverStyle(this);
		    };

		    piePieceProto._updateLabel = function (data, idx) {

		        var labelLine = this.childAt(1);
		        var labelText = this.childAt(2);

		        var seriesModel = data.hostModel;
		        var itemModel = data.getItemModel(idx);
		        var layout = data.getItemLayout(idx);
		        var labelLayout = layout.label;
		        var visualColor = data.getItemVisual(idx, 'color');

		        graphic.updateProps(labelLine, {
		            shape: {
		                points: labelLayout.linePoints || [
		                    [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y], [labelLayout.x, labelLayout.y]
		                ]
		            }
		        }, seriesModel, idx);

		        graphic.updateProps(labelText, {
		            style: {
		                x: labelLayout.x,
		                y: labelLayout.y
		            }
		        }, seriesModel, idx);
		        labelText.attr({
		            style: {
		                textVerticalAlign: labelLayout.verticalAlign,
		                textAlign: labelLayout.textAlign,
		                textFont: labelLayout.font
		            },
		            rotation: labelLayout.rotation,
		            origin: [labelLayout.x, labelLayout.y],
		            z2: 10
		        });

		        var labelModel = itemModel.getModel('label.normal');
		        var labelHoverModel = itemModel.getModel('label.emphasis');
		        var labelLineModel = itemModel.getModel('labelLine.normal');
		        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');
		        var labelPosition = labelModel.get('position') || labelHoverModel.get('position');

		        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel, labelPosition));

		        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
		        labelText.hoverIgnore = !labelHoverModel.get('show');

		        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
		        labelLine.hoverIgnore = !labelLineHoverModel.get('show');

		        // Default use item visual color
		        labelLine.setStyle({
		            stroke: visualColor,
		            opacity: data.getItemVisual(idx, 'opacity')
		        });
		        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());

		        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel, labelPosition);
		        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();

		        var smooth = labelLineModel.get('smooth');
		        if (smooth && smooth === true) {
		            smooth = 0.4;
		        }
		        labelLine.setShape({
		            smooth: smooth
		        });
		    };

		    zrUtil.inherits(PiePiece, graphic.Group);


		    // Pie view
		    var Pie = __webpack_require__(42).extend({

		        type: 'pie',

		        init: function () {
		            var sectorGroup = new graphic.Group();
		            this._sectorGroup = sectorGroup;
		        },

		        render: function (seriesModel, ecModel, api, payload) {
		            if (payload && (payload.from === this.uid)) {
		                return;
		            }

		            var data = seriesModel.getData();
		            var oldData = this._data;
		            var group = this.group;

		            var hasAnimation = ecModel.get('animation');
		            var isFirstRender = !oldData;

		            var onSectorClick = zrUtil.curry(
		                updateDataSelected, this.uid, seriesModel, hasAnimation, api
		            );

		            var selectedMode = seriesModel.get('selectedMode');

		            data.diff(oldData)
		                .add(function (idx) {
		                    var piePiece = new PiePiece(data, idx);
		                    if (isFirstRender) {
		                        piePiece.eachChild(function (child) {
		                            child.stopAnimation(true);
		                        });
		                    }

		                    selectedMode && piePiece.on('click', onSectorClick);

		                    data.setItemGraphicEl(idx, piePiece);

		                    group.add(piePiece);
		                })
		                .update(function (newIdx, oldIdx) {
		                    var piePiece = oldData.getItemGraphicEl(oldIdx);

		                    piePiece.updateData(data, newIdx);

		                    piePiece.off('click');
		                    selectedMode && piePiece.on('click', onSectorClick);
		                    group.add(piePiece);
		                    data.setItemGraphicEl(newIdx, piePiece);
		                })
		                .remove(function (idx) {
		                    var piePiece = oldData.getItemGraphicEl(idx);
		                    group.remove(piePiece);
		                })
		                .execute();

		            if (hasAnimation && isFirstRender && data.count() > 0) {
		                var shape = data.getItemLayout(0);
		                var r = Math.max(api.getWidth(), api.getHeight()) / 2;

		                var removeClipPath = zrUtil.bind(group.removeClipPath, group);
		                group.setClipPath(this._createClipPath(
		                    shape.cx, shape.cy, r, shape.startAngle, shape.clockwise, removeClipPath, seriesModel
		                ));
		            }

		            this._data = data;
		        },

		        dispose: function () {},

		        _createClipPath: function (
		            cx, cy, r, startAngle, clockwise, cb, seriesModel
		        ) {
		            var clipPath = new graphic.Sector({
		                shape: {
		                    cx: cx,
		                    cy: cy,
		                    r0: 0,
		                    r: r,
		                    startAngle: startAngle,
		                    endAngle: startAngle,
		                    clockwise: clockwise
		                }
		            });

		            graphic.initProps(clipPath, {
		                shape: {
		                    endAngle: startAngle + (clockwise ? 1 : -1) * Math.PI * 2
		                }
		            }, seriesModel, cb);

		            return clipPath;
		        },

		        /**
		         * @implement
		         */
		        containPoint: function (point, seriesModel) {
		            var data = seriesModel.getData();
		            var itemLayout = data.getItemLayout(0);
		            if (itemLayout) {
		                var dx = point[0] - itemLayout.cx;
		                var dy = point[1] - itemLayout.cy;
		                var radius = Math.sqrt(dx * dx + dy * dy);
		                return radius <= itemLayout.r && radius >= itemLayout.r0;
		            }
		        }

		    });

		    module.exports = Pie;


	/***/ },
	/* 144 */
	/***/ function(module, exports, __webpack_require__) {

		
		    var echarts = __webpack_require__(1);
		    var zrUtil = __webpack_require__(4);
		    module.exports = function (seriesType, actionInfos) {
		        zrUtil.each(actionInfos, function (actionInfo) {
		            actionInfo.update = 'updateView';
		            /**
		             * @payload
		             * @property {string} seriesName
		             * @property {string} name
		             */
		            echarts.registerAction(actionInfo, function (payload, ecModel) {
		                var selected = {};
		                ecModel.eachComponent(
		                    {mainType: 'series', subType: seriesType, query: payload},
		                    function (seriesModel) {
		                        if (seriesModel[actionInfo.method]) {
		                            seriesModel[actionInfo.method](payload.name);
		                        }
		                        var data = seriesModel.getData();
		                        // Create selected map
		                        data.each(function (idx) {
		                            var name = data.getName(idx);
		                            selected[name] = seriesModel.isSelected(name) || false;
		                        });
		                    }
		                );
		                return {
		                    name: payload.name,
		                    selected: selected
		                };
		            });
		        });
		    };


	/***/ },
	/* 145 */
	/***/ function(module, exports) {

		// Pick color from palette for each data item


		    module.exports = function (seriesType, ecModel) {
		        // Pie and funnel may use diferrent scope
		        var paletteScope = {};
		        ecModel.eachRawSeriesByType(seriesType, function (seriesModel) {
		            var dataAll = seriesModel.getRawData();
		            var idxMap = {};
		            if (!ecModel.isSeriesFiltered(seriesModel)) {
		                var data = seriesModel.getData();
		                data.each(function (idx) {
		                    var rawIdx = data.getRawIndex(idx);
		                    idxMap[rawIdx] = idx;
		                });
		                dataAll.each(function (rawIdx) {
		                    // FIXME Performance
		                    var itemModel = dataAll.getItemModel(rawIdx);
		                    var filteredIdx = idxMap[rawIdx];

		                    // If series.itemStyle.normal.color is a function. itemVisual may be encoded
		                    var singleDataColor = filteredIdx != null
		                        && data.getItemVisual(filteredIdx, 'color', true);

		                    if (!singleDataColor) {
		                        var color = itemModel.get('itemStyle.normal.color')
		                            || seriesModel.getColorFromPalette(dataAll.getName(rawIdx), paletteScope);
		                        // Legend may use the visual info in data before processed
		                        dataAll.setItemVisual(rawIdx, 'color', color);

		                        // Data is not filtered
		                        if (filteredIdx != null) {
		                            data.setItemVisual(filteredIdx, 'color', color);
		                        }
		                    }
		                    else {
		                        // Set data all color for legend
		                        dataAll.setItemVisual(rawIdx, 'color', singleDataColor);
		                    }
		                });
		            }
		        });
		    };


	/***/ },
	/* 146 */
	/***/ function(module, exports, __webpack_require__) {

		// TODO minAngle



		    var numberUtil = __webpack_require__(7);
		    var parsePercent = numberUtil.parsePercent;
		    var labelLayout = __webpack_require__(147);
		    var zrUtil = __webpack_require__(4);

		    var PI2 = Math.PI * 2;
		    var RADIAN = Math.PI / 180;

		    module.exports = function (seriesType, ecModel, api, payload) {
		        ecModel.eachSeriesByType(seriesType, function (seriesModel) {
		            var center = seriesModel.get('center');
		            var radius = seriesModel.get('radius');

		            if (!zrUtil.isArray(radius)) {
		                radius = [0, radius];
		            }
		            if (!zrUtil.isArray(center)) {
		                center = [center, center];
		            }

		            var width = api.getWidth();
		            var height = api.getHeight();
		            var size = Math.min(width, height);
		            var cx = parsePercent(center[0], width);
		            var cy = parsePercent(center[1], height);
		            var r0 = parsePercent(radius[0], size / 2);
		            var r = parsePercent(radius[1], size / 2);

		            var data = seriesModel.getData();

		            var startAngle = -seriesModel.get('startAngle') * RADIAN;

		            var minAngle = seriesModel.get('minAngle') * RADIAN;

		            var sum = data.getSum('value');
		            // Sum may be 0
		            var unitRadian = Math.PI / (sum || data.count()) * 2;

		            var clockwise = seriesModel.get('clockwise');

		            var roseType = seriesModel.get('roseType');

		            // [0...max]
		            var extent = data.getDataExtent('value');
		            extent[0] = 0;

		            // In the case some sector angle is smaller than minAngle
		            var restAngle = PI2;
		            var valueSumLargerThanMinAngle = 0;

		            var currentAngle = startAngle;

		            var dir = clockwise ? 1 : -1;
		            data.each('value', function (value, idx) {
		                var angle;
		                // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？
		                if (roseType !== 'area') {
		                    angle = sum === 0 ? unitRadian : (value * unitRadian);
		                }
		                else {
		                    angle = PI2 / (data.count() || 1);
		                }

		                if (angle < minAngle) {
		                    angle = minAngle;
		                    restAngle -= minAngle;
		                }
		                else {
		                    valueSumLargerThanMinAngle += value;
		                }

		                var endAngle = currentAngle + dir * angle;
		                data.setItemLayout(idx, {
		                    angle: angle,
		                    startAngle: currentAngle,
		                    endAngle: endAngle,
		                    clockwise: clockwise,
		                    cx: cx,
		                    cy: cy,
		                    r0: r0,
		                    r: roseType
		                        ? numberUtil.linearMap(value, extent, [r0, r])
		                        : r
		                });

		                currentAngle = endAngle;
		            }, true);

		            // Some sector is constrained by minAngle
		            // Rest sectors needs recalculate angle
		            if (restAngle < PI2) {
		                // Average the angle if rest angle is not enough after all angles is
		                // Constrained by minAngle
		                if (restAngle <= 1e-3) {
		                    var angle = PI2 / data.count();
		                    data.each(function (idx) {
		                        var layout = data.getItemLayout(idx);
		                        layout.startAngle = startAngle + dir * idx * angle;
		                        layout.endAngle = startAngle + dir * (idx + 1) * angle;
		                    });
		                }
		                else {
		                    unitRadian = restAngle / valueSumLargerThanMinAngle;
		                    currentAngle = startAngle;
		                    data.each('value', function (value, idx) {
		                        var layout = data.getItemLayout(idx);
		                        var angle = layout.angle === minAngle
		                            ? minAngle : value * unitRadian;
		                        layout.startAngle = currentAngle;
		                        layout.endAngle = currentAngle + dir * angle;
		                        currentAngle += dir * angle;
		                    });
		                }
		            }

		            labelLayout(seriesModel, r, width, height);
		        });
		    };


	/***/ },
	/* 147 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		// FIXME emphasis label position is not same with normal label position


		    var textContain = __webpack_require__(8);

		    function adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight) {
		        list.sort(function (a, b) {
		            return a.y - b.y;
		        });

		        // 压
		        function shiftDown(start, end, delta, dir) {
		            for (var j = start; j < end; j++) {
		                list[j].y += delta;
		                if (j > start
		                    && j + 1 < end
		                    && list[j + 1].y > list[j].y + list[j].height
		                ) {
		                    shiftUp(j, delta / 2);
		                    return;
		                }
		            }

		            shiftUp(end - 1, delta / 2);
		        }

		        // 弹
		        function shiftUp(end, delta) {
		            for (var j = end; j >= 0; j--) {
		                list[j].y -= delta;
		                if (j > 0
		                    && list[j].y > list[j - 1].y + list[j - 1].height
		                ) {
		                    break;
		                }
		            }
		        }

		        function changeX(list, isDownList, cx, cy, r, dir) {
		            var lastDeltaX = dir > 0
		                ? isDownList                // 右侧
		                    ? Number.MAX_VALUE      // 下
		                    : 0                     // 上
		                : isDownList                // 左侧
		                    ? Number.MAX_VALUE      // 下
		                    : 0;                    // 上

		            for (var i = 0, l = list.length; i < l; i++) {
		                // Not change x for center label
		                if (list[i].position === 'center') {
		                    continue;
		                }
		                var deltaY = Math.abs(list[i].y - cy);
		                var length = list[i].len;
		                var length2 = list[i].len2;
		                var deltaX = (deltaY < r + length)
		                    ? Math.sqrt(
		                          (r + length + length2) * (r + length + length2)
		                          - deltaY * deltaY
		                      )
		                    : Math.abs(list[i].x - cx);
		                if (isDownList && deltaX >= lastDeltaX) {
		                    // 右下，左下
		                    deltaX = lastDeltaX - 10;
		                }
		                if (!isDownList && deltaX <= lastDeltaX) {
		                    // 右上，左上
		                    deltaX = lastDeltaX + 10;
		                }

		                list[i].x = cx + deltaX * dir;
		                lastDeltaX = deltaX;
		            }
		        }

		        var lastY = 0;
		        var delta;
		        var len = list.length;
		        var upList = [];
		        var downList = [];
		        for (var i = 0; i < len; i++) {
		            delta = list[i].y - lastY;
		            if (delta < 0) {
		                shiftDown(i, len, -delta, dir);
		            }
		            lastY = list[i].y + list[i].height;
		        }
		        if (viewHeight - lastY < 0) {
		            shiftUp(len - 1, lastY - viewHeight);
		        }
		        for (var i = 0; i < len; i++) {
		            if (list[i].y >= cy) {
		                downList.push(list[i]);
		            }
		            else {
		                upList.push(list[i]);
		            }
		        }
		        changeX(upList, false, cx, cy, r, dir);
		        changeX(downList, true, cx, cy, r, dir);
		    }

		    function avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight) {
		        var leftList = [];
		        var rightList = [];
		        for (var i = 0; i < labelLayoutList.length; i++) {
		            if (labelLayoutList[i].x < cx) {
		                leftList.push(labelLayoutList[i]);
		            }
		            else {
		                rightList.push(labelLayoutList[i]);
		            }
		        }

		        adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight);
		        adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight);

		        for (var i = 0; i < labelLayoutList.length; i++) {
		            var linePoints = labelLayoutList[i].linePoints;
		            if (linePoints) {
		                var dist = linePoints[1][0] - linePoints[2][0];
		                if (labelLayoutList[i].x < cx) {
		                    linePoints[2][0] = labelLayoutList[i].x + 3;
		                }
		                else {
		                    linePoints[2][0] = labelLayoutList[i].x - 3;
		                }
		                linePoints[1][1] = linePoints[2][1] = labelLayoutList[i].y;
		                linePoints[1][0] = linePoints[2][0] + dist;
		            }
		        }
		    }

		    module.exports = function (seriesModel, r, viewWidth, viewHeight) {
		        var data = seriesModel.getData();
		        var labelLayoutList = [];
		        var cx;
		        var cy;
		        var hasLabelRotate = false;

		        data.each(function (idx) {
		            var layout = data.getItemLayout(idx);

		            var itemModel = data.getItemModel(idx);
		            var labelModel = itemModel.getModel('label.normal');
		            // Use position in normal or emphasis
		            var labelPosition = labelModel.get('position') || itemModel.get('label.emphasis.position');

		            var labelLineModel = itemModel.getModel('labelLine.normal');
		            var labelLineLen = labelLineModel.get('length');
		            var labelLineLen2 = labelLineModel.get('length2');

		            var midAngle = (layout.startAngle + layout.endAngle) / 2;
		            var dx = Math.cos(midAngle);
		            var dy = Math.sin(midAngle);

		            var textX;
		            var textY;
		            var linePoints;
		            var textAlign;

		            cx = layout.cx;
		            cy = layout.cy;

		            var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';
		            if (labelPosition === 'center') {
		                textX = layout.cx;
		                textY = layout.cy;
		                textAlign = 'center';
		            }
		            else {
		                var x1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dx : layout.r * dx) + cx;
		                var y1 = (isLabelInside ? (layout.r + layout.r0) / 2 * dy : layout.r * dy) + cy;

		                textX = x1 + dx * 3;
		                textY = y1 + dy * 3;

		                if (!isLabelInside) {
		                    // For roseType
		                    var x2 = x1 + dx * (labelLineLen + r - layout.r);
		                    var y2 = y1 + dy * (labelLineLen + r - layout.r);
		                    var x3 = x2 + ((dx < 0 ? -1 : 1) * labelLineLen2);
		                    var y3 = y2;

		                    textX = x3 + (dx < 0 ? -5 : 5);
		                    textY = y3;
		                    linePoints = [[x1, y1], [x2, y2], [x3, y3]];
		                }

		                textAlign = isLabelInside ? 'center' : (dx > 0 ? 'left' : 'right');
		            }
		            var font = labelModel.getModel('textStyle').getFont();

		            var labelRotate = labelModel.get('rotate')
		                ? (dx < 0 ? -midAngle + Math.PI : -midAngle) : 0;
		            var text = seriesModel.getFormattedLabel(idx, 'normal')
		                        || data.getName(idx);
		            var textRect = textContain.getBoundingRect(
		                text, font, textAlign, 'top'
		            );
		            hasLabelRotate = !!labelRotate;
		            layout.label = {
		                x: textX,
		                y: textY,
		                position: labelPosition,
		                height: textRect.height,
		                len: labelLineLen,
		                len2: labelLineLen2,
		                linePoints: linePoints,
		                textAlign: textAlign,
		                verticalAlign: 'middle',
		                font: font,
		                rotation: labelRotate
		            };

		            // Not layout the inside label
		            if (!isLabelInside) {
		                labelLayoutList.push(layout.label);
		            }
		        });
		        if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {
		            avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight);
		        }
		    };


	/***/ },
	/* 148 */
	/***/ function(module, exports) {

		
		    module.exports = function (seriesType, ecModel) {
		        var legendModels = ecModel.findComponents({
		            mainType: 'legend'
		        });
		        if (!legendModels || !legendModels.length) {
		            return;
		        }
		        ecModel.eachSeriesByType(seriesType, function (series) {
		            var data = series.getData();
		            data.filterSelf(function (idx) {
		                var name = data.getName(idx);
		                // If in any legend component the status is not selected.
		                for (var i = 0; i < legendModels.length; i++) {
		                    if (!legendModels[i].isSelected(name)) {
		                        return false;
		                    }
		                }
		                return true;
		            }, this);
		        }, this);
		    };


	/***/ },
	/* 149 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var echarts = __webpack_require__(1);

		    __webpack_require__(150);
		    __webpack_require__(151);

		    echarts.registerVisual(zrUtil.curry(
		        __webpack_require__(110), 'scatter', 'circle', null
		    ));
		    echarts.registerLayout(zrUtil.curry(
		        __webpack_require__(111), 'scatter'
		    ));

		    // In case developer forget to include grid component
		    __webpack_require__(113);


	/***/ },
	/* 150 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var createListFromArray = __webpack_require__(102);
		    var SeriesModel = __webpack_require__(28);

		    module.exports = SeriesModel.extend({

		        type: 'series.scatter',

		        dependencies: ['grid', 'polar'],

		        getInitialData: function (option, ecModel) {
		            var list = createListFromArray(option.data, this, ecModel);
		            return list;
		        },

		        brushSelector: 'point',

		        defaultOption: {
		            coordinateSystem: 'cartesian2d',
		            zlevel: 0,
		            z: 2,
		            legendHoverLink: true,

		            hoverAnimation: true,
		            // Cartesian coordinate system
		            // xAxisIndex: 0,
		            // yAxisIndex: 0,

		            // Polar coordinate system
		            // polarIndex: 0,

		            // Geo coordinate system
		            // geoIndex: 0,

		            // symbol: null,        // 图形类型
		            symbolSize: 10,          // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
		            // symbolRotate: null,  // 图形旋转控制

		            large: false,
		            // Available when large is true
		            largeThreshold: 2000,

		            // label: {
		                // normal: {
		                    // show: false
		                    // distance: 5,
		                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
		                    // position: 默认自适应，水平布局为'top'，垂直布局为'right'，可选为
		                    //           'inside'|'left'|'right'|'top'|'bottom'
		                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
		            //     }
		            // },
		            itemStyle: {
		                normal: {
		                    opacity: 0.8
		                    // color: 各异
		                }
		            }
		        }

		    });


	/***/ },
	/* 151 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var SymbolDraw = __webpack_require__(105);
		    var LargeSymbolDraw = __webpack_require__(152);

		    __webpack_require__(1).extendChartView({

		        type: 'scatter',

		        init: function () {
		            this._normalSymbolDraw = new SymbolDraw();
		            this._largeSymbolDraw = new LargeSymbolDraw();
		        },

		        render: function (seriesModel, ecModel, api) {
		            var data = seriesModel.getData();
		            var largeSymbolDraw = this._largeSymbolDraw;
		            var normalSymbolDraw = this._normalSymbolDraw;
		            var group = this.group;

		            var symbolDraw = seriesModel.get('large') && data.count() > seriesModel.get('largeThreshold')
		                ? largeSymbolDraw : normalSymbolDraw;

		            this._symbolDraw = symbolDraw;
		            symbolDraw.updateData(data);
		            group.add(symbolDraw.group);

		            group.remove(
		                symbolDraw === largeSymbolDraw
		                ? normalSymbolDraw.group : largeSymbolDraw.group
		            );
		        },

		        updateLayout: function (seriesModel) {
		            this._symbolDraw.updateLayout(seriesModel);
		        },

		        remove: function (ecModel, api) {
		            this._symbolDraw && this._symbolDraw.remove(api, true);
		        },

		        dispose: function () {}
		    });


	/***/ },
	/* 152 */
	/***/ function(module, exports, __webpack_require__) {

		// TODO Batch by color



		    var graphic = __webpack_require__(43);
		    var symbolUtil = __webpack_require__(107);

		    var LargeSymbolPath = graphic.extendShape({

		        shape: {
		            points: null,
		            sizes: null
		        },

		        symbolProxy: null,

		        buildPath: function (path, shape) {
		            var points = shape.points;
		            var sizes = shape.sizes;

		            var symbolProxy = this.symbolProxy;
		            var symbolProxyShape = symbolProxy.shape;
		            for (var i = 0; i < points.length; i++) {
		                var pt = points[i];
		                var size = sizes[i];
		                if (size[0] < 4) {
		                    // Optimize for small symbol
		                    path.rect(
		                        pt[0] - size[0] / 2, pt[1] - size[1] / 2,
		                        size[0], size[1]
		                    );
		                }
		                else {
		                    symbolProxyShape.x = pt[0] - size[0] / 2;
		                    symbolProxyShape.y = pt[1] - size[1] / 2;
		                    symbolProxyShape.width = size[0];
		                    symbolProxyShape.height = size[1];

		                    symbolProxy.buildPath(path, symbolProxyShape, true);
		                }
		            }
		        },

		        findDataIndex: function (x, y) {
		            var shape = this.shape;
		            var points = shape.points;
		            var sizes = shape.sizes;

		            // Not consider transform
		            // Treat each element as a rect
		            // top down traverse
		            for (var i = points.length - 1; i >= 0; i--) {
		                var pt = points[i];
		                var size = sizes[i];
		                var x0 = pt[0] - size[0] / 2;
		                var y0 = pt[1] - size[1] / 2;
		                if (x >= x0 && y >= y0 && x <= x0 + size[0] && y <= y0 + size[1]) {
		                    // i is dataIndex
		                    return i;
		                }
		            }

		            return -1;
		        }
		    });

		    function LargeSymbolDraw() {
		        this.group = new graphic.Group();

		        this._symbolEl = new LargeSymbolPath({
		            // rectHover: true,
		            // cursor: 'default'
		        });
		    }

		    var largeSymbolProto = LargeSymbolDraw.prototype;

		    /**
		     * Update symbols draw by new data
		     * @param {module:echarts/data/List} data
		     */
		    largeSymbolProto.updateData = function (data) {
		        this.group.removeAll();

		        var symbolEl = this._symbolEl;

		        var seriesModel = data.hostModel;

		        symbolEl.setShape({
		            points: data.mapArray(data.getItemLayout),
		            sizes: data.mapArray(
		                function (idx) {
		                    var size = data.getItemVisual(idx, 'symbolSize');
		                    if (!(size instanceof Array)) {
		                        size = [size, size];
		                    }
		                    return size;
		                }
		            )
		        });

		        // Create symbolProxy to build path for each data
		        symbolEl.symbolProxy = symbolUtil.createSymbol(
		            data.getVisual('symbol'), 0, 0, 0, 0
		        );
		        // Use symbolProxy setColor method
		        symbolEl.setColor = symbolEl.symbolProxy.setColor;

		        symbolEl.useStyle(
		            seriesModel.getModel('itemStyle.normal').getItemStyle(['color'])
		        );

		        var visualColor = data.getVisual('color');
		        if (visualColor) {
		            symbolEl.setColor(visualColor);
		        }

		        // Enable tooltip
		        // PENDING May have performance issue when path is extremely large
		        symbolEl.seriesIndex = seriesModel.seriesIndex;
		        symbolEl.on('mousemove', function (e) {
		            symbolEl.dataIndex = null;
		            var dataIndex = symbolEl.findDataIndex(e.offsetX, e.offsetY);
		            if (dataIndex > 0) {
		                // Provide dataIndex for tooltip
		                symbolEl.dataIndex = dataIndex;
		            }
		        });

		        // Add back
		        this.group.add(symbolEl);
		    };

		    largeSymbolProto.updateLayout = function (seriesModel) {
		        var data = seriesModel.getData();
		        this._symbolEl.setShape({
		            points: data.mapArray(data.getItemLayout)
		        });
		    };

		    largeSymbolProto.remove = function () {
		        this.group.removeAll();
		    };

		    module.exports = LargeSymbolDraw;


	/***/ },
	/* 153 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var echarts = __webpack_require__(1);

		    // Must use radar component
		    __webpack_require__(154);

		    __webpack_require__(159);
		    __webpack_require__(160);

		    echarts.registerVisual(zrUtil.curry(__webpack_require__(145), 'radar'));
		    echarts.registerVisual(zrUtil.curry(
		        __webpack_require__(110), 'radar', 'circle', null
		    ));
		    echarts.registerLayout(__webpack_require__(161));

		    echarts.registerProcessor(
		        zrUtil.curry(__webpack_require__(148), 'radar')
		    );

		    echarts.registerPreprocessor(__webpack_require__(162));


	/***/ },
	/* 154 */
	/***/ function(module, exports, __webpack_require__) {

		

		    __webpack_require__(155);
		    __webpack_require__(157);

		    __webpack_require__(158);


	/***/ },
	/* 155 */
	/***/ function(module, exports, __webpack_require__) {

		// TODO clockwise


		    var zrUtil = __webpack_require__(4);
		    var IndicatorAxis = __webpack_require__(156);
		    var IntervalScale = __webpack_require__(118);
		    var numberUtil = __webpack_require__(7);
		    var axisHelper = __webpack_require__(115);

		    function Radar(radarModel, ecModel, api) {

		        this._model = radarModel;
		        /**
		         * Radar dimensions
		         * @type {Array.<string>}
		         */
		        this.dimensions = [];

		        this._indicatorAxes = zrUtil.map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {
		            var dim = 'indicator_' + idx;
		            var indicatorAxis = new IndicatorAxis(dim, new IntervalScale());
		            indicatorAxis.name = indicatorModel.get('name');
		            // Inject model and axis
		            indicatorAxis.model = indicatorModel;
		            indicatorModel.axis = indicatorAxis;
		            this.dimensions.push(dim);
		            return indicatorAxis;
		        }, this);

		        this.resize(radarModel, api);

		        /**
		         * @type {number}
		         * @readOnly
		         */
		        this.cx;
		        /**
		         * @type {number}
		         * @readOnly
		         */
		        this.cy;
		        /**
		         * @type {number}
		         * @readOnly
		         */
		        this.r;
		        /**
		         * @type {number}
		         * @readOnly
		         */
		        this.startAngle;
		    }

		    Radar.prototype.getIndicatorAxes = function () {
		        return this._indicatorAxes;
		    };

		    Radar.prototype.dataToPoint = function (value, indicatorIndex) {
		        var indicatorAxis = this._indicatorAxes[indicatorIndex];

		        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex);
		    };

		    Radar.prototype.coordToPoint = function (coord, indicatorIndex) {
		        var indicatorAxis = this._indicatorAxes[indicatorIndex];
		        var angle = indicatorAxis.angle;
		        var x = this.cx + coord * Math.cos(angle);
		        var y = this.cy - coord * Math.sin(angle);
		        return [x, y];
		    };

		    Radar.prototype.pointToData = function (pt) {
		        var dx = pt[0] - this.cx;
		        var dy = pt[1] - this.cy;
		        var radius = Math.sqrt(dx * dx + dy * dy);
		        dx /= radius;
		        dy /= radius;

		        var radian = Math.atan2(-dy, dx);

		        // Find the closest angle
		        // FIXME index can calculated directly
		        var minRadianDiff = Infinity;
		        var closestAxis;
		        var closestAxisIdx = -1;
		        for (var i = 0; i < this._indicatorAxes.length; i++) {
		            var indicatorAxis = this._indicatorAxes[i];
		            var diff = Math.abs(radian - indicatorAxis.angle);
		            if (diff < minRadianDiff) {
		                closestAxis = indicatorAxis;
		                closestAxisIdx = i;
		                minRadianDiff = diff;
		            }
		        }

		        return [closestAxisIdx, +(closestAxis && closestAxis.coodToData(radius))];
		    };

		    Radar.prototype.resize = function (radarModel, api) {
		        var center = radarModel.get('center');
		        var viewWidth = api.getWidth();
		        var viewHeight = api.getHeight();
		        var viewSize = Math.min(viewWidth, viewHeight) / 2;
		        this.cx = numberUtil.parsePercent(center[0], viewWidth);
		        this.cy = numberUtil.parsePercent(center[1], viewHeight);

		        this.startAngle = radarModel.get('startAngle') * Math.PI / 180;

		        this.r = numberUtil.parsePercent(radarModel.get('radius'), viewSize);

		        zrUtil.each(this._indicatorAxes, function (indicatorAxis, idx) {
		            indicatorAxis.setExtent(0, this.r);
		            var angle = (this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length);
		            // Normalize to [-PI, PI]
		            angle = Math.atan2(Math.sin(angle), Math.cos(angle));
		            indicatorAxis.angle = angle;
		        }, this);
		    };

		    Radar.prototype.update = function (ecModel, api) {
		        var indicatorAxes = this._indicatorAxes;
		        var radarModel = this._model;
		        zrUtil.each(indicatorAxes, function (indicatorAxis) {
		            indicatorAxis.scale.setExtent(Infinity, -Infinity);
		        });
		        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {
		            if (radarSeries.get('coordinateSystem') !== 'radar'
		                || ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel
		            ) {
		                return;
		            }
		            var data = radarSeries.getData();
		            zrUtil.each(indicatorAxes, function (indicatorAxis) {
		                indicatorAxis.scale.unionExtent(data.getDataExtent(indicatorAxis.dim));
		            });
		        }, this);

		        var splitNumber = radarModel.get('splitNumber');

		        function increaseInterval(interval) {
		            var exp10 = Math.pow(10, Math.floor(Math.log(interval) / Math.LN10));
		            // Increase interval
		            var f = interval / exp10;
		            if (f === 2) {
		                f = 5;
		            }
		            else { // f is 2 or 5
		                f *= 2;
		            }
		            return f * exp10;
		        }
		        // Force all the axis fixing the maxSplitNumber.
		        zrUtil.each(indicatorAxes, function (indicatorAxis, idx) {
		            var rawExtent = axisHelper.getScaleExtent(indicatorAxis, indicatorAxis.model);
		            axisHelper.niceScaleExtent(indicatorAxis, indicatorAxis.model);

		            var axisModel = indicatorAxis.model;
		            var scale = indicatorAxis.scale;
		            var fixedMin = axisModel.get('min');
		            var fixedMax = axisModel.get('max');
		            var interval = scale.getInterval();

		            if (fixedMin != null && fixedMax != null) {
		                // User set min, max, divide to get new interval
		                // FIXME precision
		                scale.setInterval(
		                    (fixedMax - fixedMin) / splitNumber
		                );
		            }
		            else if (fixedMin != null) {
		                var max;
		                // User set min, expand extent on the other side
		                do {
		                    max = fixedMin + interval * splitNumber;
		                    scale.setExtent(+fixedMin, max);
		                    // Interval must been set after extent
		                    // FIXME
		                    scale.setInterval(interval);

		                    interval = increaseInterval(interval);
		                } while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1]));
		            }
		            else if (fixedMax != null) {
		                var min;
		                // User set min, expand extent on the other side
		                do {
		                    min = fixedMax - interval * splitNumber;
		                    scale.setExtent(min, +fixedMax);
		                    scale.setInterval(interval);
		                    interval = increaseInterval(interval);
		                } while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0]));
		            }
		            else {
		                var nicedSplitNumber = scale.getTicks().length - 1;
		                if (nicedSplitNumber > splitNumber) {
		                    interval = increaseInterval(interval);
		                }
		                // PENDING
		                var center = Math.round((rawExtent[0] + rawExtent[1]) / 2 / interval) * interval;
		                var halfSplitNumber = Math.round(splitNumber / 2);
		                scale.setExtent(
		                    numberUtil.round(center - halfSplitNumber * interval),
		                    numberUtil.round(center + (splitNumber - halfSplitNumber) * interval)
		                );
		                scale.setInterval(interval);
		            }
		        });
		    };

		    /**
		     * Radar dimensions is based on the data
		     * @type {Array}
		     */
		    Radar.dimensions = [];

		    Radar.create = function (ecModel, api) {
		        var radarList = [];
		        ecModel.eachComponent('radar', function (radarModel) {
		            var radar = new Radar(radarModel, ecModel, api);
		            radarList.push(radar);
		            radarModel.coordinateSystem = radar;
		        });
		        ecModel.eachSeriesByType('radar', function (radarSeries) {
		            if (radarSeries.get('coordinateSystem') === 'radar') {
		                // Inject coordinate system
		                radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0];
		            }
		        });
		        return radarList;
		    };

		    __webpack_require__(26).register('radar', Radar);
		    module.exports = Radar;


	/***/ },
	/* 156 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var Axis = __webpack_require__(124);

		    function IndicatorAxis(dim, scale, radiusExtent) {
		        Axis.call(this, dim, scale, radiusExtent);

		        /**
		         * Axis type
		         *  - 'category'
		         *  - 'value'
		         *  - 'time'
		         *  - 'log'
		         * @type {string}
		         */
		        this.type = 'value';

		        this.angle = 0;

		        /**
		         * Indicator name
		         * @type {string}
		         */
		        this.name = '';
		        /**
		         * @type {module:echarts/model/Model}
		         */
		        this.model;
		    }

		    zrUtil.inherits(IndicatorAxis, Axis);

		    module.exports = IndicatorAxis;


	/***/ },
	/* 157 */
	/***/ function(module, exports, __webpack_require__) {

		


		    var axisDefault = __webpack_require__(129);
		    var valueAxisDefault = axisDefault.valueAxis;
		    var Model = __webpack_require__(12);
		    var zrUtil = __webpack_require__(4);

		    var axisModelCommonMixin = __webpack_require__(130);

		    function defaultsShow(opt, show) {
		        return zrUtil.defaults({
		            show: show
		        }, opt);
		    }

		    var RadarModel = __webpack_require__(1).extendComponentModel({

		        type: 'radar',

		        optionUpdated: function () {
		            var boundaryGap = this.get('boundaryGap');
		            var splitNumber = this.get('splitNumber');
		            var scale = this.get('scale');
		            var axisLine = this.get('axisLine');
		            var axisTick = this.get('axisTick');
		            var axisLabel = this.get('axisLabel');
		            var nameTextStyle = this.get('name.textStyle');
		            var showName = this.get('name.show');
		            var nameFormatter = this.get('name.formatter');
		            var nameGap = this.get('nameGap');
		            var triggerEvent = this.get('triggerEvent');

		            var indicatorModels = zrUtil.map(this.get('indicator') || [], function (indicatorOpt) {
		                // PENDING
		                if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
		                    indicatorOpt.min = 0;
		                }
		                else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
		                    indicatorOpt.max = 0;
		                }
		                // Use same configuration
		                indicatorOpt = zrUtil.merge(zrUtil.clone(indicatorOpt), {
		                    boundaryGap: boundaryGap,
		                    splitNumber: splitNumber,
		                    scale: scale,
		                    axisLine: axisLine,
		                    axisTick: axisTick,
		                    axisLabel: axisLabel,
		                    // Competitable with 2 and use text
		                    name: indicatorOpt.text,
		                    nameLocation: 'end',
		                    nameGap: nameGap,
		                    // min: 0,
		                    nameTextStyle: nameTextStyle,
		                    triggerEvent: triggerEvent
		                }, false);
		                if (!showName) {
		                    indicatorOpt.name = '';
		                }
		                if (typeof nameFormatter === 'string') {
		                    var indName = indicatorOpt.name;
		                    indicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '');
		                }
		                else if (typeof nameFormatter === 'function') {
		                    indicatorOpt.name = nameFormatter(
		                        indicatorOpt.name, indicatorOpt
		                    );
		                }
		                var model = zrUtil.extend(
		                    new Model(indicatorOpt, null, this.ecModel),
		                    axisModelCommonMixin
		                );

		                // For triggerEvent.
		                model.mainType = 'radar';
		                model.componentIndex = this.componentIndex;

		                return model;
		            }, this);

		            this.getIndicatorModels = function () {
		                return indicatorModels;
		            };
		        },

		        defaultOption: {

		            zlevel: 0,

		            z: 0,

		            center: ['50%', '50%'],

		            radius: '75%',

		            startAngle: 90,

		            name: {
		                show: true
		                // formatter: null
		                // textStyle: {}
		            },

		            boundaryGap: [0, 0],

		            splitNumber: 5,

		            nameGap: 15,

		            scale: false,

		            // Polygon or circle
		            shape: 'polygon',

		            axisLine: zrUtil.merge(
		                {
		                    lineStyle: {
		                        color: '#bbb'
		                    }
		                },
		                valueAxisDefault.axisLine
		            ),
		            axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
		            axisTick: defaultsShow(valueAxisDefault.axisTick, false),
		            splitLine: defaultsShow(valueAxisDefault.splitLine, true),
		            splitArea: defaultsShow(valueAxisDefault.splitArea, true),

		            // {text, min, max}
		            indicator: []
		        }
		    });

		    module.exports = RadarModel;


	/***/ },
	/* 158 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var AxisBuilder = __webpack_require__(134);
		    var zrUtil = __webpack_require__(4);
		    var graphic = __webpack_require__(43);

		    var axisBuilderAttrs = [
		        'axisLine', 'axisLabel', 'axisTick', 'axisName'
		    ];

		    module.exports = __webpack_require__(1).extendComponentView({

		        type: 'radar',

		        render: function (radarModel, ecModel, api) {
		            var group = this.group;
		            group.removeAll();

		            this._buildAxes(radarModel);
		            this._buildSplitLineAndArea(radarModel);
		        },

		        _buildAxes: function (radarModel) {
		            var radar = radarModel.coordinateSystem;
		            var indicatorAxes = radar.getIndicatorAxes();
		            var axisBuilders = zrUtil.map(indicatorAxes, function (indicatorAxis) {
		                var axisBuilder = new AxisBuilder(indicatorAxis.model, {
		                    position: [radar.cx, radar.cy],
		                    rotation: indicatorAxis.angle,
		                    labelDirection: -1,
		                    tickDirection: -1,
		                    nameDirection: 1
		                });
		                return axisBuilder;
		            });

		            zrUtil.each(axisBuilders, function (axisBuilder) {
		                zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);
		                this.group.add(axisBuilder.getGroup());
		            }, this);
		        },

		        _buildSplitLineAndArea: function (radarModel) {
		            var radar = radarModel.coordinateSystem;
		            var splitNumber = radarModel.get('splitNumber');
		            var indicatorAxes = radar.getIndicatorAxes();
		            if (!indicatorAxes.length) {
		                return;
		            }
		            var shape = radarModel.get('shape');
		            var splitLineModel = radarModel.getModel('splitLine');
		            var splitAreaModel = radarModel.getModel('splitArea');
		            var lineStyleModel = splitLineModel.getModel('lineStyle');
		            var areaStyleModel = splitAreaModel.getModel('areaStyle');

		            var showSplitLine = splitLineModel.get('show');
		            var showSplitArea = splitAreaModel.get('show');
		            var splitLineColors = lineStyleModel.get('color');
		            var splitAreaColors = areaStyleModel.get('color');

		            splitLineColors = zrUtil.isArray(splitLineColors) ? splitLineColors : [splitLineColors];
		            splitAreaColors = zrUtil.isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors];

		            var splitLines = [];
		            var splitAreas = [];

		            function getColorIndex(areaOrLine, areaOrLineColorList, idx) {
		                var colorIndex = idx % areaOrLineColorList.length;
		                areaOrLine[colorIndex] = areaOrLine[colorIndex] || [];
		                return colorIndex;
		            }

		            if (shape === 'circle') {
		                var ticksRadius = indicatorAxes[0].getTicksCoords();
		                var cx = radar.cx;
		                var cy = radar.cy;
		                for (var i = 0; i < ticksRadius.length; i++) {
		                    if (showSplitLine) {
		                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);
		                        splitLines[colorIndex].push(new graphic.Circle({
		                            shape: {
		                                cx: cx,
		                                cy: cy,
		                                r: ticksRadius[i]
		                            }
		                        }));
		                    }
		                    if (showSplitArea && i < ticksRadius.length - 1) {
		                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i);
		                        splitAreas[colorIndex].push(new graphic.Ring({
		                            shape: {
		                                cx: cx,
		                                cy: cy,
		                                r0: ticksRadius[i],
		                                r: ticksRadius[i + 1]
		                            }
		                        }));
		                    }
		                }
		            }
		            // Polyyon
		            else {
		                var axesTicksPoints = zrUtil.map(indicatorAxes, function (indicatorAxis, idx) {
		                    var ticksCoords = indicatorAxis.getTicksCoords();
		                    return zrUtil.map(ticksCoords, function (tickCoord) {
		                        return radar.coordToPoint(tickCoord, idx);
		                    });
		                });

		                var prevPoints = [];
		                for (var i = 0; i <= splitNumber; i++) {
		                    var points = [];
		                    for (var j = 0; j < indicatorAxes.length; j++) {
		                        points.push(axesTicksPoints[j][i]);
		                    }
		                    // Close
		                    if (points[0]) {
		                        points.push(points[0].slice());
		                    }
		                    else {
		                        if (true) {
		                            console.error('Can\'t draw value axis ' + i);
		                        }
		                    }
		                    if (showSplitLine) {
		                        var colorIndex = getColorIndex(splitLines, splitLineColors, i);
		                        splitLines[colorIndex].push(new graphic.Polyline({
		                            shape: {
		                                points: points
		                            }
		                        }));
		                    }
		                    if (showSplitArea && prevPoints) {
		                        var colorIndex = getColorIndex(splitAreas, splitAreaColors, i - 1);
		                        splitAreas[colorIndex].push(new graphic.Polygon({
		                            shape: {
		                                points: points.concat(prevPoints)
		                            }
		                        }));
		                    }
		                    prevPoints = points.slice().reverse();
		                }
		            }

		            var lineStyle = lineStyleModel.getLineStyle();
		            var areaStyle = areaStyleModel.getAreaStyle();
		            // Add splitArea before splitLine
		            zrUtil.each(splitAreas, function (splitAreas, idx) {
		                this.group.add(graphic.mergePath(
		                    splitAreas, {
		                        style: zrUtil.defaults({
		                            stroke: 'none',
		                            fill: splitAreaColors[idx % splitAreaColors.length]
		                        }, areaStyle),
		                        silent: true
		                    }
		                ));
		            }, this);

		            zrUtil.each(splitLines, function (splitLines, idx) {
		                this.group.add(graphic.mergePath(
		                    splitLines, {
		                        style: zrUtil.defaults({
		                            fill: 'none',
		                            stroke: splitLineColors[idx % splitLineColors.length]
		                        }, lineStyle),
		                        silent: true
		                    }
		                ));
		            }, this);

		        }
		    });


	/***/ },
	/* 159 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var SeriesModel = __webpack_require__(28);
		    var List = __webpack_require__(98);
		    var completeDimensions = __webpack_require__(103);
		    var zrUtil = __webpack_require__(4);

		    var RadarSeries = SeriesModel.extend({

		        type: 'series.radar',

		        dependencies: ['radar'],


		        // Overwrite
		        init: function (option) {
		            RadarSeries.superApply(this, 'init', arguments);

		            // Enable legend selection for each data item
		            // Use a function instead of direct access because data reference may changed
		            this.legendDataProvider = function () {
		                return this._dataBeforeProcessed;
		            };
		        },

		        getInitialData: function (option, ecModel) {
		            var data = option.data || [];
		            var dimensions = completeDimensions(
		                [], data, [], 'indicator_'
		            );
		            var list = new List(dimensions, this);
		            list.initData(data);
		            return list;
		        },

		        formatTooltip: function (dataIndex) {
		            var value = this.getRawValue(dataIndex);
		            var coordSys = this.coordinateSystem;
		            var indicatorAxes = coordSys.getIndicatorAxes();
		            return (this._data.getName(dataIndex) == '' ? this.name : this._data.getName(dataIndex)) + '<br/>'
		                + zrUtil.map(indicatorAxes, function (axis, idx) {
		                    return axis.name + ' : ' + value[idx];
		                }).join('<br />');
		        },

		        defaultOption: {
		            zlevel: 0,
		            z: 2,
		            coordinateSystem: 'radar',
		            legendHoverLink: true,
		            radarIndex: 0,
		            lineStyle: {
		                normal: {
		                    width: 2,
		                    type: 'solid'
		                }
		            },
		            label: {
		                normal: {
		                    position: 'top'
		                }
		            },
		            // areaStyle: {
		            // },
		            // itemStyle: {}
		            symbol: 'emptyCircle',
		            symbolSize: 4
		            // symbolRotate: null
		        }
		    });

		    module.exports = RadarSeries;


	/***/ },
	/* 160 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var graphic = __webpack_require__(43);
		    var zrUtil = __webpack_require__(4);
		    var symbolUtil = __webpack_require__(107);

		    function normalizeSymbolSize(symbolSize) {
		        if (!zrUtil.isArray(symbolSize)) {
		            symbolSize = [+symbolSize, +symbolSize];
		        }
		        return symbolSize;
		    }
		    module.exports = __webpack_require__(1).extendChartView({
		        type: 'radar',

		        render: function (seriesModel, ecModel, api) {
		            var polar = seriesModel.coordinateSystem;
		            var group = this.group;

		            var data = seriesModel.getData();
		            var oldData = this._data;

		            function createSymbol(data, idx) {
		                var symbolType = data.getItemVisual(idx, 'symbol') || 'circle';
		                var color = data.getItemVisual(idx, 'color');
		                if (symbolType === 'none') {
		                    return;
		                }
		                var symbolPath = symbolUtil.createSymbol(
		                    symbolType, -0.5, -0.5, 1, 1, color
		                );
		                symbolPath.attr({
		                    style: {
		                        strokeNoScale: true
		                    },
		                    z2: 100,
		                    scale: normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))
		                });
		                return symbolPath;
		            }

		            function updateSymbols(oldPoints, newPoints, symbolGroup, data, idx, isInit) {
		                // Simply rerender all
		                symbolGroup.removeAll();
		                for (var i = 0; i < newPoints.length - 1; i++) {
		                    var symbolPath = createSymbol(data, idx);
		                    if (symbolPath) {
		                        symbolPath.__dimIdx = i;
		                        if (oldPoints[i]) {
		                            symbolPath.attr('position', oldPoints[i]);
		                            graphic[isInit ? 'initProps' : 'updateProps'](
		                                symbolPath, {
		                                    position: newPoints[i]
		                                }, seriesModel, idx
		                            );
		                        }
		                        else {
		                            symbolPath.attr('position', newPoints[i]);
		                        }
		                        symbolGroup.add(symbolPath);
		                    }
		                }
		            }

		            function getInitialPoints(points) {
		                return zrUtil.map(points, function (pt) {
		                    return [polar.cx, polar.cy];
		                });
		            }
		            data.diff(oldData)
		                .add(function (idx) {
		                    var points = data.getItemLayout(idx);
		                    if (!points) {
		                        return;
		                    }
		                    var polygon = new graphic.Polygon();
		                    var polyline = new graphic.Polyline();
		                    var target = {
		                        shape: {
		                            points: points
		                        }
		                    };
		                    polygon.shape.points = getInitialPoints(points);
		                    polyline.shape.points = getInitialPoints(points);
		                    graphic.initProps(polygon, target, seriesModel, idx);
		                    graphic.initProps(polyline, target, seriesModel, idx);

		                    var itemGroup = new graphic.Group();
		                    var symbolGroup = new graphic.Group();
		                    itemGroup.add(polyline);
		                    itemGroup.add(polygon);
		                    itemGroup.add(symbolGroup);

		                    updateSymbols(
		                        polyline.shape.points, points, symbolGroup, data, idx, true
		                    );

		                    data.setItemGraphicEl(idx, itemGroup);
		                })
		                .update(function (newIdx, oldIdx) {
		                    var itemGroup = oldData.getItemGraphicEl(oldIdx);
		                    var polyline = itemGroup.childAt(0);
		                    var polygon = itemGroup.childAt(1);
		                    var symbolGroup = itemGroup.childAt(2);
		                    var target = {
		                        shape: {
		                            points: data.getItemLayout(newIdx)
		                        }
		                    };
		                    if (!target.shape.points) {
		                        return;
		                    }
		                    updateSymbols(
		                        polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false
		                    );

		                    graphic.updateProps(polyline, target, seriesModel);
		                    graphic.updateProps(polygon, target, seriesModel);

		                    data.setItemGraphicEl(newIdx, itemGroup);
		                })
		                .remove(function (idx) {
		                    group.remove(oldData.getItemGraphicEl(idx));
		                })
		                .execute();

		            data.eachItemGraphicEl(function (itemGroup, idx) {
		                var itemModel = data.getItemModel(idx);
		                var polyline = itemGroup.childAt(0);
		                var polygon = itemGroup.childAt(1);
		                var symbolGroup = itemGroup.childAt(2);
		                var color = data.getItemVisual(idx, 'color');

		                group.add(itemGroup);

		                polyline.useStyle(
		                    zrUtil.defaults(
		                        itemModel.getModel('lineStyle.normal').getLineStyle(),
		                        {
		                            fill: 'none',
		                            stroke: color
		                        }
		                    )
		                );
		                polyline.hoverStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();

		                var areaStyleModel = itemModel.getModel('areaStyle.normal');
		                var hoverAreaStyleModel = itemModel.getModel('areaStyle.emphasis');
		                var polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty();
		                var hoverPolygonIgnore = hoverAreaStyleModel.isEmpty() && hoverAreaStyleModel.parentModel.isEmpty();

		                hoverPolygonIgnore = hoverPolygonIgnore && polygonIgnore;
		                polygon.ignore = polygonIgnore;

		                polygon.useStyle(
		                    zrUtil.defaults(
		                        areaStyleModel.getAreaStyle(),
		                        {
		                            fill: color,
		                            opacity: 0.7
		                        }
		                    )
		                );
		                polygon.hoverStyle = hoverAreaStyleModel.getAreaStyle();

		                var itemStyle = itemModel.getModel('itemStyle.normal').getItemStyle(['color']);
		                var itemHoverStyle = itemModel.getModel('itemStyle.emphasis').getItemStyle();
		                var labelModel = itemModel.getModel('label.normal');
		                var labelHoverModel = itemModel.getModel('label.emphasis');
		                symbolGroup.eachChild(function (symbolPath) {
		                    symbolPath.setStyle(itemStyle);
		                    symbolPath.hoverStyle = zrUtil.clone(itemHoverStyle);

		                    var defaultText = data.get(data.dimensions[symbolPath.__dimIdx], idx);
		                    graphic.setText(symbolPath.style, labelModel, color);
		                    symbolPath.setStyle({
		                        text: labelModel.get('show') ? zrUtil.retrieve(
		                            seriesModel.getFormattedLabel(
		                                idx, 'normal', null, symbolPath.__dimIdx
		                            ),
		                            defaultText
		                        ) : ''
		                    });

		                    graphic.setText(symbolPath.hoverStyle, labelHoverModel, color);
		                    symbolPath.hoverStyle.text = labelHoverModel.get('show') ? zrUtil.retrieve(
		                        seriesModel.getFormattedLabel(
		                            idx, 'emphasis', null, symbolPath.__dimIdx
		                        ),
		                        defaultText
		                    ) : '';
		                });

		                function onEmphasis() {
		                    polygon.attr('ignore', hoverPolygonIgnore);
		                }

		                function onNormal() {
		                    polygon.attr('ignore', polygonIgnore);
		                }

		                itemGroup.off('mouseover').off('mouseout').off('normal').off('emphasis');
		                itemGroup.on('emphasis', onEmphasis)
		                    .on('mouseover', onEmphasis)
		                    .on('normal', onNormal)
		                    .on('mouseout', onNormal);

		                graphic.setHoverStyle(itemGroup);
		            });

		            this._data = data;
		        },

		        remove: function () {
		            this.group.removeAll();
		            this._data = null;
		        },

		        dispose: function () {}
		    });


	/***/ },
	/* 161 */
	/***/ function(module, exports) {

		

		    module.exports = function (ecModel) {
		        ecModel.eachSeriesByType('radar', function (seriesModel) {
		            var data = seriesModel.getData();
		            var points = [];
		            var coordSys = seriesModel.coordinateSystem;
		            if (!coordSys) {
		                return;
		            }

		            function pointsConverter(val, idx) {
		                points[idx] = points[idx] || [];
		                points[idx][i] = coordSys.dataToPoint(val, i);
		            }
		            for (var i = 0; i < coordSys.getIndicatorAxes().length; i++) {
		                var dim = data.dimensions[i];
		                data.each(dim, pointsConverter);
		            }

		            data.each(function (idx) {
		                // Close polygon
		                points[idx][0] && points[idx].push(points[idx][0].slice());
		                data.setItemLayout(idx, points[idx]);
		            });
		        });
		    };


	/***/ },
	/* 162 */
	/***/ function(module, exports, __webpack_require__) {

		// Backward compat for radar chart in 2


		    var zrUtil = __webpack_require__(4);

		    module.exports = function (option) {
		        var polarOptArr = option.polar;
		        if (polarOptArr) {
		            if (!zrUtil.isArray(polarOptArr)) {
		                polarOptArr = [polarOptArr];
		            }
		            var polarNotRadar = [];
		            zrUtil.each(polarOptArr, function (polarOpt, idx) {
		                if (polarOpt.indicator) {
		                    if (polarOpt.type && !polarOpt.shape) {
		                        polarOpt.shape = polarOpt.type;
		                    }
		                    option.radar = option.radar || [];
		                    if (!zrUtil.isArray(option.radar)) {
		                        option.radar = [option.radar];
		                    }
		                    option.radar.push(polarOpt);
		                }
		                else {
		                    polarNotRadar.push(polarOpt);
		                }
		            });
		            option.polar = polarNotRadar;
		        }
		        zrUtil.each(option.series, function (seriesOpt) {
		            if (seriesOpt.type === 'radar' && seriesOpt.polarIndex) {
		                seriesOpt.radarIndex = seriesOpt.polarIndex;
		            }
		        });
		    };


	/***/ },
	/* 163 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var echarts = __webpack_require__(1);
		    var PRIORITY = echarts.PRIORITY;

		    __webpack_require__(164);

		    __webpack_require__(174);

		    __webpack_require__(178);

		    __webpack_require__(165);

		    echarts.registerLayout(__webpack_require__(180));

		    echarts.registerVisual(__webpack_require__(181));

		    echarts.registerProcessor(PRIORITY.PROCESSOR.STATISTIC, __webpack_require__(182));

		    echarts.registerPreprocessor(__webpack_require__(183));

		    __webpack_require__(144)('map', [{
		        type: 'mapToggleSelect',
		        event: 'mapselectchanged',
		        method: 'toggleSelected'
		    }, {
		        type: 'mapSelect',
		        event: 'mapselected',
		        method: 'select'
		    }, {
		        type: 'mapUnSelect',
		        event: 'mapunselected',
		        method: 'unSelect'
		    }]);


	/***/ },
	/* 164 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var List = __webpack_require__(98);
		    var SeriesModel = __webpack_require__(28);
		    var zrUtil = __webpack_require__(4);
		    var completeDimensions = __webpack_require__(103);

		    var formatUtil = __webpack_require__(6);
		    var encodeHTML = formatUtil.encodeHTML;
		    var addCommas = formatUtil.addCommas;

		    var dataSelectableMixin = __webpack_require__(142);

		    var geoCreator = __webpack_require__(165);

		    var MapSeries = SeriesModel.extend({

		        type: 'series.map',

		        layoutMode: 'box',

		        /**
		         * Only first map series of same mapType will drawMap
		         * @type {boolean}
		         */
		        needsDrawMap: false,

		        /**
		         * Group of all map series with same mapType
		         * @type {boolean}
		         */
		        seriesGroup: [],

		        init: function (option) {

		            option = this._fillOption(option, option.map);
		            this.option = option;

		            MapSeries.superApply(this, 'init', arguments);

		            this.updateSelectedMap(option.data);
		        },

		        getInitialData: function (option) {
		            var dimensions = completeDimensions(['value'], option.data || []);

		            var list = new List(dimensions, this);

		            list.initData(option.data);

		            return list;
		        },

		        mergeOption: function (newOption) {
		            if (newOption.data) {
		                newOption = this._fillOption(newOption, this.option.map);
		            }

		            MapSeries.superCall(this, 'mergeOption', newOption);

		            this.updateSelectedMap(this.option.data);
		        },

		        _fillOption: function (option, mapName) {
		            // Shallow clone
		            option = zrUtil.extend({}, option);

		            option.data = geoCreator.getFilledRegions(option.data, mapName);

		            return option;
		        },

		        getRawValue: function (dataIndex) {
		            // Use value stored in data instead because it is calculated from multiple series
		            // FIXME Provide all value of multiple series ?
		            return this._data.get('value', dataIndex);
		        },

		        /**
		         * Get model of region
		         * @param  {string} name
		         * @return {module:echarts/model/Model}
		         */
		        getRegionModel: function (regionName) {
		            var data = this.getData();
		            return data.getItemModel(data.indexOfName(regionName));
		        },

		        /**
		         * Map tooltip formatter
		         *
		         * @param {number} dataIndex
		         */
		        formatTooltip: function (dataIndex) {
		            // FIXME orignalData and data is a bit confusing
		            var data = this.getData();
		            var formattedValue = addCommas(this.getRawValue(dataIndex));
		            var name = data.getName(dataIndex);

		            var seriesGroup = this.seriesGroup;
		            var seriesNames = [];
		            for (var i = 0; i < seriesGroup.length; i++) {
		                var otherIndex = seriesGroup[i].originalData.indexOfName(name);
		                if (!isNaN(seriesGroup[i].originalData.get('value', otherIndex))) {
		                    seriesNames.push(
		                        encodeHTML(seriesGroup[i].name)
		                    );
		                }
		            }

		            return seriesNames.join(', ') + '<br />'
		                + name + ' : ' + formattedValue;
		        },

		        /**
		         * @implement
		         */
		        getTooltipPosition: function (dataIndex) {
		            if (dataIndex != null) {
		                var name = this.getData().getName(dataIndex);
		                var geo = this.coordinateSystem;
		                var region = geo.getRegion(name);

		                return region && geo.dataToPoint(region.center);
		            }
		        },

		        setZoom: function (zoom) {
		            this.option.zoom = zoom;
		        },

		        setCenter: function (center) {
		            this.option.center = center;
		        },

		        defaultOption: {
		            // 一级层叠
		            zlevel: 0,
		            // 二级层叠
		            z: 2,
		            coordinateSystem: 'geo',
		            // 各省的 map 暂时都用中文
		            map: 'china',

		            // 'center' | 'left' | 'right' | 'x%' | {number}
		            left: 'center',
		            // 'center' | 'top' | 'bottom' | 'x%' | {number}
		            top: 'center',
		            // right
		            // bottom
		            // width:
		            // height

		            // Aspect is width / height. Inited to be geoJson bbox aspect
		            // This parameter is used for scale this aspect
		            aspectScale: 0.75,

		            ///// Layout with center and size
		            // If you wan't to put map in a fixed size box with right aspect ratio
		            // This two properties may more conveninet
		            // layoutCenter: [50%, 50%]
		            // layoutSize: 100


		            // 数值合并方式，默认加和，可选为：
		            // 'sum' | 'average' | 'max' | 'min'
		            // mapValueCalculation: 'sum',
		            // 地图数值计算结果小数精度
		            // mapValuePrecision: 0,


		            // 显示图例颜色标识（系列标识的小圆点），图例开启时有效
		            showLegendSymbol: true,
		            // 选择模式，默认关闭，可选single，multiple
		            // selectedMode: false,
		            dataRangeHoverLink: true,
		            // 是否开启缩放及漫游模式
		            // roam: false,

		            // Default on center of map
		            center: null,

		            zoom: 1,

		            scaleLimit: null,

		            label: {
		                normal: {
		                    show: false,
		                    textStyle: {
		                        color: '#000'
		                    }
		                },
		                emphasis: {
		                    show: true,
		                    textStyle: {
		                        color: 'rgb(100,0,0)'
		                    }
		                }
		            },
		            // scaleLimit: null,
		            itemStyle: {
		                normal: {
		                    // color: 各异,
		                    borderWidth: 0.5,
		                    borderColor: '#444',
		                    areaColor: '#eee'
		                },
		                // 也是选中样式
		                emphasis: {
		                    areaColor: 'rgba(255,215,0,0.8)'
		                }
		            }
		        }

		    });

		    zrUtil.mixin(MapSeries, dataSelectableMixin);

		    module.exports = MapSeries;


	/***/ },
	/* 165 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var Geo = __webpack_require__(166);

		    var layout = __webpack_require__(21);
		    var zrUtil = __webpack_require__(4);
		    var numberUtil = __webpack_require__(7);

		    var mapDataStores = {};

		    /**
		     * Resize method bound to the geo
		     * @param {module:echarts/coord/geo/GeoModel|module:echarts/chart/map/MapModel} geoModel
		     * @param {module:echarts/ExtensionAPI} api
		     */
		    function resizeGeo (geoModel, api) {
		        var rect = this.getBoundingRect();

		        var boxLayoutOption;

		        var center = geoModel.get('layoutCenter');
		        var size = geoModel.get('layoutSize');

		        var viewWidth = api.getWidth();
		        var viewHeight = api.getHeight();

		        var aspectScale = geoModel.get('aspectScale') || 0.75;
		        var aspect = rect.width / rect.height * aspectScale;

		        var useCenterAndSize = false;
		        if (center && size) {
		            center = [
		                numberUtil.parsePercent(center[0], viewWidth),
		                numberUtil.parsePercent(center[1], viewHeight)
		            ];
		            size = numberUtil.parsePercent(size, Math.min(viewWidth, viewHeight));

		            if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {
		                useCenterAndSize = true;
		            }
		            else {
		                if (true) {
		                    console.warn('Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.');
		                }
		            }
		        }

		        var viewRect;
		        if (useCenterAndSize) {
		            var viewRect = {};
		            if (aspect > 1) {
		                // Width is same with size
		                viewRect.width = size;
		                viewRect.height = size / aspect;
		            }
		            else {
		                viewRect.height = size;
		                viewRect.width = size * aspect;
		            }
		            viewRect.y = center[1] - viewRect.height / 2;
		            viewRect.x = center[0] - viewRect.width / 2;
		        }
		        else {
		            // Use left/top/width/height
		            boxLayoutOption = geoModel.getBoxLayoutParams();

		            // 0.75 rate
		            boxLayoutOption.aspect = aspect;

		            viewRect = layout.getLayoutRect(boxLayoutOption, {
		                width: viewWidth,
		                height: viewHeight
		            });
		        }

		        this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height);

		        this.setCenter(geoModel.get('center'));
		        this.setZoom(geoModel.get('zoom'));
		    }

		    /**
		     * @param {module:echarts/coord/Geo} geo
		     * @param {module:echarts/model/Model} model
		     * @inner
		     */
		    function setGeoCoords(geo, model) {
		        zrUtil.each(model.get('geoCoord'), function (geoCoord, name) {
		            geo.addGeoCoord(name, geoCoord);
		        });
		    }

		    if (true) {
		        var mapNotExistsError = function (name) {
		            console.error('Map ' + name + ' not exists. You can download map file on http://echarts.baidu.com/download-map.html');
		        };
		    }

		    var geoCreator = {

		        // For deciding which dimensions to use when creating list data
		        dimensions: Geo.prototype.dimensions,

		        create: function (ecModel, api) {
		            var geoList = [];

		            // FIXME Create each time may be slow
		            ecModel.eachComponent('geo', function (geoModel, idx) {
		                var name = geoModel.get('map');
		                var mapData = mapDataStores[name];
		                if (true) {
		                    if (!mapData) {
		                        mapNotExistsError(name);
		                    }
		                }
		                var geo = new Geo(
		                    name + idx, name,
		                    mapData && mapData.geoJson, mapData && mapData.specialAreas,
		                    geoModel.get('nameMap')
		                );
		                geo.zoomLimit = geoModel.get('scaleLimit');
		                geoList.push(geo);

		                setGeoCoords(geo, geoModel);

		                geoModel.coordinateSystem = geo;
		                geo.model = geoModel;

		                // Inject resize method
		                geo.resize = resizeGeo;

		                geo.resize(geoModel, api);
		            });

		            ecModel.eachSeries(function (seriesModel) {
		                var coordSys = seriesModel.get('coordinateSystem');
		                if (coordSys === 'geo') {
		                    var geoIndex = seriesModel.get('geoIndex') || 0;
		                    seriesModel.coordinateSystem = geoList[geoIndex];
		                }
		            });

		            // If has map series
		            var mapModelGroupBySeries = {};

		            ecModel.eachSeriesByType('map', function (seriesModel) {
		                var mapType = seriesModel.get('map');

		                mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || [];

		                mapModelGroupBySeries[mapType].push(seriesModel);
		            });

		            zrUtil.each(mapModelGroupBySeries, function (mapSeries, mapType) {
		                var mapData = mapDataStores[mapType];
		                if (true) {
		                    if (!mapData) {
		                        mapNotExistsError(mapSeries[0].get('map'));
		                    }
		                }

		                var nameMapList = zrUtil.map(mapSeries, function (singleMapSeries) {
		                    return singleMapSeries.get('nameMap');
		                });
		                var geo = new Geo(
		                    mapType, mapType,
		                    mapData && mapData.geoJson, mapData && mapData.specialAreas,
		                    zrUtil.mergeAll(nameMapList)
		                );
		                geo.zoomLimit = zrUtil.retrieve.apply(null, zrUtil.map(mapSeries, function (singleMapSeries) {
		                    return singleMapSeries.get('scaleLimit');
		                }));
		                geoList.push(geo);

		                // Inject resize method
		                geo.resize = resizeGeo;

		                geo.resize(mapSeries[0], api);

		                zrUtil.each(mapSeries, function (singleMapSeries) {
		                    singleMapSeries.coordinateSystem = geo;

		                    setGeoCoords(geo, singleMapSeries);
		                });
		            });

		            return geoList;
		        },

		        /**
		         * @param {string} mapName
		         * @param {Object|string} geoJson
		         * @param {Object} [specialAreas]
		         *
		         * @example
		         *     $.get('USA.json', function (geoJson) {
		         *         echarts.registerMap('USA', geoJson);
		         *         // Or
		         *         echarts.registerMap('USA', {
		         *             geoJson: geoJson,
		         *             specialAreas: {}
		         *         })
		         *     });
		         */
		        registerMap: function (mapName, geoJson, specialAreas) {
		            if (geoJson.geoJson && !geoJson.features) {
		                specialAreas = geoJson.specialAreas;
		                geoJson = geoJson.geoJson;
		            }
		            if (typeof geoJson === 'string') {
		                geoJson = (typeof JSON !== 'undefined' && JSON.parse)
		                    ? JSON.parse(geoJson) : (new Function('return (' + geoJson + ');'))();
		            }
		            mapDataStores[mapName] = {
		                geoJson: geoJson,
		                specialAreas: specialAreas
		            };
		        },

		        /**
		         * @param {string} mapName
		         * @return {Object}
		         */
		        getMap: function (mapName) {
		            return mapDataStores[mapName];
		        },

		        /**
		         * Fill given regions array
		         * @param  {Array.<Object>} originRegionArr
		         * @param  {string} mapName
		         * @return {Array}
		         */
		        getFilledRegions: function (originRegionArr, mapName) {
		            // Not use the original
		            var regionsArr = (originRegionArr || []).slice();

		            var map = geoCreator.getMap(mapName);
		            var geoJson = map && map.geoJson;
		            if (!geoJson) {
		                if (true) {
		                    mapNotExistsError(mapName);
		                }
		                return originRegionArr;
		            }

		            var dataNameMap = {};
		            var features = geoJson.features;
		            for (var i = 0; i < regionsArr.length; i++) {
		                dataNameMap[regionsArr[i].name] = regionsArr[i];
		            }

		            for (var i = 0; i < features.length; i++) {
		                var name = features[i].properties.name;
		                if (!dataNameMap[name]) {
		                    regionsArr.push({
		                        name: name
		                    });
		                }
		            }
		            return regionsArr;
		        }
		    };

		    // Inject methods into echarts
		    var echarts = __webpack_require__(1);

		    echarts.registerMap = geoCreator.registerMap;

		    echarts.getMap = geoCreator.getMap;

		    // TODO
		    echarts.loadMap = function () {};

		    echarts.registerCoordinateSystem('geo', geoCreator);

		    module.exports = geoCreator;


	/***/ },
	/* 166 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var parseGeoJson = __webpack_require__(167);

		    var zrUtil = __webpack_require__(4);

		    var BoundingRect = __webpack_require__(9);

		    var View = __webpack_require__(170);


		    // Geo fix functions
		    var geoFixFuncs = [
		        __webpack_require__(171),
		        __webpack_require__(172),
		        __webpack_require__(173)
		    ];

		    /**
		     * [Geo description]
		     * @param {string} name Geo name
		     * @param {string} map Map type
		     * @param {Object} geoJson
		     * @param {Object} [specialAreas]
		     *        Specify the positioned areas by left, top, width, height
		     * @param {Object.<string, string>} [nameMap]
		     *        Specify name alias
		     */
		    function Geo(name, map, geoJson, specialAreas, nameMap) {

		        View.call(this, name);

		        /**
		         * Map type
		         * @type {string}
		         */
		        this.map = map;

		        this._nameCoordMap = {};

		        this.loadGeoJson(geoJson, specialAreas, nameMap);
		    }

		    Geo.prototype = {

		        constructor: Geo,

		        type: 'geo',

		        /**
		         * @param {Array.<string>}
		         * @readOnly
		         */
		        dimensions: ['lng', 'lat'],

		        /**
		         * If contain given lng,lat coord
		         * @param {Array.<number>}
		         * @readOnly
		         */
		        containCoord: function (coord) {
		            var regions = this.regions;
		            for (var i = 0; i < regions.length; i++) {
		                if (regions[i].contain(coord)) {
		                    return true;
		                }
		            }
		            return false;
		        },
		        /**
		         * @param {Object} geoJson
		         * @param {Object} [specialAreas]
		         *        Specify the positioned areas by left, top, width, height
		         * @param {Object.<string, string>} [nameMap]
		         *        Specify name alias
		         */
		        loadGeoJson: function (geoJson, specialAreas, nameMap) {
		            // https://jsperf.com/try-catch-performance-overhead
		            try {
		                this.regions = geoJson ? parseGeoJson(geoJson) : [];
		            }
		            catch (e) {
		                throw 'Invalid geoJson format\n' + e;
		            }
		            specialAreas = specialAreas || {};
		            nameMap = nameMap || {};
		            var regions = this.regions;
		            var regionsMap = {};
		            for (var i = 0; i < regions.length; i++) {
		                var regionName = regions[i].name;
		                // Try use the alias in nameMap
		                regionName = nameMap[regionName] || regionName;
		                regions[i].name = regionName;

		                regionsMap[regionName] = regions[i];
		                // Add geoJson
		                this.addGeoCoord(regionName, regions[i].center);

		                // Some area like Alaska in USA map needs to be tansformed
		                // to look better
		                var specialArea = specialAreas[regionName];
		                if (specialArea) {
		                    regions[i].transformTo(
		                        specialArea.left, specialArea.top, specialArea.width, specialArea.height
		                    );
		                }
		            }

		            this._regionsMap = regionsMap;

		            this._rect = null;

		            zrUtil.each(geoFixFuncs, function (fixFunc) {
		                fixFunc(this);
		            }, this);
		        },

		        // Overwrite
		        transformTo: function (x, y, width, height) {
		            var rect = this.getBoundingRect();

		            rect = rect.clone();
		            // Longitute is inverted
		            rect.y = -rect.y - rect.height;

		            var viewTransform = this._viewTransform;

		            viewTransform.transform = rect.calculateTransform(
		                new BoundingRect(x, y, width, height)
		            );

		            viewTransform.decomposeTransform();

		            var scale = viewTransform.scale;
		            scale[1] = -scale[1];

		            viewTransform.updateTransform();

		            this._updateTransform();
		        },

		        /**
		         * @param {string} name
		         * @return {module:echarts/coord/geo/Region}
		         */
		        getRegion: function (name) {
		            return this._regionsMap[name];
		        },

		        getRegionByCoord: function (coord) {
		            var regions = this.regions;
		            for (var i = 0; i < regions.length; i++) {
		                if (regions[i].contain(coord)) {
		                    return regions[i];
		                }
		            }
		        },

		        /**
		         * Add geoCoord for indexing by name
		         * @param {string} name
		         * @param {Array.<number>} geoCoord
		         */
		        addGeoCoord: function (name, geoCoord) {
		            this._nameCoordMap[name] = geoCoord;
		        },

		        /**
		         * Get geoCoord by name
		         * @param {string} name
		         * @return {Array.<number>}
		         */
		        getGeoCoord: function (name) {
		            return this._nameCoordMap[name];
		        },

		        // Overwrite
		        getBoundingRect: function () {
		            if (this._rect) {
		                return this._rect;
		            }
		            var rect;

		            var regions = this.regions;
		            for (var i = 0; i < regions.length; i++) {
		                var regionRect = regions[i].getBoundingRect();
		                rect = rect || regionRect.clone();
		                rect.union(regionRect);
		            }
		            // FIXME Always return new ?
		            return (this._rect = rect || new BoundingRect(0, 0, 0, 0));
		        },

		        /**
		         * Convert series data to a list of points
		         * @param {module:echarts/data/List} data
		         * @param {boolean} stack
		         * @return {Array}
		         *  Return list of points. For example:
		         *  `[[10, 10], [20, 20], [30, 30]]`
		         */
		        dataToPoints: function (data) {
		            var item = [];
		            return data.mapArray(['lng', 'lat'], function (lon, lat) {
		                item[0] = lon;
		                item[1] = lat;
		                return this.dataToPoint(item);
		            }, this);
		        },

		        // Overwrite
		        /**
		         * @param {string|Array.<number>} data
		         * @return {Array.<number>}
		         */
		        dataToPoint: function (data) {
		            if (typeof data === 'string') {
		                // Map area name to geoCoord
		                data = this.getGeoCoord(data);
		            }
		            if (data) {
		                return View.prototype.dataToPoint.call(this, data);
		            }
		        },

		        /**
		         * @override
		         * @implements
		         * see {module:echarts/CoodinateSystem}
		         */
		        convertToPixel: zrUtil.curry(doConvert, 'dataToPoint'),

		        /**
		         * @override
		         * @implements
		         * see {module:echarts/CoodinateSystem}
		         */
		        convertFromPixel: zrUtil.curry(doConvert, 'pointToData')

		    };

		    zrUtil.mixin(Geo, View);

		    function doConvert(methodName, ecModel, finder, value) {
		        var geoModel = finder.geoModel;
		        var seriesModel = finder.seriesModel;

		        var coordSys = geoModel
		            ? geoModel.coordinateSystem
		            : seriesModel
		            ? (
		                seriesModel.coordinateSystem // For map.
		                || (seriesModel.getReferringComponents('geo')[0] || {}).coordinateSystem
		            )
		            : null;

		        return coordSys === this ? coordSys[methodName](value) : null;
		    }

		    module.exports = Geo;


	/***/ },
	/* 167 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Parse and decode geo json
		 * @module echarts/coord/geo/parseGeoJson
		 */


		    var zrUtil = __webpack_require__(4);

		    var Region = __webpack_require__(168);

		    function decode(json) {
		        if (!json.UTF8Encoding) {
		            return json;
		        }
		        var features = json.features;

		        for (var f = 0; f < features.length; f++) {
		            var feature = features[f];
		            var geometry = feature.geometry;
		            var coordinates = geometry.coordinates;
		            var encodeOffsets = geometry.encodeOffsets;

		            for (var c = 0; c < coordinates.length; c++) {
		                var coordinate = coordinates[c];

		                if (geometry.type === 'Polygon') {
		                    coordinates[c] = decodePolygon(
		                        coordinate,
		                        encodeOffsets[c]
		                    );
		                }
		                else if (geometry.type === 'MultiPolygon') {
		                    for (var c2 = 0; c2 < coordinate.length; c2++) {
		                        var polygon = coordinate[c2];
		                        coordinate[c2] = decodePolygon(
		                            polygon,
		                            encodeOffsets[c][c2]
		                        );
		                    }
		                }
		            }
		        }
		        // Has been decoded
		        json.UTF8Encoding = false;
		        return json;
		    }

		    function decodePolygon(coordinate, encodeOffsets) {
		        var result = [];
		        var prevX = encodeOffsets[0];
		        var prevY = encodeOffsets[1];

		        for (var i = 0; i < coordinate.length; i += 2) {
		            var x = coordinate.charCodeAt(i) - 64;
		            var y = coordinate.charCodeAt(i + 1) - 64;
		            // ZigZag decoding
		            x = (x >> 1) ^ (-(x & 1));
		            y = (y >> 1) ^ (-(y & 1));
		            // Delta deocding
		            x += prevX;
		            y += prevY;

		            prevX = x;
		            prevY = y;
		            // Dequantize
		            result.push([x / 1024, y / 1024]);
		        }

		        return result;
		    }

		    /**
		     * @inner
		     */
		    function flattern2D(array) {
		        var ret = [];
		        for (var i = 0; i < array.length; i++) {
		            for (var k = 0; k < array[i].length; k++) {
		                ret.push(array[i][k]);
		            }
		        }
		        return ret;
		    }

		    /**
		     * @alias module:echarts/coord/geo/parseGeoJson
		     * @param {Object} geoJson
		     * @return {module:zrender/container/Group}
		     */
		    module.exports = function (geoJson) {

		        decode(geoJson);

		        return zrUtil.map(zrUtil.filter(geoJson.features, function (featureObj) {
		            // Output of mapshaper may have geometry null
		            return featureObj.geometry && featureObj.properties;
		        }), function (featureObj) {
		            var properties = featureObj.properties;
		            var geometry = featureObj.geometry;

		            var coordinates = geometry.coordinates;

		            if (geometry.type === 'MultiPolygon') {
		                coordinates = flattern2D(coordinates);
		            }

		            return new Region(
		                properties.name,
		                coordinates,
		                properties.cp
		            );
		        });
		    };


	/***/ },
	/* 168 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/coord/geo/Region
		 */


		    var polygonContain = __webpack_require__(169);

		    var BoundingRect = __webpack_require__(9);

		    var bbox = __webpack_require__(51);
		    var vec2 = __webpack_require__(10);

		    /**
		     * @param {string} name
		     * @param {Array} contours
		     * @param {Array.<number>} cp
		     */
		    function Region(name, contours, cp) {

		        /**
		         * @type {string}
		         * @readOnly
		         */
		        this.name = name;

		        /**
		         * @type {Array.<Array>}
		         * @readOnly
		         */
		        this.contours = contours;

		        if (!cp) {
		            var rect = this.getBoundingRect();
		            cp = [
		                rect.x + rect.width / 2,
		                rect.y + rect.height / 2
		            ];
		        }
		        else {
		            cp = [cp[0], cp[1]];
		        }
		        /**
		         * @type {Array.<number>}
		         */
		        this.center = cp;
		    }

		    Region.prototype = {

		        constructor: Region,

		        /**
		         * @return {module:zrender/core/BoundingRect}
		         */
		        getBoundingRect: function () {
		            var rect = this._rect;
		            if (rect) {
		                return rect;
		            }

		            var MAX_NUMBER = Number.MAX_VALUE;
		            var min = [MAX_NUMBER, MAX_NUMBER];
		            var max = [-MAX_NUMBER, -MAX_NUMBER];
		            var min2 = [];
		            var max2 = [];
		            var contours = this.contours;
		            for (var i = 0; i < contours.length; i++) {
		                bbox.fromPoints(contours[i], min2, max2);
		                vec2.min(min, min, min2);
		                vec2.max(max, max, max2);
		            }
		            // No data
		            if (i === 0) {
		                min[0] = min[1] = max[0] = max[1] = 0;
		            }

		            return (this._rect = new BoundingRect(
		                min[0], min[1], max[0] - min[0], max[1] - min[1]
		            ));
		        },

		        /**
		         * @param {<Array.<number>} coord
		         * @return {boolean}
		         */
		        contain: function (coord) {
		            var rect = this.getBoundingRect();
		            var contours = this.contours;
		            if (rect.contain(coord[0], coord[1])) {
		                for (var i = 0, len = contours.length; i < len; i++) {
		                    if (polygonContain.contain(contours[i], coord[0], coord[1])) {
		                        return true;
		                    }
		                }
		            }
		            return false;
		        },

		        transformTo: function (x, y, width, height) {
		            var rect = this.getBoundingRect();
		            var aspect = rect.width / rect.height;
		            if (!width) {
		                width = aspect * height;
		            }
		            else if (!height) {
		                height = width / aspect ;
		            }
		            var target = new BoundingRect(x, y, width, height);
		            var transform = rect.calculateTransform(target);
		            var contours = this.contours;
		            for (var i = 0; i < contours.length; i++) {
		                for (var p = 0; p < contours[i].length; p++) {
		                    vec2.applyTransform(contours[i][p], contours[i][p], transform);
		                }
		            }
		            rect = this._rect;
		            rect.copy(target);
		            // Update center
		            this.center = [
		                rect.x + rect.width / 2,
		                rect.y + rect.height / 2
		            ];
		        }
		    };

		    module.exports = Region;


	/***/ },
	/* 169 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var windingLine = __webpack_require__(58);

		    var EPSILON = 1e-8;

		    function isAroundEqual(a, b) {
		        return Math.abs(a - b) < EPSILON;
		    }

		    function contain(points, x, y) {
		        var w = 0;
		        var p = points[0];

		        if (!p) {
		            return false;
		        }

		        for (var i = 1; i < points.length; i++) {
		            var p2 = points[i];
		            w += windingLine(p[0], p[1], p2[0], p2[1], x, y);
		            p = p2;
		        }

		        // Close polygon
		        var p0 = points[0];
		        if (!isAroundEqual(p[0], p0[0]) || !isAroundEqual(p[1], p0[1])) {
		            w += windingLine(p[0], p[1], p0[0], p0[1], x, y);
		        }

		        return w !== 0;
		    }


		    module.exports = {
		        contain: contain
		    };


	/***/ },
	/* 170 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Simple view coordinate system
		 * Mapping given x, y to transformd view x, y
		 */


		    var vector = __webpack_require__(10);
		    var matrix = __webpack_require__(11);

		    var Transformable = __webpack_require__(34);
		    var zrUtil = __webpack_require__(4);

		    var BoundingRect = __webpack_require__(9);

		    var v2ApplyTransform = vector.applyTransform;

		    // Dummy transform node
		    function TransformDummy() {
		        Transformable.call(this);
		    }
		    zrUtil.mixin(TransformDummy, Transformable);

		    function View(name) {
		        /**
		         * @type {string}
		         */
		        this.name = name;

		        /**
		         * @type {Object}
		         */
		        this.zoomLimit;

		        Transformable.call(this);

		        this._roamTransform = new TransformDummy();

		        this._viewTransform = new TransformDummy();

		        this._center;
		        this._zoom;
		    }

		    View.prototype = {

		        constructor: View,

		        type: 'view',

		        /**
		         * @param {Array.<string>}
		         * @readOnly
		         */
		        dimensions: ['x', 'y'],

		        /**
		         * Set bounding rect
		         * @param {number} x
		         * @param {number} y
		         * @param {number} width
		         * @param {number} height
		         */

		        // PENDING to getRect
		        setBoundingRect: function (x, y, width, height) {
		            this._rect = new BoundingRect(x, y, width, height);
		            return this._rect;
		        },

		        /**
		         * @return {module:zrender/core/BoundingRect}
		         */
		        // PENDING to getRect
		        getBoundingRect: function () {
		            return this._rect;
		        },

		        /**
		         * @param {number} x
		         * @param {number} y
		         * @param {number} width
		         * @param {number} height
		         */
		        setViewRect: function (x, y, width, height) {
		            this.transformTo(x, y, width, height);
		            this._viewRect = new BoundingRect(x, y, width, height);
		        },

		        /**
		         * Transformed to particular position and size
		         * @param {number} x
		         * @param {number} y
		         * @param {number} width
		         * @param {number} height
		         */
		        transformTo: function (x, y, width, height) {
		            var rect = this.getBoundingRect();
		            var viewTransform = this._viewTransform;

		            viewTransform.transform = rect.calculateTransform(
		                new BoundingRect(x, y, width, height)
		            );

		            viewTransform.decomposeTransform();

		            this._updateTransform();
		        },

		        /**
		         * Set center of view
		         * @param {Array.<number>} [centerCoord]
		         */
		        setCenter: function (centerCoord) {
		            if (!centerCoord) {
		                return;
		            }
		            this._center = centerCoord;

		            this._updateCenterAndZoom();
		        },

		        /**
		         * @param {number} zoom
		         */
		        setZoom: function (zoom) {
		            zoom = zoom || 1;

		            var zoomLimit = this.zoomLimit;
		            if (zoomLimit) {
		                if (zoomLimit.max != null) {
		                    zoom = Math.min(zoomLimit.max, zoom);
		                }
		                if (zoomLimit.min != null) {
		                    zoom = Math.max(zoomLimit.min, zoom);
		                }
		            }
		            this._zoom = zoom;

		            this._updateCenterAndZoom();
		        },

		        /**
		         * Get default center without roam
		         */
		        getDefaultCenter: function () {
		            // Rect before any transform
		            var rawRect = this.getBoundingRect();
		            var cx = rawRect.x + rawRect.width / 2;
		            var cy = rawRect.y + rawRect.height / 2;

		            return [cx, cy];
		        },

		        getCenter: function () {
		            return this._center || this.getDefaultCenter();
		        },

		        getZoom: function () {
		            return this._zoom || 1;
		        },

		        /**
		         * @return {Array.<number}
		         */
		        getRoamTransform: function () {
		            return this._roamTransform;
		        },

		        _updateCenterAndZoom: function () {
		            // Must update after view transform updated
		            var viewTransformMatrix = this._viewTransform.getLocalTransform();
		            var roamTransform = this._roamTransform;
		            var defaultCenter = this.getDefaultCenter();
		            var center = this.getCenter();
		            var zoom = this.getZoom();

		            center = vector.applyTransform([], center, viewTransformMatrix);
		            defaultCenter = vector.applyTransform([], defaultCenter, viewTransformMatrix);

		            roamTransform.origin = center;
		            roamTransform.position = [
		                defaultCenter[0] - center[0],
		                defaultCenter[1] - center[1]
		            ];
		            roamTransform.scale = [zoom, zoom];

		            this._updateTransform();
		        },

		        /**
		         * Update transform from roam and mapLocation
		         * @private
		         */
		        _updateTransform: function () {
		            var roamTransform = this._roamTransform;
		            var viewTransform = this._viewTransform;

		            viewTransform.parent = roamTransform;
		            roamTransform.updateTransform();
		            viewTransform.updateTransform();

		            viewTransform.transform
		                && matrix.copy(this.transform || (this.transform = []), viewTransform.transform);

		            if (this.transform) {
		                this.invTransform = this.invTransform || [];
		                matrix.invert(this.invTransform, this.transform);
		            }
		            else {
		                this.invTransform = null;
		            }
		            this.decomposeTransform();
		        },

		        /**
		         * @return {module:zrender/core/BoundingRect}
		         */
		        getViewRect: function () {
		            return this._viewRect;
		        },

		        /**
		         * Get view rect after roam transform
		         * @return {module:zrender/core/BoundingRect}
		         */
		        getViewRectAfterRoam: function () {
		            var rect = this.getBoundingRect().clone();
		            rect.applyTransform(this.transform);
		            return rect;
		        },

		        /**
		         * Convert a single (lon, lat) data item to (x, y) point.
		         * @param {Array.<number>} data
		         * @return {Array.<number>}
		         */
		        dataToPoint: function (data) {
		            var transform = this.transform;
		            return transform
		                ? v2ApplyTransform([], data, transform)
		                : [data[0], data[1]];
		        },

		        /**
		         * Convert a (x, y) point to (lon, lat) data
		         * @param {Array.<number>} point
		         * @return {Array.<number>}
		         */
		        pointToData: function (point) {
		            var invTransform = this.invTransform;
		            return invTransform
		                ? v2ApplyTransform([], point, invTransform)
		                : [point[0], point[1]];
		        },

		        /**
		         * @implements
		         * see {module:echarts/CoodinateSystem}
		         */
		        convertToPixel: zrUtil.curry(doConvert, 'dataToPoint'),

		        /**
		         * @implements
		         * see {module:echarts/CoodinateSystem}
		         */
		        convertFromPixel: zrUtil.curry(doConvert, 'pointToData'),

		        /**
		         * @implements
		         * see {module:echarts/CoodinateSystem}
		         */
		        containPoint: function (point) {
		            return this.getViewRectAfterRoam().contain(point[0], point[1]);
		        }

		        /**
		         * @return {number}
		         */
		        // getScalarScale: function () {
		        //     // Use determinant square root of transform to mutiply scalar
		        //     var m = this.transform;
		        //     var det = Math.sqrt(Math.abs(m[0] * m[3] - m[2] * m[1]));
		        //     return det;
		        // }
		    };

		    zrUtil.mixin(View, Transformable);

		    function doConvert(methodName, ecModel, finder, value) {
		        var seriesModel = finder.seriesModel;
		        var coordSys = seriesModel ? seriesModel.coordinateSystem : null; // e.g., graph.
		        return coordSys === this ? coordSys[methodName](value) : null;
		    }

		    module.exports = View;


	/***/ },
	/* 171 */
	/***/ function(module, exports, __webpack_require__) {

		// Fix for 南海诸岛


		    var Region = __webpack_require__(168);

		    var geoCoord = [126, 25];

		    var points = [
		        [[0,3.5],[7,11.2],[15,11.9],[30,7],[42,0.7],[52,0.7],
		         [56,7.7],[59,0.7],[64,0.7],[64,0],[5,0],[0,3.5]],
		        [[13,16.1],[19,14.7],[16,21.7],[11,23.1],[13,16.1]],
		        [[12,32.2],[14,38.5],[15,38.5],[13,32.2],[12,32.2]],
		        [[16,47.6],[12,53.2],[13,53.2],[18,47.6],[16,47.6]],
		        [[6,64.4],[8,70],[9,70],[8,64.4],[6,64.4]],
		        [[23,82.6],[29,79.8],[30,79.8],[25,82.6],[23,82.6]],
		        [[37,70.7],[43,62.3],[44,62.3],[39,70.7],[37,70.7]],
		        [[48,51.1],[51,45.5],[53,45.5],[50,51.1],[48,51.1]],
		        [[51,35],[51,28.7],[53,28.7],[53,35],[51,35]],
		        [[52,22.4],[55,17.5],[56,17.5],[53,22.4],[52,22.4]],
		        [[58,12.6],[62,7],[63,7],[60,12.6],[58,12.6]],
		        [[0,3.5],[0,93.1],[64,93.1],[64,0],[63,0],[63,92.4],
		         [1,92.4],[1,3.5],[0,3.5]]
		    ];
		    for (var i = 0; i < points.length; i++) {
		        for (var k = 0; k < points[i].length; k++) {
		            points[i][k][0] /= 10.5;
		            points[i][k][1] /= -10.5 / 0.75;

		            points[i][k][0] += geoCoord[0];
		            points[i][k][1] += geoCoord[1];
		        }
		    }
		    module.exports = function (geo) {
		        if (geo.map === 'china') {
		            geo.regions.push(new Region(
		                '南海诸岛', points, geoCoord
		            ));
		        }
		    };


	/***/ },
	/* 172 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    var coordsOffsetMap = {
		        '南海诸岛' : [32, 80],
		        // 全国
		        '广东': [0, -10],
		        '香港': [10, 5],
		        '澳门': [-10, 10],
		        //'北京': [-10, 0],
		        '天津': [5, 5]
		    };

		    module.exports = function (geo) {
		        zrUtil.each(geo.regions, function (region) {
		            var coordFix = coordsOffsetMap[region.name];
		            if (coordFix) {
		                var cp = region.center;
		                cp[0] += coordFix[0] / 10.5;
		                cp[1] += -coordFix[1] / (10.5 / 0.75);
		            }
		        });
		    };


	/***/ },
	/* 173 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    var geoCoordMap = {
		        'Russia': [100, 60],
		        'United States of America': [-99, 38]
		    };

		    module.exports = function (geo) {
		        zrUtil.each(geo.regions, function (region) {
		            var geoCoord = geoCoordMap[region.name];
		            if (geoCoord) {
		                var cp = region.center;
		                cp[0] = geoCoord[0];
		                cp[1] = geoCoord[1];
		            }
		        });
		    };


	/***/ },
	/* 174 */
	/***/ function(module, exports, __webpack_require__) {

		

		    // var zrUtil = require('zrender/lib/core/util');
		    var graphic = __webpack_require__(43);

		    var MapDraw = __webpack_require__(175);

		    __webpack_require__(1).extendChartView({

		        type: 'map',

		        render: function (mapModel, ecModel, api, payload) {
		            // Not render if it is an toggleSelect action from self
		            if (payload && payload.type === 'mapToggleSelect'
		                && payload.from === this.uid
		            ) {
		                return;
		            }

		            var group = this.group;
		            group.removeAll();
		            // Not update map if it is an roam action from self
		            if (!(payload && payload.type === 'geoRoam'
		                && payload.componentType === 'series'
		                && payload.seriesId === mapModel.id)) {

		                if (mapModel.needsDrawMap) {
		                    var mapDraw = this._mapDraw || new MapDraw(api, true);
		                    group.add(mapDraw.group);

		                    mapDraw.draw(mapModel, ecModel, api, this, payload);

		                    this._mapDraw = mapDraw;
		                }
		                else {
		                    // Remove drawed map
		                    this._mapDraw && this._mapDraw.remove();
		                    this._mapDraw = null;
		                }
		            }
		            else {
		                var mapDraw = this._mapDraw;
		                mapDraw && group.add(mapDraw.group);
		            }

		            mapModel.get('showLegendSymbol') && ecModel.getComponent('legend')
		                && this._renderSymbols(mapModel, ecModel, api);
		        },

		        remove: function () {
		            this._mapDraw && this._mapDraw.remove();
		            this._mapDraw = null;
		            this.group.removeAll();
		        },

		        dispose: function () {
		            this._mapDraw && this._mapDraw.remove();
		            this._mapDraw = null;
		        },

		        _renderSymbols: function (mapModel, ecModel, api) {
		            var originalData = mapModel.originalData;
		            var group = this.group;

		            originalData.each('value', function (value, idx) {
		                if (isNaN(value)) {
		                    return;
		                }

		                var layout = originalData.getItemLayout(idx);

		                if (!layout || !layout.point) {
		                    // Not exists in map
		                    return;
		                }

		                var point = layout.point;
		                var offset = layout.offset;

		                var circle = new graphic.Circle({
		                    style: {
		                        // Because the special of map draw.
		                        // Which needs statistic of multiple series and draw on one map.
		                        // And each series also need a symbol with legend color
		                        //
		                        // Layout and visual are put one the different data
		                        fill: mapModel.getData().getVisual('color')
		                    },
		                    shape: {
		                        cx: point[0] + offset * 9,
		                        cy: point[1],
		                        r: 3
		                    },
		                    silent: true,
		                    z2: 10
		                });

		                // First data on the same region
		                if (!offset) {
		                    var fullData = mapModel.mainSeries.getData();
		                    var name = originalData.getName(idx);
		                    var labelText = name;
		                    var fullIndex = fullData.indexOfName(name);

		                    var itemModel = originalData.getItemModel(idx);
		                    var labelModel = itemModel.getModel('label.normal');
		                    var hoverLabelModel = itemModel.getModel('label.emphasis');

		                    var textStyleModel = labelModel.getModel('textStyle');
		                    var hoverTextStyleModel = hoverLabelModel.getModel('textStyle');

		                    var polygonGroups = fullData.getItemGraphicEl(fullIndex);
		                    circle.setStyle({
		                        textPosition: 'bottom'
		                    });

		                    var onEmphasis = function () {
		                        circle.setStyle({
		                            text: hoverLabelModel.get('show') ? labelText : '',
		                            textFill: hoverTextStyleModel.getTextColor(),
		                            textFont: hoverTextStyleModel.getFont()
		                        });
		                    };

		                    var onNormal = function () {
		                        circle.setStyle({
		                            text: labelModel.get('show') ? labelText : '',
		                            textFill: textStyleModel.getTextColor(),
		                            textFont: textStyleModel.getFont()
		                        });
		                    };

		                    polygonGroups.on('mouseover', onEmphasis)
		                        .on('mouseout', onNormal)
		                        .on('emphasis', onEmphasis)
		                        .on('normal', onNormal);

		                    onNormal();
		                }

		                group.add(circle);
		            });
		        }
		    });


	/***/ },
	/* 175 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/component/helper/MapDraw
		 */


		    var RoamController = __webpack_require__(176);
		    var graphic = __webpack_require__(43);
		    var zrUtil = __webpack_require__(4);

		    function getFixedItemStyle(model, scale) {
		        var itemStyle = model.getItemStyle();
		        var areaColor = model.get('areaColor');
		        if (areaColor) {
		            itemStyle.fill = areaColor;
		        }

		        return itemStyle;
		    }

		    function updateMapSelectHandler(mapDraw, mapOrGeoModel, group, api, fromView) {
		        group.off('click');
		        group.off('mousedown');

		        if (mapOrGeoModel.get('selectedMode')) {

		            group.on('mousedown', function () {
		                mapDraw._mouseDownFlag = true;
		            });

		            group.on('click', function (e) {
		                if (!mapDraw._mouseDownFlag) {
		                    return;
		                }
		                mapDraw._mouseDownFlag = false;

		                var el = e.target;
		                while (!el.__region) {
		                    el = el.parent;
		                }
		                if (!el) {
		                    return;
		                }

		                var region = el.__region;
		                var action = {
		                    type: (mapOrGeoModel.mainType === 'geo' ? 'geo' : 'map') + 'ToggleSelect',
		                    name: region.name,
		                    from: fromView.uid
		                };
		                action[mapOrGeoModel.mainType + 'Id'] = mapOrGeoModel.id;

		                api.dispatchAction(action);

		                updateMapSelected(mapOrGeoModel, group);
		            });
		        }
		    }

		    function updateMapSelected(mapOrGeoModel, group) {
		        // FIXME
		        group.eachChild(function (otherRegionEl) {
		            if (otherRegionEl.__region) {
		                otherRegionEl.trigger(mapOrGeoModel.isSelected(otherRegionEl.__region.name) ? 'emphasis' : 'normal');
		            }
		        });
		    }

		    /**
		     * @alias module:echarts/component/helper/MapDraw
		     * @param {module:echarts/ExtensionAPI} api
		     * @param {boolean} updateGroup
		     */
		    function MapDraw(api, updateGroup) {

		        var group = new graphic.Group();

		        /**
		         * @type {module:echarts/component/helper/RoamController}
		         * @private
		         */
		        this._controller = new RoamController(
		            api.getZr(), updateGroup ? group : null, null
		        );

		        /**
		         * @type {module:zrender/container/Group}
		         * @readOnly
		         */
		        this.group = group;

		        /**
		         * @type {boolean}
		         * @private
		         */
		        this._updateGroup = updateGroup;

		        /**
		         * This flag is used to make sure that only one among
		         * `pan`, `zoom`, `click` can occurs, otherwise 'selected'
		         * action may be triggered when `pan`, which is unexpected.
		         * @type {booelan}
		         */
		        this._mouseDownFlag;
		    }

		    MapDraw.prototype = {

		        constructor: MapDraw,

		        draw: function (mapOrGeoModel, ecModel, api, fromView, payload) {

		            // geoModel has no data
		            var data = mapOrGeoModel.getData && mapOrGeoModel.getData();

		            var geo = mapOrGeoModel.coordinateSystem;

		            var group = this.group;

		            var scale = geo.scale;
		            var groupNewProp = {
		                position: geo.position,
		                scale: scale
		            };

		            // No animation when first draw or in action
		            if (!group.childAt(0) || payload) {
		                group.attr(groupNewProp);
		            }
		            else {
		                graphic.updateProps(group, groupNewProp, mapOrGeoModel);
		            }

		            group.removeAll();

		            var itemStyleAccessPath = ['itemStyle', 'normal'];
		            var hoverItemStyleAccessPath = ['itemStyle', 'emphasis'];
		            var labelAccessPath = ['label', 'normal'];
		            var hoverLabelAccessPath = ['label', 'emphasis'];

		            zrUtil.each(geo.regions, function (region) {

		                var regionGroup = new graphic.Group();
		                var compoundPath = new graphic.CompoundPath({
		                    shape: {
		                        paths: []
		                    }
		                });
		                regionGroup.add(compoundPath);

		                var regionModel = mapOrGeoModel.getRegionModel(region.name) || mapOrGeoModel;

		                var itemStyleModel = regionModel.getModel(itemStyleAccessPath);
		                var hoverItemStyleModel = regionModel.getModel(hoverItemStyleAccessPath);
		                var itemStyle = getFixedItemStyle(itemStyleModel, scale);
		                var hoverItemStyle = getFixedItemStyle(hoverItemStyleModel, scale);

		                var labelModel = regionModel.getModel(labelAccessPath);
		                var hoverLabelModel = regionModel.getModel(hoverLabelAccessPath);

		                var dataIdx;
		                // Use the itemStyle in data if has data
		                if (data) {
		                    dataIdx = data.indexOfName(region.name);
		                    // Only visual color of each item will be used. It can be encoded by dataRange
		                    // But visual color of series is used in symbol drawing
		                    //
		                    // Visual color for each series is for the symbol draw
		                    var visualColor = data.getItemVisual(dataIdx, 'color', true);
		                    if (visualColor) {
		                        itemStyle.fill = visualColor;
		                    }
		                }

		                var textStyleModel = labelModel.getModel('textStyle');
		                var hoverTextStyleModel = hoverLabelModel.getModel('textStyle');

		                zrUtil.each(region.contours, function (contour) {

		                    var polygon = new graphic.Polygon({
		                        shape: {
		                            points: contour
		                        }
		                    });

		                    compoundPath.shape.paths.push(polygon);
		                });

		                compoundPath.setStyle(itemStyle);
		                compoundPath.style.strokeNoScale = true;
		                compoundPath.culling = true;
		                // Label
		                var showLabel = labelModel.get('show');
		                var hoverShowLabel = hoverLabelModel.get('show');

		                var isDataNaN = data && isNaN(data.get('value', dataIdx));
		                var itemLayout = data && data.getItemLayout(dataIdx);
		                // In the following cases label will be drawn
		                // 1. In map series and data value is NaN
		                // 2. In geo component
		                // 4. Region has no series legendSymbol, which will be add a showLabel flag in mapSymbolLayout
		                if (
		                    (!data || isDataNaN && (showLabel || hoverShowLabel))
		                 || (itemLayout && itemLayout.showLabel)
		                 ) {
		                    var query = data ? dataIdx : region.name;
		                    var formattedStr = mapOrGeoModel.getFormattedLabel(query, 'normal');
		                    var hoverFormattedStr = mapOrGeoModel.getFormattedLabel(query, 'emphasis');
		                    var text = new graphic.Text({
		                        style: {
		                            text: showLabel ? (formattedStr || region.name) : '',
		                            fill: textStyleModel.getTextColor(),
		                            textFont: textStyleModel.getFont(),
		                            textAlign: 'center',
		                            textVerticalAlign: 'middle'
		                        },
		                        hoverStyle: {
		                            text: hoverShowLabel ? (hoverFormattedStr || region.name) : '',
		                            fill: hoverTextStyleModel.getTextColor(),
		                            textFont: hoverTextStyleModel.getFont()
		                        },
		                        position: region.center.slice(),
		                        scale: [1 / scale[0], 1 / scale[1]],
		                        z2: 10,
		                        silent: true
		                    });

		                    regionGroup.add(text);
		                }

		                // setItemGraphicEl, setHoverStyle after all polygons and labels
		                // are added to the rigionGroup
		                if (data) {
		                    data.setItemGraphicEl(dataIdx, regionGroup);
		                }
		                else {
		                    var regionModel = mapOrGeoModel.getRegionModel(region.name);
		                    // Package custom mouse event for geo component
		                    compoundPath.eventData = {
		                        componentType: 'geo',
		                        geoIndex: mapOrGeoModel.componentIndex,
		                        name: region.name,
		                        region: (regionModel && regionModel.option) || {}
		                    };
		                }

		                regionGroup.__region = region;

		                graphic.setHoverStyle(
		                    regionGroup,
		                    hoverItemStyle,
		                    {hoverSilentOnTouch: !!mapOrGeoModel.get('selectedMode')}
		                );

		                group.add(regionGroup);
		            });

		            this._updateController(mapOrGeoModel, ecModel, api);

		            updateMapSelectHandler(this, mapOrGeoModel, group, api, fromView);

		            updateMapSelected(mapOrGeoModel, group);
		        },

		        remove: function () {
		            this.group.removeAll();
		            this._controller.dispose();
		        },

		        _updateController: function (mapOrGeoModel, ecModel, api) {
		            var geo = mapOrGeoModel.coordinateSystem;
		            var controller = this._controller;
		            controller.zoomLimit = mapOrGeoModel.get('scaleLimit');
		            // Update zoom from model
		            controller.zoom = geo.getZoom();
		            // roamType is will be set default true if it is null
		            controller.enable(mapOrGeoModel.get('roam') || false);
		            var mainType = mapOrGeoModel.mainType;

		            function makeActionBase() {
		                var action = {
		                    type: 'geoRoam',
		                    componentType: mainType
		                };
		                action[mainType + 'Id'] = mapOrGeoModel.id;
		                return action;
		            }

		            controller.off('pan').on('pan', function (dx, dy) {
		                this._mouseDownFlag = false;

		                api.dispatchAction(zrUtil.extend(makeActionBase(), {
		                    dx: dx,
		                    dy: dy
		                }));
		            }, this);

		            controller.off('zoom').on('zoom', function (zoom, mouseX, mouseY) {
		                this._mouseDownFlag = false;

		                api.dispatchAction(zrUtil.extend(makeActionBase(), {
		                    zoom: zoom,
		                    originX: mouseX,
		                    originY: mouseY
		                }));

		                if (this._updateGroup) {
		                    var group = this.group;
		                    var scale = group.scale;
		                    group.traverse(function (el) {
		                        if (el.type === 'text') {
		                            el.attr('scale', [1 / scale[0], 1 / scale[1]]);
		                        }
		                    });
		                }
		            }, this);

		            controller.setContainsPoint(function (x, y) {
		                return geo.getViewRectAfterRoam().contain(x, y);
		            });
		        }
		    };

		    module.exports = MapDraw;


	/***/ },
	/* 176 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/component/helper/RoamController
		 */



		    var Eventful = __webpack_require__(33);
		    var zrUtil = __webpack_require__(4);
		    var eventTool = __webpack_require__(88);
		    var interactionMutex = __webpack_require__(177);

		    function mousedown(e) {
		        if (e.target && e.target.draggable) {
		            return;
		        }

		        var x = e.offsetX;
		        var y = e.offsetY;

		        if (this.containsPoint && this.containsPoint(x, y)) {
		            this._x = x;
		            this._y = y;
		            this._dragging = true;
		        }
		    }

		    function mousemove(e) {
		        if (!this._dragging) {
		            return;
		        }

		        eventTool.stop(e.event);

		        if (e.gestureEvent !== 'pinch') {

		            if (interactionMutex.isTaken(this._zr, 'globalPan')) {
		                return;
		            }

		            var x = e.offsetX;
		            var y = e.offsetY;

		            var oldX = this._x;
		            var oldY = this._y;

		            var dx = x - oldX;
		            var dy = y - oldY;

		            this._x = x;
		            this._y = y;

		            var target = this.target;

		            if (target) {
		                var pos = target.position;
		                pos[0] += dx;
		                pos[1] += dy;
		                target.dirty();
		            }

		            eventTool.stop(e.event);
		            this.trigger('pan', dx, dy, oldX, oldY, x, y);
		        }
		    }

		    function mouseup(e) {
		        this._dragging = false;
		    }

		    function mousewheel(e) {
		        // Convenience:
		        // Mac and VM Windows on Mac: scroll up: zoom out.
		        // Windows: scroll up: zoom in.
		        var zoomDelta = e.wheelDelta > 0 ? 1.1 : 1 / 1.1;
		        zoom.call(this, e, zoomDelta, e.offsetX, e.offsetY);
		    }

		    function pinch(e) {
		        if (interactionMutex.isTaken(this._zr, 'globalPan')) {
		            return;
		        }
		        var zoomDelta = e.pinchScale > 1 ? 1.1 : 1 / 1.1;
		        zoom.call(this, e, zoomDelta, e.pinchX, e.pinchY);
		    }

		    function zoom(e, zoomDelta, zoomX, zoomY) {
		        if (this.containsPoint && this.containsPoint(zoomX, zoomY)) {
		            // When mouse is out of roamController rect,
		            // default befavoius should be be disabled, otherwise
		            // page sliding is disabled, contrary to expectation.
		            eventTool.stop(e.event);

		            var target = this.target;
		            var zoomLimit = this.zoomLimit;

		            if (target) {
		                var pos = target.position;
		                var scale = target.scale;

		                var newZoom = this.zoom = this.zoom || 1;
		                newZoom *= zoomDelta;
		                if (zoomLimit) {
		                    var zoomMin = zoomLimit.min || 0;
		                    var zoomMax = zoomLimit.max || Infinity;
		                    newZoom = Math.max(
		                        Math.min(zoomMax, newZoom),
		                        zoomMin
		                    );
		                }
		                var zoomScale = newZoom / this.zoom;
		                this.zoom = newZoom;
		                // Keep the mouse center when scaling
		                pos[0] -= (zoomX - pos[0]) * (zoomScale - 1);
		                pos[1] -= (zoomY - pos[1]) * (zoomScale - 1);
		                scale[0] *= zoomScale;
		                scale[1] *= zoomScale;

		                target.dirty();
		            }

		            this.trigger('zoom', zoomDelta, zoomX, zoomY);
		        }
		    }

		    /**
		     * @alias module:echarts/component/helper/RoamController
		     * @constructor
		     * @mixin {module:zrender/mixin/Eventful}
		     *
		     * @param {module:zrender/zrender~ZRender} zr
		     * @param {module:zrender/Element} target
		     */
		    function RoamController(zr, target) {

		        /**
		         * @type {module:zrender/Element}
		         */
		        this.target = target;

		        /**
		         * @type {Function}
		         */
		        this.containsPoint;

		        /**
		         * { min: 1, max: 2 }
		         * @type {Object}
		         */
		        this.zoomLimit;

		        /**
		         * @type {number}
		         */
		        this.zoom;
		        /**
		         * @type {module:zrender}
		         */
		        this._zr = zr;

		        // Avoid two roamController bind the same handler
		        var bind = zrUtil.bind;
		        var mousedownHandler = bind(mousedown, this);
		        var mousemoveHandler = bind(mousemove, this);
		        var mouseupHandler = bind(mouseup, this);
		        var mousewheelHandler = bind(mousewheel, this);
		        var pinchHandler = bind(pinch, this);

		        Eventful.call(this);

		        /**
		         * @param {Function} containsPoint
		         *                   input: x, y
		         *                   output: boolean
		         */
		        this.setContainsPoint = function (containsPoint) {
		            this.containsPoint = containsPoint;
		        };

		        /**
		         * Notice: only enable needed types. For example, if 'zoom'
		         * is not needed, 'zoom' should not be enabled, otherwise
		         * default mousewheel behaviour (scroll page) will be disabled.
		         *
		         * @param  {boolean|string} [controlType=true] Specify the control type,
		         *                          which can be null/undefined or true/false
		         *                          or 'pan/move' or 'zoom'/'scale'
		         */
		        this.enable = function (controlType) {
		            // Disable previous first
		            this.disable();

		            if (controlType == null) {
		                controlType = true;
		            }

		            if (controlType === true || (controlType === 'move' || controlType === 'pan')) {
		                zr.on('mousedown', mousedownHandler);
		                zr.on('mousemove', mousemoveHandler);
		                zr.on('mouseup', mouseupHandler);
		            }
		            if (controlType === true || (controlType === 'scale' || controlType === 'zoom')) {
		                zr.on('mousewheel', mousewheelHandler);
		                zr.on('pinch', pinchHandler);
		            }
		        };

		        this.disable = function () {
		            zr.off('mousedown', mousedownHandler);
		            zr.off('mousemove', mousemoveHandler);
		            zr.off('mouseup', mouseupHandler);
		            zr.off('mousewheel', mousewheelHandler);
		            zr.off('pinch', pinchHandler);
		        };

		        this.dispose = this.disable;

		        this.isDragging = function () {
		            return this._dragging;
		        };

		        this.isPinching = function () {
		            return this._pinching;
		        };
		    }

		    zrUtil.mixin(RoamController, Eventful);

		    module.exports = RoamController;


	/***/ },
	/* 177 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var ATTR = '\0_ec_interaction_mutex';

		    var interactionMutex = {

		        take: function (zr, resourceKey, userKey) {
		            var store = getStore(zr);
		            store[resourceKey] = userKey;
		        },

		        release: function (zr, resourceKey, userKey) {
		            var store = getStore(zr);
		            var uKey = store[resourceKey];

		            if (uKey === userKey) {
		                store[resourceKey] = null;
		            }
		        },

		        isTaken: function (zr, resourceKey) {
		            return !!getStore(zr)[resourceKey];
		        }
		    };

		    function getStore(zr) {
		        return zr[ATTR] || (zr[ATTR] = {});
		    }

		    /**
		     * payload: {
		     *     type: 'takeGlobalCursor',
		     *     key: 'dataZoomSelect', or 'brush', or ...,
		     *         If no userKey, release global cursor.
		     * }
		     */
		    __webpack_require__(1).registerAction(
		        {type: 'takeGlobalCursor', event: 'globalCursorTaken', update: 'update'},
		        function () {}
		    );

		    module.exports = interactionMutex;


	/***/ },
	/* 178 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var roamHelper = __webpack_require__(179);

		    var echarts = __webpack_require__(1);

		    /**
		     * @payload
		     * @property {string} [componentType=series]
		     * @property {number} [dx]
		     * @property {number} [dy]
		     * @property {number} [zoom]
		     * @property {number} [originX]
		     * @property {number} [originY]
		     */
		    echarts.registerAction({
		        type: 'geoRoam',
		        event: 'geoRoam',
		        update: 'updateLayout'
		    }, function (payload, ecModel) {
		        var componentType = payload.componentType || 'series';

		        ecModel.eachComponent(
		            { mainType: componentType, query: payload },
		            function (componentModel) {
		                var geo = componentModel.coordinateSystem;
		                if (geo.type !== 'geo') {
		                    return;
		                }

		                var res = roamHelper.updateCenterAndZoom(
		                    geo, payload, componentModel.get('scaleLimit')
		                );

		                componentModel.setCenter
		                    && componentModel.setCenter(res.center);

		                componentModel.setZoom
		                    && componentModel.setZoom(res.zoom);

		                // All map series with same `map` use the same geo coordinate system
		                // So the center and zoom must be in sync. Include the series not selected by legend
		                if (componentType === 'series') {
		                    zrUtil.each(componentModel.seriesGroup, function (seriesModel) {
		                        seriesModel.setCenter(res.center);
		                        seriesModel.setZoom(res.zoom);
		                    });
		                }
		            }
		        );
		    });


	/***/ },
	/* 179 */
	/***/ function(module, exports) {

		

		    var roamHelper = {};

		    /**
		     * @param {module:echarts/coord/View} view
		     * @param {Object} payload
		     * @param {Object} [zoomLimit]
		     */
		    roamHelper.updateCenterAndZoom = function (
		        view, payload, zoomLimit
		    ) {
		        var previousZoom = view.getZoom();
		        var center = view.getCenter();
		        var zoom = payload.zoom;

		        var point = view.dataToPoint(center);

		        if (payload.dx != null && payload.dy != null) {
		            point[0] -= payload.dx;
		            point[1] -= payload.dy;

		            var center = view.pointToData(point);
		            view.setCenter(center);
		        }
		        if (zoom != null) {
		            if (zoomLimit) {
		                var zoomMin = zoomLimit.min || 0;
		                var zoomMax = zoomLimit.max || Infinity;
		                zoom = Math.max(
		                    Math.min(previousZoom * zoom, zoomMax),
		                    zoomMin
		                ) / previousZoom;
		            }

		            // Zoom on given point(originX, originY)
		            view.scale[0] *= zoom;
		            view.scale[1] *= zoom;
		            var position = view.position;
		            var fixX = (payload.originX - position[0]) * (zoom - 1);
		            var fixY = (payload.originY - position[1]) * (zoom - 1);

		            position[0] -= fixX;
		            position[1] -= fixY;

		            view.updateTransform();
		            // Get the new center
		            var center = view.pointToData(point);
		            view.setCenter(center);
		            view.setZoom(zoom * previousZoom);
		        }

		        return {
		            center: view.getCenter(),
		            zoom: view.getZoom()
		        };
		    };

		    module.exports = roamHelper;


	/***/ },
	/* 180 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    module.exports = function (ecModel) {

		        var processedMapType = {};

		        ecModel.eachSeriesByType('map', function (mapSeries) {
		            var mapType = mapSeries.get('map');
		            if (processedMapType[mapType]) {
		                return;
		            }

		            var mapSymbolOffsets = {};

		            zrUtil.each(mapSeries.seriesGroup, function (subMapSeries) {
		                var geo = subMapSeries.coordinateSystem;
		                var data = subMapSeries.originalData;
		                if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {
		                    data.each('value', function (value, idx) {
		                        var name = data.getName(idx);
		                        var region = geo.getRegion(name);

		                        // If input series.data is [11, 22, '-'/null/undefined, 44],
		                        // it will be filled with NaN: [11, 22, NaN, 44] and NaN will
		                        // not be drawn. So here must validate if value is NaN.
		                        if (!region || isNaN(value)) {
		                            return;
		                        }

		                        var offset = mapSymbolOffsets[name] || 0;

		                        var point = geo.dataToPoint(region.center);

		                        mapSymbolOffsets[name] = offset + 1;

		                        data.setItemLayout(idx, {
		                            point: point,
		                            offset: offset
		                        });
		                    });
		                }
		            });

		            // Show label of those region not has legendSymbol(which is offset 0)
		            var data = mapSeries.getData();
		            data.each(function (idx) {
		                var name = data.getName(idx);
		                var layout = data.getItemLayout(idx) || {};
		                layout.showLabel = !mapSymbolOffsets[name];
		                data.setItemLayout(idx, layout);
		            });

		            processedMapType[mapType] = true;
		        });
		    };


	/***/ },
	/* 181 */
	/***/ function(module, exports) {

		
		    module.exports = function (ecModel) {
		        ecModel.eachSeriesByType('map', function (seriesModel) {
		            var colorList = seriesModel.get('color');
		            var itemStyleModel = seriesModel.getModel('itemStyle.normal');

		            var areaColor = itemStyleModel.get('areaColor');
		            var color = itemStyleModel.get('color')
		                || colorList[seriesModel.seriesIndex % colorList.length];

		            seriesModel.getData().setVisual({
		                'areaColor': areaColor,
		                'color': color
		            });
		        });
		    };


	/***/ },
	/* 182 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    // FIXME 公用？
		    /**
		     * @param {Array.<module:echarts/data/List>} datas
		     * @param {string} statisticType 'average' 'sum'
		     * @inner
		     */
		    function dataStatistics(datas, statisticType) {
		        var dataNameMap = {};
		        var dims = ['value'];

		        for (var i = 0; i < datas.length; i++) {
		            datas[i].each(dims, function (value, idx) {
		                var name = datas[i].getName(idx);
		                dataNameMap[name] = dataNameMap[name] || [];
		                if (!isNaN(value)) {
		                    dataNameMap[name].push(value);
		                }
		            });
		        }

		        return datas[0].map(dims, function (value, idx) {
		            var name = datas[0].getName(idx);
		            var sum = 0;
		            var min = Infinity;
		            var max = -Infinity;
		            var len = dataNameMap[name].length;
		            for (var i = 0; i < len; i++) {
		                min = Math.min(min, dataNameMap[name][i]);
		                max = Math.max(max, dataNameMap[name][i]);
		                sum += dataNameMap[name][i];
		            }
		            var result;
		            if (statisticType === 'min') {
		                result = min;
		            }
		            else if (statisticType === 'max') {
		                result = max;
		            }
		            else if (statisticType === 'average') {
		                result = sum / len;
		            }
		            else {
		                result = sum;
		            }
		            return len === 0 ? NaN : result;
		        });
		    }

		    module.exports = function (ecModel) {
		        var seriesGroupByMapType = {};
		        ecModel.eachSeriesByType('map', function (seriesModel) {
		            var mapType = seriesModel.get('map');
		            seriesGroupByMapType[mapType] = seriesGroupByMapType[mapType] || [];
		            seriesGroupByMapType[mapType].push(seriesModel);
		        });

		        zrUtil.each(seriesGroupByMapType, function (seriesList, mapType) {
		            var data = dataStatistics(
		                zrUtil.map(seriesList, function (seriesModel) {
		                    return seriesModel.getData();
		                }),
		                seriesList[0].get('mapValueCalculation')
		            );

		            for (var i = 0; i < seriesList.length; i++) {
		                seriesList[i].originalData = seriesList[i].getData();
		            }

		            // FIXME Put where?
		            for (var i = 0; i < seriesList.length; i++) {
		                seriesList[i].seriesGroup = seriesList;
		                seriesList[i].needsDrawMap = i === 0;

		                seriesList[i].setData(data.cloneShallow());
		                seriesList[i].mainSeries = seriesList[0];
		            }
		        });
		    };


	/***/ },
	/* 183 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    module.exports = function (option) {
		        // Save geoCoord
		        var mapSeries = [];
		        zrUtil.each(option.series, function (seriesOpt) {
		            if (seriesOpt.type === 'map') {
		                mapSeries.push(seriesOpt);
		            }
		        });

		        zrUtil.each(mapSeries, function (seriesOpt) {
		            seriesOpt.map = seriesOpt.map || seriesOpt.mapType;
		            // Put x, y, width, height, x2, y2 in the top level
		            zrUtil.defaults(seriesOpt, seriesOpt.mapLocation);
		        });
		    };


	/***/ },
	/* 184 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var echarts = __webpack_require__(1);

		    __webpack_require__(185);
		    __webpack_require__(189);
		    __webpack_require__(192);

		    echarts.registerVisual(__webpack_require__(193));

		    echarts.registerLayout(__webpack_require__(195));


	/***/ },
	/* 185 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var SeriesModel = __webpack_require__(28);
		    var Tree = __webpack_require__(186);
		    var zrUtil = __webpack_require__(4);
		    var Model = __webpack_require__(12);
		    var formatUtil = __webpack_require__(6);
		    var helper = __webpack_require__(188);
		    var encodeHTML = formatUtil.encodeHTML;
		    var addCommas = formatUtil.addCommas;


		    module.exports = SeriesModel.extend({

		        type: 'series.treemap',

		        layoutMode: 'box',

		        dependencies: ['grid', 'polar'],

		        /**
		         * @type {module:echarts/data/Tree~Node}
		         */
		        _viewRoot: null,

		        defaultOption: {
		            // Disable progressive rendering
		            progressive: 0,
		            hoverLayerThreshold: Infinity,
		            // center: ['50%', '50%'],          // not supported in ec3.
		            // size: ['80%', '80%'],            // deprecated, compatible with ec2.
		            left: 'center',
		            top: 'middle',
		            right: null,
		            bottom: null,
		            width: '80%',
		            height: '80%',
		            sort: true,                         // Can be null or false or true
		                                                // (order by desc default, asc not supported yet (strange effect))
		            clipWindow: 'origin',               // Size of clipped window when zooming. 'origin' or 'fullscreen'
		            squareRatio: 0.5 * (1 + Math.sqrt(5)), // golden ratio
		            leafDepth: null,                    // Nodes on depth from root are regarded as leaves.
		                                                // Count from zero (zero represents only view root).
		            drillDownIcon: '▶',                 // Use html character temporarily because it is complicated
		                                                // to align specialized icon. ▷▶❒❐▼✚

		            zoomToNodeRatio: 0.32 * 0.32,       // Be effective when using zoomToNode. Specify the proportion of the
		                                                // target node area in the view area.
		            roam: true,                         // true, false, 'scale' or 'zoom', 'move'.
		            nodeClick: 'zoomToNode',            // Leaf node click behaviour: 'zoomToNode', 'link', false.
		                                                // If leafDepth is set and clicking a node which has children but
		                                                // be on left depth, the behaviour would be changing root. Otherwise
		                                                // use behavious defined above.
		            animation: true,
		            animationDurationUpdate: 900,
		            animationEasing: 'quinticInOut',
		            breadcrumb: {
		                show: true,
		                height: 22,
		                left: 'center',
		                top: 'bottom',
		                // right
		                // bottom
		                emptyItemWidth: 25,             // Width of empty node.
		                itemStyle: {
		                    normal: {
		                        color: 'rgba(0,0,0,0.7)', //'#5793f3',
		                        borderColor: 'rgba(255,255,255,0.7)',
		                        borderWidth: 1,
		                        shadowColor: 'rgba(150,150,150,1)',
		                        shadowBlur: 3,
		                        shadowOffsetX: 0,
		                        shadowOffsetY: 0,
		                        textStyle: {
		                            color: '#fff'
		                        }
		                    },
		                    emphasis: {
		                        textStyle: {}
		                    }
		                }
		            },
		            label: {
		                normal: {
		                    show: true,
		                    position: 'inside', // Can be [5, '5%'] or position stirng like 'insideTopLeft', ...
		                    textStyle: {
		                        color: '#fff',
		                        ellipsis: true
		                    }
		                }
		            },
		            itemStyle: {
		                normal: {
		                    color: null,            // Can be 'none' if not necessary.
		                    colorAlpha: null,       // Can be 'none' if not necessary.
		                    colorSaturation: null,  // Can be 'none' if not necessary.
		                    borderWidth: 0,
		                    gapWidth: 0,
		                    borderColor: '#fff',
		                    borderColorSaturation: null // If specified, borderColor will be ineffective, and the
		                                                // border color is evaluated by color of current node and
		                                                // borderColorSaturation.
		                },
		                emphasis: {

		                }
		            },

		            visualDimension: 0,                 // Can be 0, 1, 2, 3.
		            visualMin: null,
		            visualMax: null,

		            color: [],                  // + treemapSeries.color should not be modified. Please only modified
		                                        // level[n].color (if necessary).
		                                        // + Specify color list of each level. level[0].color would be global
		                                        // color list if not specified. (see method `setDefault`).
		                                        // + But set as a empty array to forbid fetch color from global palette
		                                        // when using nodeModel.get('color'), otherwise nodes on deep level
		                                        // will always has color palette set and are not able to inherit color
		                                        // from parent node.
		                                        // + TreemapSeries.color can not be set as 'none', otherwise effect
		                                        // legend color fetching (see seriesColor.js).
		            colorAlpha: null,           // Array. Specify color alpha range of each level, like [0.2, 0.8]
		            colorSaturation: null,      // Array. Specify color saturation of each level, like [0.2, 0.5]
		            colorMappingBy: 'index',    // 'value' or 'index' or 'id'.
		            visibleMin: 10,             // If area less than this threshold (unit: pixel^2), node will not
		                                        // be rendered. Only works when sort is 'asc' or 'desc'.
		            childrenVisibleMin: null,   // If area of a node less than this threshold (unit: pixel^2),
		                                        // grandchildren will not show.
		                                        // Why grandchildren? If not grandchildren but children,
		                                        // some siblings show children and some not,
		                                        // the appearance may be mess and not consistent,
		            levels: []                  // Each item: {
		                                        //     visibleMin, itemStyle, visualDimension, label
		                                        // }
		            // data: {
		            //      value: [],
		            //      children: [],
		            //      link: 'http://xxx.xxx.xxx',
		            //      target: 'blank' or 'self'
		            // }
		        },

		        /**
		         * @override
		         */
		        getInitialData: function (option, ecModel) {
		            var data = option.data || [];
		            var rootName = option.name;
		            rootName == null && (rootName = option.name);

		            // Create a virtual root.
		            var root = {name: rootName, children: option.data};
		            var value0 = (data[0] || {}).value;

		            completeTreeValue(root, zrUtil.isArray(value0) ? value0.length : -1);

		            // FIXME
		            // sereis.mergeOption 的 getInitData是否放在merge后，从而能直接获取merege后的结果而非手动判断。
		            var levels = option.levels || [];

		            levels = option.levels = setDefault(levels, ecModel);

		            // Make sure always a new tree is created when setOption,
		            // in TreemapView, we check whether oldTree === newTree
		            // to choose mappings approach among old shapes and new shapes.
		            return Tree.createTree(root, this, levels).data;
		        },

		        optionUpdated: function () {
		            this.resetViewRoot();
		        },

		        /**
		         * @override
		         * @param {number} dataIndex
		         * @param {boolean} [mutipleSeries=false]
		         */
		        formatTooltip: function (dataIndex) {
		            var data = this.getData();
		            var value = this.getRawValue(dataIndex);
		            var formattedValue = zrUtil.isArray(value)
		                ? addCommas(value[0]) : addCommas(value);
		            var name = data.getName(dataIndex);

		            return encodeHTML(name) + ': ' + formattedValue;
		        },

		        /**
		         * Add tree path to tooltip param
		         *
		         * @override
		         * @param {number} dataIndex
		         * @return {Object}
		         */
		        getDataParams: function (dataIndex) {
		            var params = SeriesModel.prototype.getDataParams.apply(this, arguments);

		            var node = this.getData().tree.getNodeByDataIndex(dataIndex);
		            params.treePathInfo = helper.wrapTreePathInfo(node, this);

		            return params;
		        },

		        /**
		         * @public
		         * @param {Object} layoutInfo {
		         *                                x: containerGroup x
		         *                                y: containerGroup y
		         *                                width: containerGroup width
		         *                                height: containerGroup height
		         *                            }
		         */
		        setLayoutInfo: function (layoutInfo) {
		            /**
		             * @readOnly
		             * @type {Object}
		             */
		            this.layoutInfo = this.layoutInfo || {};
		            zrUtil.extend(this.layoutInfo, layoutInfo);
		        },

		        /**
		         * @param  {string} id
		         * @return {number} index
		         */
		        mapIdToIndex: function (id) {
		            // A feature is implemented:
		            // index is monotone increasing with the sequence of
		            // input id at the first time.
		            // This feature can make sure that each data item and its
		            // mapped color have the same index between data list and
		            // color list at the beginning, which is useful for user
		            // to adjust data-color mapping.

		            /**
		             * @private
		             * @type {Object}
		             */
		            var idIndexMap = this._idIndexMap;

		            if (!idIndexMap) {
		                idIndexMap = this._idIndexMap = {};
		                /**
		                 * @private
		                 * @type {number}
		                 */
		                this._idIndexMapCount = 0;
		            }

		            var index = idIndexMap[id];
		            if (index == null) {
		                idIndexMap[id] = index = this._idIndexMapCount++;
		            }

		            return index;
		        },

		        getViewRoot: function () {
		            return this._viewRoot;
		        },

		        /**
		         * @param {module:echarts/data/Tree~Node} [viewRoot]
		         */
		        resetViewRoot: function (viewRoot) {
		            viewRoot
		                ? (this._viewRoot = viewRoot)
		                : (viewRoot = this._viewRoot);

		            var root = this.getData().tree.root;

		            if (!viewRoot
		                || (viewRoot !== root && !root.contains(viewRoot))
		            ) {
		                this._viewRoot = root;
		            }
		        }
		    });

		    /**
		     * @param {Object} dataNode
		     */
		    function completeTreeValue(dataNode, arrValueLength) {
		        // Postorder travel tree.
		        // If value of none-leaf node is not set,
		        // calculate it by suming up the value of all children.
		        var sum = 0;

		        zrUtil.each(dataNode.children, function (child) {

		            completeTreeValue(child, arrValueLength);

		            var childValue = child.value;
		            zrUtil.isArray(childValue) && (childValue = childValue[0]);

		            sum += childValue;
		        });

		        var thisValue = dataNode.value;

		        if (arrValueLength >= 0) {
		            if (!zrUtil.isArray(thisValue)) {
		                dataNode.value = new Array(arrValueLength);
		            }
		            else {
		                thisValue = thisValue[0];
		            }
		        }

		        if (thisValue == null || isNaN(thisValue)) {
		            thisValue = sum;
		        }
		        // Value should not less than 0.
		        if (thisValue < 0) {
		            thisValue = 0;
		        }

		        arrValueLength >= 0
		            ? (dataNode.value[0] = thisValue)
		            : (dataNode.value = thisValue);
		    }

		    /**
		     * set default to level configuration
		     */
		    function setDefault(levels, ecModel) {
		        var globalColorList = ecModel.get('color');

		        if (!globalColorList) {
		            return;
		        }

		        levels = levels || [];
		        var hasColorDefine;
		        zrUtil.each(levels, function (levelDefine) {
		            var model = new Model(levelDefine);
		            var modelColor = model.get('color');

		            if (model.get('itemStyle.normal.color')
		                || (modelColor && modelColor !== 'none')
		            ) {
		                hasColorDefine = true;
		            }
		        });

		        if (!hasColorDefine) {
		            var level0 = levels[0] || (levels[0] = {});
		            level0.color = globalColorList.slice();
		        }

		        return levels;
		    }



	/***/ },
	/* 186 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Tree data structure
		 *
		 * @module echarts/data/Tree
		 */


		    var zrUtil = __webpack_require__(4);
		    var Model = __webpack_require__(12);
		    var List = __webpack_require__(98);
		    var linkList = __webpack_require__(187);
		    var completeDimensions = __webpack_require__(103);

		    /**
		     * @constructor module:echarts/data/Tree~TreeNode
		     * @param {string} name
		     * @param {module:echarts/data/Tree} hostTree
		     */
		    var TreeNode = function (name, hostTree) {
		        /**
		         * @type {string}
		         */
		        this.name = name || '';

		        /**
		         * Depth of node
		         *
		         * @type {number}
		         * @readOnly
		         */
		        this.depth = 0;

		        /**
		         * Height of the subtree rooted at this node.
		         * @type {number}
		         * @readOnly
		         */
		        this.height = 0;

		        /**
		         * @type {module:echarts/data/Tree~TreeNode}
		         * @readOnly
		         */
		        this.parentNode = null;

		        /**
		         * Reference to list item.
		         * Do not persistent dataIndex outside,
		         * besause it may be changed by list.
		         * If dataIndex -1,
		         * this node is logical deleted (filtered) in list.
		         *
		         * @type {Object}
		         * @readOnly
		         */
		        this.dataIndex = -1;

		        /**
		         * @type {Array.<module:echarts/data/Tree~TreeNode>}
		         * @readOnly
		         */
		        this.children = [];

		        /**
		         * @type {Array.<module:echarts/data/Tree~TreeNode>}
		         * @pubilc
		         */
		        this.viewChildren = [];

		        /**
		         * @type {moduel:echarts/data/Tree}
		         * @readOnly
		         */
		        this.hostTree = hostTree;
		    };

		    TreeNode.prototype = {

		        constructor: TreeNode,

		        /**
		         * The node is removed.
		         * @return {boolean} is removed.
		         */
		        isRemoved: function () {
		            return this.dataIndex < 0;
		        },

		        /**
		         * Travel this subtree (include this node).
		         * Usage:
		         *    node.eachNode(function () { ... }); // preorder
		         *    node.eachNode('preorder', function () { ... }); // preorder
		         *    node.eachNode('postorder', function () { ... }); // postorder
		         *    node.eachNode(
		         *        {order: 'postorder', attr: 'viewChildren'},
		         *        function () { ... }
		         *    ); // postorder
		         *
		         * @param {(Object|string)} options If string, means order.
		         * @param {string=} options.order 'preorder' or 'postorder'
		         * @param {string=} options.attr 'children' or 'viewChildren'
		         * @param {Function} cb If in preorder and return false,
		         *                      its subtree will not be visited.
		         * @param {Object} [context]
		         */
		        eachNode: function (options, cb, context) {
		            if (typeof options === 'function') {
		                context = cb;
		                cb = options;
		                options = null;
		            }

		            options = options || {};
		            if (zrUtil.isString(options)) {
		                options = {order: options};
		            }

		            var order = options.order || 'preorder';
		            var children = this[options.attr || 'children'];

		            var suppressVisitSub;
		            order === 'preorder' && (suppressVisitSub = cb.call(context, this));

		            for (var i = 0; !suppressVisitSub && i < children.length; i++) {
		                children[i].eachNode(options, cb, context);
		            }

		            order === 'postorder' && cb.call(context, this);
		        },

		        /**
		         * Update depth and height of this subtree.
		         *
		         * @param  {number} depth
		         */
		        updateDepthAndHeight: function (depth) {
		            var height = 0;
		            this.depth = depth;
		            for (var i = 0; i < this.children.length; i++) {
		                var child = this.children[i];
		                child.updateDepthAndHeight(depth + 1);
		                if (child.height > height) {
		                    height = child.height;
		                }
		            }
		            this.height = height + 1;
		        },

		        /**
		         * @param  {string} id
		         * @return {module:echarts/data/Tree~TreeNode}
		         */
		        getNodeById: function (id) {
		            if (this.getId() === id) {
		                return this;
		            }
		            for (var i = 0, children = this.children, len = children.length; i < len; i++) {
		                var res = children[i].getNodeById(id);
		                if (res) {
		                    return res;
		                }
		            }
		        },

		        /**
		         * @param {module:echarts/data/Tree~TreeNode} node
		         * @return {boolean}
		         */
		        contains: function (node) {
		            if (node === this) {
		                return true;
		            }
		            for (var i = 0, children = this.children, len = children.length; i < len; i++) {
		                var res = children[i].contains(node);
		                if (res) {
		                    return res;
		                }
		            }
		        },

		        /**
		         * @param {boolean} includeSelf Default false.
		         * @return {Array.<module:echarts/data/Tree~TreeNode>} order: [root, child, grandchild, ...]
		         */
		        getAncestors: function (includeSelf) {
		            var ancestors = [];
		            var node = includeSelf ? this : this.parentNode;
		            while (node) {
		                ancestors.push(node);
		                node = node.parentNode;
		            }
		            ancestors.reverse();
		            return ancestors;
		        },

		        /**
		         * @param {string|Array=} [dimension='value'] Default 'value'. can be 0, 1, 2, 3
		         * @return {number} Value.
		         */
		        getValue: function (dimension) {
		            var data = this.hostTree.data;
		            return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
		        },

		        /**
		         * @param {Object} layout
		         * @param {boolean=} [merge=false]
		         */
		        setLayout: function (layout, merge) {
		            this.dataIndex >= 0
		                && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge);
		        },

		        /**
		         * @return {Object} layout
		         */
		        getLayout: function () {
		            return this.hostTree.data.getItemLayout(this.dataIndex);
		        },

		        /**
		         * @param {string} path
		         * @return {module:echarts/model/Model}
		         */
		        getModel: function (path) {
		            if (this.dataIndex < 0) {
		                return;
		            }
		            var hostTree = this.hostTree;
		            var itemModel = hostTree.data.getItemModel(this.dataIndex);
		            var levelModel = this.getLevelModel();

		            return itemModel.getModel(path, (levelModel || hostTree.hostModel).getModel(path));
		        },

		        /**
		         * @return {module:echarts/model/Model}
		         */
		        getLevelModel: function () {
		            return (this.hostTree.levelModels || [])[this.depth];
		        },

		        /**
		         * @example
		         *  setItemVisual('color', color);
		         *  setItemVisual({
		         *      'color': color
		         *  });
		         */
		        setVisual: function (key, value) {
		            this.dataIndex >= 0
		                && this.hostTree.data.setItemVisual(this.dataIndex, key, value);
		        },

		        /**
		         * Get item visual
		         */
		        getVisual: function (key, ignoreParent) {
		            return this.hostTree.data.getItemVisual(this.dataIndex, key, ignoreParent);
		        },

		        /**
		         * @public
		         * @return {number}
		         */
		        getRawIndex: function () {
		            return this.hostTree.data.getRawIndex(this.dataIndex);
		        },

		        /**
		         * @public
		         * @return {string}
		         */
		        getId: function () {
		            return this.hostTree.data.getId(this.dataIndex);
		        }
		    };

		    /**
		     * @constructor
		     * @alias module:echarts/data/Tree
		     * @param {module:echarts/model/Model} hostModel
		     * @param {Array.<Object>} levelOptions
		     */
		    function Tree(hostModel, levelOptions) {
		        /**
		         * @type {module:echarts/data/Tree~TreeNode}
		         * @readOnly
		         */
		        this.root;

		        /**
		         * @type {module:echarts/data/List}
		         * @readOnly
		         */
		        this.data;

		        /**
		         * Index of each item is the same as the raw index of coresponding list item.
		         * @private
		         * @type {Array.<module:echarts/data/Tree~TreeNode}
		         */
		        this._nodes = [];

		        /**
		         * @private
		         * @readOnly
		         * @type {module:echarts/model/Model}
		         */
		        this.hostModel = hostModel;

		        /**
		         * @private
		         * @readOnly
		         * @type {Array.<module:echarts/model/Model}
		         */
		        this.levelModels = zrUtil.map(levelOptions || [], function (levelDefine) {
		            return new Model(levelDefine, hostModel, hostModel.ecModel);
		        });
		    }

		    Tree.prototype = {

		        constructor: Tree,

		        type: 'tree',

		        /**
		         * Travel this subtree (include this node).
		         * Usage:
		         *    node.eachNode(function () { ... }); // preorder
		         *    node.eachNode('preorder', function () { ... }); // preorder
		         *    node.eachNode('postorder', function () { ... }); // postorder
		         *    node.eachNode(
		         *        {order: 'postorder', attr: 'viewChildren'},
		         *        function () { ... }
		         *    ); // postorder
		         *
		         * @param {(Object|string)} options If string, means order.
		         * @param {string=} options.order 'preorder' or 'postorder'
		         * @param {string=} options.attr 'children' or 'viewChildren'
		         * @param {Function} cb
		         * @param {Object}   [context]
		         */
		        eachNode: function(options, cb, context) {
		            this.root.eachNode(options, cb, context);
		        },

		        /**
		         * @param {number} dataIndex
		         * @return {module:echarts/data/Tree~TreeNode}
		         */
		        getNodeByDataIndex: function (dataIndex) {
		            var rawIndex = this.data.getRawIndex(dataIndex);
		            return this._nodes[rawIndex];
		        },

		        /**
		         * @param {string} name
		         * @return {module:echarts/data/Tree~TreeNode}
		         */
		        getNodeByName: function (name) {
		            return this.root.getNodeByName(name);
		        },

		        /**
		         * Update item available by list,
		         * when list has been performed options like 'filterSelf' or 'map'.
		         */
		        update: function () {
		            var data = this.data;
		            var nodes = this._nodes;

		            for (var i = 0, len = nodes.length; i < len; i++) {
		                nodes[i].dataIndex = -1;
		            }

		            for (var i = 0, len = data.count(); i < len; i++) {
		                nodes[data.getRawIndex(i)].dataIndex = i;
		            }
		        },

		        /**
		         * Clear all layouts
		         */
		        clearLayouts: function () {
		            this.data.clearItemLayouts();
		        }
		    };

		    /**
		     * data node format:
		     * {
		     *     name: ...
		     *     value: ...
		     *     children: [
		     *         {
		     *             name: ...
		     *             value: ...
		     *             children: ...
		     *         },
		     *         ...
		     *     ]
		     * }
		     *
		     * @static
		     * @param {Objec} dataRoot Root node.
		     * @param {module:echarts/model/Model} hostModel
		     * @param {Array.<Object>} levelOptions
		     * @return module:echarts/data/Tree
		     */
		    Tree.createTree = function (dataRoot, hostModel, levelOptions) {

		        var tree = new Tree(hostModel, levelOptions);
		        var listData = [];

		        buildHierarchy(dataRoot);

		        function buildHierarchy(dataNode, parentNode) {
		            listData.push(dataNode);

		            var node = new TreeNode(dataNode.name, tree);
		            parentNode
		                ? addChild(node, parentNode)
		                : (tree.root = node);

		            tree._nodes.push(node);

		            var children = dataNode.children;
		            if (children) {
		                for (var i = 0; i < children.length; i++) {
		                    buildHierarchy(children[i], node);
		                }
		            }
		        }

		        tree.root.updateDepthAndHeight(0);

		        var dimensions = completeDimensions([{name: 'value'}], listData);
		        var list = new List(dimensions, hostModel);
		        list.initData(listData);

		        linkList({
		            mainData: list,
		            struct: tree,
		            structAttr: 'tree'
		        });

		        tree.update();

		        return tree;
		    };

		    /**
		     * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,
		     * so this function is not ready and not necessary to be public.
		     *
		     * @param {(module:echarts/data/Tree~TreeNode|Object)} child
		     */
		    function addChild(child, node) {
		        var children = node.children;
		        if (child.parentNode === node) {
		            return;
		        }

		        children.push(child);
		        child.parentNode = node;
		    }

		    module.exports = Tree;


	/***/ },
	/* 187 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Link lists and struct (graph or tree)
		 */


		    var zrUtil = __webpack_require__(4);
		    var each = zrUtil.each;

		    var DATAS = '\0__link_datas';
		    var MAIN_DATA = '\0__link_mainData';

		    // Caution:
		    // In most case, either list or its shallow clones (see list.cloneShallow)
		    // is active in echarts process. So considering heap memory consumption,
		    // we do not clone tree or graph, but share them among list and its shallow clones.
		    // But in some rare case, we have to keep old list (like do animation in chart). So
		    // please take care that both the old list and the new list share the same tree/graph.

		    /**
		     * @param {Object} opt
		     * @param {module:echarts/data/List} opt.mainData
		     * @param {Object} [opt.struct] For example, instance of Graph or Tree.
		     * @param {string} [opt.structAttr] designation: list[structAttr] = struct;
		     * @param {Object} [opt.datas] {dataType: data},
		     *                 like: {node: nodeList, edge: edgeList}.
		     *                 Should contain mainData.
		     * @param {Object} [opt.datasAttr] {dataType: attr},
		     *                 designation: struct[datasAttr[dataType]] = list;
		     */
		    function linkList(opt) {
		        var mainData = opt.mainData;
		        var datas = opt.datas;

		        if (!datas) {
		            datas = {main: mainData};
		            opt.datasAttr = {main: 'data'};
		        }
		        opt.datas = opt.mainData = null;

		        linkAll(mainData, datas, opt);

		        // Porxy data original methods.
		        each(datas, function (data) {
		            each(mainData.TRANSFERABLE_METHODS, function (methodName) {
		                data.wrapMethod(methodName, zrUtil.curry(transferInjection, opt));
		            });

		        });

		        // Beyond transfer, additional features should be added to `cloneShallow`.
		        mainData.wrapMethod('cloneShallow', zrUtil.curry(cloneShallowInjection, opt));

		        // Only mainData trigger change, because struct.update may trigger
		        // another changable methods, which may bring about dead lock.
		        each(mainData.CHANGABLE_METHODS, function (methodName) {
		            mainData.wrapMethod(methodName, zrUtil.curry(changeInjection, opt));
		        });

		        // Make sure datas contains mainData.
		        zrUtil.assert(datas[mainData.dataType] === mainData);
		    }

		    function transferInjection(opt, res) {
		        if (isMainData(this)) {
		            // Transfer datas to new main data.
		            var datas = zrUtil.extend({}, this[DATAS]);
		            datas[this.dataType] = res;
		            linkAll(res, datas, opt);
		        }
		        else {
		            // Modify the reference in main data to point newData.
		            linkSingle(res, this.dataType, this[MAIN_DATA], opt);
		        }
		        return res;
		    }

		    function changeInjection(opt, res) {
		        opt.struct && opt.struct.update(this);
		        return res;
		    }

		    function cloneShallowInjection(opt, res) {
		        // cloneShallow, which brings about some fragilities, may be inappropriate
		        // to be exposed as an API. So for implementation simplicity we can make
		        // the restriction that cloneShallow of not-mainData should not be invoked
		        // outside, but only be invoked here.
		        each(res[DATAS], function (data, dataType) {
		            data !== res && linkSingle(data.cloneShallow(), dataType, res, opt);
		        });
		        return res;
		    }

		    /**
		     * Supplement method to List.
		     *
		     * @public
		     * @param {string} [dataType] If not specified, return mainData.
		     * @return {module:echarts/data/List}
		     */
		    function getLinkedData(dataType) {
		        var mainData = this[MAIN_DATA];
		        return (dataType == null || mainData == null)
		            ? mainData
		            : mainData[DATAS][dataType];
		    }

		    function isMainData(data) {
		        return data[MAIN_DATA] === data;
		    }

		    function linkAll(mainData, datas, opt) {
		        mainData[DATAS] = {};
		        each(datas, function (data, dataType) {
		            linkSingle(data, dataType, mainData, opt);
		        });
		    }

		    function linkSingle(data, dataType, mainData, opt) {
		        mainData[DATAS][dataType] = data;
		        data[MAIN_DATA] = mainData;
		        data.dataType = dataType;

		        if (opt.struct) {
		            data[opt.structAttr] = opt.struct;
		            opt.struct[opt.datasAttr[dataType]] = data;
		        }

		        // Supplement method.
		        data.getLinkedData = getLinkedData;
		    }

		    module.exports = linkList;


	/***/ },
	/* 188 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    var helper = {

		        retrieveTargetInfo: function (payload, seriesModel) {
		            if (payload
		                && (
		                    payload.type === 'treemapZoomToNode'
		                    || payload.type === 'treemapRootToNode'
		                )
		            ) {
		                var root = seriesModel.getData().tree.root;
		                var targetNode = payload.targetNode;
		                if (targetNode && root.contains(targetNode)) {
		                    return {node: targetNode};
		                }

		                var targetNodeId = payload.targetNodeId;
		                if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
		                    return {node: targetNode};
		                }
		            }
		        },

		        // Not includes the given node at the last item.
		        getPathToRoot: function (node) {
		            var path = [];
		            while (node) {
		                node = node.parentNode;
		                node && path.push(node);
		            }
		            return path.reverse();
		        },

		        aboveViewRoot: function (viewRoot, node) {
		            var viewPath = helper.getPathToRoot(viewRoot);
		            return zrUtil.indexOf(viewPath, node) >= 0;
		        },

		        // From root to the input node (the input node will be included).
		        wrapTreePathInfo: function (node, seriesModel) {
		            var treePathInfo = [];

		            while (node) {
		                var nodeDataIndex = node.dataIndex;
		                treePathInfo.push({
		                    name: node.name,
		                    dataIndex: nodeDataIndex,
		                    value: seriesModel.getRawValue(nodeDataIndex)
		                });
		                node = node.parentNode;
		            }

		            treePathInfo.reverse();

		            return treePathInfo;
		        }
		    };

		    module.exports = helper;


	/***/ },
	/* 189 */
	/***/ function(module, exports, __webpack_require__) {

		 

		    var zrUtil = __webpack_require__(4);
		    var graphic = __webpack_require__(43);
		    var DataDiffer = __webpack_require__(99);
		    var helper = __webpack_require__(188);
		    var Breadcrumb = __webpack_require__(190);
		    var RoamController = __webpack_require__(176);
		    var BoundingRect = __webpack_require__(9);
		    var matrix = __webpack_require__(11);
		    var animationUtil = __webpack_require__(191);
		    var bind = zrUtil.bind;
		    var Group = graphic.Group;
		    var Rect = graphic.Rect;
		    var each = zrUtil.each;

		    var DRAG_THRESHOLD = 3;
		    var PATH_LABEL_NORMAL = ['label', 'normal'];
		    var PATH_LABEL_EMPHASIS = ['label', 'emphasis'];
		    var Z_BASE = 10; // Should bigger than every z.
		    var Z_BG = 1;
		    var Z_CONTENT = 2;

		    module.exports = __webpack_require__(1).extendChartView({

		        type: 'treemap',

		        /**
		         * @override
		         */
		        init: function (o, api) {

		            /**
		             * @private
		             * @type {module:zrender/container/Group}
		             */
		            this._containerGroup;

		            /**
		             * @private
		             * @type {Object.<string, Array.<module:zrender/container/Group>>}
		             */
		            this._storage = createStorage();

		            /**
		             * @private
		             * @type {module:echarts/data/Tree}
		             */
		            this._oldTree;

		            /**
		             * @private
		             * @type {module:echarts/chart/treemap/Breadcrumb}
		             */
		            this._breadcrumb;

		            /**
		             * @private
		             * @type {module:echarts/component/helper/RoamController}
		             */
		            this._controller;

		            /**
		             * 'ready', 'animating'
		             * @private
		             */
		            this._state = 'ready';

		            /**
		             * @private
		             * @type {boolean}
		             */
		            this._mayClick;
		        },

		        /**
		         * @override
		         */
		        render: function (seriesModel, ecModel, api, payload) {

		            var models = ecModel.findComponents({
		                mainType: 'series', subType: 'treemap', query: payload
		            });
		            if (zrUtil.indexOf(models, seriesModel) < 0) {
		                return;
		            }

		            this.seriesModel = seriesModel;
		            this.api = api;
		            this.ecModel = ecModel;

		            var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);
		            var payloadType = payload && payload.type;
		            var layoutInfo = seriesModel.layoutInfo;
		            var isInit = !this._oldTree;
		            var thisStorage = this._storage;

		            // Mark new root when action is treemapRootToNode.
		            var reRoot = (payloadType === 'treemapRootToNode' && targetInfo && thisStorage)
		                ? {
		                    rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
		                    direction: payload.direction
		                }
		                : null;

		            var containerGroup = this._giveContainerGroup(layoutInfo);

		            var renderResult = this._doRender(containerGroup, seriesModel, reRoot);
		            (
		                !isInit && (
		                    !payloadType
		                    || payloadType === 'treemapZoomToNode'
		                    || payloadType === 'treemapRootToNode'
		                )
		            )
		                ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot)
		                : renderResult.renderFinally();

		            this._resetController(api);

		            this._renderBreadcrumb(seriesModel, api, targetInfo);
		        },

		        /**
		         * @private
		         */
		        _giveContainerGroup: function (layoutInfo) {
		            var containerGroup = this._containerGroup;
		            if (!containerGroup) {
		                // FIXME
		                // 加一层containerGroup是为了clip，但是现在clip功能并没有实现。
		                containerGroup = this._containerGroup = new Group();
		                this._initEvents(containerGroup);
		                this.group.add(containerGroup);
		            }
		            containerGroup.attr('position', [layoutInfo.x, layoutInfo.y]);

		            return containerGroup;
		        },

		        /**
		         * @private
		         */
		        _doRender: function (containerGroup, seriesModel, reRoot) {
		            var thisTree = seriesModel.getData().tree;
		            var oldTree = this._oldTree;

		            // Clear last shape records.
		            var lastsForAnimation = createStorage();
		            var thisStorage = createStorage();
		            var oldStorage = this._storage;
		            var willInvisibleEls = [];
		            var doRenderNode = zrUtil.curry(
		                renderNode, seriesModel,
		                thisStorage, oldStorage, reRoot,
		                lastsForAnimation, willInvisibleEls
		            );

		            // Notice: when thisTree and oldTree are the same tree (see list.cloneShadow),
		            // the oldTree is actually losted, so we can not find all of the old graphic
		            // elements from tree. So we use this stragegy: make element storage, move
		            // from old storage to new storage, clear old storage.

		            dualTravel(
		                thisTree.root ? [thisTree.root] : [],
		                (oldTree && oldTree.root) ? [oldTree.root] : [],
		                containerGroup,
		                thisTree === oldTree || !oldTree,
		                0
		            );

		            // Process all removing.
		            var willDeleteEls = clearStorage(oldStorage);

		            this._oldTree = thisTree;
		            this._storage = thisStorage;

		            return {
		                lastsForAnimation: lastsForAnimation,
		                willDeleteEls: willDeleteEls,
		                renderFinally: renderFinally
		            };

		            function dualTravel(thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
		                // When 'render' is triggered by action,
		                // 'this' and 'old' may be the same tree,
		                // we use rawIndex in that case.
		                if (sameTree) {
		                    oldViewChildren = thisViewChildren;
		                    each(thisViewChildren, function (child, index) {
		                        !child.isRemoved() && processNode(index, index);
		                    });
		                }
		                // Diff hierarchically (diff only in each subtree, but not whole).
		                // because, consistency of view is important.
		                else {
		                    (new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey))
		                        .add(processNode)
		                        .update(processNode)
		                        .remove(zrUtil.curry(processNode, null))
		                        .execute();
		                }

		                function getKey(node) {
		                    // Identify by name or raw index.
		                    return node.getId();
		                }

		                function processNode(newIndex, oldIndex) {
		                    var thisNode = newIndex != null ? thisViewChildren[newIndex] : null;
		                    var oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null;

		                    var group = doRenderNode(thisNode, oldNode, parentGroup, depth);

		                    group && dualTravel(
		                        thisNode && thisNode.viewChildren || [],
		                        oldNode && oldNode.viewChildren || [],
		                        group,
		                        sameTree,
		                        depth + 1
		                    );
		                }
		            }

		            function clearStorage(storage) {
		                var willDeleteEls = createStorage();
		                storage && each(storage, function (store, storageName) {
		                    var delEls = willDeleteEls[storageName];
		                    each(store, function (el) {
		                        el && (delEls.push(el), el.__tmWillDelete = 1);
		                    });
		                });
		                return willDeleteEls;
		            }

		            function renderFinally() {
		                each(willDeleteEls, function (els) {
		                    each(els, function (el) {
		                        el.parent && el.parent.remove(el);
		                    });
		                });
		                each(willInvisibleEls, function (el) {
		                    el.invisible = true;
		                    // Setting invisible is for optimizing, so no need to set dirty,
		                    // just mark as invisible.
		                    el.dirty();
		                });
		            }
		        },

		        /**
		         * @private
		         */
		        _doAnimation: function (containerGroup, renderResult, seriesModel, reRoot) {
		            if (!seriesModel.get('animation')) {
		                return;
		            }

		            var duration = seriesModel.get('animationDurationUpdate');
		            var easing = seriesModel.get('animationEasing');
		            var animationWrap = animationUtil.createWrap();

		            // Make delete animations.
		            each(renderResult.willDeleteEls, function (store, storageName) {
		                each(store, function (el, rawIndex) {
		                    if (el.invisible) {
		                        return;
		                    }

		                    var parent = el.parent; // Always has parent, and parent is nodeGroup.
		                    var target;

		                    if (reRoot && reRoot.direction === 'drillDown') {
		                        target = parent === reRoot.rootNodeGroup
		                            // This is the content element of view root.
		                            // Only `content` will enter this branch, because
		                            // `background` and `nodeGroup` will not be deleted.
		                            ? {
		                                shape: {
		                                    x: 0,
		                                    y: 0,
		                                    width: parent.__tmNodeWidth,
		                                    height: parent.__tmNodeHeight
		                                },
		                                style: {
		                                    opacity: 0
		                                }
		                            }
		                            // Others.
		                            : {style: {opacity: 0}};
		                    }
		                    else {
		                        var targetX = 0;
		                        var targetY = 0;

		                        if (!parent.__tmWillDelete) {
		                            // Let node animate to right-bottom corner, cooperating with fadeout,
		                            // which is appropriate for user understanding.
		                            // Divided by 2 for reRoot rolling up effect.
		                            targetX = parent.__tmNodeWidth / 2;
		                            targetY = parent.__tmNodeHeight / 2;
		                        }

		                        target = storageName === 'nodeGroup'
		                            ? {position: [targetX, targetY], style: {opacity: 0}}
		                            : {
		                                shape: {x: targetX, y: targetY, width: 0, height: 0},
		                                style: {opacity: 0}
		                            };
		                    }

		                    target && animationWrap.add(el, target, duration, easing);
		                });
		            });

		            // Make other animations
		            each(this._storage, function (store, storageName) {
		                each(store, function (el, rawIndex) {
		                    var last = renderResult.lastsForAnimation[storageName][rawIndex];
		                    var target = {};

		                    if (!last) {
		                        return;
		                    }

		                    if (storageName === 'nodeGroup') {
		                        if (last.old) {
		                            target.position = el.position.slice();
		                            el.attr('position', last.old);
		                        }
		                    }
		                    else {
		                        if (last.old) {
		                            target.shape = zrUtil.extend({}, el.shape);
		                            el.setShape(last.old);
		                        }

		                        if (last.fadein) {
		                            el.setStyle('opacity', 0);
		                            target.style = {opacity: 1};
		                        }
		                        // When animation is stopped for succedent animation starting,
		                        // el.style.opacity might not be 1
		                        else if (el.style.opacity !== 1) {
		                            target.style = {opacity: 1};
		                        }
		                    }

		                    animationWrap.add(el, target, duration, easing);
		                });
		            }, this);

		            this._state = 'animating';

		            animationWrap
		                .done(bind(function () {
		                    this._state = 'ready';
		                    renderResult.renderFinally();
		                }, this))
		                .start();
		        },

		        /**
		         * @private
		         */
		        _resetController: function (api) {
		            var controller = this._controller;

		            // Init controller.
		            if (!controller) {
		                controller = this._controller = new RoamController(api.getZr());
		                controller.enable(this.seriesModel.get('roam'));
		                controller.on('pan', bind(this._onPan, this));
		                controller.on('zoom', bind(this._onZoom, this));
		            }

		            var rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight());
		            controller.setContainsPoint(function (x, y) {
		                return rect.contain(x, y);
		            });
		        },

		        /**
		         * @private
		         */
		        _clearController: function () {
		            var controller = this._controller;
		            if (controller) {
		                controller.dispose();
		                controller = null;
		            }
		        },

		        /**
		         * @private
		         */
		        _onPan: function (dx, dy) {
		            this._mayClick = false;

		            if (this._state !== 'animating'
		                && (Math.abs(dx) > DRAG_THRESHOLD || Math.abs(dy) > DRAG_THRESHOLD)
		            ) {
		                // These param must not be cached.
		                var root = this.seriesModel.getData().tree.root;

		                if (!root) {
		                    return;
		                }

		                var rootLayout = root.getLayout();

		                if (!rootLayout) {
		                    return;
		                }

		                this.api.dispatchAction({
		                    type: 'treemapMove',
		                    from: this.uid,
		                    seriesId: this.seriesModel.id,
		                    rootRect: {
		                        x: rootLayout.x + dx, y: rootLayout.y + dy,
		                        width: rootLayout.width, height: rootLayout.height
		                    }
		                });
		            }
		        },

		        /**
		         * @private
		         */
		        _onZoom: function (scale, mouseX, mouseY) {
		            this._mayClick = false;

		            if (this._state !== 'animating') {
		                // These param must not be cached.
		                var root = this.seriesModel.getData().tree.root;

		                if (!root) {
		                    return;
		                }

		                var rootLayout = root.getLayout();

		                if (!rootLayout) {
		                    return;
		                }

		                var rect = new BoundingRect(
		                    rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height
		                );
		                var layoutInfo = this.seriesModel.layoutInfo;

		                // Transform mouse coord from global to containerGroup.
		                mouseX -= layoutInfo.x;
		                mouseY -= layoutInfo.y;

		                // Scale root bounding rect.
		                var m = matrix.create();
		                matrix.translate(m, m, [-mouseX, -mouseY]);
		                matrix.scale(m, m, [scale, scale]);
		                matrix.translate(m, m, [mouseX, mouseY]);

		                rect.applyTransform(m);

		                this.api.dispatchAction({
		                    type: 'treemapRender',
		                    from: this.uid,
		                    seriesId: this.seriesModel.id,
		                    rootRect: {
		                        x: rect.x, y: rect.y,
		                        width: rect.width, height: rect.height
		                    }
		                });
		            }
		        },

		        /**
		         * @private
		         */
		        _initEvents: function (containerGroup) {
		            // FIXME
		            // 不用click以及silent的原因是，animate时视图设置silent true来避免click生效，
		            // 但是animate中，按下鼠标，animate结束后（silent设回为false）松开鼠标，
		            // 还是会触发click，期望是不触发。

		            // Mousedown occurs when drag start, and mouseup occurs when drag end,
		            // click event should not be triggered in that case.

		            containerGroup.on('mousedown', function (e) {
		                this._state === 'ready' && (this._mayClick = true);
		            }, this);
		            containerGroup.on('mouseup', function (e) {
		                if (this._mayClick) {
		                    this._mayClick = false;
		                    this._state === 'ready' && onClick.call(this, e);
		                }
		            }, this);

		            function onClick(e) {
		                var nodeClick = this.seriesModel.get('nodeClick', true);

		                if (!nodeClick) {
		                    return;
		                }

		                var targetInfo = this.findTarget(e.offsetX, e.offsetY);

		                if (!targetInfo) {
		                    return;
		                }

		                var node = targetInfo.node;
		                if (node.getLayout().isLeafRoot) {
		                    this._rootToNode(targetInfo);
		                }
		                else {
		                    if (nodeClick === 'zoomToNode') {
		                        this._zoomToNode(targetInfo);
		                    }
		                    else if (nodeClick === 'link') {
		                        var itemModel = node.hostTree.data.getItemModel(node.dataIndex);
		                        var link = itemModel.get('link', true);
		                        var linkTarget = itemModel.get('target', true) || 'blank';
		                        link && window.open(link, linkTarget);
		                    }
		                }
		            }
		        },

		        /**
		         * @private
		         */
		        _renderBreadcrumb: function (seriesModel, api, targetInfo) {
		            if (!targetInfo) {
		                targetInfo = seriesModel.get('leafDepth', true) != null
		                    ? {node: seriesModel.getViewRoot()}
		                    // FIXME
		                    // better way?
		                    // Find breadcrumb tail on center of containerGroup.
		                    : this.findTarget(api.getWidth() / 2, api.getHeight() / 2);

		                if (!targetInfo) {
		                    targetInfo = {node: seriesModel.getData().tree.root};
		                }
		            }

		            (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group)))
		                .render(seriesModel, api, targetInfo.node, bind(onSelect, this));

		            function onSelect(node) {
		                if (this._state !== 'animating') {
		                    helper.aboveViewRoot(seriesModel.getViewRoot(), node)
		                        ? this._rootToNode({node: node})
		                        : this._zoomToNode({node: node});
		                }
		            }
		        },

		        /**
		         * @override
		         */
		        remove: function () {
		            this._clearController();
		            this._containerGroup && this._containerGroup.removeAll();
		            this._storage = createStorage();
		            this._state = 'ready';
		            this._breadcrumb && this._breadcrumb.remove();
		        },

		        dispose: function () {
		            this._clearController();
		        },

		        /**
		         * @private
		         */
		        _zoomToNode: function (targetInfo) {
		            this.api.dispatchAction({
		                type: 'treemapZoomToNode',
		                from: this.uid,
		                seriesId: this.seriesModel.id,
		                targetNode: targetInfo.node
		            });
		        },

		        /**
		         * @private
		         */
		        _rootToNode: function (targetInfo) {
		            this.api.dispatchAction({
		                type: 'treemapRootToNode',
		                from: this.uid,
		                seriesId: this.seriesModel.id,
		                targetNode: targetInfo.node
		            });
		        },

		        /**
		         * @public
		         * @param {number} x Global coord x.
		         * @param {number} y Global coord y.
		         * @return {Object} info If not found, return undefined;
		         * @return {number} info.node Target node.
		         * @return {number} info.offsetX x refer to target node.
		         * @return {number} info.offsetY y refer to target node.
		         */
		        findTarget: function (x, y) {
		            var targetInfo;
		            var viewRoot = this.seriesModel.getViewRoot();

		            viewRoot.eachNode({attr: 'viewChildren', order: 'preorder'}, function (node) {
		                var bgEl = this._storage.background[node.getRawIndex()];
		                // If invisible, there might be no element.
		                if (bgEl) {
		                    var point = bgEl.transformCoordToLocal(x, y);
		                    var shape = bgEl.shape;

		                    // For performance consideration, dont use 'getBoundingRect'.
		                    if (shape.x <= point[0]
		                        && point[0] <= shape.x + shape.width
		                        && shape.y <= point[1]
		                        && point[1] <= shape.y + shape.height
		                    ) {
		                        targetInfo = {node: node, offsetX: point[0], offsetY: point[1]};
		                    }
		                    else {
		                        return false; // Suppress visit subtree.
		                    }
		                }
		            }, this);

		            return targetInfo;
		        }

		    });

		    /**
		     * @inner
		     */
		    function createStorage() {
		        return {nodeGroup: [], background: [], content: []};
		    }

		    /**
		     * @inner
		     * @return Return undefined means do not travel further.
		     */
		    function renderNode(
		        seriesModel, thisStorage, oldStorage, reRoot,
		        lastsForAnimation, willInvisibleEls,
		        thisNode, oldNode, parentGroup, depth
		    ) {
		        // Whether under viewRoot.
		        if (!thisNode) {
		            // Deleting nodes will be performed finally. This method just find
		            // element from old storage, or create new element, set them to new
		            // storage, and set styles.
		            return;
		        }

		        var thisLayout = thisNode.getLayout();

		        if (!thisLayout || !thisLayout.isInView) {
		            return;
		        }

		        var thisWidth = thisLayout.width;
		        var thisHeight = thisLayout.height;
		        var thisInvisible = thisLayout.invisible;

		        var thisRawIndex = thisNode.getRawIndex();
		        var oldRawIndex = oldNode && oldNode.getRawIndex();

		        // Node group
		        var group = giveGraphic('nodeGroup', Group);

		        if (!group) {
		            return;
		        }

		        parentGroup.add(group);
		        // x,y are not set when el is above view root.
		        group.attr('position', [thisLayout.x || 0, thisLayout.y || 0]);
		        group.__tmNodeWidth = thisWidth;
		        group.__tmNodeHeight = thisHeight;

		        if (thisLayout.isAboveViewRoot) {
		            return group;
		        }

		        // Background
		        var bg = giveGraphic('background', Rect, depth, Z_BG);
		        if (bg) {
		            bg.setShape({x: 0, y: 0, width: thisWidth, height: thisHeight});
		            updateStyle(bg, function () {
		                bg.setStyle('fill', thisNode.getVisual('borderColor', true));
		            });
		            group.add(bg);
		        }

		        var thisViewChildren = thisNode.viewChildren;

		        // No children, render content.
		        if (!thisViewChildren || !thisViewChildren.length) {
		            var content = giveGraphic('content', Rect, depth, Z_CONTENT);
		            content && renderContent(group);
		        }

		        return group;

		        // ----------------------------
		        // | Procedures in renderNode |
		        // ----------------------------

		        function renderContent(group) {
		            // For tooltip.
		            content.dataIndex = thisNode.dataIndex;
		            content.seriesIndex = seriesModel.seriesIndex;

		            var borderWidth = thisLayout.borderWidth;
		            var contentWidth = Math.max(thisWidth - 2 * borderWidth, 0);
		            var contentHeight = Math.max(thisHeight - 2 * borderWidth, 0);

		            content.culling = true;
		            content.setShape({
		                x: borderWidth,
		                y: borderWidth,
		                width: contentWidth,
		                height: contentHeight
		            });

		            var visualColor = thisNode.getVisual('color', true);
		            updateStyle(content, function () {
		                var normalStyle = {fill: visualColor};
		                var emphasisStyle = thisNode.getModel('itemStyle.emphasis').getItemStyle();

		                prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight);

		                content.setStyle(normalStyle);
		                graphic.setHoverStyle(content, emphasisStyle);
		            });

		            group.add(content);
		        }

		        function updateStyle(element, cb) {
		            if (!thisInvisible) {
		                // If invisible, do not set visual, otherwise the element will
		                // change immediately before animation. We think it is OK to
		                // remain its origin color when moving out of the view window.
		                cb();

		                if (!element.__tmWillVisible) {
		                    element.invisible = false;
		                }
		            }
		            else {
		                // Delay invisible setting utill animation finished,
		                // avoid element vanish suddenly before animation.
		                !element.invisible && willInvisibleEls.push(element);
		            }
		        }

		        function prepareText(normalStyle, emphasisStyle, visualColor, contentWidth, contentHeight) {
		            var nodeModel = thisNode.getModel();
		            var text = nodeModel.get('name');
		            if (thisLayout.isLeafRoot) {
		                var iconChar = seriesModel.get('drillDownIcon', true);
		                text = iconChar ? iconChar + ' ' + text : text;
		            }

		            setText(
		                text, normalStyle, nodeModel, PATH_LABEL_NORMAL,
		                visualColor, contentWidth, contentHeight
		            );
		            setText(
		                text, emphasisStyle, nodeModel, PATH_LABEL_EMPHASIS,
		                visualColor, contentWidth, contentHeight
		            );
		        }

		        function setText(text, style, nodeModel, labelPath, visualColor, contentWidth, contentHeight) {
		            var labelModel = nodeModel.getModel(labelPath);
		            var labelTextStyleModel = labelModel.getModel('textStyle');

		            graphic.setText(style, labelModel, visualColor);

		            // text.align and text.baseline is not included by graphic.setText,
		            // because in most cases the two attributes are not exposed to user,
		            // except in treemap.
		            style.textAlign = labelTextStyleModel.get('align');
		            style.textVerticalAlign = labelTextStyleModel.get('baseline');

		            var textRect = labelTextStyleModel.getTextRect(text);
		            if (!labelModel.getShallow('show') || textRect.height > contentHeight) {
		                style.text = '';
		            }
		            else if (textRect.width > contentWidth) {
		                style.text = labelTextStyleModel.get('ellipsis')
		                    ? labelTextStyleModel.truncateText(
		                        text, contentWidth, null, {minChar: 2}
		                    )
		                    : '';
		            }
		            else {
		                style.text = text;
		            }
		        }

		        function giveGraphic(storageName, Ctor, depth, z) {
		            var element = oldRawIndex != null && oldStorage[storageName][oldRawIndex];
		            var lasts = lastsForAnimation[storageName];

		            if (element) {
		                // Remove from oldStorage
		                oldStorage[storageName][oldRawIndex] = null;
		                prepareAnimationWhenHasOld(lasts, element, storageName);
		            }
		            // If invisible and no old element, do not create new element (for optimizing).
		            else if (!thisInvisible) {
		                element = new Ctor({z: calculateZ(depth, z)});
		                element.__tmDepth = depth;
		                element.__tmStorageName = storageName;
		                prepareAnimationWhenNoOld(lasts, element, storageName);
		            }

		            // Set to thisStorage
		            return (thisStorage[storageName][thisRawIndex] = element);
		        }

		        function prepareAnimationWhenHasOld(lasts, element, storageName) {
		            var lastCfg = lasts[thisRawIndex] = {};
		            lastCfg.old = storageName === 'nodeGroup'
		                ? element.position.slice()
		                : zrUtil.extend({}, element.shape);
		        }

		        // If a element is new, we need to find the animation start point carefully,
		        // otherwise it will looks strange when 'zoomToNode'.
		        function prepareAnimationWhenNoOld(lasts, element, storageName) {
		            var lastCfg = lasts[thisRawIndex] = {};
		            var parentNode = thisNode.parentNode;

		            if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {
		                var parentOldX = 0;
		                var parentOldY = 0;

		                // New nodes appear from right-bottom corner in 'zoomToNode' animation.
		                // For convenience, get old bounding rect from background.
		                var parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()];
		                if (!reRoot && parentOldBg && parentOldBg.old) {
		                    parentOldX = parentOldBg.old.width;
		                    parentOldY = parentOldBg.old.height;
		                }

		                // When no parent old shape found, its parent is new too,
		                // so we can just use {x:0, y:0}.
		                lastCfg.old = storageName === 'nodeGroup'
		                    ? [0, parentOldY]
		                    : {x: parentOldX, y: parentOldY, width: 0, height: 0};
		            }

		            // Fade in, user can be aware that these nodes are new.
		            lastCfg.fadein = storageName !== 'nodeGroup';
		        }
		    }

		    // We can not set all backgroud with the same z, Because the behaviour of
		    // drill down and roll up differ background creation sequence from tree
		    // hierarchy sequence, which cause that lowser background element overlap
		    // upper ones. So we calculate z based on depth.
		    // Moreover, we try to shrink down z interval to [0, 1] to avoid that
		    // treemap with large z overlaps other components.
		    function calculateZ(depth, zInLevel) {
		        var zb = depth * Z_BASE + zInLevel;
		        return (zb - 1) / zb;
		    }



	/***/ },
	/* 190 */
	/***/ function(module, exports, __webpack_require__) {

		 

		    var graphic = __webpack_require__(43);
		    var layout = __webpack_require__(21);
		    var zrUtil = __webpack_require__(4);
		    var helper = __webpack_require__(188);

		    var TEXT_PADDING = 8;
		    var ITEM_GAP = 8;
		    var ARRAY_LENGTH = 5;

		    function Breadcrumb(containerGroup) {
		        /**
		         * @private
		         * @type {module:zrender/container/Group}
		         */
		        this.group = new graphic.Group();

		        containerGroup.add(this.group);
		    }

		    Breadcrumb.prototype = {

		        constructor: Breadcrumb,

		        render: function (seriesModel, api, targetNode, onSelect) {
		            var model = seriesModel.getModel('breadcrumb');
		            var thisGroup = this.group;

		            thisGroup.removeAll();

		            if (!model.get('show') || !targetNode) {
		                return;
		            }

		            var normalStyleModel = model.getModel('itemStyle.normal');
		            // var emphasisStyleModel = model.getModel('itemStyle.emphasis');
		            var textStyleModel = normalStyleModel.getModel('textStyle');

		            var layoutParam = {
		                pos: {
		                    left: model.get('left'),
		                    right: model.get('right'),
		                    top: model.get('top'),
		                    bottom: model.get('bottom')
		                },
		                box: {
		                    width: api.getWidth(),
		                    height: api.getHeight()
		                },
		                emptyItemWidth: model.get('emptyItemWidth'),
		                totalWidth: 0,
		                renderList: []
		            };

		            this._prepare(targetNode, layoutParam, textStyleModel);
		            this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect);

		            layout.positionElement(thisGroup, layoutParam.pos, layoutParam.box);
		        },

		        /**
		         * Prepare render list and total width
		         * @private
		         */
		        _prepare: function (targetNode, layoutParam, textStyleModel) {
		            for (var node = targetNode; node; node = node.parentNode) {
		                var text = node.getModel().get('name');
		                var textRect = textStyleModel.getTextRect(text);
		                var itemWidth = Math.max(
		                    textRect.width + TEXT_PADDING * 2,
		                    layoutParam.emptyItemWidth
		                );
		                layoutParam.totalWidth += itemWidth + ITEM_GAP;
		                layoutParam.renderList.push({node: node, text: text, width: itemWidth});
		            }
		        },

		        /**
		         * @private
		         */
		        _renderContent: function (
		            seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect
		        ) {
		            // Start rendering.
		            var lastX = 0;
		            var emptyItemWidth = layoutParam.emptyItemWidth;
		            var height = seriesModel.get('breadcrumb.height');
		            var availableSize = layout.getAvailableSize(layoutParam.pos, layoutParam.box);
		            var totalWidth = layoutParam.totalWidth;
		            var renderList = layoutParam.renderList;

		            for (var i = renderList.length - 1; i >= 0; i--) {
		                var item = renderList[i];
		                var itemNode = item.node;
		                var itemWidth = item.width;
		                var text = item.text;

		                // Hdie text and shorten width if necessary.
		                if (totalWidth > availableSize.width) {
		                    totalWidth -= itemWidth - emptyItemWidth;
		                    itemWidth = emptyItemWidth;
		                    text = '';
		                }

		                var el = new graphic.Polygon({
		                    shape: {
		                        points: makeItemPoints(
		                            lastX, 0, itemWidth, height,
		                            i === renderList.length - 1, i === 0
		                        )
		                    },
		                    style: zrUtil.defaults(
		                        normalStyleModel.getItemStyle(),
		                        {
		                            lineJoin: 'bevel',
		                            text: text,
		                            textFill: textStyleModel.getTextColor(),
		                            textFont: textStyleModel.getFont()
		                        }
		                    ),
		                    z: 10,
		                    onclick: zrUtil.curry(onSelect, itemNode)
		                });
		                this.group.add(el);

		                packEventData(el, seriesModel, itemNode);

		                lastX += itemWidth + ITEM_GAP;
		            }
		        },

		        /**
		         * @override
		         */
		        remove: function () {
		            this.group.removeAll();
		        }
		    };

		    function makeItemPoints(x, y, itemWidth, itemHeight, head, tail) {
		        var points = [
		            [head ? x : x - ARRAY_LENGTH, y],
		            [x + itemWidth, y],
		            [x + itemWidth, y + itemHeight],
		            [head ? x : x - ARRAY_LENGTH, y + itemHeight]
		        ];
		        !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2]);
		        !head && points.push([x, y + itemHeight / 2]);
		        return points;
		    }

		    // Package custom mouse event.
		    function packEventData(el, seriesModel, itemNode) {
		        el.eventData = {
		            componentType: 'series',
		            componentSubType: 'treemap',
		            seriesIndex: seriesModel.componentIndex,
		            seriesName: seriesModel.name,
		            seriesType: 'treemap',
		            selfType: 'breadcrumb', // Distinguish with click event on treemap node.
		            nodeData: {
		                dataIndex: itemNode && itemNode.dataIndex,
		                name: itemNode && itemNode.name
		            },
		            treePathInfo: itemNode && helper.wrapTreePathInfo(itemNode, seriesModel)
		        };
		    }

		    module.exports = Breadcrumb;


	/***/ },
	/* 191 */
	/***/ function(module, exports, __webpack_require__) {

		 

		    var zrUtil = __webpack_require__(4);

		    /**
		     * @param {number} [time=500] Time in ms
		     * @param {string} [easing='linear']
		     * @param {number} [delay=0]
		     * @param {Function} [callback]
		     *
		     * @example
		     *  // Animate position
		     *  animation
		     *      .createWrap()
		     *      .add(el1, {position: [10, 10]})
		     *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)
		     *      .done(function () { // done })
		     *      .start('cubicOut');
		     */
		    function createWrap() {

		        var storage = [];
		        var elExistsMap = {};
		        var doneCallback;

		        return {

		            /**
		             * Caution: a el can only be added once, otherwise 'done'
		             * might not be called. This method checks this (by el.id),
		             * suppresses adding and returns false when existing el found.
		             *
		             * @param {modele:zrender/Element} el
		             * @param {Object} target
		             * @param {number} [time=500]
		             * @param {number} [delay=0]
		             * @param {string} [easing='linear']
		             * @return {boolean} Whether adding succeeded.
		             *
		             * @example
		             *     add(el, target, time, delay, easing);
		             *     add(el, target, time, easing);
		             *     add(el, target, time);
		             *     add(el, target);
		             */
		            add: function (el, target, time, delay, easing) {
		                if (zrUtil.isString(delay)) {
		                    easing = delay;
		                    delay = 0;
		                }

		                if (elExistsMap[el.id]) {
		                    return false;
		                }
		                elExistsMap[el.id] = 1;

		                storage.push(
		                    {el: el, target: target, time: time, delay: delay, easing: easing}
		                );

		                return true;
		            },

		            /**
		             * Only execute when animation finished. Will not execute when any
		             * of 'stop' or 'stopAnimation' called.
		             *
		             * @param {Function} callback
		             */
		            done: function (callback) {
		                doneCallback = callback;
		                return this;
		            },

		            /**
		             * Will stop exist animation firstly.
		             */
		            start: function () {
		                var count = storage.length;

		                for (var i = 0, len = storage.length; i < len; i++) {
		                    var item = storage[i];
		                    item.el.animateTo(item.target, item.time, item.delay, item.easing, done);
		                }

		                return this;

		                function done() {
		                    count--;
		                    if (!count) {
		                        storage.length = 0;
		                        elExistsMap = {};
		                        doneCallback && doneCallback();
		                    }
		                }
		            }
		        };
		    }

		    module.exports = {createWrap: createWrap};


	/***/ },
	/* 192 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @file Treemap action
		 */


		    var echarts = __webpack_require__(1);
		    var helper = __webpack_require__(188);

		    var noop = function () {};

		    var actionTypes = [
		        'treemapZoomToNode',
		        'treemapRender',
		        'treemapMove'
		    ];

		    for (var i = 0; i < actionTypes.length; i++) {
		        echarts.registerAction({type: actionTypes[i], update: 'updateView'}, noop);
		    }

		    echarts.registerAction(
		        {type: 'treemapRootToNode', update: 'updateView'},
		        function (payload, ecModel) {

		            ecModel.eachComponent(
		                {mainType: 'series', subType: 'treemap', query: payload},
		                handleRootToNode
		            );

		            function handleRootToNode(model, index) {
		                var targetInfo = helper.retrieveTargetInfo(payload, model);

		                if (targetInfo) {
		                    var originViewRoot = model.getViewRoot();
		                    if (originViewRoot) {
		                        payload.direction = helper.aboveViewRoot(originViewRoot, targetInfo.node)
		                            ? 'rollUp' : 'drillDown';
		                    }
		                    model.resetViewRoot(targetInfo.node);
		                }
		            }
		        }
		    );



	/***/ },
	/* 193 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var VisualMapping = __webpack_require__(194);
		    var zrColor = __webpack_require__(39);
		    var zrUtil = __webpack_require__(4);
		    var isArray = zrUtil.isArray;

		    var ITEM_STYLE_NORMAL = 'itemStyle.normal';

		    module.exports = function (ecModel, api, payload) {

		        var condition = {mainType: 'series', subType: 'treemap', query: payload};
		        ecModel.eachComponent(condition, function (seriesModel) {

		            var tree = seriesModel.getData().tree;
		            var root = tree.root;
		            var seriesItemStyleModel = seriesModel.getModel(ITEM_STYLE_NORMAL);

		            if (root.isRemoved()) {
		                return;
		            }

		            var levelItemStyles = zrUtil.map(tree.levelModels, function (levelModel) {
		                return levelModel ? levelModel.get(ITEM_STYLE_NORMAL) : null;
		            });

		            travelTree(
		                root, // Visual should calculate from tree root but not view root.
		                {},
		                levelItemStyles,
		                seriesItemStyleModel,
		                seriesModel.getViewRoot().getAncestors(),
		                seriesModel
		            );
		        });
		    };

		    function travelTree(
		        node, designatedVisual, levelItemStyles, seriesItemStyleModel,
		        viewRootAncestors, seriesModel
		    ) {
		        var nodeModel = node.getModel();
		        var nodeLayout = node.getLayout();

		        // Optimize
		        if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
		            return;
		        }

		        var nodeItemStyleModel = node.getModel(ITEM_STYLE_NORMAL);
		        var levelItemStyle = levelItemStyles[node.depth];
		        var visuals = buildVisuals(
		            nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel
		        );

		        // calculate border color
		        var borderColor = nodeItemStyleModel.get('borderColor');
		        var borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation');
		        var thisNodeColor;
		        if (borderColorSaturation != null) {
		            // For performance, do not always execute 'calculateColor'.
		            thisNodeColor = calculateColor(visuals, node);
		            borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor);
		        }
		        node.setVisual('borderColor', borderColor);

		        var viewChildren = node.viewChildren;
		        if (!viewChildren || !viewChildren.length) {
		            thisNodeColor = calculateColor(visuals, node);
		            // Apply visual to this node.
		            node.setVisual('color', thisNodeColor);
		        }
		        else {
		            var mapping = buildVisualMapping(
		                node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren
		            );

		            // Designate visual to children.
		            zrUtil.each(viewChildren, function (child, index) {
		                // If higher than viewRoot, only ancestors of viewRoot is needed to visit.
		                if (child.depth >= viewRootAncestors.length
		                    || child === viewRootAncestors[child.depth]
		                ) {
		                    var childVisual = mapVisual(
		                        nodeModel, visuals, child, index, mapping, seriesModel
		                    );
		                    travelTree(
		                        child, childVisual, levelItemStyles, seriesItemStyleModel,
		                        viewRootAncestors, seriesModel
		                    );
		                }
		            });
		        }
		    }

		    function buildVisuals(
		        nodeItemStyleModel, designatedVisual, levelItemStyle, seriesItemStyleModel
		    ) {
		        var visuals = zrUtil.extend({}, designatedVisual);

		        zrUtil.each(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {
		            // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel
		            var val = nodeItemStyleModel.get(visualName, true); // Ignore parent
		            val == null && levelItemStyle && (val = levelItemStyle[visualName]);
		            val == null && (val = designatedVisual[visualName]);
		            val == null && (val = seriesItemStyleModel.get(visualName));

		            val != null && (visuals[visualName] = val);
		        });

		        return visuals;
		    }

		    function calculateColor(visuals) {
		        var color = getValueVisualDefine(visuals, 'color');

		        if (color) {
		            var colorAlpha = getValueVisualDefine(visuals, 'colorAlpha');
		            var colorSaturation = getValueVisualDefine(visuals, 'colorSaturation');
		            if (colorSaturation) {
		                color = zrColor.modifyHSL(color, null, null, colorSaturation);
		            }
		            if (colorAlpha) {
		                color = zrColor.modifyAlpha(color, colorAlpha);
		            }

		            return color;
		        }
		    }

		    function calculateBorderColor(borderColorSaturation, thisNodeColor) {
		        return thisNodeColor != null
		             ? zrColor.modifyHSL(thisNodeColor, null, null, borderColorSaturation)
		             : null;
		    }

		    function getValueVisualDefine(visuals, name) {
		        var value = visuals[name];
		        if (value != null && value !== 'none') {
		            return value;
		        }
		    }

		    function buildVisualMapping(
		        node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren
		    ) {
		        if (!viewChildren || !viewChildren.length) {
		            return;
		        }

		        var rangeVisual = getRangeVisual(nodeModel, 'color')
		            || (
		                visuals.color != null
		                && visuals.color !== 'none'
		                && (
		                    getRangeVisual(nodeModel, 'colorAlpha')
		                    || getRangeVisual(nodeModel, 'colorSaturation')
		                )
		            );

		        if (!rangeVisual) {
		            return;
		        }

		        var visualMin = nodeModel.get('visualMin');
		        var visualMax = nodeModel.get('visualMax');
		        var dataExtent = nodeLayout.dataExtent.slice();
		        visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin);
		        visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax);

		        var colorMappingBy = nodeModel.get('colorMappingBy');
		        var opt = {
		            type: rangeVisual.name,
		            dataExtent: dataExtent,
		            visual: rangeVisual.range
		        };
		        if (opt.type === 'color'
		            && (colorMappingBy === 'index' || colorMappingBy === 'id')
		        ) {
		            opt.mappingMethod = 'category';
		            opt.loop = true;
		            // categories is ordinal, so do not set opt.categories.
		        }
		        else {
		            opt.mappingMethod = 'linear';
		        }

		        var mapping = new VisualMapping(opt);
		        mapping.__drColorMappingBy = colorMappingBy;

		        return mapping;
		    }

		    // Notice: If we dont have the attribute 'colorRange', but only use
		    // attribute 'color' to represent both concepts of 'colorRange' and 'color',
		    // (It means 'colorRange' when 'color' is Array, means 'color' when not array),
		    // this problem will be encountered:
		    // If a level-1 node dont have children, and its siblings has children,
		    // and colorRange is set on level-1, then the node can not be colored.
		    // So we separate 'colorRange' and 'color' to different attributes.
		    function getRangeVisual(nodeModel, name) {
		        // 'colorRange', 'colorARange', 'colorSRange'.
		        // If not exsits on this node, fetch from levels and series.
		        var range = nodeModel.get(name);
		        return (isArray(range) && range.length) ? {name: name, range: range} : null;
		    }

		    function mapVisual(nodeModel, visuals, child, index, mapping, seriesModel) {
		        var childVisuals = zrUtil.extend({}, visuals);

		        if (mapping) {
		            var mappingType = mapping.type;
		            var colorMappingBy = mappingType === 'color' && mapping.__drColorMappingBy;
		            var value =
		                colorMappingBy === 'index'
		                ? index
		                : colorMappingBy === 'id'
		                ? seriesModel.mapIdToIndex(child.getId())
		                : child.getValue(nodeModel.get('visualDimension'));

		            childVisuals[mappingType] = mapping.mapValueToVisual(value);
		        }

		        return childVisuals;
		    }



	/***/ },
	/* 194 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @file Visual mapping.
		 */


		    var zrUtil = __webpack_require__(4);
		    var zrColor = __webpack_require__(39);
		    var linearMap = __webpack_require__(7).linearMap;
		    var each = zrUtil.each;
		    var isObject = zrUtil.isObject;

		    var CATEGORY_DEFAULT_VISUAL_INDEX = -1;

		    /**
		     * @param {Object} option
		     * @param {string} [option.type] See visualHandlers.
		     * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'
		     * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],
		     *                                              required when mappingMethod is 'linear'
		     * @param {Array.<Object>=} [option.pieceList] [
		     *                                             {value: someValue},
		     *                                             {interval: [min1, max1], visual: {...}},
		     *                                             {interval: [min2, max2]}
		     *                                             ],
		     *                                            required when mappingMethod is 'piecewise'.
		     *                                            Visual for only each piece can be specified.
		     * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']
		     *                                            required when mappingMethod is 'category'.
		     *                                            If no option.categories, categories is set
		     *                                            as [0, 1, 2, ...].
		     * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.
		     * @param {(Array|Object|*)} [option.visual]  Visual data.
		     *                                            when mappingMethod is 'category',
		     *                                            visual data can be array or object
		     *                                            (like: {cate1: '#222', none: '#fff'})
		     *                                            or primary types (which represents
		     *                                            defualt category visual), otherwise visual
		     *                                            can be array or primary (which will be
		     *                                            normalized to array).
		     *
		     */
		    var VisualMapping = function (option) {
		        var mappingMethod = option.mappingMethod;
		        var visualType = option.type;

		        /**
		         * @readOnly
		         * @type {Object}
		         */
		        var thisOption = this.option = zrUtil.clone(option);

		        /**
		         * @readOnly
		         * @type {string}
		         */
		        this.type = visualType;

		        /**
		         * @readOnly
		         * @type {string}
		         */
		        this.mappingMethod = mappingMethod;

		        /**
		         * @private
		         * @type {Function}
		         */
		        this._normalizeData = normalizers[mappingMethod];

		        var visualHandler = visualHandlers[visualType];

		        /**
		         * @public
		         * @type {Function}
		         */
		        this.applyVisual = visualHandler.applyVisual;

		        /**
		         * @public
		         * @type {Function}
		         */
		        this.getColorMapper = visualHandler.getColorMapper;

		        /**
		         * @private
		         * @type {Function}
		         */
		        this._doMap = visualHandler._doMap[mappingMethod];

		        if (mappingMethod === 'piecewise') {
		            normalizeVisualRange(thisOption);
		            preprocessForPiecewise(thisOption);
		        }
		        else if (mappingMethod === 'category') {
		            thisOption.categories
		                ? preprocessForSpecifiedCategory(thisOption)
		                // categories is ordinal when thisOption.categories not specified,
		                // which need no more preprocess except normalize visual.
		                : normalizeVisualRange(thisOption, true);
		        }
		        else { // mappingMethod === 'linear' or 'fixed'
		            zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);
		            normalizeVisualRange(thisOption);
		        }
		    };

		    VisualMapping.prototype = {

		        constructor: VisualMapping,

		        mapValueToVisual: function (value) {
		            var normalized = this._normalizeData(value);
		            return this._doMap(normalized, value);
		        },

		        getNormalizer: function () {
		            return zrUtil.bind(this._normalizeData, this);
		        }
		    };

		    var visualHandlers = VisualMapping.visualHandlers = {

		        color: {

		            applyVisual: makeApplyVisual('color'),

		            /**
		             * Create a mapper function
		             * @return {Function}
		             */
		            getColorMapper: function () {
		                var thisOption = this.option;
		                var parsedVisual = zrUtil.map(thisOption.visual, zrColor.parse);

		                return zrUtil.bind(
		                    thisOption.mappingMethod === 'category'
		                        ? function (value, isNormalized) {
		                            !isNormalized && (value = this._normalizeData(value));
		                            return doMapCategory.call(this, value);
		                        }
		                        : function (value, isNormalized, out) {
		                            // If output rgb array
		                            // which will be much faster and useful in pixel manipulation
		                            var returnRGBArray = !!out;
		                            !isNormalized && (value = this._normalizeData(value));
		                            out = zrColor.fastMapToColor(value, parsedVisual, out);
		                            return returnRGBArray ? out : zrUtil.stringify(out, 'rgba');
		                        },
		                    this
		                );
		            },

		            _doMap: {
		                linear: function (normalized) {
		                    return zrColor.mapToColor(normalized, this.option.visual);
		                },
		                category: doMapCategory,
		                piecewise: function (normalized, value) {
		                    var result = getSpecifiedVisual.call(this, value);
		                    if (result == null) {
		                        result = zrColor.mapToColor(normalized, this.option.visual);
		                    }
		                    return result;
		                },
		                fixed: doMapFixed
		            }
		        },

		        colorHue: makePartialColorVisualHandler(function (color, value) {
		            return zrColor.modifyHSL(color, value);
		        }),

		        colorSaturation: makePartialColorVisualHandler(function (color, value) {
		            return zrColor.modifyHSL(color, null, value);
		        }),

		        colorLightness: makePartialColorVisualHandler(function (color, value) {
		            return zrColor.modifyHSL(color, null, null, value);
		        }),

		        colorAlpha: makePartialColorVisualHandler(function (color, value) {
		            return zrColor.modifyAlpha(color, value);
		        }),

		        opacity: {
		            applyVisual: makeApplyVisual('opacity'),
		            _doMap: makeDoMap([0, 1])
		        },

		        symbol: {
		            applyVisual: function (value, getter, setter) {
		                var symbolCfg = this.mapValueToVisual(value);
		                if (zrUtil.isString(symbolCfg)) {
		                    setter('symbol', symbolCfg);
		                }
		                else if (isObject(symbolCfg)) {
		                    for (var name in symbolCfg) {
		                        if (symbolCfg.hasOwnProperty(name)) {
		                            setter(name, symbolCfg[name]);
		                        }
		                    }
		                }
		            },
		            _doMap: {
		                linear: doMapToArray,
		                category: doMapCategory,
		                piecewise: function (normalized, value) {
		                    var result = getSpecifiedVisual.call(this, value);
		                    if (result == null) {
		                        result = doMapToArray.call(this, normalized);
		                    }
		                    return result;
		                },
		                fixed: doMapFixed
		            }
		        },

		        symbolSize: {
		            applyVisual: makeApplyVisual('symbolSize'),
		            _doMap: makeDoMap([0, 1])
		        }
		    };


		    function preprocessForPiecewise(thisOption) {
		        var pieceList = thisOption.pieceList;
		        thisOption.hasSpecialVisual = false;

		        zrUtil.each(pieceList, function (piece, index) {
		            piece.originIndex = index;
		            // piece.visual is "result visual value" but not
		            // a visual range, so it does not need to be normalized.
		            if (piece.visual != null) {
		                thisOption.hasSpecialVisual = true;
		            }
		        });
		    }

		    function preprocessForSpecifiedCategory(thisOption) {
		        // Hash categories.
		        var categories = thisOption.categories;
		        var visual = thisOption.visual;

		        var categoryMap = thisOption.categoryMap = {};
		        each(categories, function (cate, index) {
		            categoryMap[cate] = index;
		        });

		        // Process visual map input.
		        if (!zrUtil.isArray(visual)) {
		            var visualArr = [];

		            if (zrUtil.isObject(visual)) {
		                each(visual, function (v, cate) {
		                    var index = categoryMap[cate];
		                    visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;
		                });
		            }
		            else { // Is primary type, represents default visual.
		                visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;
		            }

		            visual = thisOption.visual = visualArr;
		        }

		        // Remove categories that has no visual,
		        // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.
		        for (var i = categories.length - 1; i >= 0; i--) {
		            if (visual[i] == null) {
		                delete categoryMap[categories[i]];
		                categories.pop();
		            }
		        }
		    }

		    function normalizeVisualRange(thisOption, isCategory) {
		        var visual = thisOption.visual;
		        var visualArr = [];

		        if (zrUtil.isObject(visual)) {
		            each(visual, function (v) {
		                visualArr.push(v);
		            });
		        }
		        else if (visual != null) {
		            visualArr.push(visual);
		        }

		        var doNotNeedPair = {color: 1, symbol: 1};

		        if (!isCategory
		            && visualArr.length === 1
		            && !doNotNeedPair.hasOwnProperty(thisOption.type)
		        ) {
		            // Do not care visualArr.length === 0, which is illegal.
		            visualArr[1] = visualArr[0];
		        }

		        thisOption.visual = visualArr;
		    }

		    function makePartialColorVisualHandler(applyValue) {
		        return {
		            applyVisual: function (value, getter, setter) {
		                value = this.mapValueToVisual(value);
		                // Must not be array value
		                setter('color', applyValue(getter('color'), value));
		            },
		            _doMap: makeDoMap([0, 1])
		        };
		    }

		    function doMapToArray(normalized) {
		        var visual = this.option.visual;
		        return visual[
		            Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))
		        ] || {};
		    }

		    function makeApplyVisual(visualType) {
		        return function (value, getter, setter) {
		            setter(visualType, this.mapValueToVisual(value));
		        };
		    }

		    function doMapCategory(normalized) {
		        var visual = this.option.visual;
		        return visual[
		            (this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX)
		                ? normalized % visual.length
		                : normalized
		        ];
		    }

		    function doMapFixed() {
		        return this.option.visual[0];
		    }

		    function makeDoMap(sourceExtent) {
		        return {
		            linear: function (normalized) {
		                return linearMap(normalized, sourceExtent, this.option.visual, true);
		            },
		            category: doMapCategory,
		            piecewise: function (normalized, value) {
		                var result = getSpecifiedVisual.call(this, value);
		                if (result == null) {
		                    result = linearMap(normalized, sourceExtent, this.option.visual, true);
		                }
		                return result;
		            },
		            fixed: doMapFixed
		        };
		    }

		    function getSpecifiedVisual(value) {
		        var thisOption = this.option;
		        var pieceList = thisOption.pieceList;
		        if (thisOption.hasSpecialVisual) {
		            var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);
		            var piece = pieceList[pieceIndex];
		            if (piece && piece.visual) {
		                return piece.visual[this.type];
		            }
		        }
		    }


		    /**
		     * Normalizers by mapping methods.
		     */
		    var normalizers = {

		        linear: function (value) {
		            return linearMap(value, this.option.dataExtent, [0, 1], true);
		        },

		        piecewise: function (value) {
		            var pieceList = this.option.pieceList;
		            var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);
		            if (pieceIndex != null) {
		                return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);
		            }
		        },

		        category: function (value) {
		            var index = this.option.categories
		                ? this.option.categoryMap[value]
		                : value; // ordinal
		            return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;
		        },

		        fixed: zrUtil.noop
		    };



		    /**
		     * List available visual types.
		     *
		     * @public
		     * @return {Array.<string>}
		     */
		    VisualMapping.listVisualTypes = function () {
		        var visualTypes = [];
		        zrUtil.each(visualHandlers, function (handler, key) {
		            visualTypes.push(key);
		        });
		        return visualTypes;
		    };

		    /**
		     * @public
		     */
		    VisualMapping.addVisualHandler = function (name, handler) {
		        visualHandlers[name] = handler;
		    };

		    /**
		     * @public
		     */
		    VisualMapping.isValidType = function (visualType) {
		        return visualHandlers.hasOwnProperty(visualType);
		    };

		    /**
		     * Convinent method.
		     * Visual can be Object or Array or primary type.
		     *
		     * @public
		     */
		    VisualMapping.eachVisual = function (visual, callback, context) {
		        if (zrUtil.isObject(visual)) {
		            zrUtil.each(visual, callback, context);
		        }
		        else {
		            callback.call(context, visual);
		        }
		    };

		    VisualMapping.mapVisual = function (visual, callback, context) {
		        var isPrimary;
		        var newVisual = zrUtil.isArray(visual)
		            ? []
		            : zrUtil.isObject(visual)
		            ? {}
		            : (isPrimary = true, null);

		        VisualMapping.eachVisual(visual, function (v, key) {
		            var newVal = callback.call(context, v, key);
		            isPrimary ? (newVisual = newVal) : (newVisual[key] = newVal);
		        });
		        return newVisual;
		    };

		    /**
		     * @public
		     * @param {Object} obj
		     * @return {Oject} new object containers visual values.
		     *                 If no visuals, return null.
		     */
		    VisualMapping.retrieveVisuals = function (obj) {
		        var ret = {};
		        var hasVisual;

		        obj && each(visualHandlers, function (h, visualType) {
		            if (obj.hasOwnProperty(visualType)) {
		                ret[visualType] = obj[visualType];
		                hasVisual = true;
		            }
		        });

		        return hasVisual ? ret : null;
		    };

		    /**
		     * Give order to visual types, considering colorSaturation, colorAlpha depends on color.
		     *
		     * @public
		     * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
		     *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
		     * @return {Array.<string>} Sorted visual types.
		     */
		    VisualMapping.prepareVisualTypes = function (visualTypes) {
		        if (isObject(visualTypes)) {
		            var types = [];
		            each(visualTypes, function (item, type) {
		                types.push(type);
		            });
		            visualTypes = types;
		        }
		        else if (zrUtil.isArray(visualTypes)) {
		            visualTypes = visualTypes.slice();
		        }
		        else {
		            return [];
		        }

		        visualTypes.sort(function (type1, type2) {
		            // color should be front of colorSaturation, colorAlpha, ...
		            // symbol and symbolSize do not matter.
		            return (type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0)
		                ? 1 : -1;
		        });

		        return visualTypes;
		    };

		    /**
		     * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
		     * Other visuals are only depends on themself.
		     *
		     * @public
		     * @param {string} visualType1
		     * @param {string} visualType2
		     * @return {boolean}
		     */
		    VisualMapping.dependsOn = function (visualType1, visualType2) {
		        return visualType2 === 'color'
		            ? !!(visualType1 && visualType1.indexOf(visualType2) === 0)
		            : visualType1 === visualType2;
		    };

		    /**
		     * @param {number} value
		     * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]
		     *                         Always from small to big.
		     * @param {boolean} [findClosestWhenOutside=false]
		     * @return {number} index
		     */
		    VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {
		        var possibleI;
		        var abs = Infinity;

		        // value has the higher priority.
		        for (var i = 0, len = pieceList.length; i < len; i++) {
		            var pieceValue = pieceList[i].value;
		            if (pieceValue != null) {
		                if (pieceValue === value) {
		                    return i;
		                }
		                findClosestWhenOutside && updatePossible(pieceValue, i);
		            }
		        }

		        for (var i = 0, len = pieceList.length; i < len; i++) {
		            var piece = pieceList[i];
		            var interval = piece.interval;
		            var close = piece.close;

		            if (interval) {
		                if (interval[0] === -Infinity) {
		                    if (littleThan(close[1], value, interval[1])) {
		                        return i;
		                    }
		                }
		                else if (interval[1] === Infinity) {
		                    if (littleThan(close[0], interval[0], value)) {
		                        return i;
		                    }
		                }
		                else if (
		                    littleThan(close[0], interval[0], value)
		                    && littleThan(close[1], value, interval[1])
		                ) {
		                    return i;
		                }
		                findClosestWhenOutside && updatePossible(interval[0], i);
		                findClosestWhenOutside && updatePossible(interval[1], i);
		            }
		        }

		        if (findClosestWhenOutside) {
		            return value === Infinity
		                ? pieceList.length - 1
		                : value === -Infinity
		                ? 0
		                : possibleI;
		        }

		        function updatePossible(val, index) {
		            var newAbs = Math.abs(val - value);
		            if (newAbs < abs) {
		                abs = newAbs;
		                possibleI = index;
		            }
		        }

		    };

		    function littleThan(close, a, b) {
		        return close ? a <= b : a < b;
		    }

		    module.exports = VisualMapping;



	/***/ },
	/* 195 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var numberUtil = __webpack_require__(7);
		    var layout = __webpack_require__(21);
		    var helper = __webpack_require__(188);
		    var BoundingRect = __webpack_require__(9);
		    var helper = __webpack_require__(188);

		    var mathMax = Math.max;
		    var mathMin = Math.min;
		    var parsePercent = numberUtil.parsePercent;
		    var retrieveValue = zrUtil.retrieve;
		    var each = zrUtil.each;

		    /**
		     * @public
		     */
		    function update(ecModel, api, payload) {
		        // Layout result in each node:
		        // {x, y, width, height, area, borderWidth}
		        var condition = {mainType: 'series', subType: 'treemap', query: payload};
		        ecModel.eachComponent(condition, function (seriesModel) {

		            var ecWidth = api.getWidth();
		            var ecHeight = api.getHeight();
		            var seriesOption = seriesModel.option;

		            var size = seriesOption.size || []; // Compatible with ec2.
		            var containerWidth = parsePercent(
		                retrieveValue(seriesOption.width, size[0]),
		                ecWidth
		            );
		            var containerHeight = parsePercent(
		                retrieveValue(seriesOption.height, size[1]),
		                ecHeight
		            );

		            var layoutInfo = layout.getLayoutRect(
		                seriesModel.getBoxLayoutParams(),
		                {
		                    width: api.getWidth(),
		                    height: api.getHeight()
		                }
		            );

		            // Fetch payload info.
		            var payloadType = payload && payload.type;
		            var targetInfo = helper.retrieveTargetInfo(payload, seriesModel);
		            var rootRect = (payloadType === 'treemapRender' || payloadType === 'treemapMove')
		                ? payload.rootRect : null;
		            var viewRoot = seriesModel.getViewRoot();
		            var viewAbovePath = helper.getPathToRoot(viewRoot);

		            if (payloadType !== 'treemapMove') {
		                var rootSize = payloadType === 'treemapZoomToNode'
		                    ? estimateRootSize(
		                        seriesModel, targetInfo, viewRoot, containerWidth, containerHeight
		                    )
		                    : rootRect
		                    ? [rootRect.width, rootRect.height]
		                    : [containerWidth, containerHeight];

		                var sort = seriesOption.sort;
		                if (sort && sort !== 'asc' && sort !== 'desc') {
		                    sort = 'desc';
		                }
		                var options = {
		                    squareRatio: seriesOption.squareRatio,
		                    sort: sort,
		                    leafDepth: seriesOption.leafDepth
		                };

		                // layout should be cleared because using updateView but not update.
		                viewRoot.hostTree.clearLayouts();

		                // TODO
		                // optimize: if out of view clip, do not layout.
		                // But take care that if do not render node out of view clip,
		                // how to calculate start po

		                var viewRootLayout = {
		                    x: 0, y: 0,
		                    width: rootSize[0], height: rootSize[1],
		                    area: rootSize[0] * rootSize[1]
		                };
		                viewRoot.setLayout(viewRootLayout);

		                squarify(viewRoot, options, false, 0);
		                // Supplement layout.
		                var viewRootLayout = viewRoot.getLayout();
		                each(viewAbovePath, function (node, index) {
		                    var childValue = (viewAbovePath[index + 1] || viewRoot).getValue();
		                    node.setLayout(zrUtil.extend(
		                        {dataExtent: [childValue, childValue], borderWidth: 0},
		                        viewRootLayout
		                    ));
		                });
		            }

		            var treeRoot = seriesModel.getData().tree.root;

		            treeRoot.setLayout(
		                calculateRootPosition(layoutInfo, rootRect, targetInfo),
		                true
		            );

		            seriesModel.setLayoutInfo(layoutInfo);

		            // FIXME
		            // 现在没有clip功能，暂时取ec高宽。
		            prunning(
		                treeRoot,
		                // Transform to base element coordinate system.
		                new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight),
		                viewAbovePath,
		                viewRoot,
		                0
		            );
		        });
		    }

		    /**
		     * Layout treemap with squarify algorithm.
		     * @see https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf
		     * @see https://github.com/mbostock/d3/blob/master/src/layout/treemap.js
		     *
		     * @protected
		     * @param {module:echarts/data/Tree~TreeNode} node
		     * @param {Object} options
		     * @param {string} options.sort 'asc' or 'desc'
		     * @param {number} options.squareRatio
		     * @param {boolean} hideChildren
		     * @param {number} depth
		     */
		    function squarify(node, options, hideChildren, depth) {
		        var width;
		        var height;

		        if (node.isRemoved()) {
		            return;
		        }

		        var thisLayout = node.getLayout();
		        width = thisLayout.width;
		        height = thisLayout.height;

		        // Considering border and gap
		        var itemStyleModel = node.getModel('itemStyle.normal');
		        var borderWidth = itemStyleModel.get('borderWidth');
		        var halfGapWidth = itemStyleModel.get('gapWidth') / 2;
		        var layoutOffset = borderWidth - halfGapWidth;
		        var nodeModel = node.getModel();

		        node.setLayout({borderWidth: borderWidth}, true);

		        width = mathMax(width - 2 * layoutOffset, 0);
		        height = mathMax(height - 2 * layoutOffset, 0);

		        var totalArea = width * height;
		        var viewChildren = initChildren(
		            node, nodeModel, totalArea, options, hideChildren, depth
		        );

		        if (!viewChildren.length) {
		            return;
		        }

		        var rect = {x: layoutOffset, y: layoutOffset, width: width, height: height};
		        var rowFixedLength = mathMin(width, height);
		        var best = Infinity; // the best row score so far
		        var row = [];
		        row.area = 0;

		        for (var i = 0, len = viewChildren.length; i < len;) {
		            var child = viewChildren[i];

		            row.push(child);
		            row.area += child.getLayout().area;
		            var score = worst(row, rowFixedLength, options.squareRatio);

		            // continue with this orientation
		            if (score <= best) {
		                i++;
		                best = score;
		            }
		            // abort, and try a different orientation
		            else {
		                row.area -= row.pop().getLayout().area;
		                position(row, rowFixedLength, rect, halfGapWidth, false);
		                rowFixedLength = mathMin(rect.width, rect.height);
		                row.length = row.area = 0;
		                best = Infinity;
		            }
		        }

		        if (row.length) {
		            position(row, rowFixedLength, rect, halfGapWidth, true);
		        }

		        if (!hideChildren) {
		            var childrenVisibleMin = nodeModel.get('childrenVisibleMin');
		            if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
		                hideChildren = true;
		            }
		        }

		        for (var i = 0, len = viewChildren.length; i < len; i++) {
		            squarify(viewChildren[i], options, hideChildren, depth + 1);
		        }
		    }

		    /**
		     * Set area to each child, and calculate data extent for visual coding.
		     */
		    function initChildren(node, nodeModel, totalArea, options, hideChildren, depth) {
		        var viewChildren = node.children || [];
		        var orderBy = options.sort;
		        orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null);

		        var overLeafDepth = options.leafDepth != null && options.leafDepth <= depth;

		        // leafDepth has higher priority.
		        if (hideChildren && !overLeafDepth) {
		            return (node.viewChildren = []);
		        }

		        // Sort children, order by desc.
		        viewChildren = zrUtil.filter(viewChildren, function (child) {
		            return !child.isRemoved();
		        });

		        sort(viewChildren, orderBy);

		        var info = statistic(nodeModel, viewChildren, orderBy);

		        if (info.sum === 0) {
		            return (node.viewChildren = []);
		        }

		        info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren);

		        if (info.sum === 0) {
		            return (node.viewChildren = []);
		        }

		        // Set area to each child.
		        for (var i = 0, len = viewChildren.length; i < len; i++) {
		            var area = viewChildren[i].getValue() / info.sum * totalArea;
		            // Do not use setLayout({...}, true), because it is needed to clear last layout.
		            viewChildren[i].setLayout({area: area});
		        }

		        if (overLeafDepth) {
		            viewChildren.length && node.setLayout({isLeafRoot: true}, true);
		            viewChildren.length = 0;
		        }

		        node.viewChildren = viewChildren;
		        node.setLayout({dataExtent: info.dataExtent}, true);

		        return viewChildren;
		    }

		    /**
		     * Consider 'visibleMin'. Modify viewChildren and get new sum.
		     */
		    function filterByThreshold(nodeModel, totalArea, sum, orderBy, orderedChildren) {

		        // visibleMin is not supported yet when no option.sort.
		        if (!orderBy) {
		            return sum;
		        }

		        var visibleMin = nodeModel.get('visibleMin');
		        var len = orderedChildren.length;
		        var deletePoint = len;

		        // Always travel from little value to big value.
		        for (var i = len - 1; i >= 0; i--) {
		            var value = orderedChildren[
		                orderBy === 'asc' ? len - i - 1 : i
		            ].getValue();

		            if (value / sum * totalArea < visibleMin) {
		                deletePoint = i;
		                sum -= value;
		            }
		        }

		        orderBy === 'asc'
		            ? orderedChildren.splice(0, len - deletePoint)
		            : orderedChildren.splice(deletePoint, len - deletePoint);

		        return sum;
		    }

		    /**
		     * Sort
		     */
		    function sort(viewChildren, orderBy) {
		        if (orderBy) {
		            viewChildren.sort(function (a, b) {
		                return orderBy === 'asc'
		                    ?  a.getValue() - b.getValue() : b.getValue() - a.getValue();
		            });
		        }
		        return viewChildren;
		    }

		    /**
		     * Statistic
		     */
		    function statistic(nodeModel, children, orderBy) {
		        // Calculate sum.
		        var sum = 0;
		        for (var i = 0, len = children.length; i < len; i++) {
		            sum += children[i].getValue();
		        }

		        // Statistic data extent for latter visual coding.
		        // Notice: data extent should be calculate based on raw children
		        // but not filtered view children, otherwise visual mapping will not
		        // be stable when zoom (where children is filtered by visibleMin).

		        var dimension = nodeModel.get('visualDimension');
		        var dataExtent;

		        // The same as area dimension.
		        if (!children || !children.length) {
		            dataExtent = [NaN, NaN];
		        }
		        else if (dimension === 'value' && orderBy) {
		            dataExtent = [
		                children[children.length - 1].getValue(),
		                children[0].getValue()
		            ];
		            orderBy === 'asc' && dataExtent.reverse();
		        }
		        // Other dimension.
		        else {
		            var dataExtent = [Infinity, -Infinity];
		            each(children, function (child) {
		                var value = child.getValue(dimension);
		                value < dataExtent[0] && (dataExtent[0] = value);
		                value > dataExtent[1] && (dataExtent[1] = value);
		            });
		        }

		        return {sum: sum, dataExtent: dataExtent};
		    }

		    /**
		     * Computes the score for the specified row,
		     * as the worst aspect ratio.
		     */
		    function worst(row, rowFixedLength, ratio) {
		        var areaMax = 0;
		        var areaMin = Infinity;

		        for (var i = 0, area, len = row.length; i < len; i++) {
		            area = row[i].getLayout().area;
		            if (area) {
		                area < areaMin && (areaMin = area);
		                area > areaMax && (areaMax = area);
		            }
		        }

		        var squareArea = row.area * row.area;
		        var f = rowFixedLength * rowFixedLength * ratio;

		        return squareArea
		            ? mathMax(
		                (f * areaMax) / squareArea,
		                squareArea / (f * areaMin)
		            )
		            : Infinity;
		    }

		    /**
		     * Positions the specified row of nodes. Modifies `rect`.
		     */
		    function position(row, rowFixedLength, rect, halfGapWidth, flush) {
		        // When rowFixedLength === rect.width,
		        // it is horizontal subdivision,
		        // rowFixedLength is the width of the subdivision,
		        // rowOtherLength is the height of the subdivision,
		        // and nodes will be positioned from left to right.

		        // wh[idx0WhenH] means: when horizontal,
		        //      wh[idx0WhenH] => wh[0] => 'width'.
		        //      xy[idx1WhenH] => xy[1] => 'y'.
		        var idx0WhenH = rowFixedLength === rect.width ? 0 : 1;
		        var idx1WhenH = 1 - idx0WhenH;
		        var xy = ['x', 'y'];
		        var wh = ['width', 'height'];

		        var last = rect[xy[idx0WhenH]];
		        var rowOtherLength = rowFixedLength
		            ? row.area / rowFixedLength : 0;

		        if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
		            rowOtherLength = rect[wh[idx1WhenH]]; // over+underflow
		        }
		        for (var i = 0, rowLen = row.length; i < rowLen; i++) {
		            var node = row[i];
		            var nodeLayout = {};
		            var step = rowOtherLength
		                ? node.getLayout().area / rowOtherLength : 0;

		            var wh1 = nodeLayout[wh[idx1WhenH]] = mathMax(rowOtherLength - 2 * halfGapWidth, 0);

		            // We use Math.max/min to avoid negative width/height when considering gap width.
		            var remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last;
		            var modWH = (i === rowLen - 1 || remain < step) ? remain : step;
		            var wh0 = nodeLayout[wh[idx0WhenH]] = mathMax(modWH - 2 * halfGapWidth, 0);

		            nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin(halfGapWidth, wh1 / 2);
		            nodeLayout[xy[idx0WhenH]] = last + mathMin(halfGapWidth, wh0 / 2);

		            last += modWH;
		            node.setLayout(nodeLayout, true);
		        }

		        rect[xy[idx1WhenH]] += rowOtherLength;
		        rect[wh[idx1WhenH]] -= rowOtherLength;
		    }

		    // Return [containerWidth, containerHeight] as defualt.
		    function estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
		        // If targetInfo.node exists, we zoom to the node,
		        // so estimate whold width and heigth by target node.
		        var currNode = (targetInfo || {}).node;
		        var defaultSize = [containerWidth, containerHeight];

		        if (!currNode || currNode === viewRoot) {
		            return defaultSize;
		        }

		        var parent;
		        var viewArea = containerWidth * containerHeight;
		        var area = viewArea * seriesModel.option.zoomToNodeRatio;

		        while (parent = currNode.parentNode) { // jshint ignore:line
		            var sum = 0;
		            var siblings = parent.children;

		            for (var i = 0, len = siblings.length; i < len; i++) {
		                sum += siblings[i].getValue();
		            }
		            var currNodeValue = currNode.getValue();
		            if (currNodeValue === 0) {
		                return defaultSize;
		            }
		            area *= sum / currNodeValue;

		            var borderWidth = parent.getModel('itemStyle.normal').get('borderWidth');

		            if (isFinite(borderWidth)) {
		                // Considering border, suppose aspect ratio is 1.
		                area += 4 * borderWidth * borderWidth + 4 * borderWidth * Math.pow(area, 0.5);
		            }

		            area > numberUtil.MAX_SAFE_INTEGER && (area = numberUtil.MAX_SAFE_INTEGER);

		            currNode = parent;
		        }

		        area < viewArea && (area = viewArea);
		        var scale = Math.pow(area / viewArea, 0.5);

		        return [containerWidth * scale, containerHeight * scale];
		    }

		    // Root postion base on coord of containerGroup
		    function calculateRootPosition(layoutInfo, rootRect, targetInfo) {
		        if (rootRect) {
		            return {x: rootRect.x, y: rootRect.y};
		        }

		        var defaultPosition = {x: 0, y: 0};
		        if (!targetInfo) {
		            return defaultPosition;
		        }

		        // If targetInfo is fetched by 'retrieveTargetInfo',
		        // old tree and new tree are the same tree,
		        // so the node still exists and we can visit it.

		        var targetNode = targetInfo.node;
		        var layout = targetNode.getLayout();

		        if (!layout) {
		            return defaultPosition;
		        }

		        // Transform coord from local to container.
		        var targetCenter = [layout.width / 2, layout.height / 2];
		        var node = targetNode;
		        while (node) {
		            var nodeLayout = node.getLayout();
		            targetCenter[0] += nodeLayout.x;
		            targetCenter[1] += nodeLayout.y;
		            node = node.parentNode;
		        }

		        return {
		            x: layoutInfo.width / 2 - targetCenter[0],
		            y: layoutInfo.height / 2 - targetCenter[1]
		        };
		    }

		    // Mark nodes visible for prunning when visual coding and rendering.
		    // Prunning depends on layout and root position, so we have to do it after layout.
		    function prunning(node, clipRect, viewAbovePath, viewRoot, depth) {
		        var nodeLayout = node.getLayout();
		        var nodeInViewAbovePath = viewAbovePath[depth];
		        var isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node;

		        if (
		            (nodeInViewAbovePath && !isAboveViewRoot)
		            || (depth === viewAbovePath.length && node !== viewRoot)
		        ) {
		            return;
		        }

		        node.setLayout({
		            // isInView means: viewRoot sub tree + viewAbovePath
		            isInView: true,
		            // invisible only means: outside view clip so that the node can not
		            // see but still layout for animation preparation but not render.
		            invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
		            isAboveViewRoot: isAboveViewRoot
		        }, true);

		        // Transform to child coordinate.
		        var childClipRect = new BoundingRect(
		            clipRect.x - nodeLayout.x,
		            clipRect.y - nodeLayout.y,
		            clipRect.width,
		            clipRect.height
		        );

		        each(node.viewChildren || [], function (child) {
		            prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1);
		        });
		    }

		    module.exports = update;


	/***/ },
	/* 196 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var echarts = __webpack_require__(1);
		    var zrUtil = __webpack_require__(4);

		    __webpack_require__(197);
		    __webpack_require__(200);

		    __webpack_require__(205);

		    echarts.registerProcessor(__webpack_require__(206));

		    echarts.registerVisual(zrUtil.curry(
		        __webpack_require__(110), 'graph', 'circle', null
		    ));
		    echarts.registerVisual(__webpack_require__(207));
		    echarts.registerVisual(__webpack_require__(208));

		    echarts.registerLayout(__webpack_require__(209));
		    echarts.registerLayout(__webpack_require__(212));
		    echarts.registerLayout(__webpack_require__(214));

		    // Graph view coordinate system
		    echarts.registerCoordinateSystem('graphView', {
		        create: __webpack_require__(216)
		    });


	/***/ },
	/* 197 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var List = __webpack_require__(98);
		    var zrUtil = __webpack_require__(4);
		    var modelUtil = __webpack_require__(5);
		    var Model = __webpack_require__(12);

		    var createGraphFromNodeEdge = __webpack_require__(198);

		    var GraphSeries = __webpack_require__(1).extendSeriesModel({

		        type: 'series.graph',

		        init: function (option) {
		            GraphSeries.superApply(this, 'init', arguments);

		            // Provide data for legend select
		            this.legendDataProvider = function () {
		                return this._categoriesData;
		            };

		            this.fillDataTextStyle(option.edges || option.links);

		            this._updateCategoriesData();
		        },

		        mergeOption: function (option) {
		            GraphSeries.superApply(this, 'mergeOption', arguments);

		            this.fillDataTextStyle(option.edges || option.links);

		            this._updateCategoriesData();
		        },

		        mergeDefaultAndTheme: function (option) {
		            GraphSeries.superApply(this, 'mergeDefaultAndTheme', arguments);
		            modelUtil.defaultEmphasis(option.edgeLabel, modelUtil.LABEL_OPTIONS);
		        },

		        getInitialData: function (option, ecModel) {
		            var edges = option.edges || option.links || [];
		            var nodes = option.data || option.nodes || [];
		            var self = this;

		            if (nodes && edges) {
		                return createGraphFromNodeEdge(nodes, edges, this, true, beforeLink).data;
		            }

		            function beforeLink(nodeData, edgeData) {
		                // Overwrite nodeData.getItemModel to
		                nodeData.wrapMethod('getItemModel', function (model) {
		                    var categoriesModels = self._categoriesModels;
		                    var categoryIdx = model.getShallow('category');
		                    var categoryModel = categoriesModels[categoryIdx];
		                    if (categoryModel) {
		                        categoryModel.parentModel = model.parentModel;
		                        model.parentModel = categoryModel;
		                    }
		                    return model;
		                });

		                var edgeLabelModel = self.getModel('edgeLabel');
		                var wrappedGetEdgeModel = function (path, parentModel) {
		                    var pathArr = (path || '').split('.');
		                    if (pathArr[0] === 'label') {
		                        parentModel = parentModel
		                            || edgeLabelModel.getModel(pathArr.slice(1));
		                    }
		                    var model = Model.prototype.getModel.call(this, pathArr, parentModel);
		                    model.getModel = wrappedGetEdgeModel;
		                    return model;
		                };
		                edgeData.wrapMethod('getItemModel', function (model) {
		                    // FIXME Wrap get method ?
		                    model.getModel = wrappedGetEdgeModel;
		                    return model;
		                });
		            }
		        },

		        /**
		         * @return {module:echarts/data/Graph}
		         */
		        getGraph: function () {
		            return this.getData().graph;
		        },

		        /**
		         * @return {module:echarts/data/List}
		         */
		        getEdgeData: function () {
		            return this.getGraph().edgeData;
		        },

		        /**
		         * @return {module:echarts/data/List}
		         */
		        getCategoriesData: function () {
		            return this._categoriesData;
		        },

		        /**
		         * @override
		         */
		        formatTooltip: function (dataIndex, multipleSeries, dataType) {
		            if (dataType === 'edge') {
		                var nodeData = this.getData();
		                var params = this.getDataParams(dataIndex, dataType);
		                var edge = nodeData.graph.getEdgeByIndex(dataIndex);
		                var sourceName = nodeData.getName(edge.node1.dataIndex);
		                var targetName = nodeData.getName(edge.node2.dataIndex);
		                var html = sourceName + ' > ' + targetName;
		                if (params.value) {
		                    html += ' : ' + params.value;
		                }
		                return html;
		            }
		            else { // dataType === 'node' or empty
		                return GraphSeries.superApply(this, 'formatTooltip', arguments);
		            }
		        },

		        _updateCategoriesData: function () {
		            var categories = zrUtil.map(this.option.categories || [], function (category) {
		                // Data must has value
		                return category.value != null ? category : zrUtil.extend({
		                    value: 0
		                }, category);
		            });
		            var categoriesData = new List(['value'], this);
		            categoriesData.initData(categories);

		            this._categoriesData = categoriesData;

		            this._categoriesModels = categoriesData.mapArray(function (idx) {
		                return categoriesData.getItemModel(idx, true);
		            });
		        },

		        setZoom: function (zoom) {
		            this.option.zoom = zoom;
		        },

		        setCenter: function (center) {
		            this.option.center = center;
		        },

		        ifEnableAnimation: function () {
		            return GraphSeries.superCall(this, 'ifEnableAnimation')
		                // Not enable animation when do force layout
		                && !(this.get('layout') === 'force' && this.get('force.layoutAnimation'));
		        },

		        defaultOption: {
		            zlevel: 0,
		            z: 2,

		            coordinateSystem: 'view',

		            // Default option for all coordinate systems
		            // xAxisIndex: 0,
		            // yAxisIndex: 0,
		            // polarIndex: 0,
		            // geoIndex: 0,

		            legendHoverLink: true,

		            hoverAnimation: true,

		            layout: null,

		            focusNodeAdjacency: false,

		            // Configuration of circular layout
		            circular: {
		                rotateLabel: false
		            },
		            // Configuration of force directed layout
		            force: {
		                initLayout: null,
		                // Node repulsion. Can be an array to represent range.
		                repulsion: [0, 50],
		                gravity: 0.1,

		                // Edge length. Can be an array to represent range.
		                edgeLength: 30,

		                layoutAnimation: true
		            },

		            left: 'center',
		            top: 'center',
		            // right: null,
		            // bottom: null,
		            // width: '80%',
		            // height: '80%',

		            symbol: 'circle',
		            symbolSize: 10,

		            edgeSymbol: ['none', 'none'],
		            edgeSymbolSize: 10,
		            edgeLabel: {
		                normal: {
		                    position: 'middle'
		                },
		                emphasis: {}
		            },

		            draggable: false,

		            roam: false,

		            // Default on center of graph
		            center: null,

		            zoom: 1,
		            // Symbol size scale ratio in roam
		            nodeScaleRatio: 0.6,

		            // categories: [],

		            // data: []
		            // Or
		            // nodes: []
		            //
		            // links: []
		            // Or
		            // edges: []

		            label: {
		                normal: {
		                    show: false,
		                    formatter: '{b}'
		                },
		                emphasis: {
		                    show: true
		                }
		            },

		            itemStyle: {
		                normal: {},
		                emphasis: {}
		            },

		            lineStyle: {
		                normal: {
		                    color: '#aaa',
		                    width: 1,
		                    curveness: 0,
		                    opacity: 0.5
		                },
		                emphasis: {}
		            }
		        }
		    });

		    module.exports = GraphSeries;


	/***/ },
	/* 198 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var List = __webpack_require__(98);
		    var Graph = __webpack_require__(199);
		    var linkList = __webpack_require__(187);
		    var completeDimensions = __webpack_require__(103);
		    var CoordinateSystem = __webpack_require__(26);
		    var zrUtil = __webpack_require__(4);
		    var createListFromArray = __webpack_require__(102);

		    module.exports = function (nodes, edges, hostModel, directed, beforeLink) {
		        var graph = new Graph(directed);
		        for (var i = 0; i < nodes.length; i++) {
		            graph.addNode(zrUtil.retrieve(
		                // Id, name, dataIndex
		                nodes[i].id, nodes[i].name, i
		            ), i);
		        }

		        var linkNameList = [];
		        var validEdges = [];
		        var linkCount = 0;
		        for (var i = 0; i < edges.length; i++) {
		            var link = edges[i];
		            var source = link.source;
		            var target = link.target;
		            // addEdge may fail when source or target not exists
		            if (graph.addEdge(source, target, linkCount)) {
		                validEdges.push(link);
		                linkNameList.push(zrUtil.retrieve(link.id, source + ' > ' + target));
		                linkCount++;
		            }
		        }

		        var coordSys = hostModel.get('coordinateSystem');
		        var nodeData;
		        if (coordSys === 'cartesian2d' || coordSys === 'polar') {
		            nodeData = createListFromArray(nodes, hostModel, hostModel.ecModel);
		        }
		        else {
		            // FIXME
		            var coordSysCtor = CoordinateSystem.get(coordSys);
		            // FIXME
		            var dimensionNames = completeDimensions(
		                ((coordSysCtor && coordSysCtor.type !== 'view') ? (coordSysCtor.dimensions || []) : []).concat(['value']),
		                nodes
		            );
		            nodeData = new List(dimensionNames, hostModel);
		            nodeData.initData(nodes);
		        }

		        var edgeData = new List(['value'], hostModel);
		        edgeData.initData(validEdges, linkNameList);

		        beforeLink && beforeLink(nodeData, edgeData);

		        linkList({
		            mainData: nodeData,
		            struct: graph,
		            structAttr: 'graph',
		            datas: {node: nodeData, edge: edgeData},
		            datasAttr: {node: 'data', edge: 'edgeData'}
		        });

		        // Update dataIndex of nodes and edges because invalid edge may be removed
		        graph.update();

		        return graph;
		    };


	/***/ },
	/* 199 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';
		/**
		 * Graph data structure
		 *
		 * @module echarts/data/Graph
		 * @author Yi Shen(https://www.github.com/pissang)
		 */


		    var zrUtil = __webpack_require__(4);

		    /**
		     * @alias module:echarts/data/Graph
		     * @constructor
		     * @param {boolean} directed
		     */
		    var Graph = function(directed) {
		        /**
		         * 是否是有向图
		         * @type {boolean}
		         * @private
		         */
		        this._directed = directed || false;

		        /**
		         * @type {Array.<module:echarts/data/Graph.Node>}
		         * @readOnly
		         */
		        this.nodes = [];

		        /**
		         * @type {Array.<module:echarts/data/Graph.Edge>}
		         * @readOnly
		         */
		        this.edges = [];

		        /**
		         * @type {Object.<string, module:echarts/data/Graph.Node>}
		         * @private
		         */
		        this._nodesMap = {};
		        /**
		         * @type {Object.<string, module:echarts/data/Graph.Edge>}
		         * @private
		         */
		        this._edgesMap = {};

		        /**
		         * @type {module:echarts/data/List}
		         * @readOnly
		         */
		        this.data;

		        /**
		         * @type {module:echarts/data/List}
		         * @readOnly
		         */
		        this.edgeData;
		    };

		    var graphProto = Graph.prototype;
		    /**
		     * @type {string}
		     */
		    graphProto.type = 'graph';

		    /**
		     * If is directed graph
		     * @return {boolean}
		     */
		    graphProto.isDirected = function () {
		        return this._directed;
		    };

		    /**
		     * Add a new node
		     * @param {string} id
		     * @param {number} [dataIndex]
		     */
		    graphProto.addNode = function (id, dataIndex) {
		        id = id || ('' + dataIndex);

		        var nodesMap = this._nodesMap;

		        if (nodesMap[id]) {
		            return;
		        }

		        var node = new Node(id, dataIndex);
		        node.hostGraph = this;

		        this.nodes.push(node);

		        nodesMap[id] = node;
		        return node;
		    };

		    /**
		     * Get node by data index
		     * @param  {number} dataIndex
		     * @return {module:echarts/data/Graph~Node}
		     */
		    graphProto.getNodeByIndex = function (dataIndex) {
		        var rawIdx = this.data.getRawIndex(dataIndex);
		        return this.nodes[rawIdx];
		    };
		    /**
		     * Get node by id
		     * @param  {string} id
		     * @return {module:echarts/data/Graph.Node}
		     */
		    graphProto.getNodeById = function (id) {
		        return this._nodesMap[id];
		    };

		    /**
		     * Add a new edge
		     * @param {number|string|module:echarts/data/Graph.Node} n1
		     * @param {number|string|module:echarts/data/Graph.Node} n2
		     * @param {number} [dataIndex=-1]
		     * @return {module:echarts/data/Graph.Edge}
		     */
		    graphProto.addEdge = function (n1, n2, dataIndex) {
		        var nodesMap = this._nodesMap;
		        var edgesMap = this._edgesMap;

		        // PNEDING
		        if (typeof n1 === 'number') {
		            n1 = this.nodes[n1];
		        }
		        if (typeof n2 === 'number') {
		            n2 = this.nodes[n2];
		        }

		        if (!(n1 instanceof Node)) {
		            n1 = nodesMap[n1];
		        }
		        if (!(n2 instanceof Node)) {
		            n2 = nodesMap[n2];
		        }
		        if (!n1 || !n2) {
		            return;
		        }

		        var key = n1.id + '-' + n2.id;
		        // PENDING
		        if (edgesMap[key]) {
		            return;
		        }

		        var edge = new Edge(n1, n2, dataIndex);
		        edge.hostGraph = this;

		        if (this._directed) {
		            n1.outEdges.push(edge);
		            n2.inEdges.push(edge);
		        }
		        n1.edges.push(edge);
		        if (n1 !== n2) {
		            n2.edges.push(edge);
		        }

		        this.edges.push(edge);
		        edgesMap[key] = edge;

		        return edge;
		    };

		    /**
		     * Get edge by data index
		     * @param  {number} dataIndex
		     * @return {module:echarts/data/Graph~Node}
		     */
		    graphProto.getEdgeByIndex = function (dataIndex) {
		        var rawIdx = this.edgeData.getRawIndex(dataIndex);
		        return this.edges[rawIdx];
		    };
		    /**
		     * Get edge by two linked nodes
		     * @param  {module:echarts/data/Graph.Node|string} n1
		     * @param  {module:echarts/data/Graph.Node|string} n2
		     * @return {module:echarts/data/Graph.Edge}
		     */
		    graphProto.getEdge = function (n1, n2) {
		        if (n1 instanceof Node) {
		            n1 = n1.id;
		        }
		        if (n2 instanceof Node) {
		            n2 = n2.id;
		        }

		        var edgesMap = this._edgesMap;

		        if (this._directed) {
		            return edgesMap[n1 + '-' + n2];
		        } else {
		            return edgesMap[n1 + '-' + n2]
		                || edgesMap[n2 + '-' + n1];
		        }
		    };

		    /**
		     * Iterate all nodes
		     * @param  {Function} cb
		     * @param  {*} [context]
		     */
		    graphProto.eachNode = function (cb, context) {
		        var nodes = this.nodes;
		        var len = nodes.length;
		        for (var i = 0; i < len; i++) {
		            if (nodes[i].dataIndex >= 0) {
		                cb.call(context, nodes[i], i);
		            }
		        }
		    };

		    /**
		     * Iterate all edges
		     * @param  {Function} cb
		     * @param  {*} [context]
		     */
		    graphProto.eachEdge = function (cb, context) {
		        var edges = this.edges;
		        var len = edges.length;
		        for (var i = 0; i < len; i++) {
		            if (edges[i].dataIndex >= 0
		                && edges[i].node1.dataIndex >= 0
		                && edges[i].node2.dataIndex >= 0
		            ) {
		                cb.call(context, edges[i], i);
		            }
		        }
		    };

		    /**
		     * Breadth first traverse
		     * @param {Function} cb
		     * @param {module:echarts/data/Graph.Node} startNode
		     * @param {string} [direction='none'] 'none'|'in'|'out'
		     * @param {*} [context]
		     */
		    graphProto.breadthFirstTraverse = function (
		        cb, startNode, direction, context
		    ) {
		        if (!(startNode instanceof Node)) {
		            startNode = this._nodesMap[startNode];
		        }
		        if (!startNode) {
		            return;
		        }

		        var edgeType = direction === 'out'
		            ? 'outEdges' : (direction === 'in' ? 'inEdges' : 'edges');

		        for (var i = 0; i < this.nodes.length; i++) {
		            this.nodes[i].__visited = false;
		        }

		        if (cb.call(context, startNode, null)) {
		            return;
		        }

		        var queue = [startNode];
		        while (queue.length) {
		            var currentNode = queue.shift();
		            var edges = currentNode[edgeType];

		            for (var i = 0; i < edges.length; i++) {
		                var e = edges[i];
		                var otherNode = e.node1 === currentNode
		                    ? e.node2 : e.node1;
		                if (!otherNode.__visited) {
		                    if (cb.call(otherNode, otherNode, currentNode)) {
		                        // Stop traversing
		                        return;
		                    }
		                    queue.push(otherNode);
		                    otherNode.__visited = true;
		                }
		            }
		        }
		    };

		    // TODO
		    // graphProto.depthFirstTraverse = function (
		    //     cb, startNode, direction, context
		    // ) {

		    // };

		    // Filter update
		    graphProto.update = function () {
		        var data = this.data;
		        var edgeData = this.edgeData;
		        var nodes = this.nodes;
		        var edges = this.edges;

		        for (var i = 0, len = nodes.length; i < len; i++) {
		            nodes[i].dataIndex = -1;
		        }
		        for (var i = 0, len = data.count(); i < len; i++) {
		            nodes[data.getRawIndex(i)].dataIndex = i;
		        }

		        edgeData.filterSelf(function (idx) {
		            var edge = edges[edgeData.getRawIndex(idx)];
		            return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0;
		        });

		        // Update edge
		        for (var i = 0, len = edges.length; i < len; i++) {
		            edges[i].dataIndex = -1;
		        }
		        for (var i = 0, len = edgeData.count(); i < len; i++) {
		            edges[edgeData.getRawIndex(i)].dataIndex = i;
		        }
		    };

		    /**
		     * @return {module:echarts/data/Graph}
		     */
		    graphProto.clone = function () {
		        var graph = new Graph(this._directed);
		        var nodes = this.nodes;
		        var edges = this.edges;
		        for (var i = 0; i < nodes.length; i++) {
		            graph.addNode(nodes[i].id, nodes[i].dataIndex);
		        }
		        for (var i = 0; i < edges.length; i++) {
		            var e = edges[i];
		            graph.addEdge(e.node1.id, e.node2.id, e.dataIndex);
		        }
		        return graph;
		    };


		    /**
		     * @alias module:echarts/data/Graph.Node
		     */
		    function Node(id, dataIndex) {
		        /**
		        * @type {string}
		        */
		        this.id = id == null ? '' : id;

		        /**
		        * @type {Array.<module:echarts/data/Graph.Edge>}
		        */
		        this.inEdges = [];
		        /**
		        * @type {Array.<module:echarts/data/Graph.Edge>}
		        */
		        this.outEdges = [];
		        /**
		        * @type {Array.<module:echarts/data/Graph.Edge>}
		        */
		        this.edges = [];
		        /**
		         * @type {module:echarts/data/Graph}
		         */
		        this.hostGraph;

		        /**
		         * @type {number}
		         */
		        this.dataIndex = dataIndex == null ? -1 : dataIndex;
		    }

		    Node.prototype = {

		        constructor: Node,

		        /**
		         * @return {number}
		         */
		        degree: function () {
		            return this.edges.length;
		        },

		        /**
		         * @return {number}
		         */
		        inDegree: function () {
		            return this.inEdges.length;
		        },

		        /**
		        * @return {number}
		        */
		        outDegree: function () {
		            return this.outEdges.length;
		        },

		        /**
		         * @param {string} [path]
		         * @return {module:echarts/model/Model}
		         */
		        getModel: function (path) {
		            if (this.dataIndex < 0) {
		                return;
		            }
		            var graph = this.hostGraph;
		            var itemModel = graph.data.getItemModel(this.dataIndex);

		            return itemModel.getModel(path);
		        }
		    };

		    /**
		     * 图边
		     * @alias module:echarts/data/Graph.Edge
		     * @param {module:echarts/data/Graph.Node} n1
		     * @param {module:echarts/data/Graph.Node} n2
		     * @param {number} [dataIndex=-1]
		     */
		    function Edge(n1, n2, dataIndex) {

		        /**
		         * 节点1，如果是有向图则为源节点
		         * @type {module:echarts/data/Graph.Node}
		         */
		        this.node1 = n1;

		        /**
		         * 节点2，如果是有向图则为目标节点
		         * @type {module:echarts/data/Graph.Node}
		         */
		        this.node2 = n2;

		        this.dataIndex = dataIndex == null ? -1 : dataIndex;
		    }

		    /**
		     * @param {string} [path]
		     * @return {module:echarts/model/Model}
		     */
		     Edge.prototype.getModel = function (path) {
		        if (this.dataIndex < 0) {
		            return;
		        }
		        var graph = this.hostGraph;
		        var itemModel = graph.edgeData.getItemModel(this.dataIndex);

		        return itemModel.getModel(path);
		    };

		    var createGraphDataProxyMixin = function (hostName, dataName) {
		        return {
		            /**
		             * @param {string=} [dimension='value'] Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
		             * @return {number}
		             */
		            getValue: function (dimension) {
		                var data = this[hostName][dataName];
		                return data.get(data.getDimension(dimension || 'value'), this.dataIndex);
		            },

		            /**
		             * @param {Object|string} key
		             * @param {*} [value]
		             */
		            setVisual: function (key, value) {
		                this.dataIndex >= 0
		                    && this[hostName][dataName].setItemVisual(this.dataIndex, key, value);
		            },

		            /**
		             * @param {string} key
		             * @return {boolean}
		             */
		            getVisual: function (key, ignoreParent) {
		                return this[hostName][dataName].getItemVisual(this.dataIndex, key, ignoreParent);
		            },

		            /**
		             * @param {Object} layout
		             * @return {boolean} [merge=false]
		             */
		            setLayout: function (layout, merge) {
		                this.dataIndex >= 0
		                    && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge);
		            },

		            /**
		             * @return {Object}
		             */
		            getLayout: function () {
		                return this[hostName][dataName].getItemLayout(this.dataIndex);
		            },

		            /**
		             * @return {module:zrender/Element}
		             */
		            getGraphicEl: function () {
		                return this[hostName][dataName].getItemGraphicEl(this.dataIndex);
		            },

		            /**
		             * @return {number}
		             */
		            getRawIndex: function () {
		                return this[hostName][dataName].getRawIndex(this.dataIndex);
		            }
		        };
		    };

		    zrUtil.mixin(Node, createGraphDataProxyMixin('hostGraph', 'data'));
		    zrUtil.mixin(Edge, createGraphDataProxyMixin('hostGraph', 'edgeData'));

		    Graph.Node = Node;
		    Graph.Edge = Edge;

		    module.exports = Graph;


	/***/ },
	/* 200 */
	/***/ function(module, exports, __webpack_require__) {

		


		    var SymbolDraw = __webpack_require__(105);
		    var LineDraw = __webpack_require__(201);
		    var RoamController = __webpack_require__(176);

		    var graphic = __webpack_require__(43);
		    var adjustEdge = __webpack_require__(204);
		    var zrUtil = __webpack_require__(4);

		    var nodeOpacityPath = ['itemStyle', 'normal', 'opacity'];
		    var lineOpacityPath = ['lineStyle', 'normal', 'opacity'];

		    function getItemOpacity(item, opacityPath) {
		        return item.getVisual('opacity') || item.getModel().get(opacityPath);
		    }

		    __webpack_require__(1).extendChartView({

		        type: 'graph',

		        init: function (ecModel, api) {
		            var symbolDraw = new SymbolDraw();
		            var lineDraw = new LineDraw();
		            var group = this.group;

		            var controller = new RoamController(api.getZr(), group);

		            group.add(symbolDraw.group);
		            group.add(lineDraw.group);

		            this._symbolDraw = symbolDraw;
		            this._lineDraw = lineDraw;
		            this._controller = controller;

		            this._firstRender = true;
		        },

		        render: function (seriesModel, ecModel, api) {
		            var coordSys = seriesModel.coordinateSystem;

		            this._model = seriesModel;
		            this._nodeScaleRatio = seriesModel.get('nodeScaleRatio');

		            var symbolDraw = this._symbolDraw;
		            var lineDraw = this._lineDraw;

		            var group = this.group;

		            if (coordSys.type === 'view') {
		                var groupNewProp = {
		                    position: coordSys.position,
		                    scale: coordSys.scale
		                };
		                if (this._firstRender) {
		                    group.attr(groupNewProp);
		                }
		                else {
		                    graphic.updateProps(group, groupNewProp, seriesModel);
		                }
		            }
		            // Fix edge contact point with node
		            adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel));

		            var data = seriesModel.getData();
		            symbolDraw.updateData(data);

		            var edgeData = seriesModel.getEdgeData();
		            lineDraw.updateData(edgeData);

		            this._updateNodeAndLinkScale();

		            this._updateController(seriesModel, api);

		            clearTimeout(this._layoutTimeout);
		            var forceLayout = seriesModel.forceLayout;
		            var layoutAnimation = seriesModel.get('force.layoutAnimation');
		            if (forceLayout) {
		                this._startForceLayoutIteration(forceLayout, layoutAnimation);
		            }
		            data.eachItemGraphicEl(function (el, idx) {
		                var itemModel = data.getItemModel(idx);
		                // Update draggable
		                el.off('drag').off('dragend');
		                var draggable = data.getItemModel(idx).get('draggable');
		                if (draggable) {
		                    el.on('drag', function () {
		                        if (forceLayout) {
		                            forceLayout.warmUp();
		                            !this._layouting
		                                && this._startForceLayoutIteration(forceLayout, layoutAnimation);
		                            forceLayout.setFixed(idx);
		                            // Write position back to layout
		                            data.setItemLayout(idx, el.position);
		                        }
		                    }, this).on('dragend', function () {
		                        if (forceLayout) {
		                            forceLayout.setUnfixed(idx);
		                        }
		                    }, this);
		                }
		                el.setDraggable(draggable && forceLayout);

		                el.off('mouseover', this._focusNodeAdjacency);
		                el.off('mouseout', this._unfocusAll);
		                if (itemModel.get('focusNodeAdjacency')) {
		                    el.on('mouseover', this._focusNodeAdjacency, this);
		                    el.on('mouseout', this._unfocusAll, this);
		                }
		            }, this);

		            var circularRotateLabel = seriesModel.get('layout') === 'circular' && seriesModel.get('circular.rotateLabel');
		            var cx = data.getLayout('cx');
		            var cy = data.getLayout('cy');
		            data.eachItemGraphicEl(function (el, idx) {
		                var symbolPath = el.getSymbolPath();
		                if (circularRotateLabel) {
		                    var pos = data.getItemLayout(idx);
		                    var rad = Math.atan2(pos[1] - cy, pos[0] - cx);
		                    if (rad < 0) {
		                        rad = Math.PI * 2 + rad;
		                    }
		                    var isLeft = pos[0] < cx;
		                    if (isLeft) {
		                        rad = rad - Math.PI;
		                    }
		                    var textPosition = isLeft ? 'left' : 'right';
		                    symbolPath.setStyle({
		                        textRotation: rad,
		                        textPosition: textPosition
		                    });
		                    symbolPath.hoverStyle && (symbolPath.hoverStyle.textPosition = textPosition);
		                }
		                else {
		                    symbolPath.setStyle({
		                        textRotation: 0
		                    });
		                }
		            });

		            this._firstRender = false;
		        },

		        dispose: function () {
		            this._controller && this._controller.dispose();
		        },

		        _focusNodeAdjacency: function (e) {
		            var data = this._model.getData();
		            var graph = data.graph;
		            var el = e.target;
		            var dataIndex = el.dataIndex;
		            var dataType = el.dataType;

		            function fadeOutItem(item, opacityPath) {
		                var opacity = getItemOpacity(item, opacityPath);
		                var el = item.getGraphicEl();
		                if (opacity == null) {
		                    opacity = 1;
		                }

		                el.traverse(function (child) {
		                    child.trigger('normal');
		                    if (child.type !== 'group') {
		                        child.setStyle('opacity', opacity * 0.1);
		                    }
		                });
		            }

		            function fadeInItem(item, opacityPath) {
		                var opacity = getItemOpacity(item, opacityPath);
		                var el = item.getGraphicEl();

		                el.traverse(function (child) {
		                    child.trigger('emphasis');
		                    if (child.type !== 'group') {
		                        child.setStyle('opacity', opacity);
		                    }
		                });
		            }
		            if (dataIndex !== null && dataType !== 'edge') {
		                graph.eachNode(function (node) {
		                    fadeOutItem(node, nodeOpacityPath);
		                });
		                graph.eachEdge(function (edge) {
		                    fadeOutItem(edge, lineOpacityPath);
		                });

		                var node = graph.getNodeByIndex(dataIndex);
		                fadeInItem(node, nodeOpacityPath);
		                zrUtil.each(node.edges, function (edge) {
		                    if (edge.dataIndex < 0) {
		                        return;
		                    }
		                    fadeInItem(edge, lineOpacityPath);
		                    fadeInItem(edge.node1, nodeOpacityPath);
		                    fadeInItem(edge.node2, nodeOpacityPath);
		                });
		            }
		        },

		        _unfocusAll: function () {
		            var data = this._model.getData();
		            var graph = data.graph;
		            graph.eachNode(function (node) {
		                var opacity = getItemOpacity(node, nodeOpacityPath);
		                node.getGraphicEl().traverse(function (child) {
		                    child.trigger('normal');
		                    if (child.type !== 'group') {
		                        child.setStyle('opacity', opacity);
		                    }
		                });
		            });
		            graph.eachEdge(function (edge) {
		                var opacity = getItemOpacity(edge, lineOpacityPath);
		                edge.getGraphicEl().traverse(function (child) {
		                    child.trigger('normal');
		                    if (child.type !== 'group') {
		                        child.setStyle('opacity', opacity);
		                    }
		                });
		            });
		        },

		        _startForceLayoutIteration: function (forceLayout, layoutAnimation) {
		            var self = this;
		            (function step() {
		                forceLayout.step(function (stopped) {
		                    self.updateLayout(self._model);
		                    (self._layouting = !stopped) && (
		                        layoutAnimation
		                            ? (self._layoutTimeout = setTimeout(step, 16))
		                            : step()
		                    );
		                });
		            })();
		        },

		        _updateController: function (seriesModel, api) {
		            var controller = this._controller;
		            var group = this.group;

		            controller.setContainsPoint(function (x, y) {
		                var rect = group.getBoundingRect();
		                rect.applyTransform(group.transform);
		                return rect.contain(x, y);
		            });

		            if (seriesModel.coordinateSystem.type !== 'view') {
		                controller.disable();
		                return;
		            }
		            controller.enable(seriesModel.get('roam'));
		            controller.zoomLimit = seriesModel.get('scaleLimit');
		            // Update zoom from model
		            controller.zoom = seriesModel.coordinateSystem.getZoom();

		            controller
		                .off('pan')
		                .off('zoom')
		                .on('pan', function (dx, dy) {
		                    api.dispatchAction({
		                        seriesId: seriesModel.id,
		                        type: 'graphRoam',
		                        dx: dx,
		                        dy: dy
		                    });
		                })
		                .on('zoom', function (zoom, mouseX, mouseY) {
		                    api.dispatchAction({
		                        seriesId: seriesModel.id,
		                        type: 'graphRoam',
		                        zoom:  zoom,
		                        originX: mouseX,
		                        originY: mouseY
		                    });
		                    this._updateNodeAndLinkScale();
		                    adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel));
		                    this._lineDraw.updateLayout();
		                }, this);
		        },

		        _updateNodeAndLinkScale: function () {
		            var seriesModel = this._model;
		            var data = seriesModel.getData();

		            var nodeScale = this._getNodeGlobalScale(seriesModel);
		            var invScale = [nodeScale, nodeScale];

		            data.eachItemGraphicEl(function (el, idx) {
		                el.attr('scale', invScale);
		            });
		        },

		        _getNodeGlobalScale: function (seriesModel) {
		            var coordSys = seriesModel.coordinateSystem;
		            if (coordSys.type !== 'view') {
		                return 1;
		            }

		            var nodeScaleRatio = this._nodeScaleRatio;

		            var groupScale = coordSys.scale;
		            var groupZoom = (groupScale && groupScale[0]) || 1;
		            // Scale node when zoom changes
		            var roamZoom = coordSys.getZoom();
		            var nodeScale = (roamZoom - 1) * nodeScaleRatio + 1;

		            return nodeScale / groupZoom;
		        },

		        updateLayout: function (seriesModel) {
		            adjustEdge(seriesModel.getGraph(), this._getNodeGlobalScale(seriesModel));

		            this._symbolDraw.updateLayout();
		            this._lineDraw.updateLayout();
		        },

		        remove: function (ecModel, api) {
		            this._symbolDraw && this._symbolDraw.remove();
		            this._lineDraw && this._lineDraw.remove();
		        }
		    });


	/***/ },
	/* 201 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/chart/helper/LineDraw
		 */


		    var graphic = __webpack_require__(43);
		    var LineGroup = __webpack_require__(202);


		    function isPointNaN(pt) {
		        return isNaN(pt[0]) || isNaN(pt[1]);
		    }
		    function lineNeedsDraw(pts) {
		        return !isPointNaN(pts[0]) && !isPointNaN(pts[1]);
		    }
		    /**
		     * @alias module:echarts/component/marker/LineDraw
		     * @constructor
		     */
		    function LineDraw(ctor) {
		        this._ctor = ctor || LineGroup;
		        this.group = new graphic.Group();
		    }

		    var lineDrawProto = LineDraw.prototype;

		    /**
		     * @param {module:echarts/data/List} lineData
		     */
		    lineDrawProto.updateData = function (lineData) {

		        var oldLineData = this._lineData;
		        var group = this.group;
		        var LineCtor = this._ctor;

		        var hostModel = lineData.hostModel;

		        var seriesScope = {
		            lineStyle: hostModel.getModel('lineStyle.normal').getLineStyle(),
		            hoverLineStyle: hostModel.getModel('lineStyle.emphasis').getLineStyle(),
		            labelModel: hostModel.getModel('label.normal'),
		            hoverLabelModel: hostModel.getModel('label.emphasis')
		        };

		        lineData.diff(oldLineData)
		            .add(function (idx) {
		                if (!lineNeedsDraw(lineData.getItemLayout(idx))) {
		                    return;
		                }
		                var lineGroup = new LineCtor(lineData, idx, seriesScope);

		                lineData.setItemGraphicEl(idx, lineGroup);

		                group.add(lineGroup);
		            })
		            .update(function (newIdx, oldIdx) {
		                var lineGroup = oldLineData.getItemGraphicEl(oldIdx);
		                if (!lineNeedsDraw(lineData.getItemLayout(newIdx))) {
		                    group.remove(lineGroup);
		                    return;
		                }

		                if (!lineGroup) {
		                    lineGroup = new LineCtor(lineData, newIdx, seriesScope);
		                }
		                else {
		                    lineGroup.updateData(lineData, newIdx, seriesScope);
		                }

		                lineData.setItemGraphicEl(newIdx, lineGroup);

		                group.add(lineGroup);
		            })
		            .remove(function (idx) {
		                group.remove(oldLineData.getItemGraphicEl(idx));
		            })
		            .execute();

		        this._lineData = lineData;
		    };

		    lineDrawProto.updateLayout = function () {
		        var lineData = this._lineData;
		        lineData.eachItemGraphicEl(function (el, idx) {
		            el.updateLayout(lineData, idx);
		        }, this);
		    };

		    lineDrawProto.remove = function () {
		        this.group.removeAll();
		    };

		    module.exports = LineDraw;


	/***/ },
	/* 202 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/chart/helper/Line
		 */


		    var symbolUtil = __webpack_require__(107);
		    var vector = __webpack_require__(10);
		    // var matrix = require('zrender/lib/core/matrix');
		    var LinePath = __webpack_require__(203);
		    var graphic = __webpack_require__(43);
		    var zrUtil = __webpack_require__(4);
		    var numberUtil = __webpack_require__(7);

		    var SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol'];
		    function makeSymbolTypeKey(symbolCategory) {
		        return '_' + symbolCategory + 'Type';
		    }
		    /**
		     * @inner
		     */
		    function createSymbol(name, lineData, idx) {
		        var color = lineData.getItemVisual(idx, 'color');
		        var symbolType = lineData.getItemVisual(idx, name);
		        var symbolSize = lineData.getItemVisual(idx, name + 'Size');

		        if (!symbolType || symbolType === 'none') {
		            return;
		        }

		        if (!zrUtil.isArray(symbolSize)) {
		            symbolSize = [symbolSize, symbolSize];
		        }
		        var symbolPath = symbolUtil.createSymbol(
		            symbolType, -symbolSize[0] / 2, -symbolSize[1] / 2,
		            symbolSize[0], symbolSize[1], color
		        );

		        symbolPath.name = name;

		        return symbolPath;
		    }

		    function createLine(points) {
		        var line = new LinePath({
		            name: 'line'
		        });
		        setLinePoints(line.shape, points);
		        return line;
		    }

		    function setLinePoints(targetShape, points) {
		        var p1 = points[0];
		        var p2 = points[1];
		        var cp1 = points[2];
		        targetShape.x1 = p1[0];
		        targetShape.y1 = p1[1];
		        targetShape.x2 = p2[0];
		        targetShape.y2 = p2[1];
		        targetShape.percent = 1;

		        if (cp1) {
		            targetShape.cpx1 = cp1[0];
		            targetShape.cpy1 = cp1[1];
		        }
		        else {
		            targetShape.cpx1 = NaN;
		            targetShape.cpy1 = NaN;
		        }
		    }

		    function updateSymbolAndLabelBeforeLineUpdate () {
		        var lineGroup = this;
		        var symbolFrom = lineGroup.childOfName('fromSymbol');
		        var symbolTo = lineGroup.childOfName('toSymbol');
		        var label = lineGroup.childOfName('label');
		        // Quick reject
		        if (!symbolFrom && !symbolTo && label.ignore) {
		            return;
		        }

		        var invScale = 1;
		        var parentNode = this.parent;
		        while (parentNode) {
		            if (parentNode.scale) {
		                invScale /= parentNode.scale[0];
		            }
		            parentNode = parentNode.parent;
		        }

		        var line = lineGroup.childOfName('line');
		        // If line not changed
		        // FIXME Parent scale changed
		        if (!this.__dirty && !line.__dirty) {
		            return;
		        }

		        var percent = line.shape.percent;
		        var fromPos = line.pointAt(0);
		        var toPos = line.pointAt(percent);

		        var d = vector.sub([], toPos, fromPos);
		        vector.normalize(d, d);

		        if (symbolFrom) {
		            symbolFrom.attr('position', fromPos);
		            var tangent = line.tangentAt(0);
		            symbolFrom.attr('rotation', Math.PI / 2 - Math.atan2(
		                tangent[1], tangent[0]
		            ));
		            symbolFrom.attr('scale', [invScale * percent, invScale * percent]);
		        }
		        if (symbolTo) {
		            symbolTo.attr('position', toPos);
		            var tangent = line.tangentAt(1);
		            symbolTo.attr('rotation', -Math.PI / 2 - Math.atan2(
		                tangent[1], tangent[0]
		            ));
		            symbolTo.attr('scale', [invScale * percent, invScale * percent]);
		        }

		        if (!label.ignore) {
		            label.attr('position', toPos);

		            var textPosition;
		            var textAlign;
		            var textVerticalAlign;

		            var distance = 5 * invScale;
		            // End
		            if (label.__position === 'end') {
		                textPosition = [d[0] * distance + toPos[0], d[1] * distance + toPos[1]];
		                textAlign = d[0] > 0.8 ? 'left' : (d[0] < -0.8 ? 'right' : 'center');
		                textVerticalAlign = d[1] > 0.8 ? 'top' : (d[1] < -0.8 ? 'bottom' : 'middle');
		            }
		            // Middle
		            else if (label.__position === 'middle') {
		                var halfPercent = percent / 2;
		                var tangent = line.tangentAt(halfPercent);
		                var n = [tangent[1], -tangent[0]];
		                var cp = line.pointAt(halfPercent);
		                if (n[1] > 0) {
		                    n[0] = -n[0];
		                    n[1] = -n[1];
		                }
		                textPosition = [cp[0] + n[0] * distance, cp[1] + n[1] * distance];
		                textAlign = 'center';
		                textVerticalAlign = 'bottom';
		                var rotation = -Math.atan2(tangent[1], tangent[0]);
		                if (toPos[0] < fromPos[0]) {
		                    rotation = Math.PI + rotation;
		                }
		                label.attr('rotation', rotation);
		            }
		            // Start
		            else {
		                textPosition = [-d[0] * distance + fromPos[0], -d[1] * distance + fromPos[1]];
		                textAlign = d[0] > 0.8 ? 'right' : (d[0] < -0.8 ? 'left' : 'center');
		                textVerticalAlign = d[1] > 0.8 ? 'bottom' : (d[1] < -0.8 ? 'top' : 'middle');
		            }
		            label.attr({
		                style: {
		                    // Use the user specified text align and baseline first
		                    textVerticalAlign: label.__verticalAlign || textVerticalAlign,
		                    textAlign: label.__textAlign || textAlign
		                },
		                position: textPosition,
		                scale: [invScale, invScale]
		            });
		        }
		    }

		    /**
		     * @constructor
		     * @extends {module:zrender/graphic/Group}
		     * @alias {module:echarts/chart/helper/Line}
		     */
		    function Line(lineData, idx, seriesScope) {
		        graphic.Group.call(this);

		        this._createLine(lineData, idx, seriesScope);
		    }

		    var lineProto = Line.prototype;

		    // Update symbol position and rotation
		    lineProto.beforeUpdate = updateSymbolAndLabelBeforeLineUpdate;

		    lineProto._createLine = function (lineData, idx, seriesScope) {
		        var seriesModel = lineData.hostModel;
		        var linePoints = lineData.getItemLayout(idx);

		        var line = createLine(linePoints);
		        line.shape.percent = 0;
		        graphic.initProps(line, {
		            shape: {
		                percent: 1
		            }
		        }, seriesModel, idx);

		        this.add(line);

		        var label = new graphic.Text({
		            name: 'label'
		        });
		        this.add(label);

		        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
		            var symbol = createSymbol(symbolCategory, lineData, idx);
		            // symbols must added after line to make sure
		            // it will be updated after line#update.
		            // Or symbol position and rotation update in line#beforeUpdate will be one frame slow
		            this.add(symbol);
		            this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory);
		        }, this);

		        this._updateCommonStl(lineData, idx, seriesScope);
		    };

		    lineProto.updateData = function (lineData, idx, seriesScope) {
		        var seriesModel = lineData.hostModel;

		        var line = this.childOfName('line');
		        var linePoints = lineData.getItemLayout(idx);
		        var target = {
		            shape: {}
		        };
		        setLinePoints(target.shape, linePoints);
		        graphic.updateProps(line, target, seriesModel, idx);

		        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
		            var symbolType = lineData.getItemVisual(idx, symbolCategory);
		            var key = makeSymbolTypeKey(symbolCategory);
		            // Symbol changed
		            if (this[key] !== symbolType) {
		                this.remove(this.childOfName(symbolCategory));
		                var symbol = createSymbol(symbolCategory, lineData, idx);
		                this.add(symbol);
		            }
		            this[key] = symbolType;
		        }, this);

		        this._updateCommonStl(lineData, idx, seriesScope);
		    };

		    lineProto._updateCommonStl = function (lineData, idx, seriesScope) {
		        var seriesModel = lineData.hostModel;

		        var line = this.childOfName('line');

		        var lineStyle = seriesScope && seriesScope.lineStyle;
		        var hoverLineStyle = seriesScope && seriesScope.hoverLineStyle;
		        var labelModel = seriesScope && seriesScope.labelModel;
		        var hoverLabelModel = seriesScope && seriesScope.hoverLabelModel;

		        // Optimization for large dataset
		        if (!seriesScope || lineData.hasItemOption) {
		            var itemModel = lineData.getItemModel(idx);

		            lineStyle = itemModel.getModel('lineStyle.normal').getLineStyle();
		            hoverLineStyle = itemModel.getModel('lineStyle.emphasis').getLineStyle();

		            labelModel = itemModel.getModel('label.normal');
		            hoverLabelModel = itemModel.getModel('label.emphasis');
		        }

		        var visualColor = lineData.getItemVisual(idx, 'color');
		        var visualOpacity = zrUtil.retrieve(
		            lineData.getItemVisual(idx, 'opacity'),
		            lineStyle.opacity,
		            1
		        );

		        line.useStyle(zrUtil.defaults(
		            {
		                strokeNoScale: true,
		                fill: 'none',
		                stroke: visualColor,
		                opacity: visualOpacity
		            },
		            lineStyle
		        ));
		        line.hoverStyle = hoverLineStyle;

		        // Update symbol
		        zrUtil.each(SYMBOL_CATEGORIES, function (symbolCategory) {
		            var symbol = this.childOfName(symbolCategory);
		            if (symbol) {
		                symbol.setColor(visualColor);
		                symbol.setStyle({
		                    opacity: visualOpacity
		                });
		            }
		        }, this);

		        var showLabel = labelModel.getShallow('show');
		        var hoverShowLabel = hoverLabelModel.getShallow('show');

		        var label = this.childOfName('label');
		        var defaultLabelColor;
		        var defaultText;

		        if (showLabel || hoverShowLabel) {
		            var rawVal = seriesModel.getRawValue(idx);
		            defaultText = rawVal == null
		                ? defaultText = lineData.getName(idx)
		                : isFinite(rawVal)
		                ? numberUtil.round(rawVal)
		                : rawVal;
		            defaultLabelColor = visualColor || '#000';
		        }

		        // label.afterUpdate = lineAfterUpdate;
		        if (showLabel) {
		            var textStyleModel = labelModel.getModel('textStyle');
		            label.setStyle({
		                text: zrUtil.retrieve(
		                    seriesModel.getFormattedLabel(idx, 'normal', lineData.dataType),
		                    defaultText
		                ),
		                textFont: textStyleModel.getFont(),
		                fill: textStyleModel.getTextColor() || defaultLabelColor
		            });

		            label.__textAlign = textStyleModel.get('align');
		            label.__verticalAlign = textStyleModel.get('baseline');
		            label.__position = labelModel.get('position');
		        }
		        else {
		            label.setStyle('text', '');
		        }
		        if (hoverShowLabel) {
		            var textStyleHoverModel = hoverLabelModel.getModel('textStyle');

		            label.hoverStyle = {
		                text: zrUtil.retrieve(
		                    seriesModel.getFormattedLabel(idx, 'emphasis', lineData.dataType),
		                    defaultText
		                ),
		                textFont: textStyleHoverModel.getFont(),
		                fill: textStyleHoverModel.getTextColor() || defaultLabelColor
		            };
		        }
		        else {
		            label.hoverStyle = {
		                text: ''
		            };
		        }

		        label.ignore = !showLabel && !hoverShowLabel;

		        graphic.setHoverStyle(this);
		    };

		    lineProto.updateLayout = function (lineData, idx) {
		        this.setLinePoints(lineData.getItemLayout(idx));
		    };

		    lineProto.setLinePoints = function (points) {
		        var linePath = this.childOfName('line');
		        setLinePoints(linePath.shape, points);
		        linePath.dirty();
		    };

		    zrUtil.inherits(Line, graphic.Group);

		    module.exports = Line;


	/***/ },
	/* 203 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Line path for bezier and straight line draw
		 */

		    var graphic = __webpack_require__(43);
		    var vec2 = __webpack_require__(10);

		    var straightLineProto = graphic.Line.prototype;
		    var bezierCurveProto = graphic.BezierCurve.prototype;

		    function isLine(shape) {
		        return isNaN(+shape.cpx1) || isNaN(+shape.cpy1);
		    }

		    module.exports = graphic.extendShape({

		        type: 'ec-line',

		        style: {
		            stroke: '#000',
		            fill: null
		        },

		        shape: {
		            x1: 0,
		            y1: 0,
		            x2: 0,
		            y2: 0,
		            percent: 1,
		            cpx1: null,
		            cpy1: null
		        },

		        buildPath: function (ctx, shape) {
		            (isLine(shape) ? straightLineProto : bezierCurveProto).buildPath(ctx, shape);
		        },

		        pointAt: function (t) {
		            return isLine(this.shape)
		                ? straightLineProto.pointAt.call(this, t)
		                : bezierCurveProto.pointAt.call(this, t);
		        },

		        tangentAt: function (t) {
		            var shape = this.shape;
		            var p = isLine(shape)
		                ? [shape.x2 - shape.x1, shape.y2 - shape.y1]
		                : bezierCurveProto.tangentAt.call(this, t);
		            return vec2.normalize(p, p);
		        }
		    });


	/***/ },
	/* 204 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var curveTool = __webpack_require__(50);
		    var vec2 = __webpack_require__(10);

		    var v1 = [];
		    var v2 = [];
		    var v3 = [];
		    var quadraticAt = curveTool.quadraticAt;
		    var v2DistSquare = vec2.distSquare;
		    var mathAbs = Math.abs;
		    function intersectCurveCircle(curvePoints, center, radius) {
		        var p0 = curvePoints[0];
		        var p1 = curvePoints[1];
		        var p2 = curvePoints[2];

		        var d = Infinity;
		        var t;
		        var radiusSquare = radius * radius;
		        var interval = 0.1;

		        for (var _t = 0.1; _t <= 0.9; _t += 0.1) {
		            v1[0] = quadraticAt(p0[0], p1[0], p2[0], _t);
		            v1[1] = quadraticAt(p0[1], p1[1], p2[1], _t);
		            var diff = mathAbs(v2DistSquare(v1, center) - radiusSquare);
		            if (diff < d) {
		                d = diff;
		                t = _t;
		            }
		        }

		        // Assume the segment is monotone，Find root through Bisection method
		        // At most 32 iteration
		        for (var i = 0; i < 32; i++) {
		            // var prev = t - interval;
		            var next = t + interval;
		            // v1[0] = quadraticAt(p0[0], p1[0], p2[0], prev);
		            // v1[1] = quadraticAt(p0[1], p1[1], p2[1], prev);
		            v2[0] = quadraticAt(p0[0], p1[0], p2[0], t);
		            v2[1] = quadraticAt(p0[1], p1[1], p2[1], t);
		            v3[0] = quadraticAt(p0[0], p1[0], p2[0], next);
		            v3[1] = quadraticAt(p0[1], p1[1], p2[1], next);

		            var diff = v2DistSquare(v2, center) - radiusSquare;
		            if (mathAbs(diff) < 1e-2) {
		                break;
		            }

		            // var prevDiff = v2DistSquare(v1, center) - radiusSquare;
		            var nextDiff = v2DistSquare(v3, center) - radiusSquare;

		            interval /= 2;
		            if (diff < 0) {
		                if (nextDiff >= 0) {
		                    t = t + interval;
		                }
		                else {
		                    t = t - interval;
		                }
		            }
		            else {
		                if (nextDiff >= 0) {
		                    t = t - interval;
		                }
		                else {
		                    t = t + interval;
		                }
		            }
		        }

		        return t;
		    }
		    // Adjust edge to avoid
		    module.exports = function (graph, scale) {
		        var tmp0 = [];
		        var quadraticSubdivide = curveTool.quadraticSubdivide;
		        var pts = [[], [], []];
		        var pts2 = [[], []];
		        var v = [];
		        scale /= 2;

		        function getSymbolSize(node) {
		            var symbolSize = node.getVisual('symbolSize');
		            if (symbolSize instanceof Array) {
		                symbolSize = (symbolSize[0] + symbolSize[1]) / 2;
		            }
		            return symbolSize;
		        }
		        graph.eachEdge(function (edge, idx) {
		            var linePoints = edge.getLayout();
		            var fromSymbol = edge.getVisual('fromSymbol');
		            var toSymbol = edge.getVisual('toSymbol');

		            if (!linePoints.__original) {
		                linePoints.__original = [
		                    vec2.clone(linePoints[0]),
		                    vec2.clone(linePoints[1])
		                ];
		                if (linePoints[2]) {
		                    linePoints.__original.push(vec2.clone(linePoints[2]));
		                }
		            }
		            var originalPoints = linePoints.__original;
		            // Quadratic curve
		            if (linePoints[2] != null) {
		                vec2.copy(pts[0], originalPoints[0]);
		                vec2.copy(pts[1], originalPoints[2]);
		                vec2.copy(pts[2], originalPoints[1]);
		                if (fromSymbol && fromSymbol != 'none') {
		                    var symbolSize = getSymbolSize(edge.node1);

		                    var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale);
		                    // Subdivide and get the second
		                    quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
		                    pts[0][0] = tmp0[3];
		                    pts[1][0] = tmp0[4];
		                    quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
		                    pts[0][1] = tmp0[3];
		                    pts[1][1] = tmp0[4];
		                }
		                if (toSymbol && toSymbol != 'none') {
		                    var symbolSize = getSymbolSize(edge.node2);

		                    var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale);
		                    // Subdivide and get the first
		                    quadraticSubdivide(pts[0][0], pts[1][0], pts[2][0], t, tmp0);
		                    pts[1][0] = tmp0[1];
		                    pts[2][0] = tmp0[2];
		                    quadraticSubdivide(pts[0][1], pts[1][1], pts[2][1], t, tmp0);
		                    pts[1][1] = tmp0[1];
		                    pts[2][1] = tmp0[2];
		                }
		                // Copy back to layout
		                vec2.copy(linePoints[0], pts[0]);
		                vec2.copy(linePoints[1], pts[2]);
		                vec2.copy(linePoints[2], pts[1]);
		            }
		            // Line
		            else {
		                vec2.copy(pts2[0], originalPoints[0]);
		                vec2.copy(pts2[1], originalPoints[1]);

		                vec2.sub(v, pts2[1], pts2[0]);
		                vec2.normalize(v, v);
		                if (fromSymbol && fromSymbol != 'none') {

		                    var symbolSize = getSymbolSize(edge.node1);

		                    vec2.scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale);
		                }
		                if (toSymbol && toSymbol != 'none') {
		                    var symbolSize = getSymbolSize(edge.node2);

		                    vec2.scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale);
		                }
		                vec2.copy(linePoints[0], pts2[0]);
		                vec2.copy(linePoints[1], pts2[1]);
		            }
		        });
		    };


	/***/ },
	/* 205 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var echarts = __webpack_require__(1);
		    var roamHelper = __webpack_require__(179);

		    var actionInfo = {
		        type: 'graphRoam',
		        event: 'graphRoam',
		        update: 'none'
		    };

		    /**
		     * @payload
		     * @property {string} name Series name
		     * @property {number} [dx]
		     * @property {number} [dy]
		     * @property {number} [zoom]
		     * @property {number} [originX]
		     * @property {number} [originY]
		     */

		    echarts.registerAction(actionInfo, function (payload, ecModel) {
		        ecModel.eachComponent({mainType: 'series', query: payload}, function (seriesModel) {
		            var coordSys = seriesModel.coordinateSystem;

		            var res = roamHelper.updateCenterAndZoom(coordSys, payload);

		            seriesModel.setCenter
		                && seriesModel.setCenter(res.center);

		            seriesModel.setZoom
		                && seriesModel.setZoom(res.zoom);
		        });
		    });


	/***/ },
	/* 206 */
	/***/ function(module, exports) {

		

		    module.exports = function (ecModel) {
		        var legendModels = ecModel.findComponents({
		            mainType: 'legend'
		        });
		        if (!legendModels || !legendModels.length) {
		            return;
		        }
		        ecModel.eachSeriesByType('graph', function (graphSeries) {
		            var categoriesData = graphSeries.getCategoriesData();
		            var graph = graphSeries.getGraph();
		            var data = graph.data;

		            var categoryNames = categoriesData.mapArray(categoriesData.getName);

		            data.filterSelf(function (idx) {
		                var model = data.getItemModel(idx);
		                var category = model.getShallow('category');
		                if (category != null) {
		                    if (typeof category === 'number') {
		                        category = categoryNames[category];
		                    }
		                    // If in any legend component the status is not selected.
		                    for (var i = 0; i < legendModels.length; i++) {
		                        if (!legendModels[i].isSelected(category)) {
		                            return false;
		                        }
		                    }
		                }
		                return true;
		            });
		        }, this);
		    };


	/***/ },
	/* 207 */
	/***/ function(module, exports) {

		

		    module.exports = function (ecModel) {

		        var paletteScope = {};
		        ecModel.eachSeriesByType('graph', function (seriesModel) {
		            var categoriesData = seriesModel.getCategoriesData();
		            var data = seriesModel.getData();

		            var categoryNameIdxMap = {};

		            categoriesData.each(function (idx) {
		                var name = categoriesData.getName(idx);
		                categoryNameIdxMap[name] = idx;

		                var itemModel = categoriesData.getItemModel(idx);
		                var color = itemModel.get('itemStyle.normal.color')
		                    || seriesModel.getColorFromPalette(name, paletteScope);
		                categoriesData.setItemVisual(idx, 'color', color);
		            });

		            // Assign category color to visual
		            if (categoriesData.count()) {
		                data.each(function (idx) {
		                    var model = data.getItemModel(idx);
		                    var category = model.getShallow('category');
		                    if (category != null) {
		                        if (typeof category === 'string') {
		                            category = categoryNameIdxMap[category];
		                        }
		                        if (!data.getItemVisual(idx, 'color', true)) {
		                            data.setItemVisual(
		                                idx, 'color',
		                                categoriesData.getItemVisual(category, 'color')
		                            );
		                        }
		                    }
		                });
		            }
		        });
		    };


	/***/ },
	/* 208 */
	/***/ function(module, exports) {

		

		    function normalize(a) {
		        if (!(a instanceof Array)) {
		            a = [a, a];
		        }
		        return a;
		    }
		    module.exports = function (ecModel) {
		        ecModel.eachSeriesByType('graph', function (seriesModel) {
		            var graph = seriesModel.getGraph();
		            var edgeData = seriesModel.getEdgeData();
		            var symbolType = normalize(seriesModel.get('edgeSymbol'));
		            var symbolSize = normalize(seriesModel.get('edgeSymbolSize'));

		            var colorQuery = 'lineStyle.normal.color'.split('.');
		            var opacityQuery = 'lineStyle.normal.opacity'.split('.');

		            edgeData.setVisual('fromSymbol', symbolType && symbolType[0]);
		            edgeData.setVisual('toSymbol', symbolType && symbolType[1]);
		            edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0]);
		            edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1]);
		            edgeData.setVisual('color', seriesModel.get(colorQuery));
		            edgeData.setVisual('opacity', seriesModel.get(opacityQuery));

		            edgeData.each(function (idx) {
		                var itemModel = edgeData.getItemModel(idx);
		                var edge = graph.getEdgeByIndex(idx);
		                var symbolType = normalize(itemModel.getShallow('symbol', true));
		                var symbolSize = normalize(itemModel.getShallow('symbolSize', true));
		                // Edge visual must after node visual
		                var color = itemModel.get(colorQuery);
		                var opacity = itemModel.get(opacityQuery);
		                switch (color) {
		                    case 'source':
		                        color = edge.node1.getVisual('color');
		                        break;
		                    case 'target':
		                        color = edge.node2.getVisual('color');
		                        break;
		                }

		                symbolType[0] && edge.setVisual('fromSymbol', symbolType[0]);
		                symbolType[1] && edge.setVisual('toSymbol', symbolType[1]);
		                symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0]);
		                symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1]);

		                edge.setVisual('color', color);
		                edge.setVisual('opacity', opacity);
		            });
		        });
		    };


	/***/ },
	/* 209 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var simpleLayoutHelper = __webpack_require__(210);
		    var simpleLayoutEdge = __webpack_require__(211);
		    module.exports = function (ecModel, api) {
		        ecModel.eachSeriesByType('graph', function (seriesModel) {
		            var layout = seriesModel.get('layout');
		            var coordSys = seriesModel.coordinateSystem;
		            if (coordSys && coordSys.type !== 'view') {
		                var data = seriesModel.getData();
		                data.each(coordSys.dimensions, function (x, y, idx) {
		                    if (!isNaN(x) && !isNaN(y)) {
		                        data.setItemLayout(idx, coordSys.dataToPoint([x, y]));
		                    }
		                    else {
		                        // Also {Array.<number>}, not undefined to avoid if...else... statement
		                        data.setItemLayout(idx, [NaN, NaN]);
		                    }
		                });

		                simpleLayoutEdge(data.graph);
		            }
		            else if (!layout || layout === 'none') {
		                simpleLayoutHelper(seriesModel);
		            }
		        });
		    };


	/***/ },
	/* 210 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var simpleLayoutEdge = __webpack_require__(211);

		    module.exports = function (seriesModel) {
		        var coordSys = seriesModel.coordinateSystem;
		        if (coordSys && coordSys.type !== 'view') {
		            return;
		        }
		        var graph = seriesModel.getGraph();

		        graph.eachNode(function (node) {
		            var model = node.getModel();
		            node.setLayout([+model.get('x'), +model.get('y')]);
		        });

		        simpleLayoutEdge(graph);
		    };


	/***/ },
	/* 211 */
	/***/ function(module, exports, __webpack_require__) {

		
		    var vec2 = __webpack_require__(10);
		    module.exports = function (graph) {
		        graph.eachEdge(function (edge) {
		            var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0;
		            var p1 = vec2.clone(edge.node1.getLayout());
		            var p2 = vec2.clone(edge.node2.getLayout());
		            var points = [p1, p2];
		            if (+curveness) {
		                points.push([
		                    (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness,
		                    (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness
		                ]);
		            }
		            edge.setLayout(points);
		        });
		    };


	/***/ },
	/* 212 */
	/***/ function(module, exports, __webpack_require__) {

		
		    var circularLayoutHelper = __webpack_require__(213);
		    module.exports = function (ecModel) {
		        ecModel.eachSeriesByType('graph', function (seriesModel) {
		            if (seriesModel.get('layout') === 'circular') {
		                circularLayoutHelper(seriesModel);
		            }
		        });
		    };


	/***/ },
	/* 213 */
	/***/ function(module, exports, __webpack_require__) {

		
		    var vec2 = __webpack_require__(10);
		    module.exports = function (seriesModel) {
		        var coordSys = seriesModel.coordinateSystem;
		        if (coordSys && coordSys.type !== 'view') {
		            return;
		        }

		        var rect = coordSys.getBoundingRect();

		        var nodeData = seriesModel.getData();
		        var graph = nodeData.graph;

		        var angle = 0;
		        var sum = nodeData.getSum('value');
		        var unitAngle = Math.PI * 2 / (sum || nodeData.count());

		        var cx = rect.width / 2 + rect.x;
		        var cy = rect.height / 2 + rect.y;

		        var r = Math.min(rect.width, rect.height) / 2;

		        graph.eachNode(function (node) {
		            var value = node.getValue('value');

		            angle += unitAngle * (sum ? value : 1) / 2;

		            node.setLayout([
		                r * Math.cos(angle) + cx,
		                r * Math.sin(angle) + cy
		            ]);

		            angle += unitAngle * (sum ? value : 1) / 2;
		        });

		        nodeData.setLayout({
		            cx: cx,
		            cy: cy
		        });

		        graph.eachEdge(function (edge) {
		            var curveness = edge.getModel().get('lineStyle.normal.curveness') || 0;
		            var p1 = vec2.clone(edge.node1.getLayout());
		            var p2 = vec2.clone(edge.node2.getLayout());
		            var cp1;
		            var x12 = (p1[0] + p2[0]) / 2;
		            var y12 = (p1[1] + p2[1]) / 2;
		            if (+curveness) {
		                curveness *= 3;
		                cp1 = [
		                    cx * curveness + x12 * (1 - curveness),
		                    cy * curveness + y12 * (1 - curveness)
		                ];
		            }
		            edge.setLayout([p1, p2, cp1]);
		        });
		    };


	/***/ },
	/* 214 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var forceHelper = __webpack_require__(215);
		    var numberUtil = __webpack_require__(7);
		    var simpleLayoutHelper = __webpack_require__(210);
		    var circularLayoutHelper = __webpack_require__(213);
		    var vec2 = __webpack_require__(10);
		    var zrUtil = __webpack_require__(4);

		    module.exports = function (ecModel) {
		        ecModel.eachSeriesByType('graph', function (graphSeries) {
		            var coordSys = graphSeries.coordinateSystem;
		            if (coordSys && coordSys.type !== 'view') {
		                return;
		            }
		            if (graphSeries.get('layout') === 'force') {
		                var preservedPoints = graphSeries.preservedPoints || {};
		                var graph = graphSeries.getGraph();
		                var nodeData = graph.data;
		                var edgeData = graph.edgeData;
		                var forceModel = graphSeries.getModel('force');
		                var initLayout = forceModel.get('initLayout');
		                if (graphSeries.preservedPoints) {
		                    nodeData.each(function (idx) {
		                        var id = nodeData.getId(idx);
		                        nodeData.setItemLayout(idx, preservedPoints[id] || [NaN, NaN]);
		                    });
		                }
		                else if (!initLayout || initLayout === 'none') {
		                    simpleLayoutHelper(graphSeries);
		                }
		                else if (initLayout === 'circular') {
		                    circularLayoutHelper(graphSeries);
		                }

		                var nodeDataExtent = nodeData.getDataExtent('value');
		                var edgeDataExtent = edgeData.getDataExtent('value');
		                // var edgeDataExtent = edgeData.getDataExtent('value');
		                var repulsion = forceModel.get('repulsion');
		                var edgeLength = forceModel.get('edgeLength');
		                if (!zrUtil.isArray(repulsion)) {
		                    repulsion = [repulsion, repulsion];
		                }
		                if (!zrUtil.isArray(edgeLength)) {
		                    edgeLength = [edgeLength, edgeLength];
		                }
		                // Larger value has smaller length
		                edgeLength = [edgeLength[1], edgeLength[0]];

		                var nodes = nodeData.mapArray('value', function (value, idx) {
		                    var point = nodeData.getItemLayout(idx);
		                    // var w = numberUtil.linearMap(value, nodeDataExtent, [0, 50]);
		                    var rep = numberUtil.linearMap(value, nodeDataExtent, repulsion);
		                    if (isNaN(rep)) {
		                        rep = (repulsion[0] + repulsion[1]) / 2;
		                    }
		                    return {
		                        w: rep,
		                        rep: rep,
		                        p: (!point || isNaN(point[0]) || isNaN(point[1])) ? null : point
		                    };
		                });
		                var edges = edgeData.mapArray('value', function (value, idx) {
		                    var edge = graph.getEdgeByIndex(idx);
		                    var d = numberUtil.linearMap(value, edgeDataExtent, edgeLength);
		                    if (isNaN(d)) {
		                        d = (edgeLength[0] + edgeLength[1]) / 2;
		                    }
		                    return {
		                        n1: nodes[edge.node1.dataIndex],
		                        n2: nodes[edge.node2.dataIndex],
		                        d: d,
		                        curveness: edge.getModel().get('lineStyle.normal.curveness') || 0
		                    };
		                });

		                var coordSys = graphSeries.coordinateSystem;
		                var rect = coordSys.getBoundingRect();
		                var forceInstance = forceHelper(nodes, edges, {
		                    rect: rect,
		                    gravity: forceModel.get('gravity')
		                });
		                var oldStep = forceInstance.step;
		                forceInstance.step = function (cb) {
		                    for (var i = 0, l = nodes.length; i < l; i++) {
		                        if (nodes[i].fixed) {
		                            // Write back to layout instance
		                            vec2.copy(nodes[i].p, graph.getNodeByIndex(i).getLayout());
		                        }
		                    }
		                    oldStep(function (nodes, edges, stopped) {
		                        for (var i = 0, l = nodes.length; i < l; i++) {
		                            if (!nodes[i].fixed) {
		                                graph.getNodeByIndex(i).setLayout(nodes[i].p);
		                            }
		                            preservedPoints[nodeData.getId(i)] = nodes[i].p;
		                        }
		                        for (var i = 0, l = edges.length; i < l; i++) {
		                            var e = edges[i];
		                            var edge = graph.getEdgeByIndex(i);
		                            var p1 = e.n1.p;
		                            var p2 = e.n2.p;
		                            var points = edge.getLayout();
		                            points = points ? points.slice() : [];
		                            points[0] = points[0] || [];
		                            points[1] = points[1] || [];
		                            vec2.copy(points[0], p1);
		                            vec2.copy(points[1], p2);
		                            if (+e.curveness) {
		                                points[2] = [
		                                    (p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness,
		                                    (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness
		                                ];
		                            }
		                            edge.setLayout(points);
		                        }
		                        // Update layout

		                        cb && cb(stopped);
		                    });
		                };
		                graphSeries.forceLayout = forceInstance;
		                graphSeries.preservedPoints = preservedPoints;

		                // Step to get the layout
		                forceInstance.step();
		            }
		            else {
		                // Remove prev injected forceLayout instance
		                graphSeries.forceLayout = null;
		            }
		        });
		    };


	/***/ },
	/* 215 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var vec2 = __webpack_require__(10);
		    var scaleAndAdd = vec2.scaleAndAdd;

		    // function adjacentNode(n, e) {
		    //     return e.n1 === n ? e.n2 : e.n1;
		    // }

		    module.exports = function (nodes, edges, opts) {
		        var rect = opts.rect;
		        var width = rect.width;
		        var height = rect.height;
		        var center = [rect.x + width / 2, rect.y + height / 2];
		        // var scale = opts.scale || 1;
		        var gravity = opts.gravity == null ? 0.1 : opts.gravity;

		        // for (var i = 0; i < edges.length; i++) {
		        //     var e = edges[i];
		        //     var n1 = e.n1;
		        //     var n2 = e.n2;
		        //     n1.edges = n1.edges || [];
		        //     n2.edges = n2.edges || [];
		        //     n1.edges.push(e);
		        //     n2.edges.push(e);
		        // }
		        // Init position
		        for (var i = 0; i < nodes.length; i++) {
		            var n = nodes[i];
		            if (!n.p) {
		                // Use the position from first adjecent node with defined position
		                // Or use a random position
		                // From d3
		                // if (n.edges) {
		                //     var j = -1;
		                //     while (++j < n.edges.length) {
		                //         var e = n.edges[j];
		                //         var other = adjacentNode(n, e);
		                //         if (other.p) {
		                //             n.p = vec2.clone(other.p);
		                //             break;
		                //         }
		                //     }
		                // }
		                // if (!n.p) {
		                    n.p = vec2.create(
		                        width * (Math.random() - 0.5) + center[0],
		                        height * (Math.random() - 0.5) + center[1]
		                    );
		                // }
		            }
		            n.pp = vec2.clone(n.p);
		            n.edges = null;
		        }

		        // Formula in 'Graph Drawing by Force-directed Placement'
		        // var k = scale * Math.sqrt(width * height / nodes.length);
		        // var k2 = k * k;

		        var friction = 0.6;

		        return {
		            warmUp: function () {
		                friction = 0.5;
		            },

		            setFixed: function (idx) {
		                nodes[idx].fixed = true;
		            },

		            setUnfixed: function (idx) {
		                nodes[idx].fixed = false;
		            },

		            step: function (cb) {
		                var v12 = [];
		                var nLen = nodes.length;
		                for (var i = 0; i < edges.length; i++) {
		                    var e = edges[i];
		                    var n1 = e.n1;
		                    var n2 = e.n2;

		                    vec2.sub(v12, n2.p, n1.p);
		                    var d = vec2.len(v12) - e.d;
		                    var w = n2.w / (n1.w + n2.w);
		                    vec2.normalize(v12, v12);

		                    !n1.fixed && scaleAndAdd(n1.p, n1.p, v12, w * d * friction);
		                    !n2.fixed && scaleAndAdd(n2.p, n2.p, v12, -(1 - w) * d * friction);
		                }
		                // Gravity
		                for (var i = 0; i < nLen; i++) {
		                    var n = nodes[i];
		                    if (!n.fixed) {
		                        vec2.sub(v12, center, n.p);
		                        // var d = vec2.len(v12);
		                        // vec2.scale(v12, v12, 1 / d);
		                        // var gravityFactor = gravity;
		                        vec2.scaleAndAdd(n.p, n.p, v12, gravity * friction);
		                    }
		                }

		                // Repulsive
		                // PENDING
		                for (var i = 0; i < nLen; i++) {
		                    var n1 = nodes[i];
		                    for (var j = i + 1; j < nLen; j++) {
		                        var n2 = nodes[j];
		                        vec2.sub(v12, n2.p, n1.p);
		                        var d = vec2.len(v12);
		                        if (d === 0) {
		                            // Random repulse
		                            vec2.set(v12, Math.random() - 0.5, Math.random() - 0.5);
		                            d = 1;
		                        }
		                        var repFact = (n1.rep + n2.rep) / d / d;
		                        !n1.fixed && scaleAndAdd(n1.pp, n1.pp, v12, repFact);
		                        !n2.fixed && scaleAndAdd(n2.pp, n2.pp, v12, -repFact);
		                    }
		                }
		                var v = [];
		                for (var i = 0; i < nLen; i++) {
		                    var n = nodes[i];
		                    if (!n.fixed) {
		                        vec2.sub(v, n.p, n.pp);
		                        vec2.scaleAndAdd(n.p, n.p, v, friction);
		                        vec2.copy(n.pp, n.p);
		                    }
		                }

		                friction = friction * 0.992;

		                cb && cb(nodes, edges, friction < 0.01);
		            }
		        };
		    };


	/***/ },
	/* 216 */
	/***/ function(module, exports, __webpack_require__) {

		
		    // FIXME Where to create the simple view coordinate system
		    var View = __webpack_require__(170);
		    var layout = __webpack_require__(21);
		    var bbox = __webpack_require__(51);

		    function getViewRect(seriesModel, api, aspect) {
		        var option = seriesModel.getBoxLayoutParams();
		        option.aspect = aspect;
		        return layout.getLayoutRect(option, {
		            width: api.getWidth(),
		            height: api.getHeight()
		        });
		    }

		    module.exports = function (ecModel, api) {
		        var viewList = [];
		        ecModel.eachSeriesByType('graph', function (seriesModel) {
		            var coordSysType = seriesModel.get('coordinateSystem');
		            if (!coordSysType || coordSysType === 'view') {

		                var data = seriesModel.getData();
		                var positions = data.mapArray(function (idx) {
		                    var itemModel = data.getItemModel(idx);
		                    return [+itemModel.get('x'), +itemModel.get('y')];
		                });

		                var min = [];
		                var max = [];

		                bbox.fromPoints(positions, min, max);

		                // If width or height is 0
		                if (max[0] - min[0] === 0) {
		                    max[0] += 1;
		                    min[0] -= 1;
		                }
		                if (max[1] - min[1] === 0) {
		                    max[1] += 1;
		                    min[1] -= 1;
		                }
		                var aspect = (max[0] - min[0]) / (max[1] - min[1]);
		                // FIXME If get view rect after data processed?
		                var viewRect = getViewRect(seriesModel, api, aspect);
		                // Position may be NaN, use view rect instead
		                if (isNaN(aspect)) {
		                    min = [viewRect.x, viewRect.y];
		                    max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height];
		                }

		                var bbWidth = max[0] - min[0];
		                var bbHeight = max[1] - min[1];

		                var viewWidth = viewRect.width;
		                var viewHeight = viewRect.height;

		                var viewCoordSys = seriesModel.coordinateSystem = new View();
		                viewCoordSys.zoomLimit = seriesModel.get('scaleLimit');

		                viewCoordSys.setBoundingRect(
		                    min[0], min[1], bbWidth, bbHeight
		                );
		                viewCoordSys.setViewRect(
		                    viewRect.x, viewRect.y, viewWidth, viewHeight
		                );

		                // Update roam info
		                viewCoordSys.setCenter(seriesModel.get('center'));
		                viewCoordSys.setZoom(seriesModel.get('zoom'));

		                viewList.push(viewCoordSys);
		            }
		        });
		        return viewList;
		    };


	/***/ },
	/* 217 */
	/***/ function(module, exports, __webpack_require__) {

		
		    __webpack_require__(218);
		    __webpack_require__(219);


	/***/ },
	/* 218 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var List = __webpack_require__(98);
		    var SeriesModel = __webpack_require__(28);
		    var zrUtil = __webpack_require__(4);

		    var GaugeSeries = SeriesModel.extend({

		        type: 'series.gauge',

		        getInitialData: function (option, ecModel) {
		            var list = new List(['value'], this);
		            var dataOpt = option.data || [];
		            if (!zrUtil.isArray(dataOpt)) {
		                dataOpt = [dataOpt];
		            }
		            // Only use the first data item
		            list.initData(dataOpt);
		            return list;
		        },

		        defaultOption: {
		            zlevel: 0,
		            z: 2,
		            // 默认全局居中
		            center: ['50%', '50%'],
		            legendHoverLink: true,
		            radius: '75%',
		            startAngle: 225,
		            endAngle: -45,
		            clockwise: true,
		            // 最小值
		            min: 0,
		            // 最大值
		            max: 100,
		            // 分割段数，默认为10
		            splitNumber: 10,
		            // 坐标轴线
		            axisLine: {
		                // 默认显示，属性show控制显示与否
		                show: true,
		                lineStyle: {       // 属性lineStyle控制线条样式
		                    color: [[0.2, '#91c7ae'], [0.8, '#63869e'], [1, '#c23531']],
		                    width: 30
		                }
		            },
		            // 分隔线
		            splitLine: {
		                // 默认显示，属性show控制显示与否
		                show: true,
		                // 属性length控制线长
		                length: 30,
		                // 属性lineStyle（详见lineStyle）控制线条样式
		                lineStyle: {
		                    color: '#eee',
		                    width: 2,
		                    type: 'solid'
		                }
		            },
		            // 坐标轴小标记
		            axisTick: {
		                // 属性show控制显示与否，默认不显示
		                show: true,
		                // 每份split细分多少段
		                splitNumber: 5,
		                // 属性length控制线长
		                length: 8,
		                // 属性lineStyle控制线条样式
		                lineStyle: {
		                    color: '#eee',
		                    width: 1,
		                    type: 'solid'
		                }
		            },
		            axisLabel: {
		                show: true,
		                distance: 5,
		                // formatter: null,
		                textStyle: {       // 其余属性默认使用全局文本样式，详见TEXTSTYLE
		                    color: 'auto'
		                }
		            },
		            pointer: {
		                show: true,
		                length: '80%',
		                width: 8
		            },
		            itemStyle: {
		                normal: {
		                    color: 'auto'
		                }
		            },
		            title: {
		                show: true,
		                // x, y，单位px
		                offsetCenter: [0, '-40%'],
		                // 其余属性默认使用全局文本样式，详见TEXTSTYLE
		                textStyle: {
		                    color: '#333',
		                    fontSize: 15
		                }
		            },
		            detail: {
		                show: true,
		                backgroundColor: 'rgba(0,0,0,0)',
		                borderWidth: 0,
		                borderColor: '#ccc',
		                width: 100,
		                height: 40,
		                // x, y，单位px
		                offsetCenter: [0, '40%'],
		                // formatter: null,
		                // 其余属性默认使用全局文本样式，详见TEXTSTYLE
		                textStyle: {
		                    color: 'auto',
		                    fontSize: 30
		                }
		            }
		        }
		    });

		    module.exports = GaugeSeries;


	/***/ },
	/* 219 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var PointerPath = __webpack_require__(220);

		    var graphic = __webpack_require__(43);
		    var numberUtil = __webpack_require__(7);
		    var parsePercent = numberUtil.parsePercent;

		    function parsePosition(seriesModel, api) {
		        var center = seriesModel.get('center');
		        var width = api.getWidth();
		        var height = api.getHeight();
		        var size = Math.min(width, height);
		        var cx = parsePercent(center[0], api.getWidth());
		        var cy = parsePercent(center[1], api.getHeight());
		        var r = parsePercent(seriesModel.get('radius'), size / 2);

		        return {
		            cx: cx,
		            cy: cy,
		            r: r
		        };
		    }

		    function formatLabel(label, labelFormatter) {
		        if (labelFormatter) {
		            if (typeof labelFormatter === 'string') {
		                label = labelFormatter.replace('{value}', label != null ? label : '');
		            }
		            else if (typeof labelFormatter === 'function') {
		                label = labelFormatter(label);
		            }
		        }

		        return label;
		    }

		    var PI2 = Math.PI * 2;

		    var GaugeView = __webpack_require__(42).extend({

		        type: 'gauge',

		        render: function (seriesModel, ecModel, api) {

		            this.group.removeAll();

		            var colorList = seriesModel.get('axisLine.lineStyle.color');
		            var posInfo = parsePosition(seriesModel, api);

		            this._renderMain(
		                seriesModel, ecModel, api, colorList, posInfo
		            );
		        },

		        dispose: function () {},

		        _renderMain: function (seriesModel, ecModel, api, colorList, posInfo) {
		            var group = this.group;

		            var axisLineModel = seriesModel.getModel('axisLine');
		            var lineStyleModel = axisLineModel.getModel('lineStyle');

		            var clockwise = seriesModel.get('clockwise');
		            var startAngle = -seriesModel.get('startAngle') / 180 * Math.PI;
		            var endAngle = -seriesModel.get('endAngle') / 180 * Math.PI;

		            var angleRangeSpan = (endAngle - startAngle) % PI2;

		            var prevEndAngle = startAngle;
		            var axisLineWidth = lineStyleModel.get('width');

		            for (var i = 0; i < colorList.length; i++) {
		                // Clamp
		                var percent = Math.min(Math.max(colorList[i][0], 0), 1);
		                var endAngle = startAngle + angleRangeSpan * percent;
		                var sector = new graphic.Sector({
		                    shape: {
		                        startAngle: prevEndAngle,
		                        endAngle: endAngle,
		                        cx: posInfo.cx,
		                        cy: posInfo.cy,
		                        clockwise: clockwise,
		                        r0: posInfo.r - axisLineWidth,
		                        r: posInfo.r
		                    },
		                    silent: true
		                });

		                sector.setStyle({
		                    fill: colorList[i][1]
		                });

		                sector.setStyle(lineStyleModel.getLineStyle(
		                    // Because we use sector to simulate arc
		                    // so the properties for stroking are useless
		                    ['color', 'borderWidth', 'borderColor']
		                ));

		                group.add(sector);

		                prevEndAngle = endAngle;
		            }

		            var getColor = function (percent) {
		                // Less than 0
		                if (percent <= 0) {
		                    return colorList[0][1];
		                }
		                for (var i = 0; i < colorList.length; i++) {
		                    if (colorList[i][0] >= percent
		                        && (i === 0 ? 0 : colorList[i - 1][0]) < percent
		                    ) {
		                        return colorList[i][1];
		                    }
		                }
		                // More than 1
		                return colorList[i - 1][1];
		            };

		            if (!clockwise) {
		                var tmp = startAngle;
		                startAngle = endAngle;
		                endAngle = tmp;
		            }

		            this._renderTicks(
		                seriesModel, ecModel, api, getColor, posInfo,
		                startAngle, endAngle, clockwise
		            );

		            this._renderPointer(
		                seriesModel, ecModel, api, getColor, posInfo,
		                startAngle, endAngle, clockwise
		            );

		            this._renderTitle(
		                seriesModel, ecModel, api, getColor, posInfo
		            );
		            this._renderDetail(
		                seriesModel, ecModel, api, getColor, posInfo
		            );
		        },

		        _renderTicks: function (
		            seriesModel, ecModel, api, getColor, posInfo,
		            startAngle, endAngle, clockwise
		        ) {
		            var group = this.group;
		            var cx = posInfo.cx;
		            var cy = posInfo.cy;
		            var r = posInfo.r;

		            var minVal = seriesModel.get('min');
		            var maxVal = seriesModel.get('max');

		            var splitLineModel = seriesModel.getModel('splitLine');
		            var tickModel = seriesModel.getModel('axisTick');
		            var labelModel = seriesModel.getModel('axisLabel');

		            var splitNumber = seriesModel.get('splitNumber');
		            var subSplitNumber = tickModel.get('splitNumber');

		            var splitLineLen = parsePercent(
		                splitLineModel.get('length'), r
		            );
		            var tickLen = parsePercent(
		                tickModel.get('length'), r
		            );

		            var angle = startAngle;
		            var step = (endAngle - startAngle) / splitNumber;
		            var subStep = step / subSplitNumber;

		            var splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle();
		            var tickLineStyle = tickModel.getModel('lineStyle').getLineStyle();
		            var textStyleModel = labelModel.getModel('textStyle');

		            for (var i = 0; i <= splitNumber; i++) {
		                var unitX = Math.cos(angle);
		                var unitY = Math.sin(angle);
		                // Split line
		                if (splitLineModel.get('show')) {
		                    var splitLine = new graphic.Line({
		                        shape: {
		                            x1: unitX * r + cx,
		                            y1: unitY * r + cy,
		                            x2: unitX * (r - splitLineLen) + cx,
		                            y2: unitY * (r - splitLineLen) + cy
		                        },
		                        style: splitLineStyle,
		                        silent: true
		                    });
		                    if (splitLineStyle.stroke === 'auto') {
		                        splitLine.setStyle({
		                            stroke: getColor(i / splitNumber)
		                        });
		                    }

		                    group.add(splitLine);
		                }

		                // Label
		                if (labelModel.get('show')) {
		                    var label = formatLabel(
		                        numberUtil.round(i / splitNumber * (maxVal - minVal) + minVal),
		                        labelModel.get('formatter')
		                    );
		                    var distance = labelModel.get('distance');

		                    var text = new graphic.Text({
		                        style: {
		                            text: label,
		                            x: unitX * (r - splitLineLen - distance) + cx,
		                            y: unitY * (r - splitLineLen - distance) + cy,
		                            fill: textStyleModel.getTextColor(),
		                            textFont: textStyleModel.getFont(),
		                            textVerticalAlign: unitY < -0.4 ? 'top' : (unitY > 0.4 ? 'bottom' : 'middle'),
		                            textAlign: unitX < -0.4 ? 'left' : (unitX > 0.4 ? 'right' : 'center')
		                        },
		                        silent: true
		                    });
		                    if (text.style.fill === 'auto') {
		                        text.setStyle({
		                            fill: getColor(i / splitNumber)
		                        });
		                    }

		                    group.add(text);
		                }

		                // Axis tick
		                if (tickModel.get('show') && i !== splitNumber) {
		                    for (var j = 0; j <= subSplitNumber; j++) {
		                        var unitX = Math.cos(angle);
		                        var unitY = Math.sin(angle);
		                        var tickLine = new graphic.Line({
		                            shape: {
		                                x1: unitX * r + cx,
		                                y1: unitY * r + cy,
		                                x2: unitX * (r - tickLen) + cx,
		                                y2: unitY * (r - tickLen) + cy
		                            },
		                            silent: true,
		                            style: tickLineStyle
		                        });

		                        if (tickLineStyle.stroke === 'auto') {
		                            tickLine.setStyle({
		                                stroke: getColor((i + j / subSplitNumber) / splitNumber)
		                            });
		                        }

		                        group.add(tickLine);
		                        angle += subStep;
		                    }
		                    angle -= subStep;
		                }
		                else {
		                    angle += step;
		                }
		            }
		        },

		        _renderPointer: function (
		            seriesModel, ecModel, api, getColor, posInfo,
		            startAngle, endAngle, clockwise
		        ) {
		            var valueExtent = [+seriesModel.get('min'), +seriesModel.get('max')];
		            var angleExtent = [startAngle, endAngle];

		            var data = seriesModel.getData();
		            var oldData = this._data;

		            var group = this.group;

		            data.diff(oldData)
		                .add(function (idx) {
		                    var pointer = new PointerPath({
		                        shape: {
		                            angle: startAngle
		                        }
		                    });

		                    graphic.updateProps(pointer, {
		                        shape: {
		                            angle: numberUtil.linearMap(data.get('value', idx), valueExtent, angleExtent, true)
		                        }
		                    }, seriesModel);

		                    group.add(pointer);
		                    data.setItemGraphicEl(idx, pointer);
		                })
		                .update(function (newIdx, oldIdx) {
		                    var pointer = oldData.getItemGraphicEl(oldIdx);

		                    graphic.updateProps(pointer, {
		                        shape: {
		                            angle: numberUtil.linearMap(data.get('value', newIdx), valueExtent, angleExtent, true)
		                        }
		                    }, seriesModel);

		                    group.add(pointer);
		                    data.setItemGraphicEl(newIdx, pointer);
		                })
		                .remove(function (idx) {
		                    var pointer = oldData.getItemGraphicEl(idx);
		                    group.remove(pointer);
		                })
		                .execute();

		            data.eachItemGraphicEl(function (pointer, idx) {
		                var itemModel = data.getItemModel(idx);
		                var pointerModel = itemModel.getModel('pointer');

		                pointer.setShape({
		                    x: posInfo.cx,
		                    y: posInfo.cy,
		                    width: parsePercent(
		                        pointerModel.get('width'), posInfo.r
		                    ),
		                    r: parsePercent(pointerModel.get('length'), posInfo.r)
		                });

		                pointer.useStyle(itemModel.getModel('itemStyle.normal').getItemStyle());

		                if (pointer.style.fill === 'auto') {
		                    pointer.setStyle('fill', getColor(
		                        (data.get('value', idx) - valueExtent[0]) / (valueExtent[1] - valueExtent[0])
		                    ));
		                }

		                graphic.setHoverStyle(
		                    pointer, itemModel.getModel('itemStyle.emphasis').getItemStyle()
		                );
		            });

		            this._data = data;
		        },

		        _renderTitle: function (
		            seriesModel, ecModel, api, getColor, posInfo
		        ) {
		            var titleModel = seriesModel.getModel('title');
		            if (titleModel.get('show')) {
		                var textStyleModel = titleModel.getModel('textStyle');
		                var offsetCenter = titleModel.get('offsetCenter');
		                var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
		                var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
		                var text = new graphic.Text({
		                    style: {
		                        x: x,
		                        y: y,
		                        // FIXME First data name ?
		                        text: seriesModel.getData().getName(0),
		                        fill: textStyleModel.getTextColor(),
		                        textFont: textStyleModel.getFont(),
		                        textAlign: 'center',
		                        textVerticalAlign: 'middle'
		                    }
		                });
		                this.group.add(text);
		            }
		        },

		        _renderDetail: function (
		            seriesModel, ecModel, api, getColor, posInfo
		        ) {
		            var detailModel = seriesModel.getModel('detail');
		            var minVal = seriesModel.get('min');
		            var maxVal = seriesModel.get('max');
		            if (detailModel.get('show')) {
		                var textStyleModel = detailModel.getModel('textStyle');
		                var offsetCenter = detailModel.get('offsetCenter');
		                var x = posInfo.cx + parsePercent(offsetCenter[0], posInfo.r);
		                var y = posInfo.cy + parsePercent(offsetCenter[1], posInfo.r);
		                var width = parsePercent(detailModel.get('width'), posInfo.r);
		                var height = parsePercent(detailModel.get('height'), posInfo.r);
		                var value = seriesModel.getData().get('value', 0);
		                var rect = new graphic.Rect({
		                    shape: {
		                        x: x - width / 2,
		                        y: y - height / 2,
		                        width: width,
		                        height: height
		                    },
		                    style: {
		                        text: formatLabel(
		                            // FIXME First data name ?
		                            value, detailModel.get('formatter')
		                        ),
		                        fill: detailModel.get('backgroundColor'),
		                        textFill: textStyleModel.getTextColor(),
		                        textFont: textStyleModel.getFont()
		                    }
		                });
		                if (rect.style.textFill === 'auto') {
		                    rect.setStyle('textFill', getColor(
		                        numberUtil.linearMap(value, [minVal, maxVal], [0, 1], true)
		                    ));
		                }
		                rect.setStyle(detailModel.getItemStyle(['color']));
		                this.group.add(rect);
		            }
		        }
		    });

		    module.exports = GaugeView;


	/***/ },
	/* 220 */
	/***/ function(module, exports, __webpack_require__) {

		

		    module.exports = __webpack_require__(45).extend({

		        type: 'echartsGaugePointer',

		        shape: {
		            angle: 0,

		            width: 10,

		            r: 10,

		            x: 0,

		            y: 0
		        },

		        buildPath: function (ctx, shape) {
		            var mathCos = Math.cos;
		            var mathSin = Math.sin;

		            var r = shape.r;
		            var width = shape.width;
		            var angle = shape.angle;
		            var x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2);
		            var y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2);

		            angle = shape.angle - Math.PI / 2;
		            ctx.moveTo(x, y);
		            ctx.lineTo(
		                shape.x + mathCos(angle) * width,
		                shape.y + mathSin(angle) * width
		            );
		            ctx.lineTo(
		                shape.x + mathCos(shape.angle) * r,
		                shape.y + mathSin(shape.angle) * r
		            );
		            ctx.lineTo(
		                shape.x - mathCos(angle) * width,
		                shape.y - mathSin(angle) * width
		            );
		            ctx.lineTo(x, y);
		            return;
		        }
		    });


	/***/ },
	/* 221 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var echarts = __webpack_require__(1);

		    __webpack_require__(222);
		    __webpack_require__(223);

		    echarts.registerVisual(zrUtil.curry(__webpack_require__(145), 'funnel'));
		    echarts.registerLayout(__webpack_require__(224));

		    echarts.registerProcessor(zrUtil.curry(__webpack_require__(148), 'funnel'));


	/***/ },
	/* 222 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var List = __webpack_require__(98);
		    var modelUtil = __webpack_require__(5);
		    var completeDimensions = __webpack_require__(103);

		    var FunnelSeries = __webpack_require__(1).extendSeriesModel({

		        type: 'series.funnel',

		        init: function (option) {
		            FunnelSeries.superApply(this, 'init', arguments);

		            // Enable legend selection for each data item
		            // Use a function instead of direct access because data reference may changed
		            this.legendDataProvider = function () {
		                return this._dataBeforeProcessed;
		            };
		            // Extend labelLine emphasis
		            this._defaultLabelLine(option);
		        },

		        getInitialData: function (option, ecModel) {
		            var dimensions = completeDimensions(['value'], option.data);
		            var list = new List(dimensions, this);
		            list.initData(option.data);
		            return list;
		        },

		        _defaultLabelLine: function (option) {
		            // Extend labelLine emphasis
		            modelUtil.defaultEmphasis(option.labelLine, ['show']);

		            var labelLineNormalOpt = option.labelLine.normal;
		            var labelLineEmphasisOpt = option.labelLine.emphasis;
		            // Not show label line if `label.normal.show = false`
		            labelLineNormalOpt.show = labelLineNormalOpt.show
		                && option.label.normal.show;
		            labelLineEmphasisOpt.show = labelLineEmphasisOpt.show
		                && option.label.emphasis.show;
		        },

		        defaultOption: {
		            zlevel: 0,                  // 一级层叠
		            z: 2,                       // 二级层叠
		            legendHoverLink: true,
		            left: 80,
		            top: 60,
		            right: 80,
		            bottom: 60,
		            // width: {totalWidth} - left - right,
		            // height: {totalHeight} - top - bottom,

		            // 默认取数据最小最大值
		            // min: 0,
		            // max: 100,
		            minSize: '0%',
		            maxSize: '100%',
		            sort: 'descending', // 'ascending', 'descending'
		            gap: 0,
		            funnelAlign: 'center',
		            label: {
		                normal: {
		                    show: true,
		                    position: 'outer'
		                    // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
		                    // textStyle: null      // 默认使用全局文本样式，详见TEXTSTYLE
		                },
		                emphasis: {
		                    show: true
		                }
		            },
		            labelLine: {
		                normal: {
		                    show: true,
		                    length: 20,
		                    lineStyle: {
		                        // color: 各异,
		                        width: 1,
		                        type: 'solid'
		                    }
		                },
		                emphasis: {}
		            },
		            itemStyle: {
		                normal: {
		                    // color: 各异,
		                    borderColor: '#fff',
		                    borderWidth: 1
		                },
		                emphasis: {
		                    // color: 各异,
		                }
		            }
		        }
		    });

		    module.exports = FunnelSeries;


	/***/ },
	/* 223 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var graphic = __webpack_require__(43);
		    var zrUtil = __webpack_require__(4);

		    /**
		     * Piece of pie including Sector, Label, LabelLine
		     * @constructor
		     * @extends {module:zrender/graphic/Group}
		     */
		    function FunnelPiece(data, idx) {

		        graphic.Group.call(this);

		        var polygon = new graphic.Polygon();
		        var labelLine = new graphic.Polyline();
		        var text = new graphic.Text();
		        this.add(polygon);
		        this.add(labelLine);
		        this.add(text);

		        this.updateData(data, idx, true);

		        // Hover to change label and labelLine
		        function onEmphasis() {
		            labelLine.ignore = labelLine.hoverIgnore;
		            text.ignore = text.hoverIgnore;
		        }
		        function onNormal() {
		            labelLine.ignore = labelLine.normalIgnore;
		            text.ignore = text.normalIgnore;
		        }
		        this.on('emphasis', onEmphasis)
		            .on('normal', onNormal)
		            .on('mouseover', onEmphasis)
		            .on('mouseout', onNormal);
		    }

		    var funnelPieceProto = FunnelPiece.prototype;

		    function getLabelStyle(data, idx, state, labelModel) {
		        var textStyleModel = labelModel.getModel('textStyle');
		        var position = labelModel.get('position');
		        var isLabelInside = position === 'inside' || position === 'inner' || position === 'center';
		        return {
		            fill: textStyleModel.getTextColor()
		                || (isLabelInside ? '#fff' : data.getItemVisual(idx, 'color')),
		            textFont: textStyleModel.getFont(),
		            text: zrUtil.retrieve(
		                data.hostModel.getFormattedLabel(idx, state),
		                data.getName(idx)
		            )
		        };
		    }

		    var opacityAccessPath = ['itemStyle', 'normal', 'opacity'];
		    funnelPieceProto.updateData = function (data, idx, firstCreate) {

		        var polygon = this.childAt(0);

		        var seriesModel = data.hostModel;
		        var itemModel = data.getItemModel(idx);
		        var layout = data.getItemLayout(idx);
		        var opacity = data.getItemModel(idx).get(opacityAccessPath);
		        opacity = opacity == null ? 1 : opacity;

		        // Reset style
		        polygon.useStyle({});

		        if (firstCreate) {
		            polygon.setShape({
		                points: layout.points
		            });
		            polygon.setStyle({ opacity : 0 });
		            graphic.initProps(polygon, {
		                style: {
		                    opacity: opacity
		                }
		            }, seriesModel, idx);
		        }
		        else {
		            graphic.updateProps(polygon, {
		                style: {
		                    opacity: opacity
		                },
		                shape: {
		                    points: layout.points
		                }
		            }, seriesModel, idx);
		        }

		        // Update common style
		        var itemStyleModel = itemModel.getModel('itemStyle');
		        var visualColor = data.getItemVisual(idx, 'color');

		        polygon.setStyle(
		            zrUtil.defaults(
		                {
		                    lineJoin: 'round',
		                    fill: visualColor
		                },
		                itemStyleModel.getModel('normal').getItemStyle(['opacity'])
		            )
		        );
		        polygon.hoverStyle = itemStyleModel.getModel('emphasis').getItemStyle();

		        this._updateLabel(data, idx);

		        graphic.setHoverStyle(this);
		    };

		    funnelPieceProto._updateLabel = function (data, idx) {

		        var labelLine = this.childAt(1);
		        var labelText = this.childAt(2);

		        var seriesModel = data.hostModel;
		        var itemModel = data.getItemModel(idx);
		        var layout = data.getItemLayout(idx);
		        var labelLayout = layout.label;
		        var visualColor = data.getItemVisual(idx, 'color');

		        graphic.updateProps(labelLine, {
		            shape: {
		                points: labelLayout.linePoints || labelLayout.linePoints
		            }
		        }, seriesModel, idx);

		        graphic.updateProps(labelText, {
		            style: {
		                x: labelLayout.x,
		                y: labelLayout.y
		            }
		        }, seriesModel, idx);
		        labelText.attr({
		            style: {
		                textAlign: labelLayout.textAlign,
		                textVerticalAlign: labelLayout.verticalAlign,
		                textFont: labelLayout.font
		            },
		            rotation: labelLayout.rotation,
		            origin: [labelLayout.x, labelLayout.y],
		            z2: 10
		        });

		        var labelModel = itemModel.getModel('label.normal');
		        var labelHoverModel = itemModel.getModel('label.emphasis');
		        var labelLineModel = itemModel.getModel('labelLine.normal');
		        var labelLineHoverModel = itemModel.getModel('labelLine.emphasis');

		        labelText.setStyle(getLabelStyle(data, idx, 'normal', labelModel));

		        labelText.ignore = labelText.normalIgnore = !labelModel.get('show');
		        labelText.hoverIgnore = !labelHoverModel.get('show');

		        labelLine.ignore = labelLine.normalIgnore = !labelLineModel.get('show');
		        labelLine.hoverIgnore = !labelLineHoverModel.get('show');

		        // Default use item visual color
		        labelLine.setStyle({
		            stroke: visualColor
		        });
		        labelLine.setStyle(labelLineModel.getModel('lineStyle').getLineStyle());

		        labelText.hoverStyle = getLabelStyle(data, idx, 'emphasis', labelHoverModel);
		        labelLine.hoverStyle = labelLineHoverModel.getModel('lineStyle').getLineStyle();
		    };

		    zrUtil.inherits(FunnelPiece, graphic.Group);


		    var Funnel = __webpack_require__(42).extend({

		        type: 'funnel',

		        render: function (seriesModel, ecModel, api) {
		            var data = seriesModel.getData();
		            var oldData = this._data;

		            var group = this.group;

		            data.diff(oldData)
		                .add(function (idx) {
		                    var funnelPiece = new FunnelPiece(data, idx);

		                    data.setItemGraphicEl(idx, funnelPiece);

		                    group.add(funnelPiece);
		                })
		                .update(function (newIdx, oldIdx) {
		                    var piePiece = oldData.getItemGraphicEl(oldIdx);

		                    piePiece.updateData(data, newIdx);

		                    group.add(piePiece);
		                    data.setItemGraphicEl(newIdx, piePiece);
		                })
		                .remove(function (idx) {
		                    var piePiece = oldData.getItemGraphicEl(idx);
		                    group.remove(piePiece);
		                })
		                .execute();

		            this._data = data;
		        },

		        remove: function () {
		            this.group.removeAll();
		            this._data = null;
		        },

		        dispose: function () {}
		    });

		    module.exports = Funnel;


	/***/ },
	/* 224 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var layout = __webpack_require__(21);
		    var number = __webpack_require__(7);

		    var parsePercent = number.parsePercent;

		    function getViewRect(seriesModel, api) {
		        return layout.getLayoutRect(
		            seriesModel.getBoxLayoutParams(), {
		                width: api.getWidth(),
		                height: api.getHeight()
		            }
		        );
		    }

		    function getSortedIndices(data, sort) {
		        var valueArr = data.mapArray('value', function (val) {
		            return val;
		        });
		        var indices = [];
		        var isAscending = sort === 'ascending';
		        for (var i = 0, len = data.count(); i < len; i++) {
		            indices[i] = i;
		        }
		        indices.sort(function (a, b) {
		            return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a];
		        });
		        return indices;
		    }

		    function labelLayout (data) {
		        data.each(function (idx) {
		            var itemModel = data.getItemModel(idx);
		            var labelModel = itemModel.getModel('label.normal');
		            var labelPosition = labelModel.get('position');

		            var labelLineModel = itemModel.getModel('labelLine.normal');

		            var layout = data.getItemLayout(idx);
		            var points = layout.points;

		            var isLabelInside = labelPosition === 'inner'
		                || labelPosition === 'inside' || labelPosition === 'center';

		            var textAlign;
		            var textX;
		            var textY;
		            var linePoints;

		            if (isLabelInside) {
		                textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4;
		                textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4;
		                textAlign = 'center';
		                linePoints = [
		                    [textX, textY], [textX, textY]
		                ];
		            }
		            else {
		                var x1;
		                var y1;
		                var x2;
		                var labelLineLen = labelLineModel.get('length');
		                if (labelPosition === 'left') {
		                    // Left side
		                    x1 = (points[3][0] + points[0][0]) / 2;
		                    y1 = (points[3][1] + points[0][1]) / 2;
		                    x2 = x1 - labelLineLen;
		                    textX = x2 - 5;
		                    textAlign = 'right';
		                }
		                else {
		                    // Right side
		                    x1 = (points[1][0] + points[2][0]) / 2;
		                    y1 = (points[1][1] + points[2][1]) / 2;
		                    x2 = x1 + labelLineLen;
		                    textX = x2 + 5;
		                    textAlign = 'left';
		                }
		                var y2 = y1;

		                linePoints = [[x1, y1], [x2, y2]];
		                textY = y2;
		            }

		            layout.label = {
		                linePoints: linePoints,
		                x: textX,
		                y: textY,
		                verticalAlign: 'middle',
		                textAlign: textAlign,
		                inside: isLabelInside
		            };
		        });
		    }

		    module.exports = function (ecModel, api, payload) {
		        ecModel.eachSeriesByType('funnel', function (seriesModel) {
		            var data = seriesModel.getData();
		            var sort = seriesModel.get('sort');
		            var viewRect = getViewRect(seriesModel, api);
		            var indices = getSortedIndices(data, sort);

		            var sizeExtent = [
		                parsePercent(seriesModel.get('minSize'), viewRect.width),
		                parsePercent(seriesModel.get('maxSize'), viewRect.width)
		            ];
		            var dataExtent = data.getDataExtent('value');
		            var min = seriesModel.get('min');
		            var max = seriesModel.get('max');
		            if (min == null) {
		                min = Math.min(dataExtent[0], 0);
		            }
		            if (max == null) {
		                max = dataExtent[1];
		            }

		            var funnelAlign = seriesModel.get('funnelAlign');
		            var gap = seriesModel.get('gap');
		            var itemHeight = (viewRect.height - gap * (data.count() - 1)) / data.count();

		            var y = viewRect.y;

		            var getLinePoints = function (idx, offY) {
		                // End point index is data.count() and we assign it 0
		                var val = data.get('value', idx) || 0;
		                var itemWidth = number.linearMap(val, [min, max], sizeExtent, true);
		                var x0;
		                switch (funnelAlign) {
		                    case 'left':
		                        x0 = viewRect.x;
		                        break;
		                    case 'center':
		                        x0 = viewRect.x + (viewRect.width - itemWidth) / 2;
		                        break;
		                    case 'right':
		                        x0 = viewRect.x + viewRect.width - itemWidth;
		                        break;
		                }
		                return [
		                    [x0, offY],
		                    [x0 + itemWidth, offY]
		                ];
		            };

		            if (sort === 'ascending') {
		                // From bottom to top
		                itemHeight = -itemHeight;
		                gap = -gap;
		                y += viewRect.height;
		                indices = indices.reverse();
		            }

		            for (var i = 0; i < indices.length; i++) {
		                var idx = indices[i];
		                var nextIdx = indices[i + 1];
		                var start = getLinePoints(idx, y);
		                var end = getLinePoints(nextIdx, y + itemHeight);

		                y += itemHeight + gap;

		                data.setItemLayout(idx, {
		                    points: start.concat(end.slice().reverse())
		                });
		            }

		            labelLayout(data);
		        });
		    };


	/***/ },
	/* 225 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var echarts = __webpack_require__(1);

		    __webpack_require__(226);

		    __webpack_require__(237);
		    __webpack_require__(238);

		    echarts.registerVisual(__webpack_require__(239));



	/***/ },
	/* 226 */
	/***/ function(module, exports, __webpack_require__) {

		

		    __webpack_require__(227);
		    __webpack_require__(230);
		    __webpack_require__(232);

		    var echarts = __webpack_require__(1);
		    var zrUtil = __webpack_require__(4);

		    var CLICK_THRESHOLD = 5; // > 4

		    // Parallel view
		    echarts.extendComponentView({
		        type: 'parallel',

		        render: function (parallelModel, ecModel, api) {
		            var zr = api.getZr();

		            if (!this.__onMouseDown) {
		                // FIXME
		                // click: mousemove check. otherwise confilct with drag brush.
		                var mousedownPoint;
		                zr.on('mousedown', this.__onMouseDown = function (e) {
		                    mousedownPoint = [e.offsetX, e.offsetY];
		                });
		                zr.on('mouseup', this.__onMouseUp = function (e) {
		                    var point = [e.offsetX, e.offsetY];
		                    var dist = Math.pow(mousedownPoint[0] - point[0], 2)
		                        + Math.pow(mousedownPoint[1] - point[1], 2);

		                    if (!parallelModel.get('axisExpandable') || dist > CLICK_THRESHOLD) {
		                        return;
		                    }

		                    var coordSys = parallelModel.coordinateSystem;
		                    var closestDim = coordSys.findClosestAxisDim(point);
		                    if (closestDim) {
		                        var axisIndex = zrUtil.indexOf(coordSys.dimensions, closestDim);
		                        api.dispatchAction({
		                            type: 'parallelAxisExpand',
		                            axisExpandCenter: axisIndex
		                        });
		                    }
		                });
		            }
		        },

		        dispose: function (ecModel, api) {
		            api.getZr().off(this.__onMouseDown);
		            api.getZr().off(this.__onMouseUp);
		        }
		    });

		    echarts.registerPreprocessor(
		        __webpack_require__(236)
		    );



	/***/ },
	/* 227 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Parallel coordinate system creater.
		 */


		    var Parallel = __webpack_require__(228);

		    function create(ecModel, api) {
		        var coordSysList = [];

		        ecModel.eachComponent('parallel', function (parallelModel, idx) {
		            var coordSys = new Parallel(parallelModel, ecModel, api);

		            coordSys.name = 'parallel_' + idx;
		            coordSys.resize(parallelModel, api);

		            parallelModel.coordinateSystem = coordSys;
		            coordSys.model = parallelModel;

		            coordSysList.push(coordSys);
		        });

		        // Inject the coordinateSystems into seriesModel
		        ecModel.eachSeries(function (seriesModel) {
		            if (seriesModel.get('coordinateSystem') === 'parallel') {
		                var parallelModel = ecModel.queryComponents({
		                    mainType: 'parallel',
		                    index: seriesModel.get('parallelIndex'),
		                    id: seriesModel.get('parallelId')
		                })[0];
		                seriesModel.coordinateSystem = parallelModel.coordinateSystem;
		            }
		        });

		        return coordSysList;
		    }

		    __webpack_require__(26).register('parallel', {create: create});



	/***/ },
	/* 228 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Parallel Coordinates
		 * <https://en.wikipedia.org/wiki/Parallel_coordinates>
		 */


		    var layout = __webpack_require__(21);
		    var axisHelper = __webpack_require__(115);
		    var zrUtil = __webpack_require__(4);
		    var ParallelAxis = __webpack_require__(229);
		    var graphic = __webpack_require__(43);
		    var matrix = __webpack_require__(11);

		    var each = zrUtil.each;

		    var PI = Math.PI;

		    function Parallel(parallelModel, ecModel, api) {

		        /**
		         * key: dimension
		         * @type {Object.<string, module:echarts/coord/parallel/Axis>}
		         * @private
		         */
		        this._axesMap = {};

		        /**
		         * key: dimension
		         * value: {position: [], rotation, }
		         * @type {Object.<string, Object>}
		         * @private
		         */
		        this._axesLayout = {};

		        /**
		         * Always follow axis order.
		         * @type {Array.<string>}
		         * @readOnly
		         */
		        this.dimensions = parallelModel.dimensions;

		        /**
		         * @type {module:zrender/core/BoundingRect}
		         */
		        this._rect;

		        /**
		         * @type {module:echarts/coord/parallel/ParallelModel}
		         */
		        this._model = parallelModel;

		        this._init(parallelModel, ecModel, api);
		    }

		    Parallel.prototype = {

		        type: 'parallel',

		        constructor: Parallel,

		        /**
		         * Initialize cartesian coordinate systems
		         * @private
		         */
		        _init: function (parallelModel, ecModel, api) {

		            var dimensions = parallelModel.dimensions;
		            var parallelAxisIndex = parallelModel.parallelAxisIndex;

		            each(dimensions, function (dim, idx) {

		                var axisIndex = parallelAxisIndex[idx];
		                var axisModel = ecModel.getComponent('parallelAxis', axisIndex);

		                var axis = this._axesMap[dim] = new ParallelAxis(
		                    dim,
		                    axisHelper.createScaleByModel(axisModel),
		                    [0, 0],
		                    axisModel.get('type'),
		                    axisIndex
		                );

		                var isCategory = axis.type === 'category';
		                axis.onBand = isCategory && axisModel.get('boundaryGap');
		                axis.inverse = axisModel.get('inverse');

		                // Inject axis into axisModel
		                axisModel.axis = axis;

		                // Inject axisModel into axis
		                axis.model = axisModel;
		            }, this);
		        },

		        /**
		         * Update axis scale after data processed
		         * @param  {module:echarts/model/Global} ecModel
		         * @param  {module:echarts/ExtensionAPI} api
		         */
		        update: function (ecModel, api) {
		            this._updateAxesFromSeries(this._model, ecModel);
		        },

		        /**
		         * Update properties from series
		         * @private
		         */
		        _updateAxesFromSeries: function (parallelModel, ecModel) {
		            ecModel.eachSeries(function (seriesModel) {

		                if (!parallelModel.contains(seriesModel, ecModel)) {
		                    return;
		                }

		                var data = seriesModel.getData();

		                each(this.dimensions, function (dim) {
		                    var axis = this._axesMap[dim];
		                    axis.scale.unionExtent(data.getDataExtent(dim));
		                    axisHelper.niceScaleExtent(axis, axis.model);
		                }, this);
		            }, this);
		        },

		        /**
		         * Resize the parallel coordinate system.
		         * @param {module:echarts/coord/parallel/ParallelModel} parallelModel
		         * @param {module:echarts/ExtensionAPI} api
		         */
		        resize: function (parallelModel, api) {
		            this._rect = layout.getLayoutRect(
		                parallelModel.getBoxLayoutParams(),
		                {
		                    width: api.getWidth(),
		                    height: api.getHeight()
		                }
		            );

		            this._layoutAxes(parallelModel);
		        },

		        /**
		         * @return {module:zrender/core/BoundingRect}
		         */
		        getRect: function () {
		            return this._rect;
		        },

		        /**
		         * @private
		         */
		        _layoutAxes: function (parallelModel) {
		            var rect = this._rect;
		            var layout = parallelModel.get('layout');
		            var axes = this._axesMap;
		            var dimensions = this.dimensions;

		            var size = [rect.width, rect.height];
		            var sizeIdx = layout === 'horizontal' ? 0 : 1;
		            var layoutLength = size[sizeIdx];
		            var axisLength = size[1 - sizeIdx];
		            var axisExtent = [0, axisLength];

		            each(axes, function (axis) {
		                var idx = axis.inverse ? 1 : 0;
		                axis.setExtent(axisExtent[idx], axisExtent[1 - idx]);
		            });

		            var axisExpandable = parallelModel.get('axisExpandable');
		            var axisExpandWidth = parallelModel.get('axisExpandWidth');
		            var axisExpandCenter = parallelModel.get('axisExpandCenter');
		            var axisExpandCount = parallelModel.get('axisExpandCount') || 0;
		            var axisExpandWindow;

		            if (axisExpandCenter != null) {
		                // Clamp
		                var left = Math.max(0, Math.floor(axisExpandCenter - (axisExpandCount - 1) / 2));
		                var right = left + axisExpandCount - 1;
		                if (right >= dimensions.length) {
		                    right = dimensions.length - 1;
		                    left = Math.max(0, Math.floor(right - axisExpandCount + 1));
		                }
		                axisExpandWindow = [left, right];
		            }

		            var calcPos = (axisExpandable && axisExpandWindow && axisExpandWidth)
		                ? function (axisIndex, layoutLength, axisCount) {
		                    var peekIntervalCount = axisExpandWindow[1] - axisExpandWindow[0];
		                    var otherWidth = (
		                        layoutLength - axisExpandWidth * peekIntervalCount
		                    ) / (axisCount - 1 - peekIntervalCount);

		                    var position;

		                    if (axisIndex < axisExpandWindow[0]) {
		                        position = (axisIndex - 1) * otherWidth;
		                    }
		                    else if (axisIndex <= axisExpandWindow[1]) {
		                        position = axisExpandWindow[0] * otherWidth
		                            + (axisIndex - axisExpandWindow[0]) * axisExpandWidth;
		                    }
		                    else if (axisIndex === axisCount - 1) {
		                        position = layoutLength;
		                    }
		                    else {
		                        position = axisExpandWindow[0] * otherWidth
		                            + peekIntervalCount * axisExpandWidth
		                            + (axisIndex - axisExpandWindow[1]) * otherWidth;
		                    }

		                    return {
		                        position: position,
		                        axisNameAvailableWidth: (
		                            axisExpandWindow[0] < axisIndex && axisIndex < axisExpandWindow[1]
		                        ) ? axisExpandWidth : otherWidth
		                    };
		                }
		                : function (axisIndex, layoutLength, axisCount) {
		                    var step = layoutLength / (axisCount - 1);
		                    return {
		                        position: step * axisIndex,
		                        axisNameAvailableWidth: step
		                    };
		                };

		            each(dimensions, function (dim, idx) {
		                var posInfo = calcPos(idx, layoutLength, dimensions.length);

		                var positionTable = {
		                    horizontal: {
		                        x: posInfo.position,
		                        y: axisLength
		                    },
		                    vertical: {
		                        x: 0,
		                        y: posInfo.position
		                    }
		                };
		                var rotationTable = {
		                    horizontal: PI / 2,
		                    vertical: 0
		                };

		                var position = [
		                    positionTable[layout].x + rect.x,
		                    positionTable[layout].y + rect.y
		                ];

		                var rotation = rotationTable[layout];
		                var transform = matrix.create();
		                matrix.rotate(transform, transform, rotation);
		                matrix.translate(transform, transform, position);

		                // TODO
		                // tick等排布信息。

		                // TODO
		                // 根据axis order 更新 dimensions顺序。

		                this._axesLayout[dim] = {
		                    position: position,
		                    rotation: rotation,
		                    transform: transform,
		                    axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
		                    tickDirection: 1,
		                    labelDirection: 1,
		                    axisExpandWindow: axisExpandWindow
		                };
		            }, this);
		        },

		        /**
		         * Get axis by dim.
		         * @param {string} dim
		         * @return {module:echarts/coord/parallel/ParallelAxis} [description]
		         */
		        getAxis: function (dim) {
		            return this._axesMap[dim];
		        },

		        /**
		         * Convert a dim value of a single item of series data to Point.
		         * @param {*} value
		         * @param {string} dim
		         * @return {Array}
		         */
		        dataToPoint: function (value, dim) {
		            return this.axisCoordToPoint(
		                this._axesMap[dim].dataToCoord(value),
		                dim
		            );
		        },

		        /**
		         * Travel data for one time, get activeState of each data item.
		         * @param {module:echarts/data/List} data
		         * @param {Functio} cb param: {string} activeState 'active' or 'inactive' or 'normal'
		         *                            {number} dataIndex
		         * @param {Object} context
		         */
		        eachActiveState: function (data, callback, context) {
		            var dimensions = this.dimensions;
		            var axesMap = this._axesMap;
		            var hasActiveSet = this.hasAxisbrushed();

		            for (var i = 0, len = data.count(); i < len; i++) {
		                var values = data.getValues(dimensions, i);
		                var activeState;

		                if (!hasActiveSet) {
		                    activeState = 'normal';
		                }
		                else {
		                    activeState = 'active';
		                    for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
		                        var dimName = dimensions[j];
		                        var state = axesMap[dimName].model.getActiveState(values[j], j);

		                        if (state === 'inactive') {
		                            activeState = 'inactive';
		                            break;
		                        }
		                    }
		                }

		                callback.call(context, activeState, i);
		            }
		        },

		        /**
		         * Whether has any activeSet.
		         * @return {boolean}
		         */
		        hasAxisbrushed: function () {
		            var dimensions = this.dimensions;
		            var axesMap = this._axesMap;
		            var hasActiveSet = false;

		            for (var j = 0, lenj = dimensions.length; j < lenj; j++) {
		                if (axesMap[dimensions[j]].model.getActiveState() !== 'normal') {
		                    hasActiveSet = true;
		                }
		            }

		            return hasActiveSet;
		        },

		        /**
		         * Convert coords of each axis to Point.
		         *  Return point. For example: [10, 20]
		         * @param {Array.<number>} coords
		         * @param {string} dim
		         * @return {Array.<number>}
		         */
		        axisCoordToPoint: function (coord, dim) {
		            var axisLayout = this._axesLayout[dim];
		            return graphic.applyTransform([coord, 0], axisLayout.transform);
		        },

		        /**
		         * Get axis layout.
		         */
		        getAxisLayout: function (dim) {
		            return zrUtil.clone(this._axesLayout[dim]);
		        },

		        findClosestAxisDim: function (point) {
		            var axisDim;
		            var minDist = Infinity;

		            zrUtil.each(this._axesLayout, function (axisLayout, dim) {
		                var localPoint = graphic.applyTransform(point, axisLayout.transform, true);
		                var extent = this._axesMap[dim].getExtent();

		                if (localPoint[0] < extent[0] || localPoint[0] > extent[1]) {
		                    return;
		                }

		                var dist = Math.abs(localPoint[1]);
		                if (dist < minDist) {
		                    minDist = dist;
		                    axisDim = dim;
		                }
		            }, this);

		            return axisDim;
		        }

		    };

		    module.exports = Parallel;


	/***/ },
	/* 229 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var Axis = __webpack_require__(124);

		    /**
		     * @constructor module:echarts/coord/parallel/ParallelAxis
		     * @extends {module:echarts/coord/Axis}
		     * @param {string} dim
		     * @param {*} scale
		     * @param {Array.<number>} coordExtent
		     * @param {string} axisType
		     */
		    var ParallelAxis = function (dim, scale, coordExtent, axisType, axisIndex) {

		        Axis.call(this, dim, scale, coordExtent);

		        /**
		         * Axis type
		         *  - 'category'
		         *  - 'value'
		         *  - 'time'
		         *  - 'log'
		         * @type {string}
		         */
		        this.type = axisType || 'value';

		        /**
		         * @type {number}
		         * @readOnly
		         */
		        this.axisIndex = axisIndex;
		    };

		    ParallelAxis.prototype = {

		        constructor: ParallelAxis,

		        /**
		         * Axis model
		         * @param {module:echarts/coord/parallel/AxisModel}
		         */
		        model: null

		    };

		    zrUtil.inherits(ParallelAxis, Axis);

		    module.exports = ParallelAxis;


	/***/ },
	/* 230 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var Component = __webpack_require__(19);

		    __webpack_require__(231);

		    Component.extend({

		        type: 'parallel',

		        dependencies: ['parallelAxis'],

		        /**
		         * @type {module:echarts/coord/parallel/Parallel}
		         */
		        coordinateSystem: null,

		        /**
		         * Each item like: 'dim0', 'dim1', 'dim2', ...
		         * @type {Array.<string>}
		         * @readOnly
		         */
		        dimensions: null,

		        /**
		         * Coresponding to dimensions.
		         * @type {Array.<number>}
		         * @readOnly
		         */
		        parallelAxisIndex: null,

		        layoutMode: 'box',

		        defaultOption: {
		            zlevel: 0,
		            z: 0,
		            left: 80,
		            top: 60,
		            right: 80,
		            bottom: 60,
		            // width: {totalWidth} - left - right,
		            // height: {totalHeight} - top - bottom,

		            layout: 'horizontal',      // 'horizontal' or 'vertical'

		            // FIXME
		            // naming?
		            axisExpandable: false,
		            axisExpandCenter: null,
		            axisExpandCount: 0,
		            axisExpandWidth: 50,      // FIXME '10%' ?

		            parallelAxisDefault: null
		        },

		        /**
		         * @override
		         */
		        init: function () {
		            Component.prototype.init.apply(this, arguments);

		            this.mergeOption({});
		        },

		        /**
		         * @override
		         */
		        mergeOption: function (newOption) {
		            var thisOption = this.option;

		            newOption && zrUtil.merge(thisOption, newOption, true);

		            this._initDimensions();
		        },

		        /**
		         * Whether series or axis is in this coordinate system.
		         * @param {module:echarts/model/Series|module:echarts/coord/parallel/AxisModel} model
		         * @param {module:echarts/model/Global} ecModel
		         */
		        contains: function (model, ecModel) {
		            var parallelIndex = model.get('parallelIndex');
		            return parallelIndex != null
		                && ecModel.getComponent('parallel', parallelIndex) === this;
		        },

		        setAxisExpand: function (opt) {
		            zrUtil.each(
		                ['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth'],
		                function (name) {
		                    if (opt.hasOwnProperty(name)) {
		                        this.option[name] = opt[name];
		                    }
		                },
		                this
		            );
		        },

		        /**
		         * @private
		         */
		        _initDimensions: function () {
		            var dimensions = this.dimensions = [];
		            var parallelAxisIndex = this.parallelAxisIndex = [];

		            var axisModels = zrUtil.filter(this.dependentModels.parallelAxis, function (axisModel) {
		                // Can not use this.contains here, because
		                // initialization has not been completed yet.
		                return axisModel.get('parallelIndex') === this.componentIndex;
		            });

		            zrUtil.each(axisModels, function (axisModel) {
		                dimensions.push('dim' + axisModel.get('dim'));
		                parallelAxisIndex.push(axisModel.componentIndex);
		            });
		        }

		    });



	/***/ },
	/* 231 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var ComponentModel = __webpack_require__(19);
		    var zrUtil = __webpack_require__(4);
		    var makeStyleMapper = __webpack_require__(15);
		    var axisModelCreator = __webpack_require__(128);
		    var numberUtil = __webpack_require__(7);

		    var AxisModel = ComponentModel.extend({

		        type: 'baseParallelAxis',

		        /**
		         * @type {module:echarts/coord/parallel/Axis}
		         */
		        axis: null,

		        /**
		         * @type {Array.<Array.<number>}
		         * @readOnly
		         */
		        activeIntervals: [],

		        /**
		         * @return {Object}
		         */
		        getAreaSelectStyle: function () {
		            return makeStyleMapper(
		                [
		                    ['fill', 'color'],
		                    ['lineWidth', 'borderWidth'],
		                    ['stroke', 'borderColor'],
		                    ['width', 'width'],
		                    ['opacity', 'opacity']
		                ]
		            ).call(this.getModel('areaSelectStyle'));
		        },

		        /**
		         * The code of this feature is put on AxisModel but not ParallelAxis,
		         * because axisModel can be alive after echarts updating but instance of
		         * ParallelAxis having been disposed. this._activeInterval should be kept
		         * when action dispatched (i.e. legend click).
		         *
		         * @param {Array.<Array<number>>} intervals interval.length === 0
		         *                                          means set all active.
		         * @public
		         */
		        setActiveIntervals: function (intervals) {
		            var activeIntervals = this.activeIntervals = zrUtil.clone(intervals);

		            // Normalize
		            if (activeIntervals) {
		                for (var i = activeIntervals.length - 1; i >= 0; i--) {
		                    numberUtil.asc(activeIntervals[i]);
		                }
		            }
		        },

		        /**
		         * @param {number|string} [value] When attempting to detect 'no activeIntervals set',
		         *                         value can not be input.
		         * @return {string} 'normal': no activeIntervals set,
		         *                  'active',
		         *                  'inactive'.
		         * @public
		         */
		        getActiveState: function (value) {
		            var activeIntervals = this.activeIntervals;

		            if (!activeIntervals.length) {
		                return 'normal';
		            }

		            if (value == null) {
		                return 'inactive';
		            }

		            for (var i = 0, len = activeIntervals.length; i < len; i++) {
		                if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
		                    return 'active';
		                }
		            }
		            return 'inactive';
		        }

		    });

		    var defaultOption = {

		        type: 'value',

		        /**
		         * @type {Array.<number>}
		         */
		        dim: null, // 0, 1, 2, ...

		        // parallelIndex: null,

		        areaSelectStyle: {
		            width: 20,
		            borderWidth: 1,
		            borderColor: 'rgba(160,197,232)',
		            color: 'rgba(160,197,232)',
		            opacity: 0.3
		        },

		        realtime: true, // Whether realtime update view when select.

		        z: 10
		    };

		    zrUtil.merge(AxisModel.prototype, __webpack_require__(130));

		    function getAxisType(axisName, option) {
		        return option.type || (option.data ? 'category' : 'value');
		    }

		    axisModelCreator('parallel', AxisModel, getAxisType, defaultOption);

		    module.exports = AxisModel;


	/***/ },
	/* 232 */
	/***/ function(module, exports, __webpack_require__) {

		

		    __webpack_require__(227);
		    __webpack_require__(233);
		    __webpack_require__(234);



	/***/ },
	/* 233 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var echarts = __webpack_require__(1);

		    /**
		     * @payload
		     * @property {string} parallelAxisId
		     * @property {Array.<Array.<number>>} intervals
		     */
		    var actionInfo = {
		        type: 'axisAreaSelect',
		        event: 'axisAreaSelected',
		        update: 'updateVisual'
		    };
		    echarts.registerAction(actionInfo, function (payload, ecModel) {
		        ecModel.eachComponent(
		            {mainType: 'parallelAxis', query: payload},
		            function (parallelAxisModel) {
		                parallelAxisModel.axis.model.setActiveIntervals(payload.intervals);
		            }
		        );
		    });

		    /**
		     * @payload
		     */
		    echarts.registerAction('parallelAxisExpand', function (payload, ecModel) {
		        ecModel.eachComponent(
		            {mainType: 'parallel', query: payload},
		            function (parallelModel) {
		                parallelModel.setAxisExpand(payload);
		            }
		        );

		    });


	/***/ },
	/* 234 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var AxisBuilder = __webpack_require__(134);
		    var BrushController = __webpack_require__(235);
		    var graphic = __webpack_require__(43);

		    var elementList = ['axisLine', 'axisLabel', 'axisTick', 'axisName'];

		    var AxisView = __webpack_require__(1).extendComponentView({

		        type: 'parallelAxis',

		        /**
		         * @override
		         */
		        init: function (ecModel, api) {
		            AxisView.superApply(this, 'init', arguments);

		            /**
		             * @type {module:echarts/component/helper/BrushController}
		             */
		            (this._brushController = new BrushController(api.getZr()))
		                .on('brush', zrUtil.bind(this._onBrush, this));
		        },

		        /**
		         * @override
		         */
		        render: function (axisModel, ecModel, api, payload) {
		            if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
		                return;
		            }

		            this.axisModel = axisModel;
		            this.api = api;

		            this.group.removeAll();

		            var oldAxisGroup = this._axisGroup;
		            this._axisGroup = new graphic.Group();
		            this.group.add(this._axisGroup);

		            if (!axisModel.get('show')) {
		                return;
		            }

		            var coordSys = ecModel.getComponent(
		                'parallel', axisModel.get('parallelIndex')
		            ).coordinateSystem;

		            var areaSelectStyle = axisModel.getAreaSelectStyle();
		            var areaWidth = areaSelectStyle.width;

		            var dim = axisModel.axis.dim;
		            var axisLayout = coordSys.getAxisLayout(dim);

		            // Fetch from axisModel by default.
		            var axisLabelShow;
		            var axisIndex = zrUtil.indexOf(coordSys.dimensions, dim);

		            var axisExpandWindow = axisLayout.axisExpandWindow;
		            if (axisExpandWindow
		                && (axisIndex <= axisExpandWindow[0] || axisIndex >= axisExpandWindow[1])
		            ) {
		                axisLabelShow = false;
		            }

		            var builderOpt = zrUtil.extend(
		                {
		                    axisLabelShow: axisLabelShow,
		                    strokeContainThreshold: areaWidth
		                },
		                axisLayout
		            );

		            var axisBuilder = new AxisBuilder(axisModel, builderOpt);

		            zrUtil.each(elementList, axisBuilder.add, axisBuilder);

		            this._axisGroup.add(axisBuilder.getGroup());

		            this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, areaWidth);

		            graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);
		        },

		        _refreshBrushController: function (builderOpt, areaSelectStyle, axisModel, areaWidth) {
		            // After filtering, axis may change, select area needs to be update.
		            var axis = axisModel.axis;
		            var coverInfoList = zrUtil.map(axisModel.activeIntervals, function (interval) {
		                return {
		                    brushType: 'lineX',
		                    panelId: 'pl',
		                    range: [
		                        axis.dataToCoord(interval[0], true),
		                        axis.dataToCoord(interval[1], true)
		                    ]
		                };
		            });

		            var extent = axis.getExtent();
		            var extentLen = extent[1] - extent[0];
		            var extra = Math.min(30, Math.abs(extentLen) * 0.1); // Arbitrary value.

		            // width/height might be negative, which will be
		            // normalized in BoundingRect.
		            var rect = graphic.BoundingRect.create({
		                x: extent[0],
		                y: -areaWidth / 2,
		                width: extentLen,
		                height: areaWidth
		            });
		            rect.x -= extra;
		            rect.width += 2 * extra;

		            this._brushController
		                .mount({
		                    enableGlobalPan: true,
		                    rotation: builderOpt.rotation,
		                    position: builderOpt.position
		                })
		                .setPanels([{
		                    panelId: 'pl',
		                    rect: rect
		                }])
		                .enableBrush({
		                    brushType: 'lineX',
		                    brushStyle: areaSelectStyle,
		                    removeOnClick: true
		                })
		                .updateCovers(coverInfoList);
		        },

		        _onBrush: function (coverInfoList, opt) {
		            // Do not cache these object, because the mey be changed.
		            var axisModel = this.axisModel;
		            var axis = axisModel.axis;

		            var intervals = zrUtil.map(coverInfoList, function (coverInfo) {
		                return [
		                    axis.coordToData(coverInfo.range[0], true),
		                    axis.coordToData(coverInfo.range[1], true)
		                ];
		            });

		            // If realtime is true, action is not dispatched on drag end, because
		            // the drag end emits the same params with the last drag move event,
		            // and may have some delay when using touch pad.
		            if (!axisModel.option.realtime === opt.isEnd || opt.removeOnClick) { // jshint ignore:line
		                this.api.dispatchAction({
		                    type: 'axisAreaSelect',
		                    parallelAxisId: axisModel.id,
		                    intervals: intervals
		                });
		            }
		        },

		        /**
		         * @override
		         */
		        dispose: function () {
		            this._brushController.dispose();
		        }
		    });

		    function fromAxisAreaSelect(axisModel, ecModel, payload) {
		        return payload
		            && payload.type === 'axisAreaSelect'
		            && ecModel.findComponents(
		                {mainType: 'parallelAxis', query: payload}
		            )[0] === axisModel;
		    }

		    module.exports = AxisView;


	/***/ },
	/* 235 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * Box selection tool.
		 *
		 * @module echarts/component/helper/BrushController
		 */



		    var Eventful = __webpack_require__(33);
		    var zrUtil = __webpack_require__(4);
		    var BoundingRect = __webpack_require__(9);
		    var graphic = __webpack_require__(43);
		    var interactionMutex = __webpack_require__(177);
		    var DataDiffer = __webpack_require__(99);

		    var curry = zrUtil.curry;
		    var each = zrUtil.each;
		    var map = zrUtil.map;
		    var mathMin = Math.min;
		    var mathMax = Math.max;
		    var mathPow = Math.pow;

		    var COVER_Z = 10000;
		    var UNSELECT_THRESHOLD = 6;
		    var MIN_RESIZE_LINE_WIDTH = 6;
		    var MUTEX_RESOURCE_KEY = 'globalPan';

		    var DIRECTION_MAP = {
		        w: [0, 0],
		        e: [0, 1],
		        n: [1, 0],
		        s: [1, 1]
		    };
		    var CURSOR_MAP = {
		        w: 'ew',
		        e: 'ew',
		        n: 'ns',
		        s: 'ns',
		        ne: 'nesw',
		        sw: 'nesw',
		        nw: 'nwse',
		        se: 'nwse'
		    };
		    var DEFAULT_BRUSH_OPT = {
		        brushStyle: {
		            lineWidth: 2,
		            stroke: 'rgba(0,0,0,0.3)',
		            fill: 'rgba(0,0,0,0.1)'
		        },
		        transformable: true,
		        brushMode: 'single',
		        removeOnClick: false
		    };

		    var baseUID = 0;

		    /**
		     * @alias module:echarts/component/helper/BrushController
		     * @constructor
		     * @mixin {module:zrender/mixin/Eventful}
		     * @event module:echarts/component/helper/BrushController#brush
		     *        params:
		     *            areas: Array.<Array>, coord relates to container group,
		     *                                    If no container specified, to global.
		     *            opt {
		     *                isEnd: boolean,
		     *                removeOnClick: boolean
		     *            }
		     *
		     * @param {module:zrender/zrender~ZRender} zr
		     */
		    function BrushController(zr) {

		        if (true) {
		            zrUtil.assert(zr);
		        }

		        Eventful.call(this);

		        /**
		         * @type {module:zrender/zrender~ZRender}
		         * @private
		         */
		        this._zr = zr;

		        /**
		         * @type {module:zrender/container/Group}
		         * @readOnly
		         */
		        this.group = new graphic.Group();

		        /**
		         * Only for drawing (after enabledBrush).
		         * @private
		         * @type {string}
		         */
		        this._brushType;

		        /**
		         * Only for drawing (after enabledBrush).
		         * @private
		         * @type {Object}
		         */
		        this._brushOption;

		        /**
		         * @private
		         * @type {Object}
		         */
		        this._panels;

		        /**
		         * @private
		         * @type {Array.<nubmer>}
		         */
		        this._track = [];

		        /**
		         * @private
		         * @type {boolean}
		         */
		        this._dragging;

		        /**
		         * @private
		         * @type {Array}
		         */
		        this._covers = [];

		        /**
		         * @private
		         * @type {moudule:zrender/container/Group}
		         */
		        this._creatingCover;

		        /**
		         * true means global panel
		         * @private
		         * @type {module:zrender/container/Group|boolean}
		         */
		        this._creatingPanel;

		        /**
		         * @private
		         * @type {boolean}
		         */
		        this._enableGlobalPan;

		        /**
		         * @private
		         * @type {boolean}
		         */
		        if (true) {
		            this._mounted;
		        }

		        /**
		         * @private
		         * @type {string}
		         */
		        this._uid = 'brushController_' + baseUID++;

		        /**
		         * @private
		         * @type {Object}
		         */
		        this._handlers = {};
		        each(mouseHandlers, function (handler, eventName) {
		            this._handlers[eventName] = zrUtil.bind(handler, this);
		        }, this);
		    }

		    BrushController.prototype = {

		        constructor: BrushController,

		        /**
		         * If set to null/undefined/false, select disabled.
		         * @param {Object} brushOption
		         * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false
		         *                          If pass false/null/undefined, disable brush.
		         * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'
		         * @param {boolean} [brushOption.transformable=true]
		         * @param {boolean} [brushOption.removeOnClick=false]
		         * @param {Object} [brushOption.brushStyle]
		         * @param {number} [brushOption.brushStyle.width]
		         * @param {number} [brushOption.brushStyle.lineWidth]
		         * @param {string} [brushOption.brushStyle.stroke]
		         * @param {string} [brushOption.brushStyle.fill]
		         */
		        enableBrush: function (brushOption) {
		            if (true) {
		                zrUtil.assert(this._mounted);
		            }

		            this._brushType && doDisableBrush(this);
		            brushOption.brushType && doEnableBrush(this, brushOption);

		            return this;
		        },

		        /**
		         * @param {Array.<Object>} panelOpts If not pass, it is global brush.
		         *        Each items: {panelId, rect}
		         */
		        setPanels: function (panelOpts) {
		            var oldPanels = this._panels || {};
		            var newPanels = this._panels = panelOpts && panelOpts.length && {};
		            var thisGroup = this.group;

		            newPanels && each(panelOpts, function (panelOpt) {
		                var panelId = panelOpt.panelId;
		                var panel = oldPanels[panelId];
		                if (!panel) {
		                    panel = new graphic.Rect({
		                        silent: true,
		                        invisible: true
		                    });
		                    thisGroup.add(panel);
		                }

		                var rect = panelOpt.rect;
		                // Using BoundingRect to normalize negative width/height.
		                if (!(rect instanceof BoundingRect)) {
		                    rect = BoundingRect.create(rect);
		                }

		                panel.attr('shape', rect.plain());
		                panel.__brushPanelId = panelId;
		                newPanels[panelId] = panel;
		                oldPanels[panelId] = null;
		            });

		            each(oldPanels, function (panel) {
		                panel && thisGroup.remove(panel);
		            });

		            return this;
		        },

		        /**
		         * @param {Object} [opt]
		         * @return {boolean} [opt.enableGlobalPan=false]
		         * @return {boolean} [opt.position=[0, 0]]
		         * @return {boolean} [opt.rotation=0]
		         * @return {boolean} [opt.scale=[1, 1]]
		         */
		        mount: function (opt) {
		            opt = opt || {};

		            if (true) {
		                this._mounted = true; // should be at first.
		            }

		            this._enableGlobalPan = opt.enableGlobalPan;

		            var thisGroup = this.group;
		            this._zr.add(thisGroup);

		            thisGroup.attr({
		                position: opt.position || [0, 0],
		                rotation: opt.rotation || 0,
		                scale: opt.scale || [1, 1]
		            });

		            return this;
		        },

		        eachCover: function (cb, context) {
		            each(this._covers, cb, context);
		        },

		        /**
		         * Update covers.
		         * @param {Array.<Object>} brushOptionList Like:
		         *        [
		         *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},
		         *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},
		         *            ...
		         *        ]
		         *        `brushType` is required in each cover info.
		         *        `id` is not mandatory.
		         *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.
		         *        If brushOptionList is null/undefined, all covers removed.
		         */
		        updateCovers: function (brushOptionList) {
		            if (true) {
		                zrUtil.assert(this._mounted);
		            }

		            brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {
		                return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
		            });

		            var tmpIdPrefix = '\0-brush-index-';
		            var oldCovers = this._covers;
		            var newCovers = this._covers = [];
		            var controller = this;
		            var creatingCover = this._creatingCover;

		            (new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey))
		                .add(addOrUpdate)
		                .update(addOrUpdate)
		                .remove(remove)
		                .execute();

		            return this;

		            function getKey(brushOption, index) {
		                return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index)
		                    + '-' + brushOption.brushType;
		            }

		            function oldGetKey(cover, index) {
		                return getKey(cover.__brushOption, index);
		            }

		            function addOrUpdate(newIndex, oldIndex) {
		                var newBrushOption = brushOptionList[newIndex];
		                // Consider setOption in event listener of brushSelect,
		                // where updating cover when creating should be forbiden.
		                if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
		                    newCovers[newIndex] = oldCovers[oldIndex];
		                }
		                else {
		                    var cover = newCovers[newIndex] = oldIndex != null
		                        ? (
		                            oldCovers[oldIndex].__brushOption = newBrushOption,
		                            oldCovers[oldIndex]
		                        )
		                        : endCreating(controller, createCover(controller, newBrushOption));
		                    updateCoverAfterCreation(controller, cover);
		                }
		            }

		            function remove(oldIndex) {
		                if (oldCovers[oldIndex] !== creatingCover) {
		                    controller.group.remove(oldCovers[oldIndex]);
		                }
		            }
		        },

		        unmount: function () {
		            this.enableBrush(false);

		            // container may 'removeAll' outside.
		            clearCovers(this);
		            this._zr.remove(this.group);

		            if (true) {
		                this._mounted = false; // should be at last.
		            }

		            return this;
		        },

		        dispose: function () {
		            this.unmount();
		            this.off();
		        }
		    };

		    zrUtil.mixin(BrushController, Eventful);


		    function doEnableBrush(controller, brushOption) {
		        var zr = controller._zr;

		        // Consider roam, which takes globalPan too.
		        if (!controller._enableGlobalPan) {
		            interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);
		        }

		        each(controller._handlers, function (handler, eventName) {
		            zr.on(eventName, handler);
		        });

		        controller._brushType = brushOption.brushType;
		        controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);
		    }

		    function doDisableBrush(controller) {
		        var zr = controller._zr;

		        interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);

		        each(controller._handlers, function (handler, eventName) {
		            zr.off(eventName, handler);
		        });

		        controller._brushType = controller._brushOption = null;
		    }

		    function createCover(controller, brushOption) {
		        var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);
		        updateZ(cover);
		        cover.__brushOption = brushOption;
		        controller.group.add(cover);
		        return cover;
		    }

		    function endCreating(controller, creatingCover) {
		        var coverRenderer = getCoverRenderer(creatingCover);
		        if (coverRenderer.endCreating) {
		            coverRenderer.endCreating(controller, creatingCover);
		            updateZ(creatingCover);
		        }
		        return creatingCover;
		    }

		    function updateCoverShape(controller, cover) {
		        var brushOption = cover.__brushOption;
		        getCoverRenderer(cover).updateCoverShape(
		            controller, cover, brushOption.range, brushOption
		        );
		    }

		    function updateZ(group) {
		        group.traverse(function (el) {
		            el.z = COVER_Z;
		            el.z2 = COVER_Z; // Consider in given container.
		        });
		    }

		    function updateCoverAfterCreation(controller, cover) {
		        getCoverRenderer(cover).updateCommon(controller, cover);
		        updateCoverShape(controller, cover);
		    }

		    function getCoverRenderer(cover) {
		        return coverRenderers[cover.__brushOption.brushType];
		    }

		    function getPanelByPoint(controller, x, y) {
		        var panels = controller._panels;
		        if (!panels) {
		            return true; // Global panel
		        }
		        var panel;
		        each(panels, function (pn) {
		            pn.contain(x, y) && (panel = pn);
		        });
		        return panel;
		    }

		    function getPanelByCover(controller, cover) {
		        var panels = controller._panels;
		        if (!panels) {
		            return true; // Global panel
		        }
		        var panelId = cover.__brushOption.panelId;
		        // User may give cover without coord sys info,
		        // which is then treated as global panel.
		        return panelId != null ? panels[panelId] : true;
		    }

		    function clearCovers(controller) {
		        var covers = controller._covers;
		        var originalLength = covers.length;
		        each(covers, function (cover) {
		            controller.group.remove(cover);
		        }, controller);
		        covers.length = 0;

		        return !!originalLength;
		    }

		    function trigger(controller, opt) {
		        var areas = map(controller._covers, function (cover) {
		            var brushOption = cover.__brushOption;
		            var range = zrUtil.clone(brushOption.range);

		            return {
		                brushType: brushOption.brushType,
		                panelId: brushOption.panelId,
		                range: range
		            };
		        });

		        controller.trigger('brush', areas, {
		            isEnd: !!opt.isEnd,
		            removeOnClick: !!opt.removeOnClick
		        });
		    }

		    function shouldShowCover(controller) {
		        var track = controller._track;

		        if (!track.length) {
		            return false;
		        }

		        var p2 = track[track.length - 1];
		        var p1 = track[0];
		        var dx = p2[0] - p1[0];
		        var dy = p2[1] - p1[1];
		        var dist = mathPow(dx * dx + dy * dy, 0.5);

		        return dist > UNSELECT_THRESHOLD;
		    }

		    function getTrackEnds(track) {
		        var tail = track.length - 1;
		        tail < 0 && (tail = 0);
		        return [track[0], track[tail]];
		    }

		    function createBaseRectCover(doDrift, controller, brushOption, edgeNames) {
		        var cover = new graphic.Group();

		        cover.add(new graphic.Rect({
		            name: 'main',
		            style: makeStyle(brushOption),
		            silent: true,
		            draggable: true,
		            cursor: 'move',
		            drift: curry(doDrift, controller, cover, 'nswe'),
		            ondragend: curry(trigger, controller, {isEnd: true})
		        }));

		        each(
		            edgeNames,
		            function (name) {
		                cover.add(new graphic.Rect({
		                    name: name,
		                    style: {opacity: 0},
		                    draggable: true,
		                    silent: true,
		                    invisible: true,
		                    drift: curry(doDrift, controller, cover, name),
		                    ondragend: curry(trigger, controller, {isEnd: true})
		                }));
		            }
		        );

		        return cover;
		    }

		    function updateBaseRect(controller, cover, localRange, brushOption) {
		        var lineWidth = brushOption.brushStyle.lineWidth || 0;
		        var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);
		        var x = localRange[0][0];
		        var y = localRange[1][0];
		        var xa = x - lineWidth / 2;
		        var ya = y - lineWidth / 2;
		        var x2 = localRange[0][1];
		        var y2 = localRange[1][1];
		        var x2a = x2 - handleSize + lineWidth / 2;
		        var y2a = y2 - handleSize + lineWidth / 2;
		        var width = x2 - x;
		        var height = y2 - y;
		        var widtha = width + lineWidth;
		        var heighta = height + lineWidth;

		        updateRectShape(controller, cover, 'main', x, y, width, height);

		        if (brushOption.transformable) {
		            updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);
		            updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);
		            updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);
		            updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);

		            updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);
		            updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);
		            updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);
		            updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);
		        }
		    }

		    function updateCommon(controller, cover) {
		        var brushOption = cover.__brushOption;
		        var transformable = brushOption.transformable;

		        var mainEl = cover.childAt(0);
		        mainEl.useStyle(makeStyle(brushOption));
		        mainEl.attr({
		            silent: !transformable,
		            cursor: transformable ? 'move' : 'default'
		        });

		        each(
		            ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'],
		            function (name) {
		                var el = cover.childOfName(name);
		                var globalDir = getGlobalDirection(controller, name);

		                el && el.attr({
		                    silent: !transformable,
		                    invisible: !transformable,
		                    cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null
		                });
		            }
		        );
		    }

		    function updateRectShape(controller, cover, name, x, y, w, h) {
		        var el = cover.childOfName(name);
		        el && el.setShape(pointsToRect(
		            clipByPanel(controller, cover, [[x, y], [x + w, y + h]])
		        ));
		    }

		    function makeStyle(brushOption) {
		        return zrUtil.defaults({strokeNoScale: true}, brushOption.brushStyle);
		    }

		    function formatRectRange(x, y, x2, y2) {
		        var min = [mathMin(x, x2), mathMin(y, y2)];
		        var max = [mathMax(x, x2), mathMax(y, y2)];

		        return [
		            [min[0], max[0]], // x range
		            [min[1], max[1]] // y range
		        ];
		    }

		    function getTransform(controller) {
		        return graphic.getTransform(controller.group);
		    }

		    function getGlobalDirection(controller, localDirection) {
		        if (localDirection.length > 1) {
		            localDirection = localDirection.split('');
		            var globalDir = [
		                getGlobalDirection(controller, localDirection[0]),
		                getGlobalDirection(controller, localDirection[1])
		            ];
		            (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();
		            return globalDir.join('');
		        }
		        else {
		            var map = {w: 'left', e: 'right', n: 'top', s: 'bottom'};
		            var inverseMap = {left: 'w', right: 'e', top: 'n', bottom: 's'};
		            var globalDir = graphic.transformDirection(
		                map[localDirection], getTransform(controller)
		            );
		            return inverseMap[globalDir];
		        }
		    }

		    function driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {
		        var brushOption = cover.__brushOption;
		        var rectRange = toRectRange(brushOption.range);
		        var localDelta = toLocalDelta(controller, dx, dy);

		        each(name.split(''), function (namePart) {
		            var ind = DIRECTION_MAP[namePart];
		            rectRange[ind[0]][ind[1]] += localDelta[ind[0]];
		        });

		        brushOption.range = fromRectRange(formatRectRange(
		            rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]
		        ));

		        updateCoverAfterCreation(controller, cover);
		        trigger(controller, {isEnd: false});
		    }

		    function driftPolygon(controller, cover, dx, dy, e) {
		        var range = cover.__brushOption.range;
		        var localDelta = toLocalDelta(controller, dx, dy);

		        each(range, function (point) {
		            point[0] += localDelta[0];
		            point[1] += localDelta[1];
		        });

		        updateCoverAfterCreation(controller, cover);
		        trigger(controller, {isEnd: false});
		    }

		    function toLocalDelta(controller, dx, dy) {
		        var thisGroup = controller.group;
		        var localD = thisGroup.transformCoordToLocal(dx, dy);
		        var localZero = thisGroup.transformCoordToLocal(0, 0);

		        return [localD[0] - localZero[0], localD[1] - localZero[1]];
		    }

		    function clipByPanel(controller, cover, data) {
		        var panel = getPanelByCover(controller, cover);
		        if (panel === true) { // Global panel
		            return zrUtil.clone(data);
		        }

		        var panelRect = panel.getBoundingRect();

		        return zrUtil.map(data, function (point) {
		            var x = point[0];
		            x = mathMax(x, panelRect.x);
		            x = mathMin(x, panelRect.x + panelRect.width);
		            var y = point[1];
		            y = mathMax(y, panelRect.y);
		            y = mathMin(y, panelRect.y + panelRect.height);
		            return [x, y];
		        });
		    }

		    function pointsToRect(points) {
		        var xmin = mathMin(points[0][0], points[1][0]);
		        var ymin = mathMin(points[0][1], points[1][1]);
		        var xmax = mathMax(points[0][0], points[1][0]);
		        var ymax = mathMax(points[0][1], points[1][1]);

		        return {
		            x: xmin,
		            y: ymin,
		            width: xmax - xmin,
		            height: ymax - ymin
		        };
		    }

		    function resetCursor(controller, e) {
		        var x = e.offsetX;
		        var y = e.offsetY;
		        var zr = controller._zr;

		        if (controller._brushType) { // If active
		            var panels = controller._panels;
		            var covers = controller._covers;
		            var inCover;

		            for (var i = 0; i < covers.length; i++) {
		                if (coverRenderers[covers[i].__brushOption.brushType].contain(covers[i], x, y)) {
		                    inCover = true;
		                    break;
		                }
		            }

		            if (!inCover) {
		                if (panels) { // Brush on panels
		                    each(panels, function (panel) {
		                        panel.contain(x, y) && zr.setCursorStyle('crosshair');
		                    });
		                }
		                else { // Global brush
		                    zr.setCursorStyle('crosshair');
		                }
		            }
		        }
		    }

		    function preventDefault(e) {
		        var rawE = e.event;
		        rawE.preventDefault && rawE.preventDefault();
		    }

		    function mainShapeContain(cover, x, y) {
		        return cover.childOfName('main').contain(x, y);
		    }

		    function updateCoverByMouse(controller, e, isEnd) {
		        var x = e.offsetX;
		        var y = e.offsetY;
		        var creatingCover = controller._creatingCover;
		        var panel = controller._creatingPanel;
		        var thisBrushOption = controller._brushOption;
		        var eventParams;

		        controller._track.push(controller.group.transformCoordToLocal(x, y));

		        if (shouldShowCover(controller) || creatingCover) {

		            if (panel && !creatingCover) {
		                thisBrushOption.brushMode === 'single' && clearCovers(controller);
		                var brushOption = zrUtil.clone(thisBrushOption);
		                brushOption.panelId = panel === true ? null : panel.__brushPanelId;
		                creatingCover = controller._creatingCover = createCover(controller, brushOption);
		                controller._covers.push(creatingCover);
		            }

		            if (creatingCover) {
		                var coverRenderer = coverRenderers[controller._brushType];
		                var coverBrushOption = creatingCover.__brushOption;

		                coverBrushOption.range = coverRenderer.getCreatingRange(
		                    clipByPanel(controller, creatingCover, controller._track)
		                );

		                if (isEnd) {
		                    endCreating(controller, creatingCover);
		                    coverRenderer.updateCommon(controller, creatingCover);
		                }

		                updateCoverShape(controller, creatingCover);

		                eventParams = {isEnd: isEnd};
		            }
		        }
		        else if (
		            isEnd
		            && thisBrushOption.brushMode === 'single'
		            && thisBrushOption.removeOnClick
		        ) {
		            // Help user to remove covers easily, only by a tiny drag, in 'single' mode.
		            // But a single click do not clear covers, because user may have casual
		            // clicks (for example, click on other component and do not expect covers
		            // disappear).
		            // Only some cover removed, trigger action, but not every click trigger action.
		            if (getPanelByPoint(controller, x, y) && clearCovers(controller)) {
		                eventParams = {isEnd: isEnd, removeOnClick: true};
		            }
		        }

		        return eventParams;
		    }

		    var mouseHandlers = {

		        mousedown: function (e) {
		            if (this._dragging) {
		                // In case some browser do not support globalOut,
		                // and release mose out side the browser.
		                handleDragEnd.call(this, e);
		            }
		            else if (!e.target || !e.target.draggable) {

		                preventDefault(e);

		                var x = e.offsetX;
		                var y = e.offsetY;

		                this._creatingCover = null;
		                var panel = this._creatingPanel = getPanelByPoint(this, x, y);

		                if (panel) {
		                    this._dragging = true;
		                    this._track = [this.group.transformCoordToLocal(x, y)];
		                }
		            }
		        },

		        mousemove: function (e) {
		            // set Cursor
		            resetCursor(this, e);

		            if (this._dragging) {

		                preventDefault(e);

		                var eventParams = updateCoverByMouse(this, e, false);

		                eventParams && trigger(this, eventParams);
		            }
		        },

		        mouseup: handleDragEnd //,

		        // FIXME
		        // in tooltip, globalout should not be triggered.
		        // globalout: handleDragEnd
		    };

		    function handleDragEnd(e) {
		        if (this._dragging) {

		            preventDefault(e);

		            var eventParams = updateCoverByMouse(this, e, true);

		            this._dragging = false;
		            this._track = [];
		            this._creatingCover = null;

		            // trigger event shoule be at final, after procedure will be nested.
		            eventParams && trigger(this, eventParams);
		        }
		    }

		    /**
		     * key: brushType
		     * @type {Object}
		     */
		    var coverRenderers = {

		        lineX: getLineRenderer(0),

		        lineY: getLineRenderer(1),

		        rect: {
		            createCover: function (controller, brushOption) {
		                return createBaseRectCover(
		                    curry(
		                        driftRect,
		                        function (range) {
		                            return range;
		                        },
		                        function (range) {
		                            return range;
		                        }
		                    ),
		                    controller,
		                    brushOption,
		                    ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']
		                );
		            },
		            getCreatingRange: function (localTrack) {
		                var ends = getTrackEnds(localTrack);
		                return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);
		            },
		            updateCoverShape: function (controller, cover, localRange, brushOption) {
		                updateBaseRect(controller, cover, localRange, brushOption);
		            },
		            updateCommon: updateCommon,
		            contain: mainShapeContain
		        },

		        polygon: {
		            createCover: function (controller, brushOption) {
		                var cover = new graphic.Group();

		                // Do not use graphic.Polygon because graphic.Polyline do not close the
		                // border of the shape when drawing, which is a better experience for user.
		                cover.add(new graphic.Polyline({
		                    name: 'main',
		                    style: makeStyle(brushOption),
		                    silent: true
		                }));

		                return cover;
		            },
		            getCreatingRange: function (localTrack) {
		                return localTrack;
		            },
		            endCreating: function (controller, cover) {
		                cover.remove(cover.childAt(0));
		                // Use graphic.Polygon close the shape.
		                cover.add(new graphic.Polygon({
		                    name: 'main',
		                    draggable: true,
		                    drift: curry(driftPolygon, controller, cover),
		                    ondragend: curry(trigger, controller, {isEnd: true})
		                }));
		            },
		            updateCoverShape: function (controller, cover, localRange, brushOption) {
		                cover.childAt(0).setShape({
		                    points: clipByPanel(controller, cover, localRange)
		                });
		            },
		            updateCommon: updateCommon,
		            contain: mainShapeContain
		        }
		    };

		    function getLineRenderer(xyIndex) {
		        return {
		            createCover: function (controller, brushOption) {
		                return createBaseRectCover(
		                    curry(
		                        driftRect,
		                        function (range) {
		                            var rectRange = [range, [0, 100]];
		                            xyIndex && rectRange.reverse();
		                            return rectRange;
		                        },
		                        function (rectRange) {
		                            return rectRange[xyIndex];
		                        }
		                    ),
		                    controller,
		                    brushOption,
		                    [['w', 'e'], ['n', 's']][xyIndex]
		                );
		            },
		            getCreatingRange: function (localTrack) {
		                var ends = getTrackEnds(localTrack);
		                var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);
		                var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);

		                return [min, max];
		            },
		            updateCoverShape: function (controller, cover, localRange, brushOption) {
		                var brushWidth = brushOption.brushStyle.width;
		                var otherExtent;
		                // If brushWidth not specified, fit the panel.
		                if (brushWidth == null) {
		                    var panel = getPanelByCover(controller, cover);
		                    var base = 0;
		                    if (panel !== true) {
		                        var rect = panel.getBoundingRect();
		                        brushWidth = xyIndex ? rect.width : rect.height;
		                        base = xyIndex ? rect.x : rect.y;
		                    }
		                    // FIXME
		                    // do not support global panel yet.
		                    otherExtent = [base, base + (brushWidth || 0)];
		                }
		                else {
		                    otherExtent = [-brushWidth / 2, brushWidth / 2];
		                }
		                var rectRange = [localRange, otherExtent];
		                xyIndex && rectRange.reverse();

		                updateBaseRect(controller, cover, rectRange, brushOption);
		            },
		            updateCommon: updateCommon,
		            contain: mainShapeContain
		        };
		    }

		    module.exports = BrushController;


	/***/ },
	/* 236 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var modelUtil = __webpack_require__(5);

		    module.exports = function (option) {
		        createParallelIfNeeded(option);
		        mergeAxisOptionFromParallel(option);
		    };

		    /**
		     * Create a parallel coordinate if not exists.
		     * @inner
		     */
		    function createParallelIfNeeded(option) {
		        if (option.parallel) {
		            return;
		        }

		        var hasParallelSeries = false;

		        zrUtil.each(option.series, function (seriesOpt) {
		            if (seriesOpt && seriesOpt.type === 'parallel') {
		                hasParallelSeries = true;
		            }
		        });

		        if (hasParallelSeries) {
		            option.parallel = [{}];
		        }
		    }

		    /**
		     * Merge aixs definition from parallel option (if exists) to axis option.
		     * @inner
		     */
		    function mergeAxisOptionFromParallel(option) {
		        var axes = modelUtil.normalizeToArray(option.parallelAxis);

		        zrUtil.each(axes, function (axisOption) {
		            if (!zrUtil.isObject(axisOption)) {
		                return;
		            }

		            var parallelIndex = axisOption.parallelIndex || 0;
		            var parallelOption = modelUtil.normalizeToArray(option.parallel)[parallelIndex];

		            if (parallelOption && parallelOption.parallelAxisDefault) {
		                zrUtil.merge(axisOption, parallelOption.parallelAxisDefault, false);
		            }
		        });
		    }



	/***/ },
	/* 237 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var List = __webpack_require__(98);
		    var zrUtil = __webpack_require__(4);
		    var SeriesModel = __webpack_require__(28);
		    var completeDimensions = __webpack_require__(103);

		    module.exports = SeriesModel.extend({

		        type: 'series.parallel',

		        dependencies: ['parallel'],

		        getInitialData: function (option, ecModel) {
		            var parallelModel = ecModel.getComponent(
		                'parallel', this.get('parallelIndex')
		            );
		            var parallelAxisIndices = parallelModel.parallelAxisIndex;

		            var rawData = option.data;
		            var modelDims = parallelModel.dimensions;

		            var dataDims = generateDataDims(modelDims, rawData);

		            var dataDimsInfo = zrUtil.map(dataDims, function (dim, dimIndex) {

		                var modelDimsIndex = zrUtil.indexOf(modelDims, dim);
		                var axisModel = modelDimsIndex >= 0 && ecModel.getComponent(
		                    'parallelAxis', parallelAxisIndices[modelDimsIndex]
		                );

		                if (axisModel && axisModel.get('type') === 'category') {
		                    translateCategoryValue(axisModel, dim, rawData);
		                    return {name: dim, type: 'ordinal'};
		                }
		                else if (modelDimsIndex < 0) {
		                    return completeDimensions.guessOrdinal(rawData, dimIndex)
		                        ? {name: dim, type: 'ordinal'}
		                        : dim;
		                }
		                else {
		                    return dim;
		                }
		            });

		            var list = new List(dataDimsInfo, this);
		            list.initData(rawData);

		            // Anication is forbiden in progressive data mode.
		            if (this.option.progressive) {
		                this.option.animation = false;
		            }

		            return list;
		        },

		        /**
		         * User can get data raw indices on 'axisAreaSelected' event received.
		         *
		         * @public
		         * @param {string} activeState 'active' or 'inactive' or 'normal'
		         * @return {Array.<number>} Raw indices
		         */
		        getRawIndicesByActiveState: function (activeState) {
		            var coordSys = this.coordinateSystem;
		            var data = this.getData();
		            var indices = [];

		            coordSys.eachActiveState(data, function (theActiveState, dataIndex) {
		                if (activeState === theActiveState) {
		                    indices.push(data.getRawIndex(dataIndex));
		                }
		            });

		            return indices;
		        },

		        defaultOption: {
		            zlevel: 0,                  // 一级层叠
		            z: 2,                       // 二级层叠

		            coordinateSystem: 'parallel',
		            parallelIndex: 0,

		            label: {
		                normal: {
		                    show: false
		                },
		                emphasis: {
		                    show: false
		                }
		            },

		            inactiveOpacity: 0.05,
		            activeOpacity: 1,

		            lineStyle: {
		                normal: {
		                    width: 1,
		                    opacity: 0.45,
		                    type: 'solid'
		                }
		            },
		            progressive: false, // 100
		            smooth: false,

		            animationEasing: 'linear'
		        }
		    });

		    function translateCategoryValue(axisModel, dim, rawData) {
		        var axisData = axisModel.get('data');
		        var numberDim = convertDimNameToNumber(dim);

		        if (axisData && axisData.length) {
		            zrUtil.each(rawData, function (dataItem) {
		                if (!dataItem) {
		                    return;
		                }
		                // FIXME
		                // time consuming, should use hash?
		                var index = zrUtil.indexOf(axisData, dataItem[numberDim]);
		                dataItem[numberDim] = index >= 0 ? index : NaN;
		            });
		        }
		        // FIXME
		        // 如果没有设置axis data, 应自动算出，或者提示。
		    }

		    function convertDimNameToNumber(dimName) {
		        return +dimName.replace('dim', '');
		    }

		    function generateDataDims(modelDims, rawData) {
		        // parallelModel.dimension should not be regarded as data
		        // dimensions. Consider dimensions = ['dim4', 'dim2', 'dim6'];

		        // We detect max dim by parallelModel.dimensions and fist
		        // item in rawData arbitrarily.
		        var maxDimNum = 0;
		        zrUtil.each(modelDims, function (dimName) {
		            var numberDim = convertDimNameToNumber(dimName);
		            numberDim > maxDimNum && (maxDimNum = numberDim);
		        });

		        var firstItem = rawData[0];
		        if (firstItem && firstItem.length - 1 > maxDimNum) {
		            maxDimNum = firstItem.length - 1;
		        }

		        var dataDims = [];
		        for (var i = 0; i <= maxDimNum; i++) {
		            dataDims.push('dim' + i);
		        }

		        return dataDims;
		    }


	/***/ },
	/* 238 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var graphic = __webpack_require__(43);
		    var zrUtil = __webpack_require__(4);

		    var SMOOTH = 0.3;

		    var ParallelView = __webpack_require__(42).extend({

		        type: 'parallel',

		        init: function () {

		            /**
		             * @type {module:zrender/container/Group}
		             * @private
		             */
		            this._dataGroup = new graphic.Group();

		            this.group.add(this._dataGroup);

		            /**
		             * @type {module:echarts/data/List}
		             */
		            this._data;
		        },

		        /**
		         * @override
		         */
		        render: function (seriesModel, ecModel, api, payload) {
		            this._renderForNormal(seriesModel);
		            // this[
		            //     seriesModel.option.progressive
		            //         ? '_renderForProgressive'
		            //         : '_renderForNormal'
		            // ](seriesModel);
		        },

		        dispose: function () {},

		        /**
		         * @private
		         */
		        _renderForNormal: function (seriesModel) {
		            var dataGroup = this._dataGroup;
		            var data = seriesModel.getData();
		            var oldData = this._data;
		            var coordSys = seriesModel.coordinateSystem;
		            var dimensions = coordSys.dimensions;
		            var option = seriesModel.option;
		            var smooth = option.smooth ? SMOOTH : null;

		            // Consider switch between progressive and not.
		            // oldData && oldData.__plProgressive && dataGroup.removeAll();

		            data.diff(oldData)
		                .add(add)
		                .update(update)
		                .remove(remove)
		                .execute();

		            // Update style
		            updateElCommon(data, smooth);

		            // First create
		            if (!this._data) {
		                var clipPath = createGridClipShape(
		                    coordSys, seriesModel, function () {
		                        // Callback will be invoked immediately if there is no animation
		                        setTimeout(function () {
		                            dataGroup.removeClipPath();
		                        });
		                    }
		                );
		                dataGroup.setClipPath(clipPath);
		            }

		            this._data = data;

		            function add(newDataIndex) {
		                addEl(data, dataGroup, newDataIndex, dimensions, coordSys, null, smooth);
		            }

		            function update(newDataIndex, oldDataIndex) {
		                var line = oldData.getItemGraphicEl(oldDataIndex);
		                var points = createLinePoints(data, newDataIndex, dimensions, coordSys);
		                data.setItemGraphicEl(newDataIndex, line);
		                graphic.updateProps(line, {shape: {points: points}}, seriesModel, newDataIndex);
		            }

		            function remove(oldDataIndex) {
		                var line = oldData.getItemGraphicEl(oldDataIndex);
		                dataGroup.remove(line);
		            }

		        },

		        /**
		         * @private
		         */
		        // _renderForProgressive: function (seriesModel) {
		        //     var dataGroup = this._dataGroup;
		        //     var data = seriesModel.getData();
		        //     var oldData = this._data;
		        //     var coordSys = seriesModel.coordinateSystem;
		        //     var dimensions = coordSys.dimensions;
		        //     var option = seriesModel.option;
		        //     var progressive = option.progressive;
		        //     var smooth = option.smooth ? SMOOTH : null;

		        //     // In progressive animation is disabled, so use simple data diff,
		        //     // which effects performance less.
		        //     // (Typically performance for data with length 7000+ like:
		        //     // simpleDiff: 60ms, addEl: 184ms,
		        //     // in RMBP 2.4GHz intel i7, OSX 10.9 chrome 50.0.2661.102 (64-bit))
		        //     if (simpleDiff(oldData, data, dimensions)) {
		        //         dataGroup.removeAll();
		        //         data.each(function (dataIndex) {
		        //             addEl(data, dataGroup, dataIndex, dimensions, coordSys);
		        //         });
		        //     }

		        //     updateElCommon(data, progressive, smooth);

		        //     // Consider switch between progressive and not.
		        //     data.__plProgressive = true;
		        //     this._data = data;
		        // },

		        /**
		         * @override
		         */
		        remove: function () {
		            this._dataGroup && this._dataGroup.removeAll();
		            this._data = null;
		        }
		    });

		    function createGridClipShape(coordSys, seriesModel, cb) {
		        var parallelModel = coordSys.model;
		        var rect = coordSys.getRect();
		        var rectEl = new graphic.Rect({
		            shape: {
		                x: rect.x,
		                y: rect.y,
		                width: rect.width,
		                height: rect.height
		            }
		        });

		        var dim = parallelModel.get('layout') === 'horizontal' ? 'width' : 'height';
		        rectEl.setShape(dim, 0);
		        graphic.initProps(rectEl, {
		            shape: {
		                width: rect.width,
		                height: rect.height
		            }
		        }, seriesModel, cb);
		        return rectEl;
		    }

		    function createLinePoints(data, dataIndex, dimensions, coordSys) {
		        var points = [];
		        for (var i = 0; i < dimensions.length; i++) {
		            var dimName = dimensions[i];
		            var value = data.get(dimName, dataIndex);
		            if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
		                points.push(coordSys.dataToPoint(value, dimName));
		            }
		        }
		        return points;
		    }

		    function addEl(data, dataGroup, dataIndex, dimensions, coordSys) {
		        var points = createLinePoints(data, dataIndex, dimensions, coordSys);
		        var line = new graphic.Polyline({
		            shape: {points: points},
		            silent: true,
		            z2: 10
		        });
		        dataGroup.add(line);
		        data.setItemGraphicEl(dataIndex, line);
		    }

		    function updateElCommon(data, smooth) {
		        var seriesStyleModel = data.hostModel.getModel('lineStyle.normal');
		        var lineStyle = seriesStyleModel.getLineStyle();
		        data.eachItemGraphicEl(function (line, dataIndex) {
		            if (data.hasItemOption) {
		                var itemModel = data.getItemModel(dataIndex);
		                var lineStyleModel = itemModel.getModel('lineStyle.normal', seriesStyleModel);
		                lineStyle = lineStyleModel.getLineStyle();
		            }

		            line.useStyle(zrUtil.extend(
		                lineStyle,
		                {
		                    fill: null,
		                    stroke: data.getItemVisual(dataIndex, 'color'),
		                    opacity: data.getItemVisual(dataIndex, 'opacity')
		                }
		            ));
		            line.shape.smooth = smooth;
		        });
		    }

		    // function simpleDiff(oldData, newData, dimensions) {
		    //     var oldLen;
		    //     if (!oldData
		    //         || !oldData.__plProgressive
		    //         || (oldLen = oldData.count()) !== newData.count()
		    //     ) {
		    //         return true;
		    //     }

		    //     var dimLen = dimensions.length;
		    //     for (var i = 0; i < oldLen; i++) {
		    //         for (var j = 0; j < dimLen; j++) {
		    //             if (oldData.get(dimensions[j], i) !== newData.get(dimensions[j], i)) {
		    //                 return true;
		    //             }
		    //         }
		    //     }

		    //     return false;
		    // }

		    // FIXME
		    // 公用方法?
		    function isEmptyValue(val, axisType) {
		        return axisType === 'category'
		            ? val == null
		            : (val == null || isNaN(val)); // axisType === 'value'
		    }

		    module.exports = ParallelView;


	/***/ },
	/* 239 */
	/***/ function(module, exports) {

		

		    module.exports = function (ecModel) {

		        ecModel.eachSeriesByType('parallel', function (seriesModel) {

		            var itemStyleModel = seriesModel.getModel('itemStyle.normal');
		            var lineStyleModel = seriesModel.getModel('lineStyle.normal');
		            var globalColors = ecModel.get('color');

		            var color = lineStyleModel.get('color')
		                || itemStyleModel.get('color')
		                || globalColors[seriesModel.seriesIndex % globalColors.length];
		            var inactiveOpacity = seriesModel.get('inactiveOpacity');
		            var activeOpacity = seriesModel.get('activeOpacity');
		            var lineStyle = seriesModel.getModel('lineStyle.normal').getLineStyle();

		            var coordSys = seriesModel.coordinateSystem;
		            var data = seriesModel.getData();

		            var opacityMap = {
		                normal: lineStyle.opacity,
		                active: activeOpacity,
		                inactive: inactiveOpacity
		            };

		            coordSys.eachActiveState(data, function (activeState, dataIndex) {
		                data.setItemVisual(dataIndex, 'opacity', opacityMap[activeState]);
		            });

		            data.setVisual('color', color);
		        });
		    };


	/***/ },
	/* 240 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var echarts = __webpack_require__(1);

		    __webpack_require__(241);
		    __webpack_require__(242);
		    echarts.registerLayout(__webpack_require__(243));
		    echarts.registerVisual(__webpack_require__(245));


	/***/ },
	/* 241 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @file Get initial data and define sankey view's series model
		 * @author Deqing Li(annong035@gmail.com)
		 */


		    var SeriesModel = __webpack_require__(28);
		    var createGraphFromNodeEdge = __webpack_require__(198);

		    var SankeySeries = SeriesModel.extend({

		        type: 'series.sankey',

		        layoutInfo: null,

		        /**
		         * Init a graph data structure from data in option series
		         *
		         * @param  {Object} option  the object used to config echarts view
		         * @return {module:echarts/data/List} storage initial data
		         */
		        getInitialData: function (option) {
		            var links = option.edges || option.links;
		            var nodes = option.data || option.nodes;
		            if (nodes && links) {
		                var graph = createGraphFromNodeEdge(nodes, links, this, true);
		                return graph.data;
		            }
		        },

		        /**
		         * Return the graphic data structure
		         *
		         * @return {module:echarts/data/Graph} graphic data structure
		         */
		        getGraph: function () {
		            return this.getData().graph;
		        },

		        /**
		         * Get edge data of graphic data structure
		         *
		         * @return {module:echarts/data/List} data structure of list
		         */
		        getEdgeData: function () {
		            return this.getGraph().edgeData;
		        },

		        /**
		         * @override
		         */
		        formatTooltip: function (dataIndex, multipleSeries, dataType) {
		            // dataType === 'node' or empty do not show tooltip by default
		            if (dataType === 'edge') {
		                var params = this.getDataParams(dataIndex, dataType);
		                var rawDataOpt = params.data;
		                var html = rawDataOpt.source + ' -- ' + rawDataOpt.target;
		                if (params.value) {
		                    html += ' : ' + params.value;
		                }
		                return html;
		            }

		            return SankeySeries.superCall(this, 'formatTooltip', dataIndex, multipleSeries);
		        },

		        defaultOption: {
		            zlevel: 0,
		            z: 2,

		            coordinateSystem: 'view',

		            layout: null,

		            // the position of the whole view
		            left: '5%',
		            top: '5%',
		            right: '20%',
		            bottom: '5%',

		            // the dx of the node
		            nodeWidth: 20,

		            // the vertical distance between two nodes
		            nodeGap: 8,

		            // the number of iterations to change the position of the node
		            layoutIterations: 32,

		            label: {
		                normal: {
		                    show: true,
		                    position: 'right',
		                    textStyle: {
		                        color: '#000',
		                        fontSize: 12
		                    }
		                },
		                emphasis: {
		                    show: true
		                }
		            },

		            itemStyle: {
		                normal: {
		                    borderWidth: 1,
		                    borderColor: '#333'
		                }
		            },

		            lineStyle: {
		                normal: {
		                    color: '#314656',
		                    opacity: 0.2,
		                    curveness: 0.5
		                },
		                emphasis: {
		                    opacity: 0.6
		                }
		            },

		            animationEasing: 'linear',

		            animationDuration: 1000
		        }

		    });

		    module.exports = SankeySeries;



	/***/ },
	/* 242 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @file  The file used to draw sankey view
		 * @author  Deqing Li(annong035@gmail.com)
		 */


		    var graphic = __webpack_require__(43);
		    var zrUtil = __webpack_require__(4);

		    var SankeyShape = graphic.extendShape({
		        shape: {
		            x1: 0, y1: 0,
		            x2: 0, y2: 0,
		            cpx1: 0, cpy1: 0,
		            cpx2: 0, cpy2: 0,

		            extent: 0
		        },

		        buildPath: function (ctx, shape) {
		            var halfExtent = shape.extent / 2;
		            ctx.moveTo(shape.x1, shape.y1 - halfExtent);
		            ctx.bezierCurveTo(
		                shape.cpx1, shape.cpy1 - halfExtent,
		                shape.cpx2, shape.cpy2 - halfExtent,
		                shape.x2, shape.y2 - halfExtent
		            );
		            ctx.lineTo(shape.x2, shape.y2 + halfExtent);
		            ctx.bezierCurveTo(
		                shape.cpx2, shape.cpy2 + halfExtent,
		                shape.cpx1, shape.cpy1 + halfExtent,
		                shape.x1, shape.y1 + halfExtent
		            );
		            ctx.closePath();
		        }
		    });

		    module.exports = __webpack_require__(1).extendChartView({

		        type: 'sankey',

		        /**
		         * @private
		         * @type {module:echarts/chart/sankey/SankeySeries}
		         */
		        _model: null,

		        render: function (seriesModel, ecModel, api) {
		            var graph = seriesModel.getGraph();
		            var group = this.group;
		            var layoutInfo = seriesModel.layoutInfo;
		            var nodeData = seriesModel.getData();
		            var edgeData = seriesModel.getData('edge');

		            this._model = seriesModel;

		            group.removeAll();

		            group.position = [layoutInfo.x, layoutInfo.y];

		            // generate a bezire Curve for each edge
		            graph.eachEdge(function (edge) {
		                var curve = new SankeyShape();

		                curve.dataIndex = edge.dataIndex;
		                curve.seriesIndex = seriesModel.seriesIndex;
		                curve.dataType = 'edge';

		                var lineStyleModel = edge.getModel('lineStyle.normal');
		                var curvature = lineStyleModel.get('curveness');
		                var n1Layout = edge.node1.getLayout();
		                var n2Layout = edge.node2.getLayout();
		                var edgeLayout = edge.getLayout();

		                curve.shape.extent = Math.max(1, edgeLayout.dy);

		                var x1 = n1Layout.x + n1Layout.dx;
		                var y1 = n1Layout.y + edgeLayout.sy + edgeLayout.dy / 2;
		                var x2 = n2Layout.x;
		                var y2 = n2Layout.y + edgeLayout.ty + edgeLayout.dy / 2;
		                var cpx1 = x1 * (1 - curvature) + x2 * curvature;
		                var cpy1 = y1;
		                var cpx2 = x1 * curvature + x2 * (1 - curvature);
		                var cpy2 = y2;

		                curve.setShape({
		                    x1: x1,
		                    y1: y1,
		                    x2: x2,
		                    y2: y2,
		                    cpx1: cpx1,
		                    cpy1: cpy1,
		                    cpx2: cpx2,
		                    cpy2: cpy2
		                });

		                curve.setStyle(lineStyleModel.getItemStyle());
		                // Special color, use source node color or target node color
		                switch (curve.style.fill) {
		                    case 'source':
		                        curve.style.fill = edge.node1.getVisual('color');
		                        break;
		                    case 'target':
		                        curve.style.fill = edge.node2.getVisual('color');
		                        break;
		                }

		                graphic.setHoverStyle(curve, edge.getModel('lineStyle.emphasis').getItemStyle());

		                group.add(curve);

		                edgeData.setItemGraphicEl(edge.dataIndex, curve);
		            });

		            // generate a rect  for each node
		            graph.eachNode(function (node) {
		                var layout = node.getLayout();
		                var itemModel = node.getModel();
		                var labelModel = itemModel.getModel('label.normal');
		                var textStyleModel = labelModel.getModel('textStyle');
		                var labelHoverModel = itemModel.getModel('label.emphasis');
		                var textStyleHoverModel = labelHoverModel.getModel('textStyle');

		                var rect = new graphic.Rect({
		                    shape: {
		                        x: layout.x,
		                        y: layout.y,
		                        width: node.getLayout().dx,
		                        height: node.getLayout().dy
		                    },
		                    style: {
		                        // Get formatted label in label.normal option
		                        //  Use node id if it is not specified
		                        text: labelModel.get('show')
		                            ? seriesModel.getFormattedLabel(node.dataIndex, 'normal') || node.id
		                            // Use empty string to hide the label
		                            : '',
		                        textFont: textStyleModel.getFont(),
		                        textFill: textStyleModel.getTextColor(),
		                        textPosition: labelModel.get('position')
		                    }
		                });

		                rect.setStyle(zrUtil.defaults(
		                    {
		                        fill: node.getVisual('color')
		                    },
		                    itemModel.getModel('itemStyle.normal').getItemStyle()
		                ));

		                graphic.setHoverStyle(rect, zrUtil.extend(
		                    node.getModel('itemStyle.emphasis'),
		                    {
		                        text: labelHoverModel.get('show')
		                            ? seriesModel.getFormattedLabel(node.dataIndex, 'emphasis') || node.id
		                            : '',
		                        textFont: textStyleHoverModel.getFont(),
		                        textFill: textStyleHoverModel.getTextColor(),
		                        textPosition: labelHoverModel.get('position')
		                    }
		                ));

		                group.add(rect);

		                nodeData.setItemGraphicEl(node.dataIndex, rect);

		                rect.dataType = 'node';
		            });

		            if (!this._data && seriesModel.get('animation')) {
		                group.setClipPath(createGridClipShape(group.getBoundingRect(), seriesModel, function () {
		                    group.removeClipPath();
		                }));
		            }

		            this._data = seriesModel.getData();
		        },

		        dispose: function () {}
		    });

		    // add animation to the view
		    function createGridClipShape(rect, seriesModel, cb) {
		        var rectEl = new graphic.Rect({
		            shape: {
		                x: rect.x - 10,
		                y: rect.y - 10,
		                width: 0,
		                height: rect.height + 20
		            }
		        });
		        graphic.initProps(rectEl, {
		            shape: {
		                width: rect.width + 20,
		                height: rect.height + 20
		            }
		        }, seriesModel, cb);

		        return rectEl;
		    }



	/***/ },
	/* 243 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @file The layout algorithm of sankey view
		 * @author  Deqing Li(annong035@gmail.com)
		 */


		    var layout = __webpack_require__(21);
		    var nest = __webpack_require__(244);
		    var zrUtil = __webpack_require__(4);

		    module.exports = function (ecModel, api, payload) {

		        ecModel.eachSeriesByType('sankey', function (seriesModel) {

		            var nodeWidth = seriesModel.get('nodeWidth');
		            var nodeGap = seriesModel.get('nodeGap');

		            var layoutInfo = getViewRect(seriesModel, api);

		            seriesModel.layoutInfo = layoutInfo;

		            var width = layoutInfo.width;
		            var height = layoutInfo.height;

		            var graph = seriesModel.getGraph();

		            var nodes = graph.nodes;
		            var edges = graph.edges;

		            computeNodeValues(nodes);

		            var filteredNodes = nodes.filter(function (node) {
		                return node.getLayout().value === 0;
		            });

		            var iterations = filteredNodes.length !== 0
		                ? 0 : seriesModel.get('layoutIterations');

		            layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations);
		        });
		    };

		    /**
		     * Get the layout position of the whole view
		     *
		     * @param {module:echarts/model/Series} seriesModel  the model object of sankey series
		     * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call
		     * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view
		     */
		    function getViewRect(seriesModel, api) {
		        return layout.getLayoutRect(
		            seriesModel.getBoxLayoutParams(), {
		                width: api.getWidth(),
		                height: api.getHeight()
		            }
		        );
		    }

		    function layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations) {
		        computeNodeBreadths(nodes, nodeWidth, width);
		        computeNodeDepths(nodes, edges, height, nodeGap, iterations);
		        computeEdgeDepths(nodes);
		    }

		    /**
		     * Compute the value of each node by summing the associated edge's value
		     *
		     * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
		     */
		    function computeNodeValues(nodes) {
		        zrUtil.each(nodes, function (node) {
		            var value1 = sum(node.outEdges, getEdgeValue);
		            var value2 = sum(node.inEdges, getEdgeValue);
		            var value = Math.max(value1, value2);
		            node.setLayout({value: value}, true);
		        });
		    }

		    /**
		     * Compute the x-position for each node
		     *
		     * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
		     * @param  {number} nodeWidth  the dx of the node
		     * @param  {number} width  the whole width of the area to draw the view
		     */
		    function computeNodeBreadths(nodes, nodeWidth, width) {
		        var remainNodes = nodes;
		        var nextNode = null;
		        var x = 0;
		        var kx = 0;

		        while (remainNodes.length) {
		            nextNode = [];
		            for (var i = 0, len = remainNodes.length; i < len; i++) {
		                var node = remainNodes[i];
		                node.setLayout({x: x}, true);
		                node.setLayout({dx: nodeWidth}, true);
		                for (var j = 0, lenj = node.outEdges.length; j < lenj; j++) {
		                    nextNode.push(node.outEdges[j].node2);
		                }
		            }
		            remainNodes = nextNode;
		            ++x;
		        }

		        moveSinksRight(nodes, x);
		        kx = (width - nodeWidth) / (x - 1);

		        scaleNodeBreadths(nodes, kx);
		    }

		    /**
		     * All the node without outEgdes are assigned maximum x-position and
		     *     be aligned in the last column.
		     *
		     * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
		     * @param {number} x  value (x-1) use to assign to node without outEdges
		     *     as x-position
		     */
		    function moveSinksRight(nodes, x) {
		        zrUtil.each(nodes, function (node) {
		            if (!node.outEdges.length) {
		                node.setLayout({x: x - 1}, true);
		            }
		        });
		    }

		    /**
		     * Scale node x-position to the width
		     *
		     * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
		     * @param {number} kx   multiple used to scale nodes
		     */
		    function scaleNodeBreadths(nodes, kx) {
		        zrUtil.each(nodes, function (node) {
		            var nodeX = node.getLayout().x * kx;
		            node.setLayout({x: nodeX}, true);
		        });
		    }

		    /**
		     * Using Gauss-Seidel iterations method to compute the node depth(y-position)
		     *
		     * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
		     * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view
		     * @param {number} height  the whole height of the area to draw the view
		     * @param {numbber} nodeGap  the vertical distance between two nodes
		     *     in the same column.
		     * @param {number} iterations  the number of iterations for the algorithm
		     */
		    function computeNodeDepths(nodes, edges, height, nodeGap, iterations) {
		        var nodesByBreadth = nest()
		            .key(function (d) {
		                return d.getLayout().x;
		            })
		            .sortKeys(ascending)
		            .entries(nodes)
		            .map(function (d) {
		                return d.values;
		            });

		        initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap);
		        resolveCollisions(nodesByBreadth, nodeGap, height);

		        for (var alpha = 1; iterations > 0; iterations--) {
		            // 0.99 is a experience parameter, ensure that each iterations of
		            // changes as small as possible.
		            alpha *= 0.99;
		            relaxRightToLeft(nodesByBreadth, alpha);
		            resolveCollisions(nodesByBreadth, nodeGap, height);
		            relaxLeftToRight(nodesByBreadth, alpha);
		            resolveCollisions(nodesByBreadth, nodeGap, height);
		        }
		    }

		    /**
		     * Compute the original y-position for each node
		     *
		     * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
		     * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
		     *     group by the array of all sankey nodes based on the nodes x-position.
		     * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view
		     * @param {number} height  the whole height of the area to draw the view
		     * @param {number} nodeGap  the vertical distance between two nodes
		     */
		    function initializeNodeDepth(nodes, nodesByBreadth, edges, height, nodeGap) {
		        var kyArray = [];
		        zrUtil.each(nodesByBreadth, function (nodes) {
		            var n = nodes.length;
		            var sum = 0;
		            zrUtil.each(nodes, function (node) {
		                sum += node.getLayout().value;
		            });
		            var ky = (height - (n - 1) * nodeGap) / sum;
		            kyArray.push(ky);
		        });

		        kyArray.sort(function (a, b) {
		            return a - b;
		        });
		        var ky0 = kyArray[0];

		        zrUtil.each(nodesByBreadth, function (nodes) {
		            zrUtil.each(nodes, function (node, i) {
		                node.setLayout({y: i}, true);
		                var nodeDy = node.getLayout().value * ky0;
		                node.setLayout({dy: nodeDy}, true);
		            });
		        });

		        zrUtil.each(edges, function (edge) {
		            var edgeDy = +edge.getValue() * ky0;
		            edge.setLayout({dy: edgeDy}, true);
		        });
		    }

		    /**
		     * Resolve the collision of initialized depth (y-position)
		     *
		     * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
		     *     group by the array of all sankey nodes based on the nodes x-position.
		     * @param {number} nodeGap  the vertical distance between two nodes
		     * @param {number} height  the whole height of the area to draw the view
		     */
		    function resolveCollisions(nodesByBreadth, nodeGap, height) {
		        zrUtil.each(nodesByBreadth, function (nodes) {
		            var node;
		            var dy;
		            var y0 = 0;
		            var n = nodes.length;
		            var i;

		            nodes.sort(ascendingDepth);

		            for (i = 0; i < n; i++) {
		                node = nodes[i];
		                dy = y0 - node.getLayout().y;
		                if (dy > 0) {
		                    var nodeY = node.getLayout().y + dy;
		                    node.setLayout({y: nodeY}, true);
		                }
		                y0 = node.getLayout().y + node.getLayout().dy + nodeGap;
		            }

		            // if the bottommost node goes outside the bounds, push it back up
		            dy = y0 - nodeGap - height;
		            if (dy > 0) {
		                var nodeY = node.getLayout().y - dy;
		                node.setLayout({y: nodeY}, true);
		                y0 = node.getLayout().y;
		                for (i = n - 2; i >= 0; --i) {
		                    node = nodes[i];
		                    dy = node.getLayout().y + node.getLayout().dy + nodeGap - y0;
		                    if (dy > 0) {
		                        nodeY = node.getLayout().y - dy;
		                        node.setLayout({y: nodeY}, true);
		                    }
		                    y0 = node.getLayout().y;
		                }
		            }
		        });
		    }

		    /**
		     * Change the y-position of the nodes, except most the right side nodes
		     *
		     * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
		     *     group by the array of all sankey nodes based on the node x-position.
		     * @param {number} alpha  parameter used to adjust the nodes y-position
		     */
		    function relaxRightToLeft(nodesByBreadth, alpha) {
		        zrUtil.each(nodesByBreadth.slice().reverse(), function (nodes) {
		            zrUtil.each(nodes, function (node) {
		                if (node.outEdges.length) {
		                    var y = sum(node.outEdges, weightedTarget) / sum(node.outEdges, getEdgeValue);
		                    var nodeY = node.getLayout().y + (y - center(node)) * alpha;
		                    node.setLayout({y: nodeY}, true);
		                }
		            });
		        });
		    }

		    function weightedTarget(edge) {
		        return center(edge.node2) * edge.getValue();
		    }

		    /**
		     * Change the y-position of the nodes, except most the left side nodes
		     *
		     * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth
		     *     group by the array of all sankey nodes based on the node x-position.
		     * @param {number} alpha  parameter used to adjust the nodes y-position
		     */
		    function relaxLeftToRight(nodesByBreadth, alpha) {
		        zrUtil.each(nodesByBreadth, function (nodes) {
		            zrUtil.each(nodes, function (node) {
		                if (node.inEdges.length) {
		                    var y = sum(node.inEdges, weightedSource) / sum(node.inEdges, getEdgeValue);
		                    var nodeY = node.getLayout().y + (y - center(node)) * alpha;
		                    node.setLayout({y: nodeY}, true);
		                }
		            });
		        });
		    }

		    function weightedSource(edge) {
		        return center(edge.node1) * edge.getValue();
		    }

		    /**
		     * Compute the depth(y-position) of each edge
		     *
		     * @param {module:echarts/data/Graph~Node} nodes  node of sankey view
		     */
		    function computeEdgeDepths(nodes) {
		        zrUtil.each(nodes, function (node) {
		            node.outEdges.sort(ascendingTargetDepth);
		            node.inEdges.sort(ascendingSourceDepth);
		        });
		        zrUtil.each(nodes, function (node) {
		            var sy = 0;
		            var ty = 0;
		            zrUtil.each(node.outEdges, function (edge) {
		                edge.setLayout({sy: sy}, true);
		                sy += edge.getLayout().dy;
		            });
		            zrUtil.each(node.inEdges, function (edge) {
		                edge.setLayout({ty: ty}, true);
		                ty += edge.getLayout().dy;
		            });
		        });
		    }

		    function ascendingTargetDepth(a, b) {
		        return a.node2.getLayout().y - b.node2.getLayout().y;
		    }

		    function ascendingSourceDepth(a, b) {
		        return a.node1.getLayout().y - b.node1.getLayout().y;
		    }

		    function sum(array, f) {
		        var sum = 0;
		        var len = array.length;
		        var i = -1;
		        while (++i < len) {
		            var value = +f.call(array, array[i], i);
		            if (!isNaN(value)) {
		                sum += value;
		            }
		        }
		        return sum;
		    }

		    function center(node) {
		        return node.getLayout().y + node.getLayout().dy / 2;
		    }

		    function ascendingDepth(a, b) {
		        return a.getLayout().y - b.getLayout().y;
		    }

		    function ascending(a, b) {
		        return a < b ? -1 : a > b ? 1 : a === b ? 0 : NaN;
		    }

		    function getEdgeValue(edge) {
		        return edge.getValue();
		    }



	/***/ },
	/* 244 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);

		    /**
		     * nest helper used to group by the array.
		     * can specified the keys and sort the keys.
		     */
		    function nest() {

		        var keysFunction = [];
		        var sortKeysFunction = [];

		        /**
		         * map an Array into the mapObject.
		         * @param {Array} array
		         * @param {number} depth
		         */
		        function map(array, depth) {
		            if (depth >= keysFunction.length) {
		                return array;
		            }
		            var i = -1;
		            var n = array.length;
		            var keyFunction = keysFunction[depth++];
		            var mapObject = {};
		            var valuesByKey = {};

		            while (++i < n) {
		                var keyValue = keyFunction(array[i]);
		                var values = valuesByKey[keyValue];

		                if (values) {
		                    values.push(array[i]);
		                }
		                else {
		                    valuesByKey[keyValue] = [array[i]];
		                }
		            }

		            zrUtil.each(valuesByKey, function (value, key) {
		                mapObject[key] = map(value, depth);
		            });

		            return mapObject;
		        }

		        /**
		         * transform the Map Object to multidimensional Array
		         * @param {Object} map
		         * @param {number} depth
		         */
		        function entriesMap(mapObject, depth) {
		            if (depth >= keysFunction.length) {
		                return mapObject;
		            }
		            var array = [];
		            var sortKeyFunction = sortKeysFunction[depth++];

		            zrUtil.each(mapObject, function (value, key) {
		                array.push({
		                    key: key, values: entriesMap(value, depth)
		                });
		            });

		            if (sortKeyFunction) {
		                return array.sort(function (a, b) {
		                    return sortKeyFunction(a.key, b.key);
		                });
		            }
		            else {
		                return array;
		            }
		        }

		        return {
		            /**
		             * specified the key to groupby the arrays.
		             * users can specified one more keys.
		             * @param {Function} d
		             */
		            key: function (d) {
		                keysFunction.push(d);
		                return this;
		            },

		            /**
		             * specified the comparator to sort the keys
		             * @param {Function} order
		             */
		            sortKeys: function (order) {
		                sortKeysFunction[keysFunction.length - 1] = order;
		                return this;
		            },

		            /**
		             * the array to be grouped by.
		             * @param {Array} array
		             */
		            entries: function (array) {
		                return entriesMap(map(array, 0), 0);
		            }
		        };
		    }
		    module.exports = nest;


	/***/ },
	/* 245 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @file Visual encoding for sankey view
		 * @author  Deqing Li(annong035@gmail.com)
		 */


		    var VisualMapping = __webpack_require__(194);
		    var zrUtil = __webpack_require__(4);

		    module.exports = function (ecModel, payload) {
		        ecModel.eachSeriesByType('sankey', function (seriesModel) {
		            var graph = seriesModel.getGraph();
		            var nodes = graph.nodes;

		            nodes.sort(function (a, b) {
		                return a.getLayout().value - b.getLayout().value;
		            });

		            var minValue = nodes[0].getLayout().value;
		            var maxValue = nodes[nodes.length - 1].getLayout().value;

		            zrUtil.each(nodes, function (node) {
		                var mapping = new VisualMapping({
		                    type: 'color',
		                    mappingMethod: 'linear',
		                    dataExtent: [minValue, maxValue],
		                    visual: seriesModel.get('color')
		                });

		                var mapValueToColor = mapping.mapValueToVisual(node.getLayout().value);
		                node.setVisual('color', mapValueToColor);
		                // If set itemStyle.normal.color
		                var itemModel = node.getModel();
		                var customColor = itemModel.get('itemStyle.normal.color');
		                if (customColor != null) {
		                    node.setVisual('color', customColor);
		                }
		            });

		        });
		    };



	/***/ },
	/* 246 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var echarts = __webpack_require__(1);

		    __webpack_require__(247);
		    __webpack_require__(250);

		    echarts.registerVisual(__webpack_require__(251));
		    echarts.registerLayout(__webpack_require__(252));



	/***/ },
	/* 247 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);
		    var SeriesModel = __webpack_require__(28);
		    var whiskerBoxCommon = __webpack_require__(248);

		    var BoxplotSeries = SeriesModel.extend({

		        type: 'series.boxplot',

		        dependencies: ['xAxis', 'yAxis', 'grid'],

		        // TODO
		        // box width represents group size, so dimension should have 'size'.

		        /**
		         * @see <https://en.wikipedia.org/wiki/Box_plot>
		         * The meanings of 'min' and 'max' depend on user,
		         * and echarts do not need to know it.
		         * @readOnly
		         */
		        valueDimensions: ['min', 'Q1', 'median', 'Q3', 'max'],

		        /**
		         * @type {Array.<string>}
		         * @readOnly
		         */
		        dimensions: null,

		        /**
		         * @override
		         */
		        defaultOption: {
		            zlevel: 0,                  // 一级层叠
		            z: 2,                       // 二级层叠
		            coordinateSystem: 'cartesian2d',
		            legendHoverLink: true,

		            hoverAnimation: true,

		            // xAxisIndex: 0,
		            // yAxisIndex: 0,

		            layout: null,               // 'horizontal' or 'vertical'
		            boxWidth: [7, 50],       // [min, max] can be percent of band width.

		            itemStyle: {
		                normal: {
		                    color: '#fff',
		                    borderWidth: 1
		                },
		                emphasis: {
		                    borderWidth: 2,
		                    shadowBlur: 5,
		                    shadowOffsetX: 2,
		                    shadowOffsetY: 2,
		                    shadowColor: 'rgba(0,0,0,0.4)'
		                }
		            },

		            animationEasing: 'elasticOut',
		            animationDuration: 800
		        }
		    });

		    zrUtil.mixin(BoxplotSeries, whiskerBoxCommon.seriesModelMixin, true);

		    module.exports = BoxplotSeries;



	/***/ },
	/* 248 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var List = __webpack_require__(98);
		    var completeDimensions = __webpack_require__(103);
		    var WhiskerBoxDraw = __webpack_require__(249);
		    var zrUtil = __webpack_require__(4);

		    function getItemValue(item) {
		        return item.value == null ? item : item.value;
		    }

		    var seriesModelMixin = {

		        /**
		         * @private
		         * @type {string}
		         */
		        _baseAxisDim: null,

		        /**
		         * @override
		         */
		        getInitialData: function (option, ecModel) {
		            // When both types of xAxis and yAxis are 'value', layout is
		            // needed to be specified by user. Otherwise, layout can be
		            // judged by which axis is category.

		            var categories;

		            var xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'));
		            var yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'));
		            var xAxisType = xAxisModel.get('type');
		            var yAxisType = yAxisModel.get('type');
		            var addOrdinal;

		            // FIXME
		            // 考虑时间轴

		            if (xAxisType === 'category') {
		                option.layout = 'horizontal';
		                categories = xAxisModel.getCategories();
		                addOrdinal = true;
		            }
		            else if (yAxisType  === 'category') {
		                option.layout = 'vertical';
		                categories = yAxisModel.getCategories();
		                addOrdinal = true;
		            }
		            else {
		                option.layout = option.layout || 'horizontal';
		            }

		            this._baseAxisDim = option.layout === 'horizontal' ? 'x' : 'y';

		            var data = option.data;
		            var dimensions = this.dimensions = ['base'].concat(this.valueDimensions);
		            completeDimensions(dimensions, data);

		            var list = new List(dimensions, this);
		            list.initData(data, categories ? categories.slice() : null, function (dataItem, dimName, idx, dimIdx) {
		                var value = getItemValue(dataItem);
		                return addOrdinal ? (dimName === 'base' ? idx : value[dimIdx - 1]) : value[dimIdx];
		            });

		            return list;
		        },

		        /**
		         * Used by Gird.
		         * @param {string} axisDim 'x' or 'y'
		         * @return {Array.<string>} dimensions on the axis.
		         */
		        coordDimToDataDim: function (axisDim) {
		            var dims = this.valueDimensions.slice();
		            var baseDim = ['base'];
		            var map = {
		                horizontal: {x: baseDim, y: dims},
		                vertical: {x: dims, y: baseDim}
		            };
		            return map[this.get('layout')][axisDim];
		        },

		        /**
		         * @override
		         * @param {string|number} dataDim
		         * @return {string} coord dimension
		         */
		        dataDimToCoordDim: function (dataDim) {
		            var dim;

		            zrUtil.each(['x', 'y'], function (coordDim, index) {
		                var dataDims = this.coordDimToDataDim(coordDim);
		                if (zrUtil.indexOf(dataDims, dataDim) >= 0) {
		                    dim = coordDim;
		                }
		            }, this);

		            return dim;
		        },

		        /**
		         * If horizontal, base axis is x, otherwise y.
		         * @override
		         */
		        getBaseAxis: function () {
		            var dim = this._baseAxisDim;
		            return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis;
		        }
		    };

		    var viewMixin = {

		        init: function () {
		            /**
		             * Old data.
		             * @private
		             * @type {module:echarts/chart/helper/WhiskerBoxDraw}
		             */
		            var whiskerBoxDraw = this._whiskerBoxDraw = new WhiskerBoxDraw(
		                this.getStyleUpdater()
		            );
		            this.group.add(whiskerBoxDraw.group);
		        },

		        render: function (seriesModel, ecModel, api) {
		            this._whiskerBoxDraw.updateData(seriesModel.getData());
		        },

		        remove: function (ecModel) {
		            this._whiskerBoxDraw.remove();
		        }
		    };

		    module.exports = {
		        seriesModelMixin: seriesModelMixin,
		        viewMixin: viewMixin
		    };


	/***/ },
	/* 249 */
	/***/ function(module, exports, __webpack_require__) {

		/**
		 * @module echarts/chart/helper/Symbol
		 */


		    var zrUtil = __webpack_require__(4);
		    var graphic = __webpack_require__(43);
		    var Path = __webpack_require__(45);

		    var WhiskerPath = Path.extend({

		        type: 'whiskerInBox',

		        shape: {},

		        buildPath: function (ctx, shape) {
		            for (var i in shape) {
		                if (shape.hasOwnProperty(i) && i.indexOf('ends') === 0) {
		                    var pts = shape[i];
		                    ctx.moveTo(pts[0][0], pts[0][1]);
		                    ctx.lineTo(pts[1][0], pts[1][1]);
		                }
		            }
		        }
		    });

		    /**
		     * @constructor
		     * @alias {module:echarts/chart/helper/WhiskerBox}
		     * @param {module:echarts/data/List} data
		     * @param {number} idx
		     * @param {Function} styleUpdater
		     * @param {boolean} isInit
		     * @extends {module:zrender/graphic/Group}
		     */
		    function WhiskerBox(data, idx, styleUpdater, isInit) {
		        graphic.Group.call(this);

		        /**
		         * @type {number}
		         * @readOnly
		         */
		        this.bodyIndex;

		        /**
		         * @type {number}
		         * @readOnly
		         */
		        this.whiskerIndex;

		        /**
		         * @type {Function}
		         */
		        this.styleUpdater = styleUpdater;

		        this._createContent(data, idx, isInit);

		        this.updateData(data, idx, isInit);

		        /**
		         * Last series model.
		         * @type {module:echarts/model/Series}
		         */
		        this._seriesModel;
		    }

		    var whiskerBoxProto = WhiskerBox.prototype;

		    whiskerBoxProto._createContent = function (data, idx, isInit) {
		        var itemLayout = data.getItemLayout(idx);
		        var constDim = itemLayout.chartLayout === 'horizontal' ? 1 : 0;
		        var count = 0;

		        // Whisker element.
		        this.add(new graphic.Polygon({
		            shape: {
		                points: isInit
		                    ? transInit(itemLayout.bodyEnds, constDim, itemLayout)
		                    : itemLayout.bodyEnds
		            },
		            style: {strokeNoScale: true},
		            z2: 100
		        }));
		        this.bodyIndex = count++;

		        // Box element.
		        var whiskerEnds = zrUtil.map(itemLayout.whiskerEnds, function (ends) {
		            return isInit ? transInit(ends, constDim, itemLayout) : ends;
		        });
		        this.add(new WhiskerPath({
		            shape: makeWhiskerEndsShape(whiskerEnds),
		            style: {strokeNoScale: true},
		            z2: 100
		        }));
		        this.whiskerIndex = count++;
		    };

		    function transInit(points, dim, itemLayout) {
		        return zrUtil.map(points, function (point) {
		            point = point.slice();
		            point[dim] = itemLayout.initBaseline;
		            return point;
		        });
		    }

		    function makeWhiskerEndsShape(whiskerEnds) {
		        // zr animation only support 2-dim array.
		        var shape = {};
		        zrUtil.each(whiskerEnds, function (ends, i) {
		            shape['ends' + i] = ends;
		        });
		        return shape;
		    }

		    /**
		     * Update symbol properties
		     * @param  {module:echarts/data/List} data
		     * @param  {number} idx
		     */
		    whiskerBoxProto.updateData = function (data, idx, isInit) {
		        var seriesModel = this._seriesModel = data.hostModel;
		        var itemLayout = data.getItemLayout(idx);
		        var updateMethod = graphic[isInit ? 'initProps' : 'updateProps'];
		        // this.childAt(this.bodyIndex).stopAnimation(true);
		        // this.childAt(this.whiskerIndex).stopAnimation(true);
		        updateMethod(
		            this.childAt(this.bodyIndex),
		            {shape: {points: itemLayout.bodyEnds}},
		            seriesModel, idx
		        );
		        updateMethod(
		            this.childAt(this.whiskerIndex),
		            {shape: makeWhiskerEndsShape(itemLayout.whiskerEnds)},
		            seriesModel, idx
		        );

		        this.styleUpdater.call(null, this, data, idx);
		    };

		    zrUtil.inherits(WhiskerBox, graphic.Group);


		    /**
		     * @constructor
		     * @alias module:echarts/chart/helper/WhiskerBoxDraw
		     */
		    function WhiskerBoxDraw(styleUpdater) {
		        this.group = new graphic.Group();
		        this.styleUpdater = styleUpdater;
		    }

		    var whiskerBoxDrawProto = WhiskerBoxDraw.prototype;

		    /**
		     * Update symbols draw by new data
		     * @param {module:echarts/data/List} data
		     */
		    whiskerBoxDrawProto.updateData = function (data) {
		        var group = this.group;
		        var oldData = this._data;
		        var styleUpdater = this.styleUpdater;

		        data.diff(oldData)
		            .add(function (newIdx) {
		                if (data.hasValue(newIdx)) {
		                    var symbolEl = new WhiskerBox(data, newIdx, styleUpdater, true);
		                    data.setItemGraphicEl(newIdx, symbolEl);
		                    group.add(symbolEl);
		                }
		            })
		            .update(function (newIdx, oldIdx) {
		                var symbolEl = oldData.getItemGraphicEl(oldIdx);

		                // Empty data
		                if (!data.hasValue(newIdx)) {
		                    group.remove(symbolEl);
		                    return;
		                }

		                if (!symbolEl) {
		                    symbolEl = new WhiskerBox(data, newIdx, styleUpdater);
		                }
		                else {
		                    symbolEl.updateData(data, newIdx);
		                }

		                // Add back
		                group.add(symbolEl);

		                data.setItemGraphicEl(newIdx, symbolEl);
		            })
		            .remove(function (oldIdx) {
		                var el = oldData.getItemGraphicEl(oldIdx);
		                el && group.remove(el);
		            })
		            .execute();

		        this._data = data;
		    };

		    /**
		     * Remove symbols.
		     * @param {module:echarts/data/List} data
		     */
		    whiskerBoxDrawProto.remove = function () {
		        var group = this.group;
		        var data = this._data;
		        this._data = null;
		        data && data.eachItemGraphicEl(function (el) {
		            el && group.remove(el);
		        });
		    };

		    module.exports = WhiskerBoxDraw;


	/***/ },
	/* 250 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);
		    var ChartView = __webpack_require__(42);
		    var graphic = __webpack_require__(43);
		    var whiskerBoxCommon = __webpack_require__(248);

		    var BoxplotView = ChartView.extend({

		        type: 'boxplot',

		        getStyleUpdater: function () {
		            return updateStyle;
		        },

		        dispose: zrUtil.noop
		    });

		    zrUtil.mixin(BoxplotView, whiskerBoxCommon.viewMixin, true);

		    // Update common properties
		    var normalStyleAccessPath = ['itemStyle', 'normal'];
		    var emphasisStyleAccessPath = ['itemStyle', 'emphasis'];

		    function updateStyle(itemGroup, data, idx) {
		        var itemModel = data.getItemModel(idx);
		        var normalItemStyleModel = itemModel.getModel(normalStyleAccessPath);
		        var borderColor = data.getItemVisual(idx, 'color');

		        // Exclude borderColor.
		        var itemStyle = normalItemStyleModel.getItemStyle(['borderColor']);

		        var whiskerEl = itemGroup.childAt(itemGroup.whiskerIndex);
		        whiskerEl.style.set(itemStyle);
		        whiskerEl.style.stroke = borderColor;
		        whiskerEl.dirty();

		        var bodyEl = itemGroup.childAt(itemGroup.bodyIndex);
		        bodyEl.style.set(itemStyle);
		        bodyEl.style.stroke = borderColor;
		        bodyEl.dirty();

		        var hoverStyle = itemModel.getModel(emphasisStyleAccessPath).getItemStyle();
		        graphic.setHoverStyle(itemGroup, hoverStyle);
		    }

		    module.exports = BoxplotView;



	/***/ },
	/* 251 */
	/***/ function(module, exports) {

		

		    var borderColorQuery = ['itemStyle', 'normal', 'borderColor'];

		    module.exports = function (ecModel, api) {

		        var globalColors = ecModel.get('color');

		        ecModel.eachRawSeriesByType('boxplot', function (seriesModel) {

		            var defaulColor = globalColors[seriesModel.seriesIndex % globalColors.length];
		            var data = seriesModel.getData();

		            data.setVisual({
		                legendSymbol: 'roundRect',
		                // Use name 'color' but not 'borderColor' for legend usage and
		                // visual coding from other component like dataRange.
		                color: seriesModel.get(borderColorQuery) || defaulColor
		            });

		            // Only visible series has each data be visual encoded
		            if (!ecModel.isSeriesFiltered(seriesModel)) {
		                data.each(function (idx) {
		                    var itemModel = data.getItemModel(idx);
		                    data.setItemVisual(
		                        idx,
		                        {color: itemModel.get(borderColorQuery, true)}
		                    );
		                });
		            }
		        });

		    };


	/***/ },
	/* 252 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var zrUtil = __webpack_require__(4);
		    var numberUtil = __webpack_require__(7);
		    var parsePercent = numberUtil.parsePercent;
		    var each = zrUtil.each;

		    module.exports = function (ecModel) {

		        var groupResult = groupSeriesByAxis(ecModel);

		        each(groupResult, function (groupItem) {
		            var seriesModels = groupItem.seriesModels;

		            if (!seriesModels.length) {
		                return;
		            }

		            calculateBase(groupItem);

		            each(seriesModels, function (seriesModel, idx) {
		                layoutSingleSeries(
		                    seriesModel,
		                    groupItem.boxOffsetList[idx],
		                    groupItem.boxWidthList[idx]
		                );
		            });
		        });
		    };

		    /**
		     * Group series by axis.
		     */
		    function groupSeriesByAxis(ecModel) {
		        var result = [];
		        var axisList = [];

		        ecModel.eachSeriesByType('boxplot', function (seriesModel) {
		            var baseAxis = seriesModel.getBaseAxis();
		            var idx = zrUtil.indexOf(axisList, baseAxis);

		            if (idx < 0) {
		                idx = axisList.length;
		                axisList[idx] = baseAxis;
		                result[idx] = {axis: baseAxis, seriesModels: []};
		            }

		            result[idx].seriesModels.push(seriesModel);
		        });

		        return result;
		    }

		    /**
		     * Calculate offset and box width for each series.
		     */
		    function calculateBase(groupItem) {
		        var extent;
		        var baseAxis = groupItem.axis;
		        var seriesModels = groupItem.seriesModels;
		        var seriesCount = seriesModels.length;

		        var boxWidthList = groupItem.boxWidthList = [];
		        var boxOffsetList = groupItem.boxOffsetList = [];
		        var boundList = [];

		        var bandWidth;
		        if (baseAxis.type === 'category') {
		            bandWidth = baseAxis.getBandWidth();
		        }
		        else {
		            var maxDataCount = 0;
		            each(seriesModels, function (seriesModel) {
		                maxDataCount = Math.max(maxDataCount, seriesModel.getData().count());
		            });
		            extent = baseAxis.getExtent(),
		            Math.abs(extent[1] - extent[0]) / maxDataCount;
		        }

		        each(seriesModels, function (seriesModel) {
		            var boxWidthBound = seriesModel.get('boxWidth');
		            if (!zrUtil.isArray(boxWidthBound)) {
		                boxWidthBound = [boxWidthBound, boxWidthBound];
		            }
		            boundList.push([
		                parsePercent(boxWidthBound[0], bandWidth) || 0,
		                parsePercent(boxWidthBound[1], bandWidth) || 0
		            ]);
		        });

		        var availableWidth = bandWidth * 0.8 - 2;
		        var boxGap = availableWidth / seriesCount * 0.3;
		        var boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount;
		        var base = boxWidth / 2 - availableWidth / 2;

		        each(seriesModels, function (seriesModel, idx) {
		            boxOffsetList.push(base);
		            base += boxGap + boxWidth;

		            boxWidthList.push(
		                Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1])
		            );
		        });
		    }

		    /**
		     * Calculate points location for each series.
		     */
		    function layoutSingleSeries(seriesModel, offset, boxWidth) {
		        var coordSys = seriesModel.coordinateSystem;
		        var data = seriesModel.getData();
		        var dimensions = seriesModel.dimensions;
		        var chartLayout = seriesModel.get('layout');
		        var halfWidth = boxWidth / 2;

		        data.each(dimensions, function () {
		            var args = arguments;
		            var dimLen = dimensions.length;
		            var axisDimVal = args[0];
		            var idx = args[dimLen];
		            var variableDim = chartLayout === 'horizontal' ? 0 : 1;
		            var constDim = 1 - variableDim;

		            var median = getPoint(args[3]);
		            var end1 = getPoint(args[1]);
		            var end5 = getPoint(args[5]);
		            var whiskerEnds = [
		                [end1, getPoint(args[2])],
		                [end5, getPoint(args[4])]
		            ];
		            layEndLine(end1);
		            layEndLine(end5);
		            layEndLine(median);

		            var bodyEnds = [];
		            addBodyEnd(whiskerEnds[0][1], 0);
		            addBodyEnd(whiskerEnds[1][1], 1);

		            data.setItemLayout(idx, {
		                chartLayout: chartLayout,
		                initBaseline: median[constDim],
		                median: median,
		                bodyEnds: bodyEnds,
		                whiskerEnds: whiskerEnds
		            });

		            function getPoint(val) {
		                var p = [];
		                p[variableDim] = axisDimVal;
		                p[constDim] = val;
		                var point;
		                if (isNaN(axisDimVal) || isNaN(val)) {
		                    point = [NaN, NaN];
		                }
		                else {
		                    point = coordSys.dataToPoint(p);
		                    point[variableDim] += offset;
		                }
		                return point;
		            }

		            function addBodyEnd(point, start) {
		                var point1 = point.slice();
		                var point2 = point.slice();
		                point1[variableDim] += halfWidth;
		                point2[variableDim] -= halfWidth;
		                start
		                    ? bodyEnds.push(point1, point2)
		                    : bodyEnds.push(point2, point1);
		            }

		            function layEndLine(endCenter) {
		                var line = [endCenter.slice(), endCenter.slice()];
		                line[0][variableDim] -= halfWidth;
		                line[1][variableDim] += halfWidth;
		                whiskerEnds.push(line);
		            }
		        });
		    }



	/***/ },
	/* 253 */
	/***/ function(module, exports, __webpack_require__) {

		

		    var echarts = __webpack_require__(1);

		    __webpack_require__(254);
		    __webpack_require__(255);

		    echarts.registerPreprocessor(
		        __webpack_require__(256)
		    );

		    echarts.registerVisual(__webpack_require__(257));
		    echarts.registerLayout(__webpack_require__(258));



	/***/ },
	/* 254 */
	/***/ function(module, exports, __webpack_require__) {

		'use strict';


		    var zrUtil = __webpack_require__(4);
		    var SeriesModel = __webpack_require__(28);
		    var whiskerBoxCommon = __webpack_require__(248);
		    var formatUtil = __webpack_require__(6);
		    var encodeHTML = formatUtil.encodeHTML;
		    var addCommas = forma